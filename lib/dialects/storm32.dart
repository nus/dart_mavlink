import 'dart:typed_data';
import 'package:dart_mavlink/mavlink_dialect.dart';
import 'package:dart_mavlink/mavlink_message.dart';
import 'package:dart_mavlink/types.dart';

/// Micro air vehicle / autopilot classes. This identifies the individual model.
///
/// MAV_AUTOPILOT
typedef MavAutopilot = int;

/// Generic autopilot, full support for everything
///
/// MAV_AUTOPILOT_GENERIC
const MavAutopilot mavAutopilotGeneric = 0;

/// Reserved for future use.
///
/// MAV_AUTOPILOT_RESERVED
const MavAutopilot mavAutopilotReserved = 1;

/// SLUGS autopilot, http://slugsuav.soe.ucsc.edu
///
/// MAV_AUTOPILOT_SLUGS
const MavAutopilot mavAutopilotSlugs = 2;

/// ArduPilot - Plane/Copter/Rover/Sub/Tracker, https://ardupilot.org
///
/// MAV_AUTOPILOT_ARDUPILOTMEGA
const MavAutopilot mavAutopilotArdupilotmega = 3;

/// OpenPilot, http://openpilot.org
///
/// MAV_AUTOPILOT_OPENPILOT
const MavAutopilot mavAutopilotOpenpilot = 4;

/// Generic autopilot only supporting simple waypoints
///
/// MAV_AUTOPILOT_GENERIC_WAYPOINTS_ONLY
const MavAutopilot mavAutopilotGenericWaypointsOnly = 5;

/// Generic autopilot supporting waypoints and other simple navigation commands
///
/// MAV_AUTOPILOT_GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY
const MavAutopilot mavAutopilotGenericWaypointsAndSimpleNavigationOnly = 6;

/// Generic autopilot supporting the full mission command set
///
/// MAV_AUTOPILOT_GENERIC_MISSION_FULL
const MavAutopilot mavAutopilotGenericMissionFull = 7;

/// No valid autopilot, e.g. a GCS or other MAVLink component
///
/// MAV_AUTOPILOT_INVALID
const MavAutopilot mavAutopilotInvalid = 8;

/// PPZ UAV - http://nongnu.org/paparazzi
///
/// MAV_AUTOPILOT_PPZ
const MavAutopilot mavAutopilotPpz = 9;

/// UAV Dev Board
///
/// MAV_AUTOPILOT_UDB
const MavAutopilot mavAutopilotUdb = 10;

/// FlexiPilot
///
/// MAV_AUTOPILOT_FP
const MavAutopilot mavAutopilotFp = 11;

/// PX4 Autopilot - http://px4.io/
///
/// MAV_AUTOPILOT_PX4
const MavAutopilot mavAutopilotPx4 = 12;

/// SMACCMPilot - http://smaccmpilot.org
///
/// MAV_AUTOPILOT_SMACCMPILOT
const MavAutopilot mavAutopilotSmaccmpilot = 13;

/// AutoQuad -- http://autoquad.org
///
/// MAV_AUTOPILOT_AUTOQUAD
const MavAutopilot mavAutopilotAutoquad = 14;

/// Armazila -- http://armazila.com
///
/// MAV_AUTOPILOT_ARMAZILA
const MavAutopilot mavAutopilotArmazila = 15;

/// Aerob -- http://aerob.ru
///
/// MAV_AUTOPILOT_AEROB
const MavAutopilot mavAutopilotAerob = 16;

/// ASLUAV autopilot -- http://www.asl.ethz.ch
///
/// MAV_AUTOPILOT_ASLUAV
const MavAutopilot mavAutopilotAsluav = 17;

/// SmartAP Autopilot - http://sky-drones.com
///
/// MAV_AUTOPILOT_SMARTAP
const MavAutopilot mavAutopilotSmartap = 18;

/// AirRails - http://uaventure.com
///
/// MAV_AUTOPILOT_AIRRAILS
const MavAutopilot mavAutopilotAirrails = 19;

/// Fusion Reflex - https://fusion.engineering
///
/// MAV_AUTOPILOT_REFLEX
const MavAutopilot mavAutopilotReflex = 20;

/// MAVLINK component type reported in HEARTBEAT message. Flight controllers must report the type of the vehicle on which they are mounted (e.g. MAV_TYPE_OCTOROTOR). All other components must report a value appropriate for their type (e.g. a camera must use MAV_TYPE_CAMERA).
///
/// MAV_TYPE
typedef MavType = int;

/// Generic micro air vehicle
///
/// MAV_TYPE_GENERIC
const MavType mavTypeGeneric = 0;

/// Fixed wing aircraft.
///
/// MAV_TYPE_FIXED_WING
const MavType mavTypeFixedWing = 1;

/// Quadrotor
///
/// MAV_TYPE_QUADROTOR
const MavType mavTypeQuadrotor = 2;

/// Coaxial helicopter
///
/// MAV_TYPE_COAXIAL
const MavType mavTypeCoaxial = 3;

/// Normal helicopter with tail rotor.
///
/// MAV_TYPE_HELICOPTER
const MavType mavTypeHelicopter = 4;

/// Ground installation
///
/// MAV_TYPE_ANTENNA_TRACKER
const MavType mavTypeAntennaTracker = 5;

/// Operator control unit / ground control station
///
/// MAV_TYPE_GCS
const MavType mavTypeGcs = 6;

/// Airship, controlled
///
/// MAV_TYPE_AIRSHIP
const MavType mavTypeAirship = 7;

/// Free balloon, uncontrolled
///
/// MAV_TYPE_FREE_BALLOON
const MavType mavTypeFreeBalloon = 8;

/// Rocket
///
/// MAV_TYPE_ROCKET
const MavType mavTypeRocket = 9;

/// Ground rover
///
/// MAV_TYPE_GROUND_ROVER
const MavType mavTypeGroundRover = 10;

/// Surface vessel, boat, ship
///
/// MAV_TYPE_SURFACE_BOAT
const MavType mavTypeSurfaceBoat = 11;

/// Submarine
///
/// MAV_TYPE_SUBMARINE
const MavType mavTypeSubmarine = 12;

/// Hexarotor
///
/// MAV_TYPE_HEXAROTOR
const MavType mavTypeHexarotor = 13;

/// Octorotor
///
/// MAV_TYPE_OCTOROTOR
const MavType mavTypeOctorotor = 14;

/// Tricopter
///
/// MAV_TYPE_TRICOPTER
const MavType mavTypeTricopter = 15;

/// Flapping wing
///
/// MAV_TYPE_FLAPPING_WING
const MavType mavTypeFlappingWing = 16;

/// Kite
///
/// MAV_TYPE_KITE
const MavType mavTypeKite = 17;

/// Onboard companion controller
///
/// MAV_TYPE_ONBOARD_CONTROLLER
const MavType mavTypeOnboardController = 18;

/// Two-rotor Tailsitter VTOL that additionally uses control surfaces in vertical operation. Note, value previously named MAV_TYPE_VTOL_DUOROTOR.
///
/// MAV_TYPE_VTOL_TAILSITTER_DUOROTOR
const MavType mavTypeVtolTailsitterDuorotor = 19;

/// Quad-rotor Tailsitter VTOL using a V-shaped quad config in vertical operation. Note: value previously named MAV_TYPE_VTOL_QUADROTOR.
///
/// MAV_TYPE_VTOL_TAILSITTER_QUADROTOR
const MavType mavTypeVtolTailsitterQuadrotor = 20;

/// Tiltrotor VTOL. Fuselage and wings stay (nominally) horizontal in all flight phases. It able to tilt (some) rotors to provide thrust in cruise flight.
///
/// MAV_TYPE_VTOL_TILTROTOR
const MavType mavTypeVtolTiltrotor = 21;

/// VTOL with separate fixed rotors for hover and cruise flight. Fuselage and wings stay (nominally) horizontal in all flight phases.
///
/// MAV_TYPE_VTOL_FIXEDROTOR
const MavType mavTypeVtolFixedrotor = 22;

/// Tailsitter VTOL. Fuselage and wings orientation changes depending on flight phase: vertical for hover, horizontal for cruise. Use more specific VTOL MAV_TYPE_VTOL_TAILSITTER_DUOROTOR or MAV_TYPE_VTOL_TAILSITTER_QUADROTOR if appropriate.
///
/// MAV_TYPE_VTOL_TAILSITTER
const MavType mavTypeVtolTailsitter = 23;

/// Tiltwing VTOL. Fuselage stays horizontal in all flight phases. The whole wing, along with any attached engine, can tilt between vertical and horizontal mode.
///
/// MAV_TYPE_VTOL_TILTWING
const MavType mavTypeVtolTiltwing = 24;

/// VTOL reserved 5
///
/// MAV_TYPE_VTOL_RESERVED5
const MavType mavTypeVtolReserved5 = 25;

/// Gimbal
///
/// MAV_TYPE_GIMBAL
const MavType mavTypeGimbal = 26;

/// ADSB system
///
/// MAV_TYPE_ADSB
const MavType mavTypeAdsb = 27;

/// Steerable, nonrigid airfoil
///
/// MAV_TYPE_PARAFOIL
const MavType mavTypeParafoil = 28;

/// Dodecarotor
///
/// MAV_TYPE_DODECAROTOR
const MavType mavTypeDodecarotor = 29;

/// Camera
///
/// MAV_TYPE_CAMERA
const MavType mavTypeCamera = 30;

/// Charging station
///
/// MAV_TYPE_CHARGING_STATION
const MavType mavTypeChargingStation = 31;

/// FLARM collision avoidance system
///
/// MAV_TYPE_FLARM
const MavType mavTypeFlarm = 32;

/// Servo
///
/// MAV_TYPE_SERVO
const MavType mavTypeServo = 33;

/// Open Drone ID. See https://mavlink.io/en/services/opendroneid.html.
///
/// MAV_TYPE_ODID
const MavType mavTypeOdid = 34;

/// Decarotor
///
/// MAV_TYPE_DECAROTOR
const MavType mavTypeDecarotor = 35;

/// Battery
///
/// MAV_TYPE_BATTERY
const MavType mavTypeBattery = 36;

/// Parachute
///
/// MAV_TYPE_PARACHUTE
const MavType mavTypeParachute = 37;

/// Log
///
/// MAV_TYPE_LOG
const MavType mavTypeLog = 38;

/// OSD
///
/// MAV_TYPE_OSD
const MavType mavTypeOsd = 39;

/// IMU
///
/// MAV_TYPE_IMU
const MavType mavTypeImu = 40;

/// GPS
///
/// MAV_TYPE_GPS
const MavType mavTypeGps = 41;

/// Winch
///
/// MAV_TYPE_WINCH
const MavType mavTypeWinch = 42;

/// Generic multirotor that does not fit into a specific type or whose type is unknown
///
/// MAV_TYPE_GENERIC_MULTIROTOR
const MavType mavTypeGenericMultirotor = 43;

/// Illuminator. An illuminator is a light source that is used for lighting up dark areas external to the sytstem: e.g. a torch or searchlight (as opposed to a light source for illuminating the system itself, e.g. an indicator light).
///
/// MAV_TYPE_ILLUMINATOR
const MavType mavTypeIlluminator = 44;

/// These flags encode the MAV mode.
///
/// MAV_MODE_FLAG
typedef MavModeFlag = int;

/// 0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM shall be used instead. The flag can still be used to report the armed state.
///
/// MAV_MODE_FLAG_SAFETY_ARMED
const MavModeFlag mavModeFlagSafetyArmed = 128;

/// 0b01000000 remote control input is enabled.
///
/// MAV_MODE_FLAG_MANUAL_INPUT_ENABLED
const MavModeFlag mavModeFlagManualInputEnabled = 64;

/// 0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software is full operational.
///
/// MAV_MODE_FLAG_HIL_ENABLED
const MavModeFlag mavModeFlagHilEnabled = 32;

/// 0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further control inputs to move around.
///
/// MAV_MODE_FLAG_STABILIZE_ENABLED
const MavModeFlag mavModeFlagStabilizeEnabled = 16;

/// 0b00001000 guided mode enabled, system flies waypoints / mission items.
///
/// MAV_MODE_FLAG_GUIDED_ENABLED
const MavModeFlag mavModeFlagGuidedEnabled = 8;

/// 0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not, depends on the actual implementation.
///
/// MAV_MODE_FLAG_AUTO_ENABLED
const MavModeFlag mavModeFlagAutoEnabled = 4;

/// 0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should not be used for stable implementations.
///
/// MAV_MODE_FLAG_TEST_ENABLED
const MavModeFlag mavModeFlagTestEnabled = 2;

/// 0b00000001 Reserved for future use.
///
/// MAV_MODE_FLAG_CUSTOM_MODE_ENABLED
const MavModeFlag mavModeFlagCustomModeEnabled = 1;

/// These values encode the bit positions of the decode position. These values can be used to read the value of a flag bit by combining the base_mode variable with AND with the flag position value. The result will be either 0 or 1, depending on if the flag is set or not.
///
/// MAV_MODE_FLAG_DECODE_POSITION
typedef MavModeFlagDecodePosition = int;

/// First bit:  10000000
///
/// MAV_MODE_FLAG_DECODE_POSITION_SAFETY
const MavModeFlagDecodePosition mavModeFlagDecodePositionSafety = 128;

/// Second bit: 01000000
///
/// MAV_MODE_FLAG_DECODE_POSITION_MANUAL
const MavModeFlagDecodePosition mavModeFlagDecodePositionManual = 64;

/// Third bit:  00100000
///
/// MAV_MODE_FLAG_DECODE_POSITION_HIL
const MavModeFlagDecodePosition mavModeFlagDecodePositionHil = 32;

/// Fourth bit: 00010000
///
/// MAV_MODE_FLAG_DECODE_POSITION_STABILIZE
const MavModeFlagDecodePosition mavModeFlagDecodePositionStabilize = 16;

/// Fifth bit:  00001000
///
/// MAV_MODE_FLAG_DECODE_POSITION_GUIDED
const MavModeFlagDecodePosition mavModeFlagDecodePositionGuided = 8;

/// Sixth bit:   00000100
///
/// MAV_MODE_FLAG_DECODE_POSITION_AUTO
const MavModeFlagDecodePosition mavModeFlagDecodePositionAuto = 4;

/// Seventh bit: 00000010
///
/// MAV_MODE_FLAG_DECODE_POSITION_TEST
const MavModeFlagDecodePosition mavModeFlagDecodePositionTest = 2;

/// Eighth bit: 00000001
///
/// MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE
const MavModeFlagDecodePosition mavModeFlagDecodePositionCustomMode = 1;

///
/// MAV_STATE
typedef MavState = int;

/// Uninitialized system, state is unknown.
///
/// MAV_STATE_UNINIT
const MavState mavStateUninit = 0;

/// System is booting up.
///
/// MAV_STATE_BOOT
const MavState mavStateBoot = 1;

/// System is calibrating and not flight-ready.
///
/// MAV_STATE_CALIBRATING
const MavState mavStateCalibrating = 2;

/// System is grounded and on standby. It can be launched any time.
///
/// MAV_STATE_STANDBY
const MavState mavStateStandby = 3;

/// System is active and might be already airborne. Motors are engaged.
///
/// MAV_STATE_ACTIVE
const MavState mavStateActive = 4;

/// System is in a non-normal flight mode (failsafe). It can however still navigate.
///
/// MAV_STATE_CRITICAL
const MavState mavStateCritical = 5;

/// System is in a non-normal flight mode (failsafe). It lost control over parts or over the whole airframe. It is in mayday and going down.
///
/// MAV_STATE_EMERGENCY
const MavState mavStateEmergency = 6;

/// System just initialized its power-down sequence, will shut down now.
///
/// MAV_STATE_POWEROFF
const MavState mavStatePoweroff = 7;

/// System is terminating itself (failsafe or commanded).
///
/// MAV_STATE_FLIGHT_TERMINATION
const MavState mavStateFlightTermination = 8;

/// Component ids (values) for the different types and instances of onboard hardware/software that might make up a MAVLink system (autopilot, cameras, servos, GPS systems, avoidance systems etc.).
/// Components must use the appropriate ID in their source address when sending messages. Components can also use IDs to determine if they are the intended recipient of an incoming message. The MAV_COMP_ID_ALL value is used to indicate messages that must be processed by all components.
/// When creating new entries, components that can have multiple instances (e.g. cameras, servos etc.) should be allocated sequential values. An appropriate number of values should be left free after these components to allow the number of instances to be expanded.
///
/// MAV_COMPONENT
typedef MavComponent = int;

/// Target id (target_component) used to broadcast messages to all components of the receiving system. Components should attempt to process messages with this component ID and forward to components on any other interfaces. Note: This is not a valid *source* component id for a message.
///
/// MAV_COMP_ID_ALL
const MavComponent mavCompIdAll = 0;

/// System flight controller component ("autopilot"). Only one autopilot is expected in a particular system.
///
/// MAV_COMP_ID_AUTOPILOT1
const MavComponent mavCompIdAutopilot1 = 1;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER1
const MavComponent mavCompIdUser1 = 25;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER2
const MavComponent mavCompIdUser2 = 26;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER3
const MavComponent mavCompIdUser3 = 27;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER4
const MavComponent mavCompIdUser4 = 28;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER5
const MavComponent mavCompIdUser5 = 29;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER6
const MavComponent mavCompIdUser6 = 30;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER7
const MavComponent mavCompIdUser7 = 31;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER8
const MavComponent mavCompIdUser8 = 32;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER9
const MavComponent mavCompIdUser9 = 33;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER10
const MavComponent mavCompIdUser10 = 34;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER11
const MavComponent mavCompIdUser11 = 35;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER12
const MavComponent mavCompIdUser12 = 36;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER13
const MavComponent mavCompIdUser13 = 37;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER14
const MavComponent mavCompIdUser14 = 38;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER15
const MavComponent mavCompIdUser15 = 39;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER16
const MavComponent mavCompIdUser16 = 40;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER17
const MavComponent mavCompIdUser17 = 41;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER18
const MavComponent mavCompIdUser18 = 42;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER19
const MavComponent mavCompIdUser19 = 43;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER20
const MavComponent mavCompIdUser20 = 44;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER21
const MavComponent mavCompIdUser21 = 45;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER22
const MavComponent mavCompIdUser22 = 46;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER23
const MavComponent mavCompIdUser23 = 47;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER24
const MavComponent mavCompIdUser24 = 48;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER25
const MavComponent mavCompIdUser25 = 49;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER26
const MavComponent mavCompIdUser26 = 50;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER27
const MavComponent mavCompIdUser27 = 51;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER28
const MavComponent mavCompIdUser28 = 52;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER29
const MavComponent mavCompIdUser29 = 53;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER30
const MavComponent mavCompIdUser30 = 54;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER31
const MavComponent mavCompIdUser31 = 55;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER32
const MavComponent mavCompIdUser32 = 56;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER33
const MavComponent mavCompIdUser33 = 57;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER34
const MavComponent mavCompIdUser34 = 58;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER35
const MavComponent mavCompIdUser35 = 59;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER36
const MavComponent mavCompIdUser36 = 60;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER37
const MavComponent mavCompIdUser37 = 61;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER38
const MavComponent mavCompIdUser38 = 62;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER39
const MavComponent mavCompIdUser39 = 63;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER40
const MavComponent mavCompIdUser40 = 64;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER41
const MavComponent mavCompIdUser41 = 65;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER42
const MavComponent mavCompIdUser42 = 66;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER43
const MavComponent mavCompIdUser43 = 67;

/// Telemetry radio (e.g. SiK radio, or other component that emits RADIO_STATUS messages).
///
/// MAV_COMP_ID_TELEMETRY_RADIO
const MavComponent mavCompIdTelemetryRadio = 68;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER45
const MavComponent mavCompIdUser45 = 69;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER46
const MavComponent mavCompIdUser46 = 70;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER47
const MavComponent mavCompIdUser47 = 71;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER48
const MavComponent mavCompIdUser48 = 72;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER49
const MavComponent mavCompIdUser49 = 73;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER50
const MavComponent mavCompIdUser50 = 74;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER51
const MavComponent mavCompIdUser51 = 75;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER52
const MavComponent mavCompIdUser52 = 76;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER53
const MavComponent mavCompIdUser53 = 77;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER54
const MavComponent mavCompIdUser54 = 78;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER55
const MavComponent mavCompIdUser55 = 79;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER56
const MavComponent mavCompIdUser56 = 80;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER57
const MavComponent mavCompIdUser57 = 81;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER58
const MavComponent mavCompIdUser58 = 82;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER59
const MavComponent mavCompIdUser59 = 83;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER60
const MavComponent mavCompIdUser60 = 84;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER61
const MavComponent mavCompIdUser61 = 85;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER62
const MavComponent mavCompIdUser62 = 86;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER63
const MavComponent mavCompIdUser63 = 87;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER64
const MavComponent mavCompIdUser64 = 88;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER65
const MavComponent mavCompIdUser65 = 89;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER66
const MavComponent mavCompIdUser66 = 90;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER67
const MavComponent mavCompIdUser67 = 91;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER68
const MavComponent mavCompIdUser68 = 92;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER69
const MavComponent mavCompIdUser69 = 93;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER70
const MavComponent mavCompIdUser70 = 94;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER71
const MavComponent mavCompIdUser71 = 95;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER72
const MavComponent mavCompIdUser72 = 96;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER73
const MavComponent mavCompIdUser73 = 97;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER74
const MavComponent mavCompIdUser74 = 98;

/// Id for a component on privately managed MAVLink network. Can be used for any purpose but may not be published by components outside of the private network.
///
/// MAV_COMP_ID_USER75
const MavComponent mavCompIdUser75 = 99;

/// Camera #1.
///
/// MAV_COMP_ID_CAMERA
const MavComponent mavCompIdCamera = 100;

/// Camera #2.
///
/// MAV_COMP_ID_CAMERA2
const MavComponent mavCompIdCamera2 = 101;

/// Camera #3.
///
/// MAV_COMP_ID_CAMERA3
const MavComponent mavCompIdCamera3 = 102;

/// Camera #4.
///
/// MAV_COMP_ID_CAMERA4
const MavComponent mavCompIdCamera4 = 103;

/// Camera #5.
///
/// MAV_COMP_ID_CAMERA5
const MavComponent mavCompIdCamera5 = 104;

/// Camera #6.
///
/// MAV_COMP_ID_CAMERA6
const MavComponent mavCompIdCamera6 = 105;

/// Servo #1.
///
/// MAV_COMP_ID_SERVO1
const MavComponent mavCompIdServo1 = 140;

/// Servo #2.
///
/// MAV_COMP_ID_SERVO2
const MavComponent mavCompIdServo2 = 141;

/// Servo #3.
///
/// MAV_COMP_ID_SERVO3
const MavComponent mavCompIdServo3 = 142;

/// Servo #4.
///
/// MAV_COMP_ID_SERVO4
const MavComponent mavCompIdServo4 = 143;

/// Servo #5.
///
/// MAV_COMP_ID_SERVO5
const MavComponent mavCompIdServo5 = 144;

/// Servo #6.
///
/// MAV_COMP_ID_SERVO6
const MavComponent mavCompIdServo6 = 145;

/// Servo #7.
///
/// MAV_COMP_ID_SERVO7
const MavComponent mavCompIdServo7 = 146;

/// Servo #8.
///
/// MAV_COMP_ID_SERVO8
const MavComponent mavCompIdServo8 = 147;

/// Servo #9.
///
/// MAV_COMP_ID_SERVO9
const MavComponent mavCompIdServo9 = 148;

/// Servo #10.
///
/// MAV_COMP_ID_SERVO10
const MavComponent mavCompIdServo10 = 149;

/// Servo #11.
///
/// MAV_COMP_ID_SERVO11
const MavComponent mavCompIdServo11 = 150;

/// Servo #12.
///
/// MAV_COMP_ID_SERVO12
const MavComponent mavCompIdServo12 = 151;

/// Servo #13.
///
/// MAV_COMP_ID_SERVO13
const MavComponent mavCompIdServo13 = 152;

/// Servo #14.
///
/// MAV_COMP_ID_SERVO14
const MavComponent mavCompIdServo14 = 153;

/// Gimbal #1.
///
/// MAV_COMP_ID_GIMBAL
const MavComponent mavCompIdGimbal = 154;

/// Logging component.
///
/// MAV_COMP_ID_LOG
const MavComponent mavCompIdLog = 155;

/// Automatic Dependent Surveillance-Broadcast (ADS-B) component.
///
/// MAV_COMP_ID_ADSB
const MavComponent mavCompIdAdsb = 156;

/// On Screen Display (OSD) devices for video links.
///
/// MAV_COMP_ID_OSD
const MavComponent mavCompIdOsd = 157;

/// Generic autopilot peripheral component ID. Meant for devices that do not implement the parameter microservice.
///
/// MAV_COMP_ID_PERIPHERAL
const MavComponent mavCompIdPeripheral = 158;

/// Gimbal ID for QX1.
///
/// MAV_COMP_ID_QX1_GIMBAL
@Deprecated(
    "Replaced by [MAV_COMP_ID_GIMBAL] since 2018-11. All gimbals should use MAV_COMP_ID_GIMBAL.")
const MavComponent mavCompIdQx1Gimbal = 159;

/// FLARM collision alert component.
///
/// MAV_COMP_ID_FLARM
const MavComponent mavCompIdFlarm = 160;

/// Parachute component.
///
/// MAV_COMP_ID_PARACHUTE
const MavComponent mavCompIdParachute = 161;

/// Winch component.
///
/// MAV_COMP_ID_WINCH
const MavComponent mavCompIdWinch = 169;

/// Gimbal #2.
///
/// MAV_COMP_ID_GIMBAL2
const MavComponent mavCompIdGimbal2 = 171;

/// Gimbal #3.
///
/// MAV_COMP_ID_GIMBAL3
const MavComponent mavCompIdGimbal3 = 172;

/// Gimbal #4
///
/// MAV_COMP_ID_GIMBAL4
const MavComponent mavCompIdGimbal4 = 173;

/// Gimbal #5.
///
/// MAV_COMP_ID_GIMBAL5
const MavComponent mavCompIdGimbal5 = 174;

/// Gimbal #6.
///
/// MAV_COMP_ID_GIMBAL6
const MavComponent mavCompIdGimbal6 = 175;

/// Battery #1.
///
/// MAV_COMP_ID_BATTERY
const MavComponent mavCompIdBattery = 180;

/// Battery #2.
///
/// MAV_COMP_ID_BATTERY2
const MavComponent mavCompIdBattery2 = 181;

/// CAN over MAVLink client.
///
/// MAV_COMP_ID_MAVCAN
const MavComponent mavCompIdMavcan = 189;

/// Component that can generate/supply a mission flight plan (e.g. GCS or developer API).
///
/// MAV_COMP_ID_MISSIONPLANNER
const MavComponent mavCompIdMissionplanner = 190;

/// Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.
///
/// MAV_COMP_ID_ONBOARD_COMPUTER
const MavComponent mavCompIdOnboardComputer = 191;

/// Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.
///
/// MAV_COMP_ID_ONBOARD_COMPUTER2
const MavComponent mavCompIdOnboardComputer2 = 192;

/// Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.
///
/// MAV_COMP_ID_ONBOARD_COMPUTER3
const MavComponent mavCompIdOnboardComputer3 = 193;

/// Component that lives on the onboard computer (companion computer) and has some generic functionalities, such as settings system parameters and monitoring the status of some processes that don't directly speak mavlink and so on.
///
/// MAV_COMP_ID_ONBOARD_COMPUTER4
const MavComponent mavCompIdOnboardComputer4 = 194;

/// Component that finds an optimal path between points based on a certain constraint (e.g. minimum snap, shortest path, cost, etc.).
///
/// MAV_COMP_ID_PATHPLANNER
const MavComponent mavCompIdPathplanner = 195;

/// Component that plans a collision free path between two points.
///
/// MAV_COMP_ID_OBSTACLE_AVOIDANCE
const MavComponent mavCompIdObstacleAvoidance = 196;

/// Component that provides position estimates using VIO techniques.
///
/// MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY
const MavComponent mavCompIdVisualInertialOdometry = 197;

/// Component that manages pairing of vehicle and GCS.
///
/// MAV_COMP_ID_PAIRING_MANAGER
const MavComponent mavCompIdPairingManager = 198;

/// Inertial Measurement Unit (IMU) #1.
///
/// MAV_COMP_ID_IMU
const MavComponent mavCompIdImu = 200;

/// Inertial Measurement Unit (IMU) #2.
///
/// MAV_COMP_ID_IMU_2
const MavComponent mavCompIdImu2 = 201;

/// Inertial Measurement Unit (IMU) #3.
///
/// MAV_COMP_ID_IMU_3
const MavComponent mavCompIdImu3 = 202;

/// GPS #1.
///
/// MAV_COMP_ID_GPS
const MavComponent mavCompIdGps = 220;

/// GPS #2.
///
/// MAV_COMP_ID_GPS2
const MavComponent mavCompIdGps2 = 221;

/// Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet).
///
/// MAV_COMP_ID_ODID_TXRX_1
const MavComponent mavCompIdOdidTxrx1 = 236;

/// Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet).
///
/// MAV_COMP_ID_ODID_TXRX_2
const MavComponent mavCompIdOdidTxrx2 = 237;

/// Open Drone ID transmitter/receiver (Bluetooth/WiFi/Internet).
///
/// MAV_COMP_ID_ODID_TXRX_3
const MavComponent mavCompIdOdidTxrx3 = 238;

/// Component to bridge MAVLink to UDP (i.e. from a UART).
///
/// MAV_COMP_ID_UDP_BRIDGE
const MavComponent mavCompIdUdpBridge = 240;

/// Component to bridge to UART (i.e. from UDP).
///
/// MAV_COMP_ID_UART_BRIDGE
const MavComponent mavCompIdUartBridge = 241;

/// Component handling TUNNEL messages (e.g. vendor specific GUI of a component).
///
/// MAV_COMP_ID_TUNNEL_NODE
const MavComponent mavCompIdTunnelNode = 242;

/// Illuminator
///
/// MAV_COMP_ID_ILLUMINATOR
const MavComponent mavCompIdIlluminator = 243;

/// Deprecated, don't use. Component for handling system messages (e.g. to ARM, takeoff, etc.).
///
/// MAV_COMP_ID_SYSTEM_CONTROL
@Deprecated(
    "Replaced by [MAV_COMP_ID_ALL] since 2018-11. System control does not require a separate component ID. Instead, system commands should be sent with target_component=MAV_COMP_ID_ALL allowing the target component to use any appropriate component id.")
const MavComponent mavCompIdSystemControl = 250;

/// These values define the type of firmware release.  These values indicate the first version or release of this type.  For example the first alpha release would be 64, the second would be 65.
///
/// FIRMWARE_VERSION_TYPE
typedef FirmwareVersionType = int;

/// development release
///
/// FIRMWARE_VERSION_TYPE_DEV
const FirmwareVersionType firmwareVersionTypeDev = 0;

/// alpha release
///
/// FIRMWARE_VERSION_TYPE_ALPHA
const FirmwareVersionType firmwareVersionTypeAlpha = 64;

/// beta release
///
/// FIRMWARE_VERSION_TYPE_BETA
const FirmwareVersionType firmwareVersionTypeBeta = 128;

/// release candidate
///
/// FIRMWARE_VERSION_TYPE_RC
const FirmwareVersionType firmwareVersionTypeRc = 192;

/// official stable release
///
/// FIRMWARE_VERSION_TYPE_OFFICIAL
const FirmwareVersionType firmwareVersionTypeOfficial = 255;

/// Flags to report failure cases over the high latency telemetry.
///
/// HL_FAILURE_FLAG
typedef HlFailureFlag = int;

/// GPS failure.
///
/// HL_FAILURE_FLAG_GPS
const HlFailureFlag hlFailureFlagGps = 1;

/// Differential pressure sensor failure.
///
/// HL_FAILURE_FLAG_DIFFERENTIAL_PRESSURE
const HlFailureFlag hlFailureFlagDifferentialPressure = 2;

/// Absolute pressure sensor failure.
///
/// HL_FAILURE_FLAG_ABSOLUTE_PRESSURE
const HlFailureFlag hlFailureFlagAbsolutePressure = 4;

/// Accelerometer sensor failure.
///
/// HL_FAILURE_FLAG_3D_ACCEL
const HlFailureFlag hlFailureFlag3dAccel = 8;

/// Gyroscope sensor failure.
///
/// HL_FAILURE_FLAG_3D_GYRO
const HlFailureFlag hlFailureFlag3dGyro = 16;

/// Magnetometer sensor failure.
///
/// HL_FAILURE_FLAG_3D_MAG
const HlFailureFlag hlFailureFlag3dMag = 32;

/// Terrain subsystem failure.
///
/// HL_FAILURE_FLAG_TERRAIN
const HlFailureFlag hlFailureFlagTerrain = 64;

/// Battery failure/critical low battery.
///
/// HL_FAILURE_FLAG_BATTERY
const HlFailureFlag hlFailureFlagBattery = 128;

/// RC receiver failure/no RC connection.
///
/// HL_FAILURE_FLAG_RC_RECEIVER
const HlFailureFlag hlFailureFlagRcReceiver = 256;

/// Offboard link failure.
///
/// HL_FAILURE_FLAG_OFFBOARD_LINK
const HlFailureFlag hlFailureFlagOffboardLink = 512;

/// Engine failure.
///
/// HL_FAILURE_FLAG_ENGINE
const HlFailureFlag hlFailureFlagEngine = 1024;

/// Geofence violation.
///
/// HL_FAILURE_FLAG_GEOFENCE
const HlFailureFlag hlFailureFlagGeofence = 2048;

/// Estimator failure, for example measurement rejection or large variances.
///
/// HL_FAILURE_FLAG_ESTIMATOR
const HlFailureFlag hlFailureFlagEstimator = 4096;

/// Mission failure.
///
/// HL_FAILURE_FLAG_MISSION
const HlFailureFlag hlFailureFlagMission = 8192;

/// Actions that may be specified in MAV_CMD_OVERRIDE_GOTO to override mission execution.
///
/// MAV_GOTO
typedef MavGoto = int;

/// Hold at the current position.
///
/// MAV_GOTO_DO_HOLD
const MavGoto mavGotoDoHold = 0;

/// Continue with the next item in mission execution.
///
/// MAV_GOTO_DO_CONTINUE
const MavGoto mavGotoDoContinue = 1;

/// Hold at the current position of the system
///
/// MAV_GOTO_HOLD_AT_CURRENT_POSITION
const MavGoto mavGotoHoldAtCurrentPosition = 2;

/// Hold at the position specified in the parameters of the DO_HOLD action
///
/// MAV_GOTO_HOLD_AT_SPECIFIED_POSITION
const MavGoto mavGotoHoldAtSpecifiedPosition = 3;

/// These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it
/// simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override.
///
/// MAV_MODE
typedef MavMode = int;

/// System is not ready to fly, booting, calibrating, etc. No flag is set.
///
/// MAV_MODE_PREFLIGHT
const MavMode mavModePreflight = 0;

/// System is allowed to be active, under assisted RC control.
///
/// MAV_MODE_STABILIZE_DISARMED
const MavMode mavModeStabilizeDisarmed = 80;

/// System is allowed to be active, under assisted RC control.
///
/// MAV_MODE_STABILIZE_ARMED
const MavMode mavModeStabilizeArmed = 208;

/// System is allowed to be active, under manual (RC) control, no stabilization
///
/// MAV_MODE_MANUAL_DISARMED
const MavMode mavModeManualDisarmed = 64;

/// System is allowed to be active, under manual (RC) control, no stabilization
///
/// MAV_MODE_MANUAL_ARMED
const MavMode mavModeManualArmed = 192;

/// System is allowed to be active, under autonomous control, manual setpoint
///
/// MAV_MODE_GUIDED_DISARMED
const MavMode mavModeGuidedDisarmed = 88;

/// System is allowed to be active, under autonomous control, manual setpoint
///
/// MAV_MODE_GUIDED_ARMED
const MavMode mavModeGuidedArmed = 216;

/// System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints)
///
/// MAV_MODE_AUTO_DISARMED
const MavMode mavModeAutoDisarmed = 92;

/// System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard and not pre-programmed by waypoints)
///
/// MAV_MODE_AUTO_ARMED
const MavMode mavModeAutoArmed = 220;

/// UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only.
///
/// MAV_MODE_TEST_DISARMED
const MavMode mavModeTestDisarmed = 66;

/// UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only.
///
/// MAV_MODE_TEST_ARMED
const MavMode mavModeTestArmed = 194;

/// These encode the sensors whose status is sent as part of the SYS_STATUS message.
///
/// MAV_SYS_STATUS_SENSOR
typedef MavSysStatusSensor = int;

/// 0x01 3D gyro
///
/// MAV_SYS_STATUS_SENSOR_3D_GYRO
const MavSysStatusSensor mavSysStatusSensor3dGyro = 1;

/// 0x02 3D accelerometer
///
/// MAV_SYS_STATUS_SENSOR_3D_ACCEL
const MavSysStatusSensor mavSysStatusSensor3dAccel = 2;

/// 0x04 3D magnetometer
///
/// MAV_SYS_STATUS_SENSOR_3D_MAG
const MavSysStatusSensor mavSysStatusSensor3dMag = 4;

/// 0x08 absolute pressure
///
/// MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE
const MavSysStatusSensor mavSysStatusSensorAbsolutePressure = 8;

/// 0x10 differential pressure
///
/// MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE
const MavSysStatusSensor mavSysStatusSensorDifferentialPressure = 16;

/// 0x20 GPS
///
/// MAV_SYS_STATUS_SENSOR_GPS
const MavSysStatusSensor mavSysStatusSensorGps = 32;

/// 0x40 optical flow
///
/// MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW
const MavSysStatusSensor mavSysStatusSensorOpticalFlow = 64;

/// 0x80 computer vision position
///
/// MAV_SYS_STATUS_SENSOR_VISION_POSITION
const MavSysStatusSensor mavSysStatusSensorVisionPosition = 128;

/// 0x100 laser based position
///
/// MAV_SYS_STATUS_SENSOR_LASER_POSITION
const MavSysStatusSensor mavSysStatusSensorLaserPosition = 256;

/// 0x200 external ground truth (Vicon or Leica)
///
/// MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH
const MavSysStatusSensor mavSysStatusSensorExternalGroundTruth = 512;

/// 0x400 3D angular rate control
///
/// MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL
const MavSysStatusSensor mavSysStatusSensorAngularRateControl = 1024;

/// 0x800 attitude stabilization
///
/// MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION
const MavSysStatusSensor mavSysStatusSensorAttitudeStabilization = 2048;

/// 0x1000 yaw position
///
/// MAV_SYS_STATUS_SENSOR_YAW_POSITION
const MavSysStatusSensor mavSysStatusSensorYawPosition = 4096;

/// 0x2000 z/altitude control
///
/// MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL
const MavSysStatusSensor mavSysStatusSensorZAltitudeControl = 8192;

/// 0x4000 x/y position control
///
/// MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL
const MavSysStatusSensor mavSysStatusSensorXyPositionControl = 16384;

/// 0x8000 motor outputs / control
///
/// MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS
const MavSysStatusSensor mavSysStatusSensorMotorOutputs = 32768;

/// 0x10000 RC receiver
///
/// MAV_SYS_STATUS_SENSOR_RC_RECEIVER
const MavSysStatusSensor mavSysStatusSensorRcReceiver = 65536;

/// 0x20000 2nd 3D gyro
///
/// MAV_SYS_STATUS_SENSOR_3D_GYRO2
const MavSysStatusSensor mavSysStatusSensor3dGyro2 = 131072;

/// 0x40000 2nd 3D accelerometer
///
/// MAV_SYS_STATUS_SENSOR_3D_ACCEL2
const MavSysStatusSensor mavSysStatusSensor3dAccel2 = 262144;

/// 0x80000 2nd 3D magnetometer
///
/// MAV_SYS_STATUS_SENSOR_3D_MAG2
const MavSysStatusSensor mavSysStatusSensor3dMag2 = 524288;

/// 0x100000 geofence
///
/// MAV_SYS_STATUS_GEOFENCE
const MavSysStatusSensor mavSysStatusGeofence = 1048576;

/// 0x200000 AHRS subsystem health
///
/// MAV_SYS_STATUS_AHRS
const MavSysStatusSensor mavSysStatusAhrs = 2097152;

/// 0x400000 Terrain subsystem health
///
/// MAV_SYS_STATUS_TERRAIN
const MavSysStatusSensor mavSysStatusTerrain = 4194304;

/// 0x800000 Motors are reversed
///
/// MAV_SYS_STATUS_REVERSE_MOTOR
const MavSysStatusSensor mavSysStatusReverseMotor = 8388608;

/// 0x1000000 Logging
///
/// MAV_SYS_STATUS_LOGGING
const MavSysStatusSensor mavSysStatusLogging = 16777216;

/// 0x2000000 Battery
///
/// MAV_SYS_STATUS_SENSOR_BATTERY
const MavSysStatusSensor mavSysStatusSensorBattery = 33554432;

/// 0x4000000 Proximity
///
/// MAV_SYS_STATUS_SENSOR_PROXIMITY
const MavSysStatusSensor mavSysStatusSensorProximity = 67108864;

/// 0x8000000 Satellite Communication
///
/// MAV_SYS_STATUS_SENSOR_SATCOM
const MavSysStatusSensor mavSysStatusSensorSatcom = 134217728;

/// 0x10000000 pre-arm check status. Always healthy when armed
///
/// MAV_SYS_STATUS_PREARM_CHECK
const MavSysStatusSensor mavSysStatusPrearmCheck = 268435456;

/// 0x20000000 Avoidance/collision prevention
///
/// MAV_SYS_STATUS_OBSTACLE_AVOIDANCE
const MavSysStatusSensor mavSysStatusObstacleAvoidance = 536870912;

/// 0x40000000 propulsion (actuator, esc, motor or propellor)
///
/// MAV_SYS_STATUS_SENSOR_PROPULSION
const MavSysStatusSensor mavSysStatusSensorPropulsion = 1073741824;

/// 0x80000000 Extended bit-field are used for further sensor status bits (needs to be set in onboard_control_sensors_present only)
///
/// MAV_SYS_STATUS_EXTENSION_USED
const MavSysStatusSensor mavSysStatusExtensionUsed = 2147483648;

/// These encode the sensors whose status is sent as part of the SYS_STATUS message in the extended fields.
///
/// MAV_SYS_STATUS_SENSOR_EXTENDED
typedef MavSysStatusSensorExtended = int;

/// 0x01 Recovery system (parachute, balloon, retracts etc)
///
/// MAV_SYS_STATUS_RECOVERY_SYSTEM
const MavSysStatusSensorExtended mavSysStatusRecoverySystem = 1;

/// Coordinate frames used by MAVLink. Not all frames are supported by all commands, messages, or vehicles.
///
/// Global frames use the following naming conventions:
/// - "GLOBAL": Global coordinate frame with WGS84 latitude/longitude and altitude positive over mean sea level (MSL) by default.
/// The following modifiers may be used with "GLOBAL":
/// - "RELATIVE_ALT": Altitude is relative to the vehicle home position rather than MSL.
/// - "TERRAIN_ALT": Altitude is relative to ground level rather than MSL.
/// - "INT": Latitude/longitude (in degrees) are scaled by multiplying by 1E7.
///
/// Local frames use the following naming conventions:
/// - "LOCAL": Origin of local frame is fixed relative to earth. Unless otherwise specified this origin is the origin of the vehicle position-estimator ("EKF").
/// - "BODY": Origin of local frame travels with the vehicle. NOTE, "BODY" does NOT indicate alignment of frame axis with vehicle attitude.
/// - "OFFSET": Deprecated synonym for "BODY" (origin travels with the vehicle). Not to be used for new frames.
///
/// Some deprecated frames do not follow these conventions (e.g. MAV_FRAME_BODY_NED and MAV_FRAME_BODY_OFFSET_NED).
///
///
/// MAV_FRAME
typedef MavFrame = int;

/// Global (WGS84) coordinate frame + altitude relative to mean sea level (MSL).
///
/// MAV_FRAME_GLOBAL
const MavFrame mavFrameGlobal = 0;

/// NED local tangent frame (x: North, y: East, z: Down) with origin fixed relative to earth.
///
/// MAV_FRAME_LOCAL_NED
const MavFrame mavFrameLocalNed = 1;

/// NOT a coordinate frame, indicates a mission command.
///
/// MAV_FRAME_MISSION
const MavFrame mavFrameMission = 2;

///
/// Global (WGS84) coordinate frame + altitude relative to the home position.
///
///
/// MAV_FRAME_GLOBAL_RELATIVE_ALT
const MavFrame mavFrameGlobalRelativeAlt = 3;

/// ENU local tangent frame (x: East, y: North, z: Up) with origin fixed relative to earth.
///
/// MAV_FRAME_LOCAL_ENU
const MavFrame mavFrameLocalEnu = 4;

/// Global (WGS84) coordinate frame (scaled) + altitude relative to mean sea level (MSL).
///
/// MAV_FRAME_GLOBAL_INT
@Deprecated(
    "Replaced by [MAV_FRAME_GLOBAL] since 2024-03. Use MAV_FRAME_GLOBAL in COMMAND_INT (and elsewhere) as a synonymous replacement.")
const MavFrame mavFrameGlobalInt = 5;

/// Global (WGS84) coordinate frame (scaled) + altitude relative to the home position.
///
/// MAV_FRAME_GLOBAL_RELATIVE_ALT_INT
@Deprecated(
    "Replaced by [MAV_FRAME_GLOBAL_RELATIVE_ALT] since 2024-03. Use MAV_FRAME_GLOBAL_RELATIVE_ALT in COMMAND_INT (and elsewhere) as a synonymous replacement.")
const MavFrame mavFrameGlobalRelativeAltInt = 6;

/// NED local tangent frame (x: North, y: East, z: Down) with origin that travels with the vehicle.
///
/// MAV_FRAME_LOCAL_OFFSET_NED
const MavFrame mavFrameLocalOffsetNed = 7;

/// Same as MAV_FRAME_LOCAL_NED when used to represent position values. Same as MAV_FRAME_BODY_FRD when used with velocity/acceleration values.
///
/// MAV_FRAME_BODY_NED
@Deprecated("Replaced by [MAV_FRAME_BODY_FRD] since 2019-08. ")
const MavFrame mavFrameBodyNed = 8;

/// This is the same as MAV_FRAME_BODY_FRD.
///
/// MAV_FRAME_BODY_OFFSET_NED
@Deprecated("Replaced by [MAV_FRAME_BODY_FRD] since 2019-08. ")
const MavFrame mavFrameBodyOffsetNed = 9;

/// Global (WGS84) coordinate frame with AGL altitude (altitude at ground level).
///
/// MAV_FRAME_GLOBAL_TERRAIN_ALT
const MavFrame mavFrameGlobalTerrainAlt = 10;

/// Global (WGS84) coordinate frame (scaled) with AGL altitude (altitude at ground level).
///
/// MAV_FRAME_GLOBAL_TERRAIN_ALT_INT
@Deprecated(
    "Replaced by [MAV_FRAME_GLOBAL_TERRAIN_ALT] since 2024-03. Use MAV_FRAME_GLOBAL_TERRAIN_ALT in COMMAND_INT (and elsewhere) as a synonymous replacement.")
const MavFrame mavFrameGlobalTerrainAltInt = 11;

/// FRD local frame aligned to the vehicle's attitude (x: Forward, y: Right, z: Down) with an origin that travels with vehicle.
///
/// MAV_FRAME_BODY_FRD
const MavFrame mavFrameBodyFrd = 12;

/// MAV_FRAME_BODY_FLU - Body fixed frame of reference, Z-up (x: Forward, y: Left, z: Up).
///
/// MAV_FRAME_RESERVED_13
@Deprecated("Replaced by [] since 2019-04. ")
const MavFrame mavFrameReserved13 = 13;

/// MAV_FRAME_MOCAP_NED - Odometry local coordinate frame of data given by a motion capture system, Z-down (x: North, y: East, z: Down).
///
/// MAV_FRAME_RESERVED_14
@Deprecated("Replaced by [MAV_FRAME_LOCAL_FRD] since 2019-04. ")
const MavFrame mavFrameReserved14 = 14;

/// MAV_FRAME_MOCAP_ENU - Odometry local coordinate frame of data given by a motion capture system, Z-up (x: East, y: North, z: Up).
///
/// MAV_FRAME_RESERVED_15
@Deprecated("Replaced by [MAV_FRAME_LOCAL_FLU] since 2019-04. ")
const MavFrame mavFrameReserved15 = 15;

/// MAV_FRAME_VISION_NED - Odometry local coordinate frame of data given by a vision estimation system, Z-down (x: North, y: East, z: Down).
///
/// MAV_FRAME_RESERVED_16
@Deprecated("Replaced by [MAV_FRAME_LOCAL_FRD] since 2019-04. ")
const MavFrame mavFrameReserved16 = 16;

/// MAV_FRAME_VISION_ENU - Odometry local coordinate frame of data given by a vision estimation system, Z-up (x: East, y: North, z: Up).
///
/// MAV_FRAME_RESERVED_17
@Deprecated("Replaced by [MAV_FRAME_LOCAL_FLU] since 2019-04. ")
const MavFrame mavFrameReserved17 = 17;

/// MAV_FRAME_ESTIM_NED - Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-down (x: North, y: East, z: Down).
///
/// MAV_FRAME_RESERVED_18
@Deprecated("Replaced by [MAV_FRAME_LOCAL_FRD] since 2019-04. ")
const MavFrame mavFrameReserved18 = 18;

/// MAV_FRAME_ESTIM_ENU - Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-up (x: East, y: North, z: Up).
///
/// MAV_FRAME_RESERVED_19
@Deprecated("Replaced by [MAV_FRAME_LOCAL_FLU] since 2019-04. ")
const MavFrame mavFrameReserved19 = 19;

/// FRD local tangent frame (x: Forward, y: Right, z: Down) with origin fixed relative to earth. The forward axis is aligned to the front of the vehicle in the horizontal plane.
///
/// MAV_FRAME_LOCAL_FRD
const MavFrame mavFrameLocalFrd = 20;

/// FLU local tangent frame (x: Forward, y: Left, z: Up) with origin fixed relative to earth. The forward axis is aligned to the front of the vehicle in the horizontal plane.
///
/// MAV_FRAME_LOCAL_FLU
const MavFrame mavFrameLocalFlu = 21;

///
/// MAVLINK_DATA_STREAM_TYPE
typedef MavlinkDataStreamType = int;

///
///
/// MAVLINK_DATA_STREAM_IMG_JPEG
const MavlinkDataStreamType mavlinkDataStreamImgJpeg = 0;

///
///
/// MAVLINK_DATA_STREAM_IMG_BMP
const MavlinkDataStreamType mavlinkDataStreamImgBmp = 1;

///
///
/// MAVLINK_DATA_STREAM_IMG_RAW8U
const MavlinkDataStreamType mavlinkDataStreamImgRaw8u = 2;

///
///
/// MAVLINK_DATA_STREAM_IMG_RAW32U
const MavlinkDataStreamType mavlinkDataStreamImgRaw32u = 3;

///
///
/// MAVLINK_DATA_STREAM_IMG_PGM
const MavlinkDataStreamType mavlinkDataStreamImgPgm = 4;

///
///
/// MAVLINK_DATA_STREAM_IMG_PNG
const MavlinkDataStreamType mavlinkDataStreamImgPng = 5;

/// Actions following geofence breach.
///
/// FENCE_ACTION
typedef FenceAction = int;

/// Disable fenced mode. If used in a plan this would mean the next fence is disabled.
///
/// FENCE_ACTION_NONE
const FenceAction fenceActionNone = 0;

/// Fly to geofence MAV_CMD_NAV_FENCE_RETURN_POINT in GUIDED mode. Note: This action is only supported by ArduPlane, and may not be supported in all versions.
///
/// FENCE_ACTION_GUIDED
const FenceAction fenceActionGuided = 1;

/// Report fence breach, but don't take action
///
/// FENCE_ACTION_REPORT
const FenceAction fenceActionReport = 2;

/// Fly to geofence MAV_CMD_NAV_FENCE_RETURN_POINT with manual throttle control in GUIDED mode. Note: This action is only supported by ArduPlane, and may not be supported in all versions.
///
/// FENCE_ACTION_GUIDED_THR_PASS
const FenceAction fenceActionGuidedThrPass = 3;

/// Return/RTL mode.
///
/// FENCE_ACTION_RTL
const FenceAction fenceActionRtl = 4;

/// Hold at current location.
///
/// FENCE_ACTION_HOLD
const FenceAction fenceActionHold = 5;

/// Termination failsafe. Motors are shut down (some flight stacks may trigger other failsafe actions).
///
/// FENCE_ACTION_TERMINATE
const FenceAction fenceActionTerminate = 6;

/// Land at current location.
///
/// FENCE_ACTION_LAND
const FenceAction fenceActionLand = 7;

///
/// FENCE_BREACH
typedef FenceBreach = int;

/// No last fence breach
///
/// FENCE_BREACH_NONE
const FenceBreach fenceBreachNone = 0;

/// Breached minimum altitude
///
/// FENCE_BREACH_MINALT
const FenceBreach fenceBreachMinalt = 1;

/// Breached maximum altitude
///
/// FENCE_BREACH_MAXALT
const FenceBreach fenceBreachMaxalt = 2;

/// Breached fence boundary
///
/// FENCE_BREACH_BOUNDARY
const FenceBreach fenceBreachBoundary = 3;

/// Actions being taken to mitigate/prevent fence breach
///
/// FENCE_MITIGATE
typedef FenceMitigate = int;

/// Unknown
///
/// FENCE_MITIGATE_UNKNOWN
const FenceMitigate fenceMitigateUnknown = 0;

/// No actions being taken
///
/// FENCE_MITIGATE_NONE
const FenceMitigate fenceMitigateNone = 1;

/// Velocity limiting active to prevent breach
///
/// FENCE_MITIGATE_VEL_LIMIT
const FenceMitigate fenceMitigateVelLimit = 2;

///
/// FENCE_TYPE
typedef FenceType = int;

/// All fence types
///
/// FENCE_TYPE_ALL
const FenceType fenceTypeAll = 0;

/// Maximum altitude fence
///
/// FENCE_TYPE_ALT_MAX
const FenceType fenceTypeAltMax = 1;

/// Circle fence
///
/// FENCE_TYPE_CIRCLE
const FenceType fenceTypeCircle = 2;

/// Polygon fence
///
/// FENCE_TYPE_POLYGON
const FenceType fenceTypePolygon = 4;

/// Minimum altitude fence
///
/// FENCE_TYPE_ALT_MIN
const FenceType fenceTypeAltMin = 8;

/// Enumeration of possible mount operation modes. This message is used by obsolete/deprecated gimbal messages.
///
/// MAV_MOUNT_MODE
typedef MavMountMode = int;

/// Load and keep safe position (Roll,Pitch,Yaw) from permanent memory and stop stabilization
///
/// MAV_MOUNT_MODE_RETRACT
const MavMountMode mavMountModeRetract = 0;

/// Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory.
///
/// MAV_MOUNT_MODE_NEUTRAL
const MavMountMode mavMountModeNeutral = 1;

/// Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization
///
/// MAV_MOUNT_MODE_MAVLINK_TARGETING
const MavMountMode mavMountModeMavlinkTargeting = 2;

/// Load neutral position and start RC Roll,Pitch,Yaw control with stabilization
///
/// MAV_MOUNT_MODE_RC_TARGETING
const MavMountMode mavMountModeRcTargeting = 3;

/// Load neutral position and start to point to Lat,Lon,Alt
///
/// MAV_MOUNT_MODE_GPS_POINT
const MavMountMode mavMountModeGpsPoint = 4;

/// Gimbal tracks system with specified system ID
///
/// MAV_MOUNT_MODE_SYSID_TARGET
const MavMountMode mavMountModeSysidTarget = 5;

/// Gimbal tracks home position
///
/// MAV_MOUNT_MODE_HOME_LOCATION
const MavMountMode mavMountModeHomeLocation = 6;

/// Gimbal device (low level) capability flags (bitmap).
///
/// GIMBAL_DEVICE_CAP_FLAGS
typedef GimbalDeviceCapFlags = int;

/// Gimbal device supports a retracted position.
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_RETRACT
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasRetract = 1;

/// Gimbal device supports a horizontal, forward looking position, stabilized.
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_NEUTRAL
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasNeutral = 2;

/// Gimbal device supports rotating around roll axis.
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_AXIS
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasRollAxis = 4;

/// Gimbal device supports to follow a roll angle relative to the vehicle.
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_FOLLOW
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasRollFollow = 8;

/// Gimbal device supports locking to a roll angle (generally that's the default with roll stabilized).
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_LOCK
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasRollLock = 16;

/// Gimbal device supports rotating around pitch axis.
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_AXIS
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasPitchAxis = 32;

/// Gimbal device supports to follow a pitch angle relative to the vehicle.
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_FOLLOW
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasPitchFollow = 64;

/// Gimbal device supports locking to a pitch angle (generally that's the default with pitch stabilized).
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_LOCK
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasPitchLock = 128;

/// Gimbal device supports rotating around yaw axis.
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_AXIS
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasYawAxis = 256;

/// Gimbal device supports to follow a yaw angle relative to the vehicle (generally that's the default).
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_FOLLOW
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasYawFollow = 512;

/// Gimbal device supports locking to an absolute heading, i.e., yaw angle relative to North (earth frame, often this is an option available).
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_LOCK
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasYawLock = 1024;

/// Gimbal device supports yawing/panning infinitely (e.g. using slip disk).
///
/// GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_INFINITE_YAW
const GimbalDeviceCapFlags gimbalDeviceCapFlagsSupportsInfiniteYaw = 2048;

/// Gimbal device supports yaw angles and angular velocities relative to North (earth frame). This usually requires support by an autopilot via AUTOPILOT_STATE_FOR_GIMBAL_DEVICE. Support can go on and off during runtime, which is reported by the flag GIMBAL_DEVICE_FLAGS_CAN_ACCEPT_YAW_IN_EARTH_FRAME.
///
/// GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_YAW_IN_EARTH_FRAME
const GimbalDeviceCapFlags gimbalDeviceCapFlagsSupportsYawInEarthFrame = 4096;

/// Gimbal device supports radio control inputs as an alternative input for controlling the gimbal orientation.
///
/// GIMBAL_DEVICE_CAP_FLAGS_HAS_RC_INPUTS
const GimbalDeviceCapFlags gimbalDeviceCapFlagsHasRcInputs = 8192;

/// Gimbal manager high level capability flags (bitmap). The first 16 bits are identical to the GIMBAL_DEVICE_CAP_FLAGS. However, the gimbal manager does not need to copy the flags from the gimbal but can also enhance the capabilities and thus add flags.
///
/// GIMBAL_MANAGER_CAP_FLAGS
typedef GimbalManagerCapFlags = int;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_RETRACT.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_RETRACT
const GimbalManagerCapFlags gimbalManagerCapFlagsHasRetract = 1;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_NEUTRAL.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_NEUTRAL
const GimbalManagerCapFlags gimbalManagerCapFlagsHasNeutral = 2;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_AXIS.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_AXIS
const GimbalManagerCapFlags gimbalManagerCapFlagsHasRollAxis = 4;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_FOLLOW.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_FOLLOW
const GimbalManagerCapFlags gimbalManagerCapFlagsHasRollFollow = 8;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_LOCK.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_LOCK
const GimbalManagerCapFlags gimbalManagerCapFlagsHasRollLock = 16;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_AXIS.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_AXIS
const GimbalManagerCapFlags gimbalManagerCapFlagsHasPitchAxis = 32;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_FOLLOW.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_FOLLOW
const GimbalManagerCapFlags gimbalManagerCapFlagsHasPitchFollow = 64;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_LOCK.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_LOCK
const GimbalManagerCapFlags gimbalManagerCapFlagsHasPitchLock = 128;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_AXIS.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_AXIS
const GimbalManagerCapFlags gimbalManagerCapFlagsHasYawAxis = 256;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_FOLLOW.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_FOLLOW
const GimbalManagerCapFlags gimbalManagerCapFlagsHasYawFollow = 512;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_LOCK.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_LOCK
const GimbalManagerCapFlags gimbalManagerCapFlagsHasYawLock = 1024;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_INFINITE_YAW.
///
/// GIMBAL_MANAGER_CAP_FLAGS_SUPPORTS_INFINITE_YAW
const GimbalManagerCapFlags gimbalManagerCapFlagsSupportsInfiniteYaw = 2048;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_YAW_IN_EARTH_FRAME.
///
/// GIMBAL_MANAGER_CAP_FLAGS_SUPPORTS_YAW_IN_EARTH_FRAME
const GimbalManagerCapFlags gimbalManagerCapFlagsSupportsYawInEarthFrame = 4096;

/// Based on GIMBAL_DEVICE_CAP_FLAGS_HAS_RC_INPUTS.
///
/// GIMBAL_MANAGER_CAP_FLAGS_HAS_RC_INPUTS
const GimbalManagerCapFlags gimbalManagerCapFlagsHasRcInputs = 8192;

/// Gimbal manager supports to point to a local position.
///
/// GIMBAL_MANAGER_CAP_FLAGS_CAN_POINT_LOCATION_LOCAL
const GimbalManagerCapFlags gimbalManagerCapFlagsCanPointLocationLocal = 65536;

/// Gimbal manager supports to point to a global latitude, longitude, altitude position.
///
/// GIMBAL_MANAGER_CAP_FLAGS_CAN_POINT_LOCATION_GLOBAL
const GimbalManagerCapFlags gimbalManagerCapFlagsCanPointLocationGlobal =
    131072;

/// Flags for gimbal device (lower level) operation.
///
/// GIMBAL_DEVICE_FLAGS
typedef GimbalDeviceFlags = int;

/// Set to retracted safe position (no stabilization), takes precedence over all other flags.
///
/// GIMBAL_DEVICE_FLAGS_RETRACT
const GimbalDeviceFlags gimbalDeviceFlagsRetract = 1;

/// Set to neutral/default position, taking precedence over all other flags except RETRACT. Neutral is commonly forward-facing and horizontal (roll=pitch=yaw=0) but may be any orientation.
///
/// GIMBAL_DEVICE_FLAGS_NEUTRAL
const GimbalDeviceFlags gimbalDeviceFlagsNeutral = 2;

/// Lock roll angle to absolute angle relative to horizon (not relative to vehicle). This is generally the default with a stabilizing gimbal.
///
/// GIMBAL_DEVICE_FLAGS_ROLL_LOCK
const GimbalDeviceFlags gimbalDeviceFlagsRollLock = 4;

/// Lock pitch angle to absolute angle relative to horizon (not relative to vehicle). This is generally the default with a stabilizing gimbal.
///
/// GIMBAL_DEVICE_FLAGS_PITCH_LOCK
const GimbalDeviceFlags gimbalDeviceFlagsPitchLock = 8;

/// Lock yaw angle to absolute angle relative to North (not relative to vehicle). If this flag is set, the yaw angle and z component of angular velocity are relative to North (earth frame, x-axis pointing North), else they are relative to the vehicle heading (vehicle frame, earth frame rotated so that the x-axis is pointing forward).
///
/// GIMBAL_DEVICE_FLAGS_YAW_LOCK
const GimbalDeviceFlags gimbalDeviceFlagsYawLock = 16;

/// Yaw angle and z component of angular velocity are relative to the vehicle heading (vehicle frame, earth frame rotated such that the x-axis is pointing forward).
///
/// GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME
const GimbalDeviceFlags gimbalDeviceFlagsYawInVehicleFrame = 32;

/// Yaw angle and z component of angular velocity are relative to North (earth frame, x-axis is pointing North).
///
/// GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME
const GimbalDeviceFlags gimbalDeviceFlagsYawInEarthFrame = 64;

/// Gimbal device can accept yaw angle inputs relative to North (earth frame). This flag is only for reporting (attempts to set this flag are ignored).
///
/// GIMBAL_DEVICE_FLAGS_ACCEPTS_YAW_IN_EARTH_FRAME
const GimbalDeviceFlags gimbalDeviceFlagsAcceptsYawInEarthFrame = 128;

/// The gimbal orientation is set exclusively by the RC signals feed to the gimbal's radio control inputs. MAVLink messages for setting the gimbal orientation (GIMBAL_DEVICE_SET_ATTITUDE) are ignored.
///
/// GIMBAL_DEVICE_FLAGS_RC_EXCLUSIVE
const GimbalDeviceFlags gimbalDeviceFlagsRcExclusive = 256;

/// The gimbal orientation is determined by combining/mixing the RC signals feed to the gimbal's radio control inputs and the MAVLink messages for setting the gimbal orientation (GIMBAL_DEVICE_SET_ATTITUDE). How these two controls are combined or mixed is not defined by the protocol but is up to the implementation.
///
/// GIMBAL_DEVICE_FLAGS_RC_MIXED
const GimbalDeviceFlags gimbalDeviceFlagsRcMixed = 512;

/// Flags for high level gimbal manager operation The first 16 bits are identical to the GIMBAL_DEVICE_FLAGS.
///
/// GIMBAL_MANAGER_FLAGS
typedef GimbalManagerFlags = int;

/// Based on GIMBAL_DEVICE_FLAGS_RETRACT.
///
/// GIMBAL_MANAGER_FLAGS_RETRACT
const GimbalManagerFlags gimbalManagerFlagsRetract = 1;

/// Based on GIMBAL_DEVICE_FLAGS_NEUTRAL.
///
/// GIMBAL_MANAGER_FLAGS_NEUTRAL
const GimbalManagerFlags gimbalManagerFlagsNeutral = 2;

/// Based on GIMBAL_DEVICE_FLAGS_ROLL_LOCK.
///
/// GIMBAL_MANAGER_FLAGS_ROLL_LOCK
const GimbalManagerFlags gimbalManagerFlagsRollLock = 4;

/// Based on GIMBAL_DEVICE_FLAGS_PITCH_LOCK.
///
/// GIMBAL_MANAGER_FLAGS_PITCH_LOCK
const GimbalManagerFlags gimbalManagerFlagsPitchLock = 8;

/// Based on GIMBAL_DEVICE_FLAGS_YAW_LOCK.
///
/// GIMBAL_MANAGER_FLAGS_YAW_LOCK
const GimbalManagerFlags gimbalManagerFlagsYawLock = 16;

/// Based on GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME.
///
/// GIMBAL_MANAGER_FLAGS_YAW_IN_VEHICLE_FRAME
const GimbalManagerFlags gimbalManagerFlagsYawInVehicleFrame = 32;

/// Based on GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME.
///
/// GIMBAL_MANAGER_FLAGS_YAW_IN_EARTH_FRAME
const GimbalManagerFlags gimbalManagerFlagsYawInEarthFrame = 64;

/// Based on GIMBAL_DEVICE_FLAGS_ACCEPTS_YAW_IN_EARTH_FRAME.
///
/// GIMBAL_MANAGER_FLAGS_ACCEPTS_YAW_IN_EARTH_FRAME
const GimbalManagerFlags gimbalManagerFlagsAcceptsYawInEarthFrame = 128;

/// Based on GIMBAL_DEVICE_FLAGS_RC_EXCLUSIVE.
///
/// GIMBAL_MANAGER_FLAGS_RC_EXCLUSIVE
const GimbalManagerFlags gimbalManagerFlagsRcExclusive = 256;

/// Based on GIMBAL_DEVICE_FLAGS_RC_MIXED.
///
/// GIMBAL_MANAGER_FLAGS_RC_MIXED
const GimbalManagerFlags gimbalManagerFlagsRcMixed = 512;

/// Gimbal device (low level) error flags (bitmap, 0 means no error)
///
/// GIMBAL_DEVICE_ERROR_FLAGS
typedef GimbalDeviceErrorFlags = int;

/// Gimbal device is limited by hardware roll limit.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_AT_ROLL_LIMIT
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsAtRollLimit = 1;

/// Gimbal device is limited by hardware pitch limit.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_AT_PITCH_LIMIT
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsAtPitchLimit = 2;

/// Gimbal device is limited by hardware yaw limit.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_AT_YAW_LIMIT
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsAtYawLimit = 4;

/// There is an error with the gimbal encoders.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_ENCODER_ERROR
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsEncoderError = 8;

/// There is an error with the gimbal power source.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_POWER_ERROR
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsPowerError = 16;

/// There is an error with the gimbal motors.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_MOTOR_ERROR
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsMotorError = 32;

/// There is an error with the gimbal's software.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_SOFTWARE_ERROR
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsSoftwareError = 64;

/// There is an error with the gimbal's communication.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_COMMS_ERROR
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsCommsError = 128;

/// Gimbal device is currently calibrating.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_CALIBRATION_RUNNING
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsCalibrationRunning = 256;

/// Gimbal device is not assigned to a gimbal manager.
///
/// GIMBAL_DEVICE_ERROR_FLAGS_NO_MANAGER
const GimbalDeviceErrorFlags gimbalDeviceErrorFlagsNoManager = 512;

/// Gripper actions.
///
/// GRIPPER_ACTIONS
typedef GripperActions = int;

/// Gripper release cargo.
///
/// GRIPPER_ACTION_RELEASE
const GripperActions gripperActionRelease = 0;

/// Gripper grab onto cargo.
///
/// GRIPPER_ACTION_GRAB
const GripperActions gripperActionGrab = 1;

/// Winch actions.
///
/// WINCH_ACTIONS
typedef WinchActions = int;

/// Allow motor to freewheel.
///
/// WINCH_RELAXED
const WinchActions winchRelaxed = 0;

/// Wind or unwind specified length of line, optionally using specified rate.
///
/// WINCH_RELATIVE_LENGTH_CONTROL
const WinchActions winchRelativeLengthControl = 1;

/// Wind or unwind line at specified rate.
///
/// WINCH_RATE_CONTROL
const WinchActions winchRateControl = 2;

/// Perform the locking sequence to relieve motor while in the fully retracted position. Only action and instance command parameters are used, others are ignored.
///
/// WINCH_LOCK
const WinchActions winchLock = 3;

/// Sequence of drop, slow down, touch down, reel up, lock. Only action and instance command parameters are used, others are ignored.
///
/// WINCH_DELIVER
const WinchActions winchDeliver = 4;

/// Engage motor and hold current position. Only action and instance command parameters are used, others are ignored.
///
/// WINCH_HOLD
const WinchActions winchHold = 5;

/// Return the reel to the fully retracted position. Only action and instance command parameters are used, others are ignored.
///
/// WINCH_RETRACT
const WinchActions winchRetract = 6;

/// Load the reel with line. The winch will calculate the total loaded length and stop when the tension exceeds a threshold. Only action and instance command parameters are used, others are ignored.
///
/// WINCH_LOAD_LINE
const WinchActions winchLoadLine = 7;

/// Spool out the entire length of the line. Only action and instance command parameters are used, others are ignored.
///
/// WINCH_ABANDON_LINE
const WinchActions winchAbandonLine = 8;

/// Spools out just enough to present the hook to the user to load the payload. Only action and instance command parameters are used, others are ignored
///
/// WINCH_LOAD_PAYLOAD
const WinchActions winchLoadPayload = 9;

/// Generalized UAVCAN node health
///
/// UAVCAN_NODE_HEALTH
typedef UavcanNodeHealth = int;

/// The node is functioning properly.
///
/// UAVCAN_NODE_HEALTH_OK
const UavcanNodeHealth uavcanNodeHealthOk = 0;

/// A critical parameter went out of range or the node has encountered a minor failure.
///
/// UAVCAN_NODE_HEALTH_WARNING
const UavcanNodeHealth uavcanNodeHealthWarning = 1;

/// The node has encountered a major failure.
///
/// UAVCAN_NODE_HEALTH_ERROR
const UavcanNodeHealth uavcanNodeHealthError = 2;

/// The node has suffered a fatal malfunction.
///
/// UAVCAN_NODE_HEALTH_CRITICAL
const UavcanNodeHealth uavcanNodeHealthCritical = 3;

/// Generalized UAVCAN node mode
///
/// UAVCAN_NODE_MODE
typedef UavcanNodeMode = int;

/// The node is performing its primary functions.
///
/// UAVCAN_NODE_MODE_OPERATIONAL
const UavcanNodeMode uavcanNodeModeOperational = 0;

/// The node is initializing; this mode is entered immediately after startup.
///
/// UAVCAN_NODE_MODE_INITIALIZATION
const UavcanNodeMode uavcanNodeModeInitialization = 1;

/// The node is under maintenance.
///
/// UAVCAN_NODE_MODE_MAINTENANCE
const UavcanNodeMode uavcanNodeModeMaintenance = 2;

/// The node is in the process of updating its software.
///
/// UAVCAN_NODE_MODE_SOFTWARE_UPDATE
const UavcanNodeMode uavcanNodeModeSoftwareUpdate = 3;

/// The node is no longer available online.
///
/// UAVCAN_NODE_MODE_OFFLINE
const UavcanNodeMode uavcanNodeModeOffline = 7;

/// Indicates the ESC connection type.
///
/// ESC_CONNECTION_TYPE
typedef EscConnectionType = int;

/// Traditional PPM ESC.
///
/// ESC_CONNECTION_TYPE_PPM
const EscConnectionType escConnectionTypePpm = 0;

/// Serial Bus connected ESC.
///
/// ESC_CONNECTION_TYPE_SERIAL
const EscConnectionType escConnectionTypeSerial = 1;

/// One Shot PPM ESC.
///
/// ESC_CONNECTION_TYPE_ONESHOT
const EscConnectionType escConnectionTypeOneshot = 2;

/// I2C ESC.
///
/// ESC_CONNECTION_TYPE_I2C
const EscConnectionType escConnectionTypeI2c = 3;

/// CAN-Bus ESC.
///
/// ESC_CONNECTION_TYPE_CAN
const EscConnectionType escConnectionTypeCan = 4;

/// DShot ESC.
///
/// ESC_CONNECTION_TYPE_DSHOT
const EscConnectionType escConnectionTypeDshot = 5;

/// Flags to report ESC failures.
///
/// ESC_FAILURE_FLAGS
typedef EscFailureFlags = int;

/// No ESC failure.
///
/// ESC_FAILURE_NONE
const EscFailureFlags escFailureNone = 0;

/// Over current failure.
///
/// ESC_FAILURE_OVER_CURRENT
const EscFailureFlags escFailureOverCurrent = 1;

/// Over voltage failure.
///
/// ESC_FAILURE_OVER_VOLTAGE
const EscFailureFlags escFailureOverVoltage = 2;

/// Over temperature failure.
///
/// ESC_FAILURE_OVER_TEMPERATURE
const EscFailureFlags escFailureOverTemperature = 4;

/// Over RPM failure.
///
/// ESC_FAILURE_OVER_RPM
const EscFailureFlags escFailureOverRpm = 8;

/// Inconsistent command failure i.e. out of bounds.
///
/// ESC_FAILURE_INCONSISTENT_CMD
const EscFailureFlags escFailureInconsistentCmd = 16;

/// Motor stuck failure.
///
/// ESC_FAILURE_MOTOR_STUCK
const EscFailureFlags escFailureMotorStuck = 32;

/// Generic ESC failure.
///
/// ESC_FAILURE_GENERIC
const EscFailureFlags escFailureGeneric = 64;

/// Flags to indicate the status of camera storage.
///
/// STORAGE_STATUS
typedef StorageStatus = int;

/// Storage is missing (no microSD card loaded for example.)
///
/// STORAGE_STATUS_EMPTY
const StorageStatus storageStatusEmpty = 0;

/// Storage present but unformatted.
///
/// STORAGE_STATUS_UNFORMATTED
const StorageStatus storageStatusUnformatted = 1;

/// Storage present and ready.
///
/// STORAGE_STATUS_READY
const StorageStatus storageStatusReady = 2;

/// Camera does not supply storage status information. Capacity information in STORAGE_INFORMATION fields will be ignored.
///
/// STORAGE_STATUS_NOT_SUPPORTED
const StorageStatus storageStatusNotSupported = 3;

/// Flags to indicate the type of storage.
///
/// STORAGE_TYPE
typedef StorageType = int;

/// Storage type is not known.
///
/// STORAGE_TYPE_UNKNOWN
const StorageType storageTypeUnknown = 0;

/// Storage type is USB device.
///
/// STORAGE_TYPE_USB_STICK
const StorageType storageTypeUsbStick = 1;

/// Storage type is SD card.
///
/// STORAGE_TYPE_SD
const StorageType storageTypeSd = 2;

/// Storage type is microSD card.
///
/// STORAGE_TYPE_MICROSD
const StorageType storageTypeMicrosd = 3;

/// Storage type is CFast.
///
/// STORAGE_TYPE_CF
const StorageType storageTypeCf = 4;

/// Storage type is CFexpress.
///
/// STORAGE_TYPE_CFE
const StorageType storageTypeCfe = 5;

/// Storage type is XQD.
///
/// STORAGE_TYPE_XQD
const StorageType storageTypeXqd = 6;

/// Storage type is HD mass storage type.
///
/// STORAGE_TYPE_HD
const StorageType storageTypeHd = 7;

/// Storage type is other, not listed type.
///
/// STORAGE_TYPE_OTHER
const StorageType storageTypeOther = 254;

/// Flags to indicate usage for a particular storage (see STORAGE_INFORMATION.storage_usage and MAV_CMD_SET_STORAGE_USAGE).
///
/// STORAGE_USAGE_FLAG
typedef StorageUsageFlag = int;

/// Always set to 1 (indicates STORAGE_INFORMATION.storage_usage is supported).
///
/// STORAGE_USAGE_FLAG_SET
const StorageUsageFlag storageUsageFlagSet = 1;

/// Storage for saving photos.
///
/// STORAGE_USAGE_FLAG_PHOTO
const StorageUsageFlag storageUsageFlagPhoto = 2;

/// Storage for saving videos.
///
/// STORAGE_USAGE_FLAG_VIDEO
const StorageUsageFlag storageUsageFlagVideo = 4;

/// Storage for saving logs.
///
/// STORAGE_USAGE_FLAG_LOGS
const StorageUsageFlag storageUsageFlagLogs = 8;

/// Yaw behaviour during orbit flight.
///
/// ORBIT_YAW_BEHAVIOUR
typedef OrbitYawBehaviour = int;

/// Vehicle front points to the center (default).
///
/// ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TO_CIRCLE_CENTER
const OrbitYawBehaviour orbitYawBehaviourHoldFrontToCircleCenter = 0;

/// Vehicle front holds heading when message received.
///
/// ORBIT_YAW_BEHAVIOUR_HOLD_INITIAL_HEADING
const OrbitYawBehaviour orbitYawBehaviourHoldInitialHeading = 1;

/// Yaw uncontrolled.
///
/// ORBIT_YAW_BEHAVIOUR_UNCONTROLLED
const OrbitYawBehaviour orbitYawBehaviourUncontrolled = 2;

/// Vehicle front follows flight path (tangential to circle).
///
/// ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TANGENT_TO_CIRCLE
const OrbitYawBehaviour orbitYawBehaviourHoldFrontTangentToCircle = 3;

/// Yaw controlled by RC input.
///
/// ORBIT_YAW_BEHAVIOUR_RC_CONTROLLED
const OrbitYawBehaviour orbitYawBehaviourRcControlled = 4;

/// Vehicle uses current yaw behaviour (unchanged). The vehicle-default yaw behaviour is used if this value is specified when orbit is first commanded.
///
/// ORBIT_YAW_BEHAVIOUR_UNCHANGED
const OrbitYawBehaviour orbitYawBehaviourUnchanged = 5;

/// Possible responses from a WIFI_CONFIG_AP message.
///
/// WIFI_CONFIG_AP_RESPONSE
typedef WifiConfigApResponse = int;

/// Undefined response. Likely an indicative of a system that doesn't support this request.
///
/// WIFI_CONFIG_AP_RESPONSE_UNDEFINED
const WifiConfigApResponse wifiConfigApResponseUndefined = 0;

/// Changes accepted.
///
/// WIFI_CONFIG_AP_RESPONSE_ACCEPTED
const WifiConfigApResponse wifiConfigApResponseAccepted = 1;

/// Changes rejected.
///
/// WIFI_CONFIG_AP_RESPONSE_REJECTED
const WifiConfigApResponse wifiConfigApResponseRejected = 2;

/// Invalid Mode.
///
/// WIFI_CONFIG_AP_RESPONSE_MODE_ERROR
const WifiConfigApResponse wifiConfigApResponseModeError = 3;

/// Invalid SSID.
///
/// WIFI_CONFIG_AP_RESPONSE_SSID_ERROR
const WifiConfigApResponse wifiConfigApResponseSsidError = 4;

/// Invalid Password.
///
/// WIFI_CONFIG_AP_RESPONSE_PASSWORD_ERROR
const WifiConfigApResponse wifiConfigApResponsePasswordError = 5;

/// Possible responses from a CELLULAR_CONFIG message.
///
/// CELLULAR_CONFIG_RESPONSE
typedef CellularConfigResponse = int;

/// Changes accepted.
///
/// CELLULAR_CONFIG_RESPONSE_ACCEPTED
const CellularConfigResponse cellularConfigResponseAccepted = 0;

/// Invalid APN.
///
/// CELLULAR_CONFIG_RESPONSE_APN_ERROR
const CellularConfigResponse cellularConfigResponseApnError = 1;

/// Invalid PIN.
///
/// CELLULAR_CONFIG_RESPONSE_PIN_ERROR
const CellularConfigResponse cellularConfigResponsePinError = 2;

/// Changes rejected.
///
/// CELLULAR_CONFIG_RESPONSE_REJECTED
const CellularConfigResponse cellularConfigResponseRejected = 3;

/// PUK is required to unblock SIM card.
///
/// CELLULAR_CONFIG_BLOCKED_PUK_REQUIRED
const CellularConfigResponse cellularConfigBlockedPukRequired = 4;

/// WiFi Mode.
///
/// WIFI_CONFIG_AP_MODE
typedef WifiConfigApMode = int;

/// WiFi mode is undefined.
///
/// WIFI_CONFIG_AP_MODE_UNDEFINED
const WifiConfigApMode wifiConfigApModeUndefined = 0;

/// WiFi configured as an access point.
///
/// WIFI_CONFIG_AP_MODE_AP
const WifiConfigApMode wifiConfigApModeAp = 1;

/// WiFi configured as a station connected to an existing local WiFi network.
///
/// WIFI_CONFIG_AP_MODE_STATION
const WifiConfigApMode wifiConfigApModeStation = 2;

/// WiFi disabled.
///
/// WIFI_CONFIG_AP_MODE_DISABLED
const WifiConfigApMode wifiConfigApModeDisabled = 3;

/// Supported component metadata types. These are used in the "general" metadata file returned by COMPONENT_METADATA to provide information about supported metadata types. The types are not used directly in MAVLink messages.
///
/// COMP_METADATA_TYPE
typedef CompMetadataType = int;

/// General information about the component. General metadata includes information about other metadata types supported by the component. Files of this type must be supported, and must be downloadable from vehicle using a MAVLink FTP URI.
///
/// COMP_METADATA_TYPE_GENERAL
const CompMetadataType compMetadataTypeGeneral = 0;

/// Parameter meta data.
///
/// COMP_METADATA_TYPE_PARAMETER
const CompMetadataType compMetadataTypeParameter = 1;

/// Meta data that specifies which commands and command parameters the vehicle supports. (WIP)
///
/// COMP_METADATA_TYPE_COMMANDS
const CompMetadataType compMetadataTypeCommands = 2;

/// Meta data that specifies external non-MAVLink peripherals.
///
/// COMP_METADATA_TYPE_PERIPHERALS
const CompMetadataType compMetadataTypePeripherals = 3;

/// Meta data for the events interface.
///
/// COMP_METADATA_TYPE_EVENTS
const CompMetadataType compMetadataTypeEvents = 4;

/// Meta data for actuator configuration (motors, servos and vehicle geometry) and testing.
///
/// COMP_METADATA_TYPE_ACTUATORS
const CompMetadataType compMetadataTypeActuators = 5;

/// Actuator configuration, used to change a setting on an actuator. Component information metadata can be used to know which outputs support which commands.
///
/// ACTUATOR_CONFIGURATION
typedef ActuatorConfiguration = int;

/// Do nothing.
///
/// ACTUATOR_CONFIGURATION_NONE
const ActuatorConfiguration actuatorConfigurationNone = 0;

/// Command the actuator to beep now.
///
/// ACTUATOR_CONFIGURATION_BEEP
const ActuatorConfiguration actuatorConfigurationBeep = 1;

/// Permanently set the actuator (ESC) to 3D mode (reversible thrust).
///
/// ACTUATOR_CONFIGURATION_3D_MODE_ON
const ActuatorConfiguration actuatorConfiguration3dModeOn = 2;

/// Permanently set the actuator (ESC) to non 3D mode (non-reversible thrust).
///
/// ACTUATOR_CONFIGURATION_3D_MODE_OFF
const ActuatorConfiguration actuatorConfiguration3dModeOff = 3;

/// Permanently set the actuator (ESC) to spin direction 1 (which can be clockwise or counter-clockwise).
///
/// ACTUATOR_CONFIGURATION_SPIN_DIRECTION1
const ActuatorConfiguration actuatorConfigurationSpinDirection1 = 4;

/// Permanently set the actuator (ESC) to spin direction 2 (opposite of direction 1).
///
/// ACTUATOR_CONFIGURATION_SPIN_DIRECTION2
const ActuatorConfiguration actuatorConfigurationSpinDirection2 = 5;

/// Actuator output function. Values greater or equal to 1000 are autopilot-specific.
///
/// ACTUATOR_OUTPUT_FUNCTION
typedef ActuatorOutputFunction = int;

/// No function (disabled).
///
/// ACTUATOR_OUTPUT_FUNCTION_NONE
const ActuatorOutputFunction actuatorOutputFunctionNone = 0;

/// Motor 1
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR1
const ActuatorOutputFunction actuatorOutputFunctionMotor1 = 1;

/// Motor 2
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR2
const ActuatorOutputFunction actuatorOutputFunctionMotor2 = 2;

/// Motor 3
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR3
const ActuatorOutputFunction actuatorOutputFunctionMotor3 = 3;

/// Motor 4
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR4
const ActuatorOutputFunction actuatorOutputFunctionMotor4 = 4;

/// Motor 5
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR5
const ActuatorOutputFunction actuatorOutputFunctionMotor5 = 5;

/// Motor 6
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR6
const ActuatorOutputFunction actuatorOutputFunctionMotor6 = 6;

/// Motor 7
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR7
const ActuatorOutputFunction actuatorOutputFunctionMotor7 = 7;

/// Motor 8
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR8
const ActuatorOutputFunction actuatorOutputFunctionMotor8 = 8;

/// Motor 9
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR9
const ActuatorOutputFunction actuatorOutputFunctionMotor9 = 9;

/// Motor 10
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR10
const ActuatorOutputFunction actuatorOutputFunctionMotor10 = 10;

/// Motor 11
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR11
const ActuatorOutputFunction actuatorOutputFunctionMotor11 = 11;

/// Motor 12
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR12
const ActuatorOutputFunction actuatorOutputFunctionMotor12 = 12;

/// Motor 13
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR13
const ActuatorOutputFunction actuatorOutputFunctionMotor13 = 13;

/// Motor 14
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR14
const ActuatorOutputFunction actuatorOutputFunctionMotor14 = 14;

/// Motor 15
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR15
const ActuatorOutputFunction actuatorOutputFunctionMotor15 = 15;

/// Motor 16
///
/// ACTUATOR_OUTPUT_FUNCTION_MOTOR16
const ActuatorOutputFunction actuatorOutputFunctionMotor16 = 16;

/// Servo 1
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO1
const ActuatorOutputFunction actuatorOutputFunctionServo1 = 33;

/// Servo 2
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO2
const ActuatorOutputFunction actuatorOutputFunctionServo2 = 34;

/// Servo 3
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO3
const ActuatorOutputFunction actuatorOutputFunctionServo3 = 35;

/// Servo 4
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO4
const ActuatorOutputFunction actuatorOutputFunctionServo4 = 36;

/// Servo 5
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO5
const ActuatorOutputFunction actuatorOutputFunctionServo5 = 37;

/// Servo 6
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO6
const ActuatorOutputFunction actuatorOutputFunctionServo6 = 38;

/// Servo 7
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO7
const ActuatorOutputFunction actuatorOutputFunctionServo7 = 39;

/// Servo 8
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO8
const ActuatorOutputFunction actuatorOutputFunctionServo8 = 40;

/// Servo 9
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO9
const ActuatorOutputFunction actuatorOutputFunctionServo9 = 41;

/// Servo 10
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO10
const ActuatorOutputFunction actuatorOutputFunctionServo10 = 42;

/// Servo 11
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO11
const ActuatorOutputFunction actuatorOutputFunctionServo11 = 43;

/// Servo 12
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO12
const ActuatorOutputFunction actuatorOutputFunctionServo12 = 44;

/// Servo 13
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO13
const ActuatorOutputFunction actuatorOutputFunctionServo13 = 45;

/// Servo 14
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO14
const ActuatorOutputFunction actuatorOutputFunctionServo14 = 46;

/// Servo 15
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO15
const ActuatorOutputFunction actuatorOutputFunctionServo15 = 47;

/// Servo 16
///
/// ACTUATOR_OUTPUT_FUNCTION_SERVO16
const ActuatorOutputFunction actuatorOutputFunctionServo16 = 48;

/// Enable axes that will be tuned via autotuning. Used in MAV_CMD_DO_AUTOTUNE_ENABLE.
///
/// AUTOTUNE_AXIS
typedef AutotuneAxis = int;

/// Flight stack tunes axis according to its default settings.
///
/// AUTOTUNE_AXIS_DEFAULT
const AutotuneAxis autotuneAxisDefault = 0;

/// Autotune roll axis.
///
/// AUTOTUNE_AXIS_ROLL
const AutotuneAxis autotuneAxisRoll = 1;

/// Autotune pitch axis.
///
/// AUTOTUNE_AXIS_PITCH
const AutotuneAxis autotuneAxisPitch = 2;

/// Autotune yaw axis.
///
/// AUTOTUNE_AXIS_YAW
const AutotuneAxis autotuneAxisYaw = 4;

///
/// Actions for reading/writing parameters between persistent and volatile storage when using MAV_CMD_PREFLIGHT_STORAGE.
/// (Commonly parameters are loaded from persistent storage (flash/EEPROM) into volatile storage (RAM) on startup and written back when they are changed.)
///
///
/// PREFLIGHT_STORAGE_PARAMETER_ACTION
typedef PreflightStorageParameterAction = int;

/// Read all parameters from persistent storage. Replaces values in volatile storage.
///
/// PARAM_READ_PERSISTENT
const PreflightStorageParameterAction paramReadPersistent = 0;

/// Write all parameter values to persistent storage (flash/EEPROM)
///
/// PARAM_WRITE_PERSISTENT
const PreflightStorageParameterAction paramWritePersistent = 1;

/// Reset all user configurable parameters to their default value (including airframe selection, sensor calibration data, safety settings, and so on). Does not reset values that contain operation counters and vehicle computed statistics.
///
/// PARAM_RESET_CONFIG_DEFAULT
const PreflightStorageParameterAction paramResetConfigDefault = 2;

/// Reset only sensor calibration parameters to factory defaults (or firmware default if not available)
///
/// PARAM_RESET_SENSOR_DEFAULT
const PreflightStorageParameterAction paramResetSensorDefault = 3;

/// Reset all parameters, including operation counters, to default values
///
/// PARAM_RESET_ALL_DEFAULT
const PreflightStorageParameterAction paramResetAllDefault = 4;

///
/// Actions for reading and writing plan information (mission, rally points, geofence) between persistent and volatile storage when using MAV_CMD_PREFLIGHT_STORAGE.
/// (Commonly missions are loaded from persistent storage (flash/EEPROM) into volatile storage (RAM) on startup and written back when they are changed.)
///
///
/// PREFLIGHT_STORAGE_MISSION_ACTION
typedef PreflightStorageMissionAction = int;

/// Read current mission data from persistent storage
///
/// MISSION_READ_PERSISTENT
const PreflightStorageMissionAction missionReadPersistent = 0;

/// Write current mission data to persistent storage
///
/// MISSION_WRITE_PERSISTENT
const PreflightStorageMissionAction missionWritePersistent = 1;

/// Erase all mission data stored on the vehicle (both persistent and volatile storage)
///
/// MISSION_RESET_DEFAULT
const PreflightStorageMissionAction missionResetDefault = 2;

/// Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script. If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows: Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data. NaN and INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current yaw or latitude rather than a specific value). See https://mavlink.io/en/guide/xml_schema.html#MAV_CMD for information about the structure of the MAV_CMD entries
///
/// MAV_CMD
typedef MavCmd = int;

/// Navigate to waypoint. This is intended for use in missions (for guided commands outside of missions use MAV_CMD_DO_REPOSITION).
///
/// MAV_CMD_NAV_WAYPOINT
const MavCmd mavCmdNavWaypoint = 16;

/// Loiter around this waypoint an unlimited amount of time
///
/// MAV_CMD_NAV_LOITER_UNLIM
const MavCmd mavCmdNavLoiterUnlim = 17;

/// Loiter around this waypoint for X turns
///
/// MAV_CMD_NAV_LOITER_TURNS
const MavCmd mavCmdNavLoiterTurns = 18;

/// Loiter at the specified latitude, longitude and altitude for a certain amount of time. Multicopter vehicles stop at the point (within a vehicle-specific acceptance radius). Forward-only moving vehicles (e.g. fixed-wing) circle the point with the specified radius/direction. If the Heading Required parameter (2) is non-zero forward moving aircraft will only leave the loiter circle once heading towards the next waypoint.
///
/// MAV_CMD_NAV_LOITER_TIME
const MavCmd mavCmdNavLoiterTime = 19;

/// Return to launch location
///
/// MAV_CMD_NAV_RETURN_TO_LAUNCH
const MavCmd mavCmdNavReturnToLaunch = 20;

/// Land at location.
///
/// MAV_CMD_NAV_LAND
const MavCmd mavCmdNavLand = 21;

/// Takeoff from ground / hand. Vehicles that support multiple takeoff modes (e.g. VTOL quadplane) should take off using the currently configured mode.
///
/// MAV_CMD_NAV_TAKEOFF
const MavCmd mavCmdNavTakeoff = 22;

/// Land at local position (local frame only)
///
/// MAV_CMD_NAV_LAND_LOCAL
const MavCmd mavCmdNavLandLocal = 23;

/// Takeoff from local position (local frame only)
///
/// MAV_CMD_NAV_TAKEOFF_LOCAL
const MavCmd mavCmdNavTakeoffLocal = 24;

/// Vehicle following, i.e. this waypoint represents the position of a moving vehicle
///
/// MAV_CMD_NAV_FOLLOW
const MavCmd mavCmdNavFollow = 25;

/// Continue on the current course and climb/descend to specified altitude.  When the altitude is reached continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached.
///
/// MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT
const MavCmd mavCmdNavContinueAndChangeAlt = 30;

/// Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.  Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached. Additionally, if the Heading Required parameter is non-zero the aircraft will not leave the loiter until heading toward the next waypoint.
///
/// MAV_CMD_NAV_LOITER_TO_ALT
const MavCmd mavCmdNavLoiterToAlt = 31;

/// Begin following a target
///
/// MAV_CMD_DO_FOLLOW
const MavCmd mavCmdDoFollow = 32;

/// Reposition the MAV after a follow target command has been sent
///
/// MAV_CMD_DO_FOLLOW_REPOSITION
const MavCmd mavCmdDoFollowReposition = 33;

/// WIP.
/// Start orbiting on the circumference of a circle defined by the parameters. Setting values to NaN/INT32_MAX (as appropriate) results in using defaults.
///
/// MAV_CMD_DO_ORBIT
const MavCmd mavCmdDoOrbit = 34;

/// Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras.
///
/// MAV_CMD_NAV_ROI
@Deprecated("Replaced by [`MAV_CMD_DO_SET_ROI_*`] since 2018-01. ")
const MavCmd mavCmdNavRoi = 80;

/// Control autonomous path planning on the MAV.
///
/// MAV_CMD_NAV_PATHPLANNING
const MavCmd mavCmdNavPathplanning = 81;

/// Navigate to waypoint using a spline path.
///
/// MAV_CMD_NAV_SPLINE_WAYPOINT
const MavCmd mavCmdNavSplineWaypoint = 82;

/// Takeoff from ground using VTOL mode, and transition to forward flight with specified heading. The command should be ignored by vehicles that dont support both VTOL and fixed-wing flight (multicopters, boats,etc.).
///
/// MAV_CMD_NAV_VTOL_TAKEOFF
const MavCmd mavCmdNavVtolTakeoff = 84;

/// Land using VTOL mode
///
/// MAV_CMD_NAV_VTOL_LAND
const MavCmd mavCmdNavVtolLand = 85;

/// hand control over to an external controller
///
/// MAV_CMD_NAV_GUIDED_ENABLE
const MavCmd mavCmdNavGuidedEnable = 92;

/// Delay the next navigation command a number of seconds or until a specified time
///
/// MAV_CMD_NAV_DELAY
const MavCmd mavCmdNavDelay = 93;

/// Descend and place payload. Vehicle moves to specified location, descends until it detects a hanging payload has reached the ground, and then releases the payload. If ground is not detected before the reaching the maximum descent value (param1), the command will complete without releasing the payload.
///
/// MAV_CMD_NAV_PAYLOAD_PLACE
const MavCmd mavCmdNavPayloadPlace = 94;

/// NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeration
///
/// MAV_CMD_NAV_LAST
const MavCmd mavCmdNavLast = 95;

/// Delay mission state machine.
///
/// MAV_CMD_CONDITION_DELAY
const MavCmd mavCmdConditionDelay = 112;

/// Ascend/descend to target altitude at specified rate. Delay mission state machine until desired altitude reached.
///
/// MAV_CMD_CONDITION_CHANGE_ALT
const MavCmd mavCmdConditionChangeAlt = 113;

/// Delay mission state machine until within desired distance of next NAV point.
///
/// MAV_CMD_CONDITION_DISTANCE
const MavCmd mavCmdConditionDistance = 114;

/// Reach a certain target angle.
///
/// MAV_CMD_CONDITION_YAW
const MavCmd mavCmdConditionYaw = 115;

/// NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeration
///
/// MAV_CMD_CONDITION_LAST
const MavCmd mavCmdConditionLast = 159;

/// Set system mode.
///
/// MAV_CMD_DO_SET_MODE
const MavCmd mavCmdDoSetMode = 176;

/// Jump to the desired command in the mission list.  Repeat this action only the specified number of times
///
/// MAV_CMD_DO_JUMP
const MavCmd mavCmdDoJump = 177;

/// Change speed and/or throttle set points. The value persists until it is overridden or there is a mode change
///
/// MAV_CMD_DO_CHANGE_SPEED
const MavCmd mavCmdDoChangeSpeed = 178;

///
/// Sets the home position to either to the current position or a specified position.
/// The home position is the default position that the system will return to and land on.
/// The position is set automatically by the system during the takeoff (and may also be set using this command).
/// Note: the current home position may be emitted in a HOME_POSITION message on request (using MAV_CMD_REQUEST_MESSAGE with param1=242).
///
///
/// MAV_CMD_DO_SET_HOME
const MavCmd mavCmdDoSetHome = 179;

/// Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value of the parameter.
///
/// MAV_CMD_DO_SET_PARAMETER
@Deprecated("Replaced by [PARAM_SET] since 2024-04. ")
const MavCmd mavCmdDoSetParameter = 180;

/// Set a relay to a condition.
///
/// MAV_CMD_DO_SET_RELAY
const MavCmd mavCmdDoSetRelay = 181;

/// Cycle a relay on and off for a desired number of cycles with a desired period.
///
/// MAV_CMD_DO_REPEAT_RELAY
const MavCmd mavCmdDoRepeatRelay = 182;

/// Set a servo to a desired PWM value.
///
/// MAV_CMD_DO_SET_SERVO
const MavCmd mavCmdDoSetServo = 183;

/// Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period.
///
/// MAV_CMD_DO_REPEAT_SERVO
const MavCmd mavCmdDoRepeatServo = 184;

/// Terminate flight immediately.
/// Flight termination immediately and irreversibly terminates the current flight, returning the vehicle to ground.
/// The vehicle will ignore RC or other input until it has been power-cycled.
/// Termination may trigger safety measures, including: disabling motors and deployment of parachute on multicopters, and setting flight surfaces to initiate a landing pattern on fixed-wing).
/// On multicopters without a parachute it may trigger a crash landing.
/// Support for this command can be tested using the protocol bit: MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION.
/// Support for this command can also be tested by sending the command with param1=0 (< 0.5); the ACK should be either MAV_RESULT_FAILED or MAV_RESULT_UNSUPPORTED.
///
///
/// MAV_CMD_DO_FLIGHTTERMINATION
const MavCmd mavCmdDoFlighttermination = 185;

/// Change altitude set point.
///
/// MAV_CMD_DO_CHANGE_ALTITUDE
const MavCmd mavCmdDoChangeAltitude = 186;

/// Sets actuators (e.g. servos) to a desired value. The actuator numbers are mapped to specific outputs (e.g. on any MAIN or AUX PWM or UAVCAN) using a flight-stack specific mechanism (i.e. a parameter).
///
/// MAV_CMD_DO_SET_ACTUATOR
const MavCmd mavCmdDoSetActuator = 187;

/// WIP.
/// Mission item to specify the start of a failsafe/landing return-path segment (the end of the segment is the next MAV_CMD_DO_LAND_START item).
/// A vehicle that is using missions for landing (e.g. in a return mode) will join the mission on the closest path of the return-path segment (instead of MAV_CMD_DO_LAND_START or the nearest waypoint).
/// The main use case is to minimize the failsafe flight path in corridor missions, where the inbound/outbound paths are constrained (by geofences) to the same particular path.
/// The MAV_CMD_NAV_RETURN_PATH_START would be placed at the start of the return path.
/// If a failsafe occurs on the outbound path the vehicle will move to the nearest point on the return path (which is parallel for this kind of mission), effectively turning round and following the shortest path to landing.
/// If a failsafe occurs on the inbound path the vehicle is already on the return segment and will continue to landing.
/// The Latitude/Longitude/Altitude are optional, and may be set to 0 if not needed.
/// If specified, the item defines the waypoint at which the return segment starts.
/// If sent using as a command, the vehicle will perform a mission landing (using the land segment if defined) or reject the command if mission landings are not supported, or no mission landing is defined. When used as a command any position information in the command is ignored.
///
///
/// MAV_CMD_DO_RETURN_PATH_START
const MavCmd mavCmdDoReturnPathStart = 188;

/// Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where a sequence of mission items that represents a landing starts.
/// It may also be sent via a COMMAND_LONG to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will be used.
/// The Latitude/Longitude/Altitude is optional, and may be set to 0 if not needed. If specified then it will be used to help find the closest landing sequence.
///
///
/// MAV_CMD_DO_LAND_START
const MavCmd mavCmdDoLandStart = 189;

/// Mission command to perform a landing from a rally point.
///
/// MAV_CMD_DO_RALLY_LAND
const MavCmd mavCmdDoRallyLand = 190;

/// Mission command to safely abort an autonomous landing.
///
/// MAV_CMD_DO_GO_AROUND
const MavCmd mavCmdDoGoAround = 191;

/// Reposition the vehicle to a specific WGS84 global position. This command is intended for guided commands (for missions use MAV_CMD_NAV_WAYPOINT instead).
///
/// MAV_CMD_DO_REPOSITION
const MavCmd mavCmdDoReposition = 192;

/// If in a GPS controlled position mode, hold the current position or continue.
///
/// MAV_CMD_DO_PAUSE_CONTINUE
const MavCmd mavCmdDoPauseContinue = 193;

/// Set moving direction to forward or reverse.
///
/// MAV_CMD_DO_SET_REVERSE
const MavCmd mavCmdDoSetReverse = 194;

/// Sets the region of interest (ROI) to a location. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal is not to react to this message.
///
/// MAV_CMD_DO_SET_ROI_LOCATION
const MavCmd mavCmdDoSetRoiLocation = 195;

/// Sets the region of interest (ROI) to be toward next waypoint, with optional pitch/roll/yaw offset. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal device is not to react to this message.
///
/// MAV_CMD_DO_SET_ROI_WPNEXT_OFFSET
const MavCmd mavCmdDoSetRoiWpnextOffset = 196;

/// Cancels any previous ROI command returning the vehicle/sensors to default flight characteristics. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal device is not to react to this message. After this command the gimbal manager should go back to manual input if available, and otherwise assume a neutral position.
///
/// MAV_CMD_DO_SET_ROI_NONE
const MavCmd mavCmdDoSetRoiNone = 197;

/// Mount tracks system with specified system ID. Determination of target vehicle position may be done with GLOBAL_POSITION_INT or any other means. This command can be sent to a gimbal manager but not to a gimbal device. A gimbal device is not to react to this message.
///
/// MAV_CMD_DO_SET_ROI_SYSID
const MavCmd mavCmdDoSetRoiSysid = 198;

/// Control onboard camera system.
///
/// MAV_CMD_DO_CONTROL_VIDEO
const MavCmd mavCmdDoControlVideo = 200;

/// Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the vehicle's control system to control the vehicle attitude and the attitude of various sensors such as cameras.
///
/// MAV_CMD_DO_SET_ROI
@Deprecated("Replaced by [`MAV_CMD_DO_SET_ROI_*`] since 2018-01. ")
const MavCmd mavCmdDoSetRoi = 201;

/// Configure digital camera. This is a fallback message for systems that have not yet implemented PARAM_EXT_XXX messages and camera definition files (see https://mavlink.io/en/services/camera_def.html ).
///
/// MAV_CMD_DO_DIGICAM_CONFIGURE
const MavCmd mavCmdDoDigicamConfigure = 202;

/// Control digital camera. This is a fallback message for systems that have not yet implemented PARAM_EXT_XXX messages and camera definition files (see https://mavlink.io/en/services/camera_def.html ).
///
/// MAV_CMD_DO_DIGICAM_CONTROL
const MavCmd mavCmdDoDigicamControl = 203;

/// Mission command to configure a camera or antenna mount
///
/// MAV_CMD_DO_MOUNT_CONFIGURE
@Deprecated(
    "Replaced by [MAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE] since 2020-01. This message has been superseded by MAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE. The message can still be used to communicate with legacy gimbals implementing it.")
const MavCmd mavCmdDoMountConfigure = 204;

/// Mission command to control a camera or antenna mount
///
/// MAV_CMD_DO_MOUNT_CONTROL
@Deprecated(
    "Replaced by [MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW] since 2020-01. This message is ambiguous and inconsistent. It has been superseded by MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW and `MAV_CMD_DO_SET_ROI_*` variants. The message can still be used to communicate with legacy gimbals implementing it.")
const MavCmd mavCmdDoMountControl = 205;

/// Mission command to set camera trigger distance for this flight. The camera is triggered each time this distance is exceeded. This command can also be used to set the shutter integration time for the camera.
///
/// MAV_CMD_DO_SET_CAM_TRIGG_DIST
const MavCmd mavCmdDoSetCamTriggDist = 206;

///
/// Enable the geofence.
/// This can be used in a mission or via the command protocol.
/// The persistence/lifetime of the setting is undefined.
/// Depending on flight stack implementation it may persist until superseded, or it may revert to a system default at the end of a mission.
/// Flight stacks typically reset the setting to system defaults on reboot.
///
///
/// MAV_CMD_DO_FENCE_ENABLE
const MavCmd mavCmdDoFenceEnable = 207;

/// Mission item/command to release a parachute or enable/disable auto release.
///
/// MAV_CMD_DO_PARACHUTE
const MavCmd mavCmdDoParachute = 208;

/// Command to perform motor test.
///
/// MAV_CMD_DO_MOTOR_TEST
const MavCmd mavCmdDoMotorTest = 209;

/// Change to/from inverted flight.
///
/// MAV_CMD_DO_INVERTED_FLIGHT
const MavCmd mavCmdDoInvertedFlight = 210;

/// Mission command to operate a gripper.
///
/// MAV_CMD_DO_GRIPPER
const MavCmd mavCmdDoGripper = 211;

/// Enable/disable autotune.
///
/// MAV_CMD_DO_AUTOTUNE_ENABLE
const MavCmd mavCmdDoAutotuneEnable = 212;

/// Sets a desired vehicle turn angle and speed change.
///
/// MAV_CMD_NAV_SET_YAW_SPEED
const MavCmd mavCmdNavSetYawSpeed = 213;

/// Mission command to set camera trigger interval for this flight. If triggering is enabled, the camera is triggered each time this interval expires. This command can also be used to set the shutter integration time for the camera.
///
/// MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL
const MavCmd mavCmdDoSetCamTriggInterval = 214;

/// Mission command to control a camera or antenna mount, using a quaternion as reference.
///
/// MAV_CMD_DO_MOUNT_CONTROL_QUAT
@Deprecated("Replaced by [MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW] since 2020-01. ")
const MavCmd mavCmdDoMountControlQuat = 220;

/// set id of master controller
///
/// MAV_CMD_DO_GUIDED_MASTER
const MavCmd mavCmdDoGuidedMaster = 221;

/// Set limits for external control
///
/// MAV_CMD_DO_GUIDED_LIMITS
const MavCmd mavCmdDoGuidedLimits = 222;

/// Control vehicle engine. This is interpreted by the vehicles engine controller to change the target engine state. It is intended for vehicles with internal combustion engines
///
/// MAV_CMD_DO_ENGINE_CONTROL
const MavCmd mavCmdDoEngineControl = 223;

///
/// Set the mission item with sequence number seq as the current item and emit MISSION_CURRENT (whether or not the mission number changed).
/// If a mission is currently being executed, the system will continue to this new mission item on the shortest path, skipping any intermediate mission items.
/// Note that mission jump repeat counters are not reset unless param2 is set (see MAV_CMD_DO_JUMP param2).
///
/// This command may trigger a mission state-machine change on some systems: for example from MISSION_STATE_NOT_STARTED or MISSION_STATE_PAUSED to MISSION_STATE_ACTIVE.
/// If the system is in mission mode, on those systems this command might therefore start, restart or resume the mission.
/// If the system is not in mission mode this command must not trigger a switch to mission mode.
///
/// The mission may be "reset" using param2.
/// Resetting sets jump counters to initial values (to reset counters without changing the current mission item set the param1 to `-1`).
/// Resetting also explicitly changes a mission state of MISSION_STATE_COMPLETE to MISSION_STATE_PAUSED or MISSION_STATE_ACTIVE, potentially allowing it to resume when it is (next) in a mission mode.
///
/// The command will ACK with MAV_RESULT_FAILED if the sequence number is out of range (including if there is no mission item).
///
///
/// MAV_CMD_DO_SET_MISSION_CURRENT
const MavCmd mavCmdDoSetMissionCurrent = 224;

/// NOP - This command is only used to mark the upper limit of the DO commands in the enumeration
///
/// MAV_CMD_DO_LAST
const MavCmd mavCmdDoLast = 240;

/// Trigger calibration. This command will be only accepted if in pre-flight mode. Except for Temperature Calibration, only one sensor should be set in a single message and all others should be zero.
///
/// MAV_CMD_PREFLIGHT_CALIBRATION
const MavCmd mavCmdPreflightCalibration = 241;

/// Set sensor offsets. This command will be only accepted if in pre-flight mode.
///
/// MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS
const MavCmd mavCmdPreflightSetSensorOffsets = 242;

/// Trigger UAVCAN configuration (actuator ID assignment and direction mapping). Note that this maps to the legacy UAVCAN v0 function UAVCAN_ENUMERATE, which is intended to be executed just once during initial vehicle configuration (it is not a normal pre-flight command and has been poorly named).
///
/// MAV_CMD_PREFLIGHT_UAVCAN
const MavCmd mavCmdPreflightUavcan = 243;

/// Request storage of different parameter values and logs. This command will be only accepted if in pre-flight mode.
///
/// MAV_CMD_PREFLIGHT_STORAGE
const MavCmd mavCmdPreflightStorage = 245;

/// Request the reboot or shutdown of system components.
///
/// MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN
const MavCmd mavCmdPreflightRebootShutdown = 246;

/// Override current mission with command to pause mission, pause mission and move to position, continue/resume mission. When param 1 indicates that the mission is paused (MAV_GOTO_DO_HOLD), param 2 defines whether it holds in place or moves to another position.
///
/// MAV_CMD_OVERRIDE_GOTO
const MavCmd mavCmdOverrideGoto = 252;

/// Mission command to set a Camera Auto Mount Pivoting Oblique Survey (Replaces CAM_TRIGG_DIST for this purpose). The camera is triggered each time this distance is exceeded, then the mount moves to the next position. Params 4~6 set-up the angle limits and number of positions for oblique survey, where mount-enabled vehicles automatically roll the camera between shots to emulate an oblique camera setup (providing an increased HFOV). This command can also be used to set the shutter integration time for the camera.
///
/// MAV_CMD_OBLIQUE_SURVEY
const MavCmd mavCmdObliqueSurvey = 260;

/// start running a mission
///
/// MAV_CMD_MISSION_START
const MavCmd mavCmdMissionStart = 300;

/// Actuator testing command. This is similar to MAV_CMD_DO_MOTOR_TEST but operates on the level of output functions, i.e. it is possible to test Motor1 independent from which output it is configured on. Autopilots typically refuse this command while armed.
///
/// MAV_CMD_ACTUATOR_TEST
const MavCmd mavCmdActuatorTest = 310;

/// Actuator configuration command.
///
/// MAV_CMD_CONFIGURE_ACTUATOR
const MavCmd mavCmdConfigureActuator = 311;

/// Arms / Disarms a component
///
/// MAV_CMD_COMPONENT_ARM_DISARM
const MavCmd mavCmdComponentArmDisarm = 400;

/// Instructs a target system to run pre-arm checks.
/// This allows preflight checks to be run on demand, which may be useful on systems that normally run them at low rate, or which do not trigger checks when the armable state might have changed.
/// This command should return MAV_RESULT_ACCEPTED if it will run the checks.
/// The results of the checks are usually then reported in SYS_STATUS messages (this is system-specific).
/// The command should return MAV_RESULT_TEMPORARILY_REJECTED if the system is already armed.
///
///
/// MAV_CMD_RUN_PREARM_CHECKS
const MavCmd mavCmdRunPrearmChecks = 401;

/// Turns illuminators ON/OFF. An illuminator is a light source that is used for lighting up dark areas external to the system: e.g. a torch or searchlight (as opposed to a light source for illuminating the system itself, e.g. an indicator light).
///
/// MAV_CMD_ILLUMINATOR_ON_OFF
const MavCmd mavCmdIlluminatorOnOff = 405;

/// Configures illuminator settings. An illuminator is a light source that is used for lighting up dark areas external to the system: e.g. a torch or searchlight (as opposed to a light source for illuminating the system itself, e.g. an indicator light).
///
/// MAV_CMD_DO_ILLUMINATOR_CONFIGURE
const MavCmd mavCmdDoIlluminatorConfigure = 406;

/// Request the home position from the vehicle.
/// The vehicle will ACK the command and then emit the HOME_POSITION message.
///
/// MAV_CMD_GET_HOME_POSITION
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2022-04. ")
const MavCmd mavCmdGetHomePosition = 410;

/// Inject artificial failure for testing purposes. Note that autopilots should implement an additional protection before accepting this command such as a specific param setting.
///
/// MAV_CMD_INJECT_FAILURE
const MavCmd mavCmdInjectFailure = 420;

/// Starts receiver pairing.
///
/// MAV_CMD_START_RX_PAIR
const MavCmd mavCmdStartRxPair = 500;

///
/// Request the interval between messages for a particular MAVLink message ID.
/// The receiver should ACK the command and then emit its response in a MESSAGE_INTERVAL message.
///
///
/// MAV_CMD_GET_MESSAGE_INTERVAL
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2022-04. ")
const MavCmd mavCmdGetMessageInterval = 510;

/// Set the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREAM.
///
/// MAV_CMD_SET_MESSAGE_INTERVAL
const MavCmd mavCmdSetMessageInterval = 511;

/// Request the target system(s) emit a single instance of a specified message (i.e. a "one-shot" version of MAV_CMD_SET_MESSAGE_INTERVAL).
///
/// MAV_CMD_REQUEST_MESSAGE
const MavCmd mavCmdRequestMessage = 512;

/// Request MAVLink protocol version compatibility. All receivers should ACK the command and then emit their capabilities in an PROTOCOL_VERSION message
///
/// MAV_CMD_REQUEST_PROTOCOL_VERSION
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestProtocolVersion = 519;

/// Request autopilot capabilities. The receiver should ACK the command and then emit its capabilities in an AUTOPILOT_VERSION message
///
/// MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestAutopilotCapabilities = 520;

/// Request camera information (CAMERA_INFORMATION).
///
/// MAV_CMD_REQUEST_CAMERA_INFORMATION
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestCameraInformation = 521;

/// Request camera settings (CAMERA_SETTINGS).
///
/// MAV_CMD_REQUEST_CAMERA_SETTINGS
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestCameraSettings = 522;

/// Request storage information (STORAGE_INFORMATION). Use the command's target_component to target a specific component's storage.
///
/// MAV_CMD_REQUEST_STORAGE_INFORMATION
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestStorageInformation = 525;

/// Format a storage medium. Once format is complete, a STORAGE_INFORMATION message is sent. Use the command's target_component to target a specific component's storage.
///
/// MAV_CMD_STORAGE_FORMAT
const MavCmd mavCmdStorageFormat = 526;

/// Request camera capture status (CAMERA_CAPTURE_STATUS)
///
/// MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestCameraCaptureStatus = 527;

/// Request flight information (FLIGHT_INFORMATION)
///
/// MAV_CMD_REQUEST_FLIGHT_INFORMATION
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestFlightInformation = 528;

/// Reset all camera settings to Factory Default
///
/// MAV_CMD_RESET_CAMERA_SETTINGS
const MavCmd mavCmdResetCameraSettings = 529;

/// Set camera running mode. Use NaN for reserved values. GCS will send a MAV_CMD_REQUEST_VIDEO_STREAM_STATUS command after a mode change if the camera supports video streaming.
///
/// MAV_CMD_SET_CAMERA_MODE
const MavCmd mavCmdSetCameraMode = 530;

/// Set camera zoom. Camera must respond with a CAMERA_SETTINGS message (on success).
///
/// MAV_CMD_SET_CAMERA_ZOOM
const MavCmd mavCmdSetCameraZoom = 531;

/// Set camera focus. Camera must respond with a CAMERA_SETTINGS message (on success).
///
/// MAV_CMD_SET_CAMERA_FOCUS
const MavCmd mavCmdSetCameraFocus = 532;

/// Set that a particular storage is the preferred location for saving photos, videos, and/or other media (e.g. to set that an SD card is used for storing videos).
/// There can only be one preferred save location for each particular media type: setting a media usage flag will clear/reset that same flag if set on any other storage.
/// If no flag is set the system should use its default storage.
/// A target system can choose to always use default storage, in which case it should ACK the command with MAV_RESULT_UNSUPPORTED.
/// A target system can choose to not allow a particular storage to be set as preferred storage, in which case it should ACK the command with MAV_RESULT_DENIED.
///
/// MAV_CMD_SET_STORAGE_USAGE
const MavCmd mavCmdSetStorageUsage = 533;

/// Set camera source. Changes the camera's active sources on cameras with multiple image sensors.
///
/// MAV_CMD_SET_CAMERA_SOURCE
const MavCmd mavCmdSetCameraSource = 534;

/// Tagged jump target. Can be jumped to with MAV_CMD_DO_JUMP_TAG.
///
/// MAV_CMD_JUMP_TAG
const MavCmd mavCmdJumpTag = 600;

/// Jump to the matching tag in the mission list. Repeat this action for the specified number of times. A mission should contain a single matching tag for each jump. If this is not the case then a jump to a missing tag should complete the mission, and a jump where there are multiple matching tags should always select the one with the lowest mission sequence number.
///
/// MAV_CMD_DO_JUMP_TAG
const MavCmd mavCmdDoJumpTag = 601;

/// Set gimbal manager pitch/yaw setpoints (low rate command). It is possible to set combinations of the values below. E.g. an angle as well as a desired angular rate can be used to get to this angle at a certain angular rate, or an angular rate only will result in continuous turning. NaN is to be used to signal unset. Note: only the gimbal manager will react to this command - it will be ignored by a gimbal device. Use GIMBAL_MANAGER_SET_PITCHYAW if you need to stream pitch/yaw setpoints at higher rate.
///
/// MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW
const MavCmd mavCmdDoGimbalManagerPitchyaw = 1000;

/// Gimbal configuration to set which sysid/compid is in primary and secondary control.
///
/// MAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE
const MavCmd mavCmdDoGimbalManagerConfigure = 1001;

/// Start image capture sequence. CAMERA_IMAGE_CAPTURED must be emitted after each capture.
///
/// Param1 (id) may be used to specify the target camera: 0: all cameras, 1 to 6: autopilot-connected cameras, 7-255: MAVLink camera component ID.
/// It is needed in order to target specific cameras connected to the autopilot, or specific sensors in a multi-sensor camera (neither of which have a distinct MAVLink component ID).
/// It is also needed to specify the target camera in missions.
///
/// When used in a mission, an autopilot should execute the MAV_CMD for a specified local camera (param1 = 1-6), or resend it as a command if it is intended for a MAVLink camera (param1 = 7 - 255), setting the command's target_component as the param1 value (and setting param1 in the command to zero).
/// If the param1 is 0 the autopilot should do both.
///
/// When sent in a command the target MAVLink address is set using target_component.
/// If addressed specifically to an autopilot: param1 should be used in the same way as it is for missions (though command should NACK with MAV_RESULT_DENIED if a specified local camera does not exist).
/// If addressed to a MAVLink camera, param 1 can be used to address all cameras (0), or to separately address 1 to 7 individual sensors. Other values should be NACKed with MAV_RESULT_DENIED.
/// If the command is broadcast (target_component is 0) then param 1 should be set to 0 (any other value should be NACKED with MAV_RESULT_DENIED). An autopilot would trigger any local cameras and forward the command to all channels.
///
///
/// MAV_CMD_IMAGE_START_CAPTURE
const MavCmd mavCmdImageStartCapture = 2000;

/// Stop image capture sequence.
///
/// Param1 (id) may be used to specify the target camera: 0: all cameras, 1 to 6: autopilot-connected cameras, 7-255: MAVLink camera component ID.
/// It is needed in order to target specific cameras connected to the autopilot, or specific sensors in a multi-sensor camera (neither of which have a distinct MAVLink component ID).
/// It is also needed to specify the target camera in missions.
///
/// When used in a mission, an autopilot should execute the MAV_CMD for a specified local camera (param1 = 1-6), or resend it as a command if it is intended for a MAVLink camera (param1 = 7 - 255), setting the command's target_component as the param1 value (and setting param1 in the command to zero).
/// If the param1 is 0 the autopilot should do both.
///
/// When sent in a command the target MAVLink address is set using target_component.
/// If addressed specifically to an autopilot: param1 should be used in the same way as it is for missions (though command should NACK with MAV_RESULT_DENIED if a specified local camera does not exist).
/// If addressed to a MAVLink camera, param1 can be used to address all cameras (0), or to separately address 1 to 7 individual sensors. Other values should be NACKed with MAV_RESULT_DENIED.
/// If the command is broadcast (target_component is 0) then param 1 should be set to 0 (any other value should be NACKED with MAV_RESULT_DENIED). An autopilot would trigger any local cameras and forward the command to all channels.
///
///
/// MAV_CMD_IMAGE_STOP_CAPTURE
const MavCmd mavCmdImageStopCapture = 2001;

/// Re-request a CAMERA_IMAGE_CAPTURED message.
///
/// MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestCameraImageCapture = 2002;

/// Enable or disable on-board camera triggering system.
///
/// MAV_CMD_DO_TRIGGER_CONTROL
const MavCmd mavCmdDoTriggerControl = 2003;

/// If the camera supports point visual tracking (CAMERA_CAP_FLAGS_HAS_TRACKING_POINT is set), this command allows to initiate the tracking.
///
/// MAV_CMD_CAMERA_TRACK_POINT
const MavCmd mavCmdCameraTrackPoint = 2004;

/// If the camera supports rectangle visual tracking (CAMERA_CAP_FLAGS_HAS_TRACKING_RECTANGLE is set), this command allows to initiate the tracking.
///
/// MAV_CMD_CAMERA_TRACK_RECTANGLE
const MavCmd mavCmdCameraTrackRectangle = 2005;

/// Stops ongoing tracking.
///
/// MAV_CMD_CAMERA_STOP_TRACKING
const MavCmd mavCmdCameraStopTracking = 2010;

/// Starts video capture (recording).
///
/// MAV_CMD_VIDEO_START_CAPTURE
const MavCmd mavCmdVideoStartCapture = 2500;

/// Stop the current video capture (recording).
///
/// MAV_CMD_VIDEO_STOP_CAPTURE
const MavCmd mavCmdVideoStopCapture = 2501;

/// Start video streaming
///
/// MAV_CMD_VIDEO_START_STREAMING
const MavCmd mavCmdVideoStartStreaming = 2502;

/// Stop the given video stream
///
/// MAV_CMD_VIDEO_STOP_STREAMING
const MavCmd mavCmdVideoStopStreaming = 2503;

/// Request video stream information (VIDEO_STREAM_INFORMATION)
///
/// MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestVideoStreamInformation = 2504;

/// Request video stream status (VIDEO_STREAM_STATUS)
///
/// MAV_CMD_REQUEST_VIDEO_STREAM_STATUS
@Deprecated("Replaced by [MAV_CMD_REQUEST_MESSAGE] since 2019-08. ")
const MavCmd mavCmdRequestVideoStreamStatus = 2505;

/// Request to start streaming logging data over MAVLink (see also LOGGING_DATA message)
///
/// MAV_CMD_LOGGING_START
const MavCmd mavCmdLoggingStart = 2510;

/// Request to stop streaming log data over MAVLink
///
/// MAV_CMD_LOGGING_STOP
const MavCmd mavCmdLoggingStop = 2511;

///
///
/// MAV_CMD_AIRFRAME_CONFIGURATION
const MavCmd mavCmdAirframeConfiguration = 2520;

/// Request to start/stop transmitting over the high latency telemetry
///
/// MAV_CMD_CONTROL_HIGH_LATENCY
const MavCmd mavCmdControlHighLatency = 2600;

/// Create a panorama at the current position
///
/// MAV_CMD_PANORAMA_CREATE
const MavCmd mavCmdPanoramaCreate = 2800;

/// Request VTOL transition
///
/// MAV_CMD_DO_VTOL_TRANSITION
const MavCmd mavCmdDoVtolTransition = 3000;

/// Request authorization to arm the vehicle to a external entity, the arm authorizer is responsible to request all data that is needs from the vehicle before authorize or deny the request.
/// If approved the COMMAND_ACK message progress field should be set with period of time that this authorization is valid in seconds.
/// If the authorization is denied COMMAND_ACK.result_param2 should be set with one of the reasons in ARM_AUTH_DENIED_REASON.
///
///
/// MAV_CMD_ARM_AUTHORIZATION_REQUEST
const MavCmd mavCmdArmAuthorizationRequest = 3001;

/// This command sets the submode to standard guided when vehicle is in guided mode. The vehicle holds position and altitude and the user can input the desired velocities along all three axes.
///
///
/// MAV_CMD_SET_GUIDED_SUBMODE_STANDARD
const MavCmd mavCmdSetGuidedSubmodeStandard = 4000;

/// This command sets submode circle when vehicle is in guided mode. Vehicle flies along a circle facing the center of the circle. The user can input the velocity along the circle and change the radius. If no input is given the vehicle will hold position.
///
///
/// MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE
const MavCmd mavCmdSetGuidedSubmodeCircle = 4001;

/// WIP.
/// Delay mission state machine until gate has been reached.
///
/// MAV_CMD_CONDITION_GATE
const MavCmd mavCmdConditionGate = 4501;

/// Fence return point (there can only be one such point in a geofence definition). If rally points are supported they should be used instead.
///
/// MAV_CMD_NAV_FENCE_RETURN_POINT
const MavCmd mavCmdNavFenceReturnPoint = 5000;

/// Fence vertex for an inclusion polygon (the polygon must not be self-intersecting). The vehicle must stay within this area. Minimum of 3 vertices required.
///
///
/// MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION
const MavCmd mavCmdNavFencePolygonVertexInclusion = 5001;

/// Fence vertex for an exclusion polygon (the polygon must not be self-intersecting). The vehicle must stay outside this area. Minimum of 3 vertices required.
///
///
/// MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION
const MavCmd mavCmdNavFencePolygonVertexExclusion = 5002;

/// Circular fence area. The vehicle must stay inside this area.
///
///
/// MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION
const MavCmd mavCmdNavFenceCircleInclusion = 5003;

/// Circular fence area. The vehicle must stay outside this area.
///
///
/// MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION
const MavCmd mavCmdNavFenceCircleExclusion = 5004;

/// Rally point. You can have multiple rally points defined.
///
///
/// MAV_CMD_NAV_RALLY_POINT
const MavCmd mavCmdNavRallyPoint = 5100;

/// Commands the vehicle to respond with a sequence of messages UAVCAN_NODE_INFO, one message per every UAVCAN node that is online. Note that some of the response messages can be lost, which the receiver can detect easily by checking whether every received UAVCAN_NODE_STATUS has a matching message UAVCAN_NODE_INFO received earlier; if not, this command should be sent again in order to request re-transmission of the node information messages.
///
/// MAV_CMD_UAVCAN_GET_NODE_INFO
const MavCmd mavCmdUavcanGetNodeInfo = 5200;

/// Change state of safety switch.
///
/// MAV_CMD_DO_SET_SAFETY_SWITCH_STATE
const MavCmd mavCmdDoSetSafetySwitchState = 5300;

/// Trigger the start of an ADSB-out IDENT. This should only be used when requested to do so by an Air Traffic Controller in controlled airspace. This starts the IDENT which is then typically held for 18 seconds by the hardware per the Mode A, C, and S transponder spec.
///
/// MAV_CMD_DO_ADSB_OUT_IDENT
const MavCmd mavCmdDoAdsbOutIdent = 10001;

/// Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release position and velocity.
///
/// MAV_CMD_PAYLOAD_PREPARE_DEPLOY
@Deprecated("Replaced by [] since 2021-06. ")
const MavCmd mavCmdPayloadPrepareDeploy = 30001;

/// Control the payload deployment.
///
/// MAV_CMD_PAYLOAD_CONTROL_DEPLOY
@Deprecated("Replaced by [] since 2021-06. ")
const MavCmd mavCmdPayloadControlDeploy = 30002;

/// Magnetometer calibration based on provided known yaw. This allows for fast calibration using WMM field tables in the vehicle, given only the known yaw of the vehicle. If Latitude and longitude are both zero then use the current vehicle location.
///
/// MAV_CMD_FIXED_MAG_CAL_YAW
const MavCmd mavCmdFixedMagCalYaw = 42006;

/// Command to operate winch.
///
/// MAV_CMD_DO_WINCH
const MavCmd mavCmdDoWinch = 42600;

/// Provide an external position estimate for use when dead-reckoning. This is meant to be used for occasional position resets that may be provided by a external system such as a remote pilot using landmarks over a video link.
///
/// MAV_CMD_EXTERNAL_POSITION_ESTIMATE
const MavCmd mavCmdExternalPositionEstimate = 43003;

/// User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
///
/// MAV_CMD_WAYPOINT_USER_1
const MavCmd mavCmdWaypointUser1 = 31000;

/// User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
///
/// MAV_CMD_WAYPOINT_USER_2
const MavCmd mavCmdWaypointUser2 = 31001;

/// User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
///
/// MAV_CMD_WAYPOINT_USER_3
const MavCmd mavCmdWaypointUser3 = 31002;

/// User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
///
/// MAV_CMD_WAYPOINT_USER_4
const MavCmd mavCmdWaypointUser4 = 31003;

/// User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
///
/// MAV_CMD_WAYPOINT_USER_5
const MavCmd mavCmdWaypointUser5 = 31004;

/// User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.
///
/// MAV_CMD_SPATIAL_USER_1
const MavCmd mavCmdSpatialUser1 = 31005;

/// User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.
///
/// MAV_CMD_SPATIAL_USER_2
const MavCmd mavCmdSpatialUser2 = 31006;

/// User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.
///
/// MAV_CMD_SPATIAL_USER_3
const MavCmd mavCmdSpatialUser3 = 31007;

/// User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.
///
/// MAV_CMD_SPATIAL_USER_4
const MavCmd mavCmdSpatialUser4 = 31008;

/// User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example: ROI item.
///
/// MAV_CMD_SPATIAL_USER_5
const MavCmd mavCmdSpatialUser5 = 31009;

/// User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.
///
/// MAV_CMD_USER_1
const MavCmd mavCmdUser1 = 31010;

/// User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.
///
/// MAV_CMD_USER_2
const MavCmd mavCmdUser2 = 31011;

/// User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.
///
/// MAV_CMD_USER_3
const MavCmd mavCmdUser3 = 31012;

/// User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.
///
/// MAV_CMD_USER_4
const MavCmd mavCmdUser4 = 31013;

/// User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER item.
///
/// MAV_CMD_USER_5
const MavCmd mavCmdUser5 = 31014;

/// Request forwarding of CAN packets from the given CAN bus to this component. CAN Frames are sent using CAN_FRAME and CANFD_FRAME messages
///
/// MAV_CMD_CAN_FORWARD
const MavCmd mavCmdCanForward = 32000;

/// A data stream is not a fixed set of messages, but rather a
/// recommendation to the autopilot software. Individual autopilots may or may not obey
/// the recommended messages.
///
/// MAV_DATA_STREAM
typedef MavDataStream = int;

/// Enable all data streams
///
/// MAV_DATA_STREAM_ALL
const MavDataStream mavDataStreamAll = 0;

/// Enable IMU_RAW, GPS_RAW, GPS_STATUS packets.
///
/// MAV_DATA_STREAM_RAW_SENSORS
const MavDataStream mavDataStreamRawSensors = 1;

/// Enable GPS_STATUS, CONTROL_STATUS, AUX_STATUS
///
/// MAV_DATA_STREAM_EXTENDED_STATUS
const MavDataStream mavDataStreamExtendedStatus = 2;

/// Enable RC_CHANNELS_SCALED, RC_CHANNELS_RAW, SERVO_OUTPUT_RAW
///
/// MAV_DATA_STREAM_RC_CHANNELS
const MavDataStream mavDataStreamRcChannels = 3;

/// Enable ATTITUDE_CONTROLLER_OUTPUT, POSITION_CONTROLLER_OUTPUT, NAV_CONTROLLER_OUTPUT.
///
/// MAV_DATA_STREAM_RAW_CONTROLLER
const MavDataStream mavDataStreamRawController = 4;

/// Enable LOCAL_POSITION, GLOBAL_POSITION_INT messages.
///
/// MAV_DATA_STREAM_POSITION
const MavDataStream mavDataStreamPosition = 6;

/// Dependent on the autopilot
///
/// MAV_DATA_STREAM_EXTRA1
const MavDataStream mavDataStreamExtra1 = 10;

/// Dependent on the autopilot
///
/// MAV_DATA_STREAM_EXTRA2
const MavDataStream mavDataStreamExtra2 = 11;

/// Dependent on the autopilot
///
/// MAV_DATA_STREAM_EXTRA3
const MavDataStream mavDataStreamExtra3 = 12;

/// The ROI (region of interest) for the vehicle. This can be
/// be used by the vehicle for camera/vehicle attitude alignment (see
/// MAV_CMD_NAV_ROI).
///
/// MAV_ROI
typedef MavRoi = int;

/// No region of interest.
///
/// MAV_ROI_NONE
const MavRoi mavRoiNone = 0;

/// Point toward next waypoint, with optional pitch/roll/yaw offset.
///
/// MAV_ROI_WPNEXT
const MavRoi mavRoiWpnext = 1;

/// Point toward given waypoint.
///
/// MAV_ROI_WPINDEX
const MavRoi mavRoiWpindex = 2;

/// Point toward fixed location.
///
/// MAV_ROI_LOCATION
const MavRoi mavRoiLocation = 3;

/// Point toward of given id.
///
/// MAV_ROI_TARGET
const MavRoi mavRoiTarget = 4;

/// Specifies the datatype of a MAVLink parameter.
///
/// MAV_PARAM_TYPE
typedef MavParamType = int;

/// 8-bit unsigned integer
///
/// MAV_PARAM_TYPE_UINT8
const MavParamType mavParamTypeUint8 = 1;

/// 8-bit signed integer
///
/// MAV_PARAM_TYPE_INT8
const MavParamType mavParamTypeInt8 = 2;

/// 16-bit unsigned integer
///
/// MAV_PARAM_TYPE_UINT16
const MavParamType mavParamTypeUint16 = 3;

/// 16-bit signed integer
///
/// MAV_PARAM_TYPE_INT16
const MavParamType mavParamTypeInt16 = 4;

/// 32-bit unsigned integer
///
/// MAV_PARAM_TYPE_UINT32
const MavParamType mavParamTypeUint32 = 5;

/// 32-bit signed integer
///
/// MAV_PARAM_TYPE_INT32
const MavParamType mavParamTypeInt32 = 6;

/// 64-bit unsigned integer
///
/// MAV_PARAM_TYPE_UINT64
const MavParamType mavParamTypeUint64 = 7;

/// 64-bit signed integer
///
/// MAV_PARAM_TYPE_INT64
const MavParamType mavParamTypeInt64 = 8;

/// 32-bit floating-point
///
/// MAV_PARAM_TYPE_REAL32
const MavParamType mavParamTypeReal32 = 9;

/// 64-bit floating-point
///
/// MAV_PARAM_TYPE_REAL64
const MavParamType mavParamTypeReal64 = 10;

/// Specifies the datatype of a MAVLink extended parameter.
///
/// MAV_PARAM_EXT_TYPE
typedef MavParamExtType = int;

/// 8-bit unsigned integer
///
/// MAV_PARAM_EXT_TYPE_UINT8
const MavParamExtType mavParamExtTypeUint8 = 1;

/// 8-bit signed integer
///
/// MAV_PARAM_EXT_TYPE_INT8
const MavParamExtType mavParamExtTypeInt8 = 2;

/// 16-bit unsigned integer
///
/// MAV_PARAM_EXT_TYPE_UINT16
const MavParamExtType mavParamExtTypeUint16 = 3;

/// 16-bit signed integer
///
/// MAV_PARAM_EXT_TYPE_INT16
const MavParamExtType mavParamExtTypeInt16 = 4;

/// 32-bit unsigned integer
///
/// MAV_PARAM_EXT_TYPE_UINT32
const MavParamExtType mavParamExtTypeUint32 = 5;

/// 32-bit signed integer
///
/// MAV_PARAM_EXT_TYPE_INT32
const MavParamExtType mavParamExtTypeInt32 = 6;

/// 64-bit unsigned integer
///
/// MAV_PARAM_EXT_TYPE_UINT64
const MavParamExtType mavParamExtTypeUint64 = 7;

/// 64-bit signed integer
///
/// MAV_PARAM_EXT_TYPE_INT64
const MavParamExtType mavParamExtTypeInt64 = 8;

/// 32-bit floating-point
///
/// MAV_PARAM_EXT_TYPE_REAL32
const MavParamExtType mavParamExtTypeReal32 = 9;

/// 64-bit floating-point
///
/// MAV_PARAM_EXT_TYPE_REAL64
const MavParamExtType mavParamExtTypeReal64 = 10;

/// Custom Type
///
/// MAV_PARAM_EXT_TYPE_CUSTOM
const MavParamExtType mavParamExtTypeCustom = 11;

/// Result from a MAVLink command (MAV_CMD)
///
/// MAV_RESULT
typedef MavResult = int;

/// Command is valid (is supported and has valid parameters), and was executed.
///
/// MAV_RESULT_ACCEPTED
const MavResult mavResultAccepted = 0;

/// Command is valid, but cannot be executed at this time. This is used to indicate a problem that should be fixed just by waiting (e.g. a state machine is busy, can't arm because have not got GPS lock, etc.). Retrying later should work.
///
/// MAV_RESULT_TEMPORARILY_REJECTED
const MavResult mavResultTemporarilyRejected = 1;

/// Command is invalid (is supported but has invalid parameters). Retrying same command and parameters will not work.
///
/// MAV_RESULT_DENIED
const MavResult mavResultDenied = 2;

/// Command is not supported (unknown).
///
/// MAV_RESULT_UNSUPPORTED
const MavResult mavResultUnsupported = 3;

/// Command is valid, but execution has failed. This is used to indicate any non-temporary or unexpected problem, i.e. any problem that must be fixed before the command can succeed/be retried. For example, attempting to write a file when out of memory, attempting to arm when sensors are not calibrated, etc.
///
/// MAV_RESULT_FAILED
const MavResult mavResultFailed = 4;

/// Command is valid and is being executed. This will be followed by further progress updates, i.e. the component may send further COMMAND_ACK messages with result MAV_RESULT_IN_PROGRESS (at a rate decided by the implementation), and must terminate by sending a COMMAND_ACK message with final result of the operation. The COMMAND_ACK.progress field can be used to indicate the progress of the operation.
///
/// MAV_RESULT_IN_PROGRESS
const MavResult mavResultInProgress = 5;

/// Command has been cancelled (as a result of receiving a COMMAND_CANCEL message).
///
/// MAV_RESULT_CANCELLED
const MavResult mavResultCancelled = 6;

/// Command is only accepted when sent as a COMMAND_LONG.
///
/// MAV_RESULT_COMMAND_LONG_ONLY
const MavResult mavResultCommandLongOnly = 7;

/// Command is only accepted when sent as a COMMAND_INT.
///
/// MAV_RESULT_COMMAND_INT_ONLY
const MavResult mavResultCommandIntOnly = 8;

/// Command is invalid because a frame is required and the specified frame is not supported.
///
/// MAV_RESULT_COMMAND_UNSUPPORTED_MAV_FRAME
const MavResult mavResultCommandUnsupportedMavFrame = 9;

/// WIP.
/// Sender is not authorized to control this MAV component. Control may be requested using MAV_CMD_REQUEST_OPERATOR_CONTROL.
///
/// MAV_RESULT_PERMISSION_DENIED
const MavResult mavResultPermissionDenied = 10;

/// Result of mission operation (in a MISSION_ACK message).
///
/// MAV_MISSION_RESULT
typedef MavMissionResult = int;

/// mission accepted OK
///
/// MAV_MISSION_ACCEPTED
const MavMissionResult mavMissionAccepted = 0;

/// Generic error / not accepting mission commands at all right now.
///
/// MAV_MISSION_ERROR
const MavMissionResult mavMissionError = 1;

/// Coordinate frame is not supported.
///
/// MAV_MISSION_UNSUPPORTED_FRAME
const MavMissionResult mavMissionUnsupportedFrame = 2;

/// Command is not supported.
///
/// MAV_MISSION_UNSUPPORTED
const MavMissionResult mavMissionUnsupported = 3;

/// Mission items exceed storage space.
///
/// MAV_MISSION_NO_SPACE
const MavMissionResult mavMissionNoSpace = 4;

/// One of the parameters has an invalid value.
///
/// MAV_MISSION_INVALID
const MavMissionResult mavMissionInvalid = 5;

/// param1 has an invalid value.
///
/// MAV_MISSION_INVALID_PARAM1
const MavMissionResult mavMissionInvalidParam1 = 6;

/// param2 has an invalid value.
///
/// MAV_MISSION_INVALID_PARAM2
const MavMissionResult mavMissionInvalidParam2 = 7;

/// param3 has an invalid value.
///
/// MAV_MISSION_INVALID_PARAM3
const MavMissionResult mavMissionInvalidParam3 = 8;

/// param4 has an invalid value.
///
/// MAV_MISSION_INVALID_PARAM4
const MavMissionResult mavMissionInvalidParam4 = 9;

/// x / param5 has an invalid value.
///
/// MAV_MISSION_INVALID_PARAM5_X
const MavMissionResult mavMissionInvalidParam5X = 10;

/// y / param6 has an invalid value.
///
/// MAV_MISSION_INVALID_PARAM6_Y
const MavMissionResult mavMissionInvalidParam6Y = 11;

/// z / param7 has an invalid value.
///
/// MAV_MISSION_INVALID_PARAM7
const MavMissionResult mavMissionInvalidParam7 = 12;

/// Mission item received out of sequence
///
/// MAV_MISSION_INVALID_SEQUENCE
const MavMissionResult mavMissionInvalidSequence = 13;

/// Not accepting any mission commands from this communication partner.
///
/// MAV_MISSION_DENIED
const MavMissionResult mavMissionDenied = 14;

/// Current mission operation cancelled (e.g. mission upload, mission download).
///
/// MAV_MISSION_OPERATION_CANCELLED
const MavMissionResult mavMissionOperationCancelled = 15;

/// Indicates the severity level, generally used for status messages to indicate their relative urgency. Based on RFC-5424 using expanded definitions at: http://www.kiwisyslog.com/kb/info:-syslog-message-levels/.
///
/// MAV_SEVERITY
typedef MavSeverity = int;

/// System is unusable. This is a "panic" condition.
///
/// MAV_SEVERITY_EMERGENCY
const MavSeverity mavSeverityEmergency = 0;

/// Action should be taken immediately. Indicates error in non-critical systems.
///
/// MAV_SEVERITY_ALERT
const MavSeverity mavSeverityAlert = 1;

/// Action must be taken immediately. Indicates failure in a primary system.
///
/// MAV_SEVERITY_CRITICAL
const MavSeverity mavSeverityCritical = 2;

/// Indicates an error in secondary/redundant systems.
///
/// MAV_SEVERITY_ERROR
const MavSeverity mavSeverityError = 3;

/// Indicates about a possible future error if this is not resolved within a given timeframe. Example would be a low battery warning.
///
/// MAV_SEVERITY_WARNING
const MavSeverity mavSeverityWarning = 4;

/// An unusual event has occurred, though not an error condition. This should be investigated for the root cause.
///
/// MAV_SEVERITY_NOTICE
const MavSeverity mavSeverityNotice = 5;

/// Normal operational messages. Useful for logging. No action is required for these messages.
///
/// MAV_SEVERITY_INFO
const MavSeverity mavSeverityInfo = 6;

/// Useful non-operational messages that can assist in debugging. These should not occur during normal operation.
///
/// MAV_SEVERITY_DEBUG
const MavSeverity mavSeverityDebug = 7;

/// Power supply status flags (bitmask)
///
/// MAV_POWER_STATUS
typedef MavPowerStatus = int;

/// main brick power supply valid
///
/// MAV_POWER_STATUS_BRICK_VALID
const MavPowerStatus mavPowerStatusBrickValid = 1;

/// main servo power supply valid for FMU
///
/// MAV_POWER_STATUS_SERVO_VALID
const MavPowerStatus mavPowerStatusServoValid = 2;

/// USB power is connected
///
/// MAV_POWER_STATUS_USB_CONNECTED
const MavPowerStatus mavPowerStatusUsbConnected = 4;

/// peripheral supply is in over-current state
///
/// MAV_POWER_STATUS_PERIPH_OVERCURRENT
const MavPowerStatus mavPowerStatusPeriphOvercurrent = 8;

/// hi-power peripheral supply is in over-current state
///
/// MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT
const MavPowerStatus mavPowerStatusPeriphHipowerOvercurrent = 16;

/// Power status has changed since boot
///
/// MAV_POWER_STATUS_CHANGED
const MavPowerStatus mavPowerStatusChanged = 32;

/// SERIAL_CONTROL device types
///
/// SERIAL_CONTROL_DEV
typedef SerialControlDev = int;

/// First telemetry port
///
/// SERIAL_CONTROL_DEV_TELEM1
const SerialControlDev serialControlDevTelem1 = 0;

/// Second telemetry port
///
/// SERIAL_CONTROL_DEV_TELEM2
const SerialControlDev serialControlDevTelem2 = 1;

/// First GPS port
///
/// SERIAL_CONTROL_DEV_GPS1
const SerialControlDev serialControlDevGps1 = 2;

/// Second GPS port
///
/// SERIAL_CONTROL_DEV_GPS2
const SerialControlDev serialControlDevGps2 = 3;

/// system shell
///
/// SERIAL_CONTROL_DEV_SHELL
const SerialControlDev serialControlDevShell = 10;

/// SERIAL0
///
/// SERIAL_CONTROL_SERIAL0
const SerialControlDev serialControlSerial0 = 100;

/// SERIAL1
///
/// SERIAL_CONTROL_SERIAL1
const SerialControlDev serialControlSerial1 = 101;

/// SERIAL2
///
/// SERIAL_CONTROL_SERIAL2
const SerialControlDev serialControlSerial2 = 102;

/// SERIAL3
///
/// SERIAL_CONTROL_SERIAL3
const SerialControlDev serialControlSerial3 = 103;

/// SERIAL4
///
/// SERIAL_CONTROL_SERIAL4
const SerialControlDev serialControlSerial4 = 104;

/// SERIAL5
///
/// SERIAL_CONTROL_SERIAL5
const SerialControlDev serialControlSerial5 = 105;

/// SERIAL6
///
/// SERIAL_CONTROL_SERIAL6
const SerialControlDev serialControlSerial6 = 106;

/// SERIAL7
///
/// SERIAL_CONTROL_SERIAL7
const SerialControlDev serialControlSerial7 = 107;

/// SERIAL8
///
/// SERIAL_CONTROL_SERIAL8
const SerialControlDev serialControlSerial8 = 108;

/// SERIAL9
///
/// SERIAL_CONTROL_SERIAL9
const SerialControlDev serialControlSerial9 = 109;

/// SERIAL_CONTROL flags (bitmask)
///
/// SERIAL_CONTROL_FLAG
typedef SerialControlFlag = int;

/// Set if this is a reply
///
/// SERIAL_CONTROL_FLAG_REPLY
const SerialControlFlag serialControlFlagReply = 1;

/// Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message
///
/// SERIAL_CONTROL_FLAG_RESPOND
const SerialControlFlag serialControlFlagRespond = 2;

/// Set if access to the serial port should be removed from whatever driver is currently using it, giving exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without this flag set
///
/// SERIAL_CONTROL_FLAG_EXCLUSIVE
const SerialControlFlag serialControlFlagExclusive = 4;

/// Block on writes to the serial port
///
/// SERIAL_CONTROL_FLAG_BLOCKING
const SerialControlFlag serialControlFlagBlocking = 8;

/// Send multiple replies until port is drained
///
/// SERIAL_CONTROL_FLAG_MULTI
const SerialControlFlag serialControlFlagMulti = 16;

/// Enumeration of distance sensor types
///
/// MAV_DISTANCE_SENSOR
typedef MavDistanceSensor = int;

/// Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units
///
/// MAV_DISTANCE_SENSOR_LASER
const MavDistanceSensor mavDistanceSensorLaser = 0;

/// Ultrasound rangefinder, e.g. MaxBotix units
///
/// MAV_DISTANCE_SENSOR_ULTRASOUND
const MavDistanceSensor mavDistanceSensorUltrasound = 1;

/// Infrared rangefinder, e.g. Sharp units
///
/// MAV_DISTANCE_SENSOR_INFRARED
const MavDistanceSensor mavDistanceSensorInfrared = 2;

/// Radar type, e.g. uLanding units
///
/// MAV_DISTANCE_SENSOR_RADAR
const MavDistanceSensor mavDistanceSensorRadar = 3;

/// Broken or unknown type, e.g. analog units
///
/// MAV_DISTANCE_SENSOR_UNKNOWN
const MavDistanceSensor mavDistanceSensorUnknown = 4;

/// Enumeration of sensor orientation, according to its rotations
///
/// MAV_SENSOR_ORIENTATION
typedef MavSensorOrientation = int;

/// Roll: 0, Pitch: 0, Yaw: 0
///
/// MAV_SENSOR_ROTATION_NONE
const MavSensorOrientation mavSensorRotationNone = 0;

/// Roll: 0, Pitch: 0, Yaw: 45
///
/// MAV_SENSOR_ROTATION_YAW_45
const MavSensorOrientation mavSensorRotationYaw45 = 1;

/// Roll: 0, Pitch: 0, Yaw: 90
///
/// MAV_SENSOR_ROTATION_YAW_90
const MavSensorOrientation mavSensorRotationYaw90 = 2;

/// Roll: 0, Pitch: 0, Yaw: 135
///
/// MAV_SENSOR_ROTATION_YAW_135
const MavSensorOrientation mavSensorRotationYaw135 = 3;

/// Roll: 0, Pitch: 0, Yaw: 180
///
/// MAV_SENSOR_ROTATION_YAW_180
const MavSensorOrientation mavSensorRotationYaw180 = 4;

/// Roll: 0, Pitch: 0, Yaw: 225
///
/// MAV_SENSOR_ROTATION_YAW_225
const MavSensorOrientation mavSensorRotationYaw225 = 5;

/// Roll: 0, Pitch: 0, Yaw: 270
///
/// MAV_SENSOR_ROTATION_YAW_270
const MavSensorOrientation mavSensorRotationYaw270 = 6;

/// Roll: 0, Pitch: 0, Yaw: 315
///
/// MAV_SENSOR_ROTATION_YAW_315
const MavSensorOrientation mavSensorRotationYaw315 = 7;

/// Roll: 180, Pitch: 0, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_180
const MavSensorOrientation mavSensorRotationRoll180 = 8;

/// Roll: 180, Pitch: 0, Yaw: 45
///
/// MAV_SENSOR_ROTATION_ROLL_180_YAW_45
const MavSensorOrientation mavSensorRotationRoll180Yaw45 = 9;

/// Roll: 180, Pitch: 0, Yaw: 90
///
/// MAV_SENSOR_ROTATION_ROLL_180_YAW_90
const MavSensorOrientation mavSensorRotationRoll180Yaw90 = 10;

/// Roll: 180, Pitch: 0, Yaw: 135
///
/// MAV_SENSOR_ROTATION_ROLL_180_YAW_135
const MavSensorOrientation mavSensorRotationRoll180Yaw135 = 11;

/// Roll: 0, Pitch: 180, Yaw: 0
///
/// MAV_SENSOR_ROTATION_PITCH_180
const MavSensorOrientation mavSensorRotationPitch180 = 12;

/// Roll: 180, Pitch: 0, Yaw: 225
///
/// MAV_SENSOR_ROTATION_ROLL_180_YAW_225
const MavSensorOrientation mavSensorRotationRoll180Yaw225 = 13;

/// Roll: 180, Pitch: 0, Yaw: 270
///
/// MAV_SENSOR_ROTATION_ROLL_180_YAW_270
const MavSensorOrientation mavSensorRotationRoll180Yaw270 = 14;

/// Roll: 180, Pitch: 0, Yaw: 315
///
/// MAV_SENSOR_ROTATION_ROLL_180_YAW_315
const MavSensorOrientation mavSensorRotationRoll180Yaw315 = 15;

/// Roll: 90, Pitch: 0, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_90
const MavSensorOrientation mavSensorRotationRoll90 = 16;

/// Roll: 90, Pitch: 0, Yaw: 45
///
/// MAV_SENSOR_ROTATION_ROLL_90_YAW_45
const MavSensorOrientation mavSensorRotationRoll90Yaw45 = 17;

/// Roll: 90, Pitch: 0, Yaw: 90
///
/// MAV_SENSOR_ROTATION_ROLL_90_YAW_90
const MavSensorOrientation mavSensorRotationRoll90Yaw90 = 18;

/// Roll: 90, Pitch: 0, Yaw: 135
///
/// MAV_SENSOR_ROTATION_ROLL_90_YAW_135
const MavSensorOrientation mavSensorRotationRoll90Yaw135 = 19;

/// Roll: 270, Pitch: 0, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_270
const MavSensorOrientation mavSensorRotationRoll270 = 20;

/// Roll: 270, Pitch: 0, Yaw: 45
///
/// MAV_SENSOR_ROTATION_ROLL_270_YAW_45
const MavSensorOrientation mavSensorRotationRoll270Yaw45 = 21;

/// Roll: 270, Pitch: 0, Yaw: 90
///
/// MAV_SENSOR_ROTATION_ROLL_270_YAW_90
const MavSensorOrientation mavSensorRotationRoll270Yaw90 = 22;

/// Roll: 270, Pitch: 0, Yaw: 135
///
/// MAV_SENSOR_ROTATION_ROLL_270_YAW_135
const MavSensorOrientation mavSensorRotationRoll270Yaw135 = 23;

/// Roll: 0, Pitch: 90, Yaw: 0
///
/// MAV_SENSOR_ROTATION_PITCH_90
const MavSensorOrientation mavSensorRotationPitch90 = 24;

/// Roll: 0, Pitch: 270, Yaw: 0
///
/// MAV_SENSOR_ROTATION_PITCH_270
const MavSensorOrientation mavSensorRotationPitch270 = 25;

/// Roll: 0, Pitch: 180, Yaw: 90
///
/// MAV_SENSOR_ROTATION_PITCH_180_YAW_90
const MavSensorOrientation mavSensorRotationPitch180Yaw90 = 26;

/// Roll: 0, Pitch: 180, Yaw: 270
///
/// MAV_SENSOR_ROTATION_PITCH_180_YAW_270
const MavSensorOrientation mavSensorRotationPitch180Yaw270 = 27;

/// Roll: 90, Pitch: 90, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_90_PITCH_90
const MavSensorOrientation mavSensorRotationRoll90Pitch90 = 28;

/// Roll: 180, Pitch: 90, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_180_PITCH_90
const MavSensorOrientation mavSensorRotationRoll180Pitch90 = 29;

/// Roll: 270, Pitch: 90, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_270_PITCH_90
const MavSensorOrientation mavSensorRotationRoll270Pitch90 = 30;

/// Roll: 90, Pitch: 180, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_90_PITCH_180
const MavSensorOrientation mavSensorRotationRoll90Pitch180 = 31;

/// Roll: 270, Pitch: 180, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_270_PITCH_180
const MavSensorOrientation mavSensorRotationRoll270Pitch180 = 32;

/// Roll: 90, Pitch: 270, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_90_PITCH_270
const MavSensorOrientation mavSensorRotationRoll90Pitch270 = 33;

/// Roll: 180, Pitch: 270, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_180_PITCH_270
const MavSensorOrientation mavSensorRotationRoll180Pitch270 = 34;

/// Roll: 270, Pitch: 270, Yaw: 0
///
/// MAV_SENSOR_ROTATION_ROLL_270_PITCH_270
const MavSensorOrientation mavSensorRotationRoll270Pitch270 = 35;

/// Roll: 90, Pitch: 180, Yaw: 90
///
/// MAV_SENSOR_ROTATION_ROLL_90_PITCH_180_YAW_90
const MavSensorOrientation mavSensorRotationRoll90Pitch180Yaw90 = 36;

/// Roll: 90, Pitch: 0, Yaw: 270
///
/// MAV_SENSOR_ROTATION_ROLL_90_YAW_270
const MavSensorOrientation mavSensorRotationRoll90Yaw270 = 37;

/// Roll: 90, Pitch: 68, Yaw: 293
///
/// MAV_SENSOR_ROTATION_ROLL_90_PITCH_68_YAW_293
const MavSensorOrientation mavSensorRotationRoll90Pitch68Yaw293 = 38;

/// Pitch: 315
///
/// MAV_SENSOR_ROTATION_PITCH_315
const MavSensorOrientation mavSensorRotationPitch315 = 39;

/// Roll: 90, Pitch: 315
///
/// MAV_SENSOR_ROTATION_ROLL_90_PITCH_315
const MavSensorOrientation mavSensorRotationRoll90Pitch315 = 40;

/// Custom orientation
///
/// MAV_SENSOR_ROTATION_CUSTOM
const MavSensorOrientation mavSensorRotationCustom = 100;

/// Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability.
///
/// MAV_PROTOCOL_CAPABILITY
typedef MavProtocolCapability = int;

/// Autopilot supports the MISSION_ITEM float message type.
/// Note that MISSION_ITEM is deprecated, and autopilots should use MISSION_INT instead.
///
///
/// MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT
const MavProtocolCapability mavProtocolCapabilityMissionFloat = 1;

/// Autopilot supports the new param float message type.
///
/// MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT
@Deprecated(
    "Replaced by [MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_C_CAST] since 2022-03. ")
const MavProtocolCapability mavProtocolCapabilityParamFloat = 2;

/// Autopilot supports MISSION_ITEM_INT scaled integer message type.
/// Note that this flag must always be set if missions are supported, because missions must always use MISSION_ITEM_INT (rather than MISSION_ITEM, which is deprecated).
///
///
/// MAV_PROTOCOL_CAPABILITY_MISSION_INT
const MavProtocolCapability mavProtocolCapabilityMissionInt = 4;

/// Autopilot supports COMMAND_INT scaled integer message type.
///
/// MAV_PROTOCOL_CAPABILITY_COMMAND_INT
const MavProtocolCapability mavProtocolCapabilityCommandInt = 8;

/// Parameter protocol uses byte-wise encoding of parameter values into param_value (float) fields: https://mavlink.io/en/services/parameter.html#parameter-encoding.
/// Note that either this flag or MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_C_CAST should be set if the parameter protocol is supported.
///
///
/// MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_BYTEWISE
const MavProtocolCapability mavProtocolCapabilityParamEncodeBytewise = 16;

/// Autopilot supports the File Transfer Protocol v1: https://mavlink.io/en/services/ftp.html.
///
/// MAV_PROTOCOL_CAPABILITY_FTP
const MavProtocolCapability mavProtocolCapabilityFtp = 32;

/// Autopilot supports commanding attitude offboard.
///
/// MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET
const MavProtocolCapability mavProtocolCapabilitySetAttitudeTarget = 64;

/// Autopilot supports commanding position and velocity targets in local NED frame.
///
/// MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED
const MavProtocolCapability mavProtocolCapabilitySetPositionTargetLocalNed =
    128;

/// Autopilot supports commanding position and velocity targets in global scaled integers.
///
/// MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT
const MavProtocolCapability mavProtocolCapabilitySetPositionTargetGlobalInt =
    256;

/// Autopilot supports terrain protocol / data handling.
///
/// MAV_PROTOCOL_CAPABILITY_TERRAIN
const MavProtocolCapability mavProtocolCapabilityTerrain = 512;

/// Reserved for future use.
///
/// MAV_PROTOCOL_CAPABILITY_RESERVED3
const MavProtocolCapability mavProtocolCapabilityReserved3 = 1024;

/// Autopilot supports the MAV_CMD_DO_FLIGHTTERMINATION command (flight termination).
///
/// MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION
const MavProtocolCapability mavProtocolCapabilityFlightTermination = 2048;

/// Autopilot supports onboard compass calibration.
///
/// MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION
const MavProtocolCapability mavProtocolCapabilityCompassCalibration = 4096;

/// Autopilot supports MAVLink version 2.
///
/// MAV_PROTOCOL_CAPABILITY_MAVLINK2
const MavProtocolCapability mavProtocolCapabilityMavlink2 = 8192;

/// Autopilot supports mission fence protocol.
///
/// MAV_PROTOCOL_CAPABILITY_MISSION_FENCE
const MavProtocolCapability mavProtocolCapabilityMissionFence = 16384;

/// Autopilot supports mission rally point protocol.
///
/// MAV_PROTOCOL_CAPABILITY_MISSION_RALLY
const MavProtocolCapability mavProtocolCapabilityMissionRally = 32768;

/// Reserved for future use.
///
/// MAV_PROTOCOL_CAPABILITY_RESERVED2
const MavProtocolCapability mavProtocolCapabilityReserved2 = 65536;

/// Parameter protocol uses C-cast of parameter values to set the param_value (float) fields: https://mavlink.io/en/services/parameter.html#parameter-encoding.
/// Note that either this flag or MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_BYTEWISE should be set if the parameter protocol is supported.
///
///
/// MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_C_CAST
const MavProtocolCapability mavProtocolCapabilityParamEncodeCCast = 131072;

/// This component implements/is a gimbal manager. This means the GIMBAL_MANAGER_INFORMATION, and other messages can be requested.
///
///
/// MAV_PROTOCOL_CAPABILITY_COMPONENT_IMPLEMENTS_GIMBAL_MANAGER
const MavProtocolCapability
    mavProtocolCapabilityComponentImplementsGimbalManager = 262144;

/// WIP.
/// Component supports locking control to a particular GCS independent of its system (via MAV_CMD_REQUEST_OPERATOR_CONTROL).
///
/// MAV_PROTOCOL_CAPABILITY_COMPONENT_ACCEPTS_GCS_CONTROL
const MavProtocolCapability mavProtocolCapabilityComponentAcceptsGcsControl =
    524288;

/// Type of mission items being requested/sent in mission protocol.
///
/// MAV_MISSION_TYPE
typedef MavMissionType = int;

/// Items are mission commands for main mission.
///
/// MAV_MISSION_TYPE_MISSION
const MavMissionType mavMissionTypeMission = 0;

/// Specifies GeoFence area(s). Items are MAV_CMD_NAV_FENCE_ GeoFence items.
///
/// MAV_MISSION_TYPE_FENCE
const MavMissionType mavMissionTypeFence = 1;

/// Specifies the rally points for the vehicle. Rally points are alternative RTL points. Items are MAV_CMD_NAV_RALLY_POINT rally point items.
///
/// MAV_MISSION_TYPE_RALLY
const MavMissionType mavMissionTypeRally = 2;

/// Only used in MISSION_CLEAR_ALL to clear all mission types.
///
/// MAV_MISSION_TYPE_ALL
const MavMissionType mavMissionTypeAll = 255;

/// Enumeration of estimator types
///
/// MAV_ESTIMATOR_TYPE
typedef MavEstimatorType = int;

/// Unknown type of the estimator.
///
/// MAV_ESTIMATOR_TYPE_UNKNOWN
const MavEstimatorType mavEstimatorTypeUnknown = 0;

/// This is a naive estimator without any real covariance feedback.
///
/// MAV_ESTIMATOR_TYPE_NAIVE
const MavEstimatorType mavEstimatorTypeNaive = 1;

/// Computer vision based estimate. Might be up to scale.
///
/// MAV_ESTIMATOR_TYPE_VISION
const MavEstimatorType mavEstimatorTypeVision = 2;

/// Visual-inertial estimate.
///
/// MAV_ESTIMATOR_TYPE_VIO
const MavEstimatorType mavEstimatorTypeVio = 3;

/// Plain GPS estimate.
///
/// MAV_ESTIMATOR_TYPE_GPS
const MavEstimatorType mavEstimatorTypeGps = 4;

/// Estimator integrating GPS and inertial sensing.
///
/// MAV_ESTIMATOR_TYPE_GPS_INS
const MavEstimatorType mavEstimatorTypeGpsIns = 5;

/// Estimate from external motion capturing system.
///
/// MAV_ESTIMATOR_TYPE_MOCAP
const MavEstimatorType mavEstimatorTypeMocap = 6;

/// Estimator based on lidar sensor input.
///
/// MAV_ESTIMATOR_TYPE_LIDAR
const MavEstimatorType mavEstimatorTypeLidar = 7;

/// Estimator on autopilot.
///
/// MAV_ESTIMATOR_TYPE_AUTOPILOT
const MavEstimatorType mavEstimatorTypeAutopilot = 8;

/// Enumeration of battery types
///
/// MAV_BATTERY_TYPE
typedef MavBatteryType = int;

/// Not specified.
///
/// MAV_BATTERY_TYPE_UNKNOWN
const MavBatteryType mavBatteryTypeUnknown = 0;

/// Lithium polymer battery
///
/// MAV_BATTERY_TYPE_LIPO
const MavBatteryType mavBatteryTypeLipo = 1;

/// Lithium-iron-phosphate battery
///
/// MAV_BATTERY_TYPE_LIFE
const MavBatteryType mavBatteryTypeLife = 2;

/// Lithium-ION battery
///
/// MAV_BATTERY_TYPE_LION
const MavBatteryType mavBatteryTypeLion = 3;

/// Nickel metal hydride battery
///
/// MAV_BATTERY_TYPE_NIMH
const MavBatteryType mavBatteryTypeNimh = 4;

/// Enumeration of battery functions
///
/// MAV_BATTERY_FUNCTION
typedef MavBatteryFunction = int;

/// Battery function is unknown
///
/// MAV_BATTERY_FUNCTION_UNKNOWN
const MavBatteryFunction mavBatteryFunctionUnknown = 0;

/// Battery supports all flight systems
///
/// MAV_BATTERY_FUNCTION_ALL
const MavBatteryFunction mavBatteryFunctionAll = 1;

/// Battery for the propulsion system
///
/// MAV_BATTERY_FUNCTION_PROPULSION
const MavBatteryFunction mavBatteryFunctionPropulsion = 2;

/// Avionics battery
///
/// MAV_BATTERY_FUNCTION_AVIONICS
const MavBatteryFunction mavBatteryFunctionAvionics = 3;

/// Payload battery
///
/// MAV_BATTERY_FUNCTION_PAYLOAD
const MavBatteryFunction mavBatteryFunctionPayload = 4;

/// Enumeration for battery charge states.
///
/// MAV_BATTERY_CHARGE_STATE
typedef MavBatteryChargeState = int;

/// Low battery state is not provided
///
/// MAV_BATTERY_CHARGE_STATE_UNDEFINED
const MavBatteryChargeState mavBatteryChargeStateUndefined = 0;

/// Battery is not in low state. Normal operation.
///
/// MAV_BATTERY_CHARGE_STATE_OK
const MavBatteryChargeState mavBatteryChargeStateOk = 1;

/// Battery state is low, warn and monitor close.
///
/// MAV_BATTERY_CHARGE_STATE_LOW
const MavBatteryChargeState mavBatteryChargeStateLow = 2;

/// Battery state is critical, return or abort immediately.
///
/// MAV_BATTERY_CHARGE_STATE_CRITICAL
const MavBatteryChargeState mavBatteryChargeStateCritical = 3;

/// Battery state is too low for ordinary abort sequence. Perform fastest possible emergency stop to prevent damage.
///
/// MAV_BATTERY_CHARGE_STATE_EMERGENCY
const MavBatteryChargeState mavBatteryChargeStateEmergency = 4;

/// Battery failed, damage unavoidable. Possible causes (faults) are listed in MAV_BATTERY_FAULT.
///
/// MAV_BATTERY_CHARGE_STATE_FAILED
const MavBatteryChargeState mavBatteryChargeStateFailed = 5;

/// Battery is diagnosed to be defective or an error occurred, usage is discouraged / prohibited. Possible causes (faults) are listed in MAV_BATTERY_FAULT.
///
/// MAV_BATTERY_CHARGE_STATE_UNHEALTHY
const MavBatteryChargeState mavBatteryChargeStateUnhealthy = 6;

/// Battery is charging.
///
/// MAV_BATTERY_CHARGE_STATE_CHARGING
const MavBatteryChargeState mavBatteryChargeStateCharging = 7;

/// Battery mode. Note, the normal operation mode (i.e. when flying) should be reported as MAV_BATTERY_MODE_UNKNOWN to allow message trimming in normal flight.
///
/// MAV_BATTERY_MODE
typedef MavBatteryMode = int;

/// Battery mode not supported/unknown battery mode/normal operation.
///
/// MAV_BATTERY_MODE_UNKNOWN
const MavBatteryMode mavBatteryModeUnknown = 0;

/// Battery is auto discharging (towards storage level).
///
/// MAV_BATTERY_MODE_AUTO_DISCHARGING
const MavBatteryMode mavBatteryModeAutoDischarging = 1;

/// Battery in hot-swap mode (current limited to prevent spikes that might damage sensitive electrical circuits).
///
/// MAV_BATTERY_MODE_HOT_SWAP
const MavBatteryMode mavBatteryModeHotSwap = 2;

/// Smart battery supply status/fault flags (bitmask) for health indication. The battery must also report either MAV_BATTERY_CHARGE_STATE_FAILED or MAV_BATTERY_CHARGE_STATE_UNHEALTHY if any of these are set.
///
/// MAV_BATTERY_FAULT
typedef MavBatteryFault = int;

/// Battery has deep discharged.
///
/// MAV_BATTERY_FAULT_DEEP_DISCHARGE
const MavBatteryFault mavBatteryFaultDeepDischarge = 1;

/// Voltage spikes.
///
/// MAV_BATTERY_FAULT_SPIKES
const MavBatteryFault mavBatteryFaultSpikes = 2;

/// One or more cells have failed. Battery should also report MAV_BATTERY_CHARGE_STATE_FAILE (and should not be used).
///
/// MAV_BATTERY_FAULT_CELL_FAIL
const MavBatteryFault mavBatteryFaultCellFail = 4;

/// Over-current fault.
///
/// MAV_BATTERY_FAULT_OVER_CURRENT
const MavBatteryFault mavBatteryFaultOverCurrent = 8;

/// Over-temperature fault.
///
/// MAV_BATTERY_FAULT_OVER_TEMPERATURE
const MavBatteryFault mavBatteryFaultOverTemperature = 16;

/// Under-temperature fault.
///
/// MAV_BATTERY_FAULT_UNDER_TEMPERATURE
const MavBatteryFault mavBatteryFaultUnderTemperature = 32;

/// Vehicle voltage is not compatible with this battery (batteries on same power rail should have similar voltage).
///
/// MAV_BATTERY_FAULT_INCOMPATIBLE_VOLTAGE
const MavBatteryFault mavBatteryFaultIncompatibleVoltage = 64;

/// Battery firmware is not compatible with current autopilot firmware.
///
/// MAV_BATTERY_FAULT_INCOMPATIBLE_FIRMWARE
const MavBatteryFault mavBatteryFaultIncompatibleFirmware = 128;

/// Battery is not compatible due to cell configuration (e.g. 5s1p when vehicle requires 6s).
///
/// BATTERY_FAULT_INCOMPATIBLE_CELLS_CONFIGURATION
const MavBatteryFault batteryFaultIncompatibleCellsConfiguration = 256;

/// Flags to report status/failure cases for a power generator (used in GENERATOR_STATUS). Note that FAULTS are conditions that cause the generator to fail. Warnings are conditions that require attention before the next use (they indicate the system is not operating properly).
///
/// MAV_GENERATOR_STATUS_FLAG
typedef MavGeneratorStatusFlag = int;

/// Generator is off.
///
/// MAV_GENERATOR_STATUS_FLAG_OFF
const MavGeneratorStatusFlag mavGeneratorStatusFlagOff = 1;

/// Generator is ready to start generating power.
///
/// MAV_GENERATOR_STATUS_FLAG_READY
const MavGeneratorStatusFlag mavGeneratorStatusFlagReady = 2;

/// Generator is generating power.
///
/// MAV_GENERATOR_STATUS_FLAG_GENERATING
const MavGeneratorStatusFlag mavGeneratorStatusFlagGenerating = 4;

/// Generator is charging the batteries (generating enough power to charge and provide the load).
///
/// MAV_GENERATOR_STATUS_FLAG_CHARGING
const MavGeneratorStatusFlag mavGeneratorStatusFlagCharging = 8;

/// Generator is operating at a reduced maximum power.
///
/// MAV_GENERATOR_STATUS_FLAG_REDUCED_POWER
const MavGeneratorStatusFlag mavGeneratorStatusFlagReducedPower = 16;

/// Generator is providing the maximum output.
///
/// MAV_GENERATOR_STATUS_FLAG_MAXPOWER
const MavGeneratorStatusFlag mavGeneratorStatusFlagMaxpower = 32;

/// Generator is near the maximum operating temperature, cooling is insufficient.
///
/// MAV_GENERATOR_STATUS_FLAG_OVERTEMP_WARNING
const MavGeneratorStatusFlag mavGeneratorStatusFlagOvertempWarning = 64;

/// Generator hit the maximum operating temperature and shutdown.
///
/// MAV_GENERATOR_STATUS_FLAG_OVERTEMP_FAULT
const MavGeneratorStatusFlag mavGeneratorStatusFlagOvertempFault = 128;

/// Power electronics are near the maximum operating temperature, cooling is insufficient.
///
/// MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_OVERTEMP_WARNING
const MavGeneratorStatusFlag mavGeneratorStatusFlagElectronicsOvertempWarning =
    256;

/// Power electronics hit the maximum operating temperature and shutdown.
///
/// MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_OVERTEMP_FAULT
const MavGeneratorStatusFlag mavGeneratorStatusFlagElectronicsOvertempFault =
    512;

/// Power electronics experienced a fault and shutdown.
///
/// MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_FAULT
const MavGeneratorStatusFlag mavGeneratorStatusFlagElectronicsFault = 1024;

/// The power source supplying the generator failed e.g. mechanical generator stopped, tether is no longer providing power, solar cell is in shade, hydrogen reaction no longer happening.
///
/// MAV_GENERATOR_STATUS_FLAG_POWERSOURCE_FAULT
const MavGeneratorStatusFlag mavGeneratorStatusFlagPowersourceFault = 2048;

/// Generator controller having communication problems.
///
/// MAV_GENERATOR_STATUS_FLAG_COMMUNICATION_WARNING
const MavGeneratorStatusFlag mavGeneratorStatusFlagCommunicationWarning = 4096;

/// Power electronic or generator cooling system error.
///
/// MAV_GENERATOR_STATUS_FLAG_COOLING_WARNING
const MavGeneratorStatusFlag mavGeneratorStatusFlagCoolingWarning = 8192;

/// Generator controller power rail experienced a fault.
///
/// MAV_GENERATOR_STATUS_FLAG_POWER_RAIL_FAULT
const MavGeneratorStatusFlag mavGeneratorStatusFlagPowerRailFault = 16384;

/// Generator controller exceeded the overcurrent threshold and shutdown to prevent damage.
///
/// MAV_GENERATOR_STATUS_FLAG_OVERCURRENT_FAULT
const MavGeneratorStatusFlag mavGeneratorStatusFlagOvercurrentFault = 32768;

/// Generator controller detected a high current going into the batteries and shutdown to prevent battery damage.
///
/// MAV_GENERATOR_STATUS_FLAG_BATTERY_OVERCHARGE_CURRENT_FAULT
const MavGeneratorStatusFlag
    mavGeneratorStatusFlagBatteryOverchargeCurrentFault = 65536;

/// Generator controller exceeded it's overvoltage threshold and shutdown to prevent it exceeding the voltage rating.
///
/// MAV_GENERATOR_STATUS_FLAG_OVERVOLTAGE_FAULT
const MavGeneratorStatusFlag mavGeneratorStatusFlagOvervoltageFault = 131072;

/// Batteries are under voltage (generator will not start).
///
/// MAV_GENERATOR_STATUS_FLAG_BATTERY_UNDERVOLT_FAULT
const MavGeneratorStatusFlag mavGeneratorStatusFlagBatteryUndervoltFault =
    262144;

/// Generator start is inhibited by e.g. a safety switch.
///
/// MAV_GENERATOR_STATUS_FLAG_START_INHIBITED
const MavGeneratorStatusFlag mavGeneratorStatusFlagStartInhibited = 524288;

/// Generator requires maintenance.
///
/// MAV_GENERATOR_STATUS_FLAG_MAINTENANCE_REQUIRED
const MavGeneratorStatusFlag mavGeneratorStatusFlagMaintenanceRequired =
    1048576;

/// Generator is not ready to generate yet.
///
/// MAV_GENERATOR_STATUS_FLAG_WARMING_UP
const MavGeneratorStatusFlag mavGeneratorStatusFlagWarmingUp = 2097152;

/// Generator is idle.
///
/// MAV_GENERATOR_STATUS_FLAG_IDLE
const MavGeneratorStatusFlag mavGeneratorStatusFlagIdle = 4194304;

/// Enumeration of VTOL states
///
/// MAV_VTOL_STATE
typedef MavVtolState = int;

/// MAV is not configured as VTOL
///
/// MAV_VTOL_STATE_UNDEFINED
const MavVtolState mavVtolStateUndefined = 0;

/// VTOL is in transition from multicopter to fixed-wing
///
/// MAV_VTOL_STATE_TRANSITION_TO_FW
const MavVtolState mavVtolStateTransitionToFw = 1;

/// VTOL is in transition from fixed-wing to multicopter
///
/// MAV_VTOL_STATE_TRANSITION_TO_MC
const MavVtolState mavVtolStateTransitionToMc = 2;

/// VTOL is in multicopter state
///
/// MAV_VTOL_STATE_MC
const MavVtolState mavVtolStateMc = 3;

/// VTOL is in fixed-wing state
///
/// MAV_VTOL_STATE_FW
const MavVtolState mavVtolStateFw = 4;

/// Enumeration of landed detector states
///
/// MAV_LANDED_STATE
typedef MavLandedState = int;

/// MAV landed state is unknown
///
/// MAV_LANDED_STATE_UNDEFINED
const MavLandedState mavLandedStateUndefined = 0;

/// MAV is landed (on ground)
///
/// MAV_LANDED_STATE_ON_GROUND
const MavLandedState mavLandedStateOnGround = 1;

/// MAV is in air
///
/// MAV_LANDED_STATE_IN_AIR
const MavLandedState mavLandedStateInAir = 2;

/// MAV currently taking off
///
/// MAV_LANDED_STATE_TAKEOFF
const MavLandedState mavLandedStateTakeoff = 3;

/// MAV currently landing
///
/// MAV_LANDED_STATE_LANDING
const MavLandedState mavLandedStateLanding = 4;

/// Enumeration of the ADSB altimeter types
///
/// ADSB_ALTITUDE_TYPE
typedef AdsbAltitudeType = int;

/// Altitude reported from a Baro source using QNH reference
///
/// ADSB_ALTITUDE_TYPE_PRESSURE_QNH
const AdsbAltitudeType adsbAltitudeTypePressureQnh = 0;

/// Altitude reported from a GNSS source
///
/// ADSB_ALTITUDE_TYPE_GEOMETRIC
const AdsbAltitudeType adsbAltitudeTypeGeometric = 1;

/// ADSB classification for the type of vehicle emitting the transponder signal
///
/// ADSB_EMITTER_TYPE
typedef AdsbEmitterType = int;

///
/// ADSB_EMITTER_TYPE_NO_INFO
const AdsbEmitterType adsbEmitterTypeNoInfo = 0;

///
/// ADSB_EMITTER_TYPE_LIGHT
const AdsbEmitterType adsbEmitterTypeLight = 1;

///
/// ADSB_EMITTER_TYPE_SMALL
const AdsbEmitterType adsbEmitterTypeSmall = 2;

///
/// ADSB_EMITTER_TYPE_LARGE
const AdsbEmitterType adsbEmitterTypeLarge = 3;

///
/// ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE
const AdsbEmitterType adsbEmitterTypeHighVortexLarge = 4;

///
/// ADSB_EMITTER_TYPE_HEAVY
const AdsbEmitterType adsbEmitterTypeHeavy = 5;

///
/// ADSB_EMITTER_TYPE_HIGHLY_MANUV
const AdsbEmitterType adsbEmitterTypeHighlyManuv = 6;

///
/// ADSB_EMITTER_TYPE_ROTOCRAFT
const AdsbEmitterType adsbEmitterTypeRotocraft = 7;

///
/// ADSB_EMITTER_TYPE_UNASSIGNED
const AdsbEmitterType adsbEmitterTypeUnassigned = 8;

///
/// ADSB_EMITTER_TYPE_GLIDER
const AdsbEmitterType adsbEmitterTypeGlider = 9;

///
/// ADSB_EMITTER_TYPE_LIGHTER_AIR
const AdsbEmitterType adsbEmitterTypeLighterAir = 10;

///
/// ADSB_EMITTER_TYPE_PARACHUTE
const AdsbEmitterType adsbEmitterTypeParachute = 11;

///
/// ADSB_EMITTER_TYPE_ULTRA_LIGHT
const AdsbEmitterType adsbEmitterTypeUltraLight = 12;

///
/// ADSB_EMITTER_TYPE_UNASSIGNED2
const AdsbEmitterType adsbEmitterTypeUnassigned2 = 13;

///
/// ADSB_EMITTER_TYPE_UAV
const AdsbEmitterType adsbEmitterTypeUav = 14;

///
/// ADSB_EMITTER_TYPE_SPACE
const AdsbEmitterType adsbEmitterTypeSpace = 15;

///
/// ADSB_EMITTER_TYPE_UNASSGINED3
const AdsbEmitterType adsbEmitterTypeUnassgined3 = 16;

///
/// ADSB_EMITTER_TYPE_EMERGENCY_SURFACE
const AdsbEmitterType adsbEmitterTypeEmergencySurface = 17;

///
/// ADSB_EMITTER_TYPE_SERVICE_SURFACE
const AdsbEmitterType adsbEmitterTypeServiceSurface = 18;

///
/// ADSB_EMITTER_TYPE_POINT_OBSTACLE
const AdsbEmitterType adsbEmitterTypePointObstacle = 19;

/// These flags indicate status such as data validity of each data source. Set = data valid
///
/// ADSB_FLAGS
typedef AdsbFlags = int;

///
/// ADSB_FLAGS_VALID_COORDS
const AdsbFlags adsbFlagsValidCoords = 1;

///
/// ADSB_FLAGS_VALID_ALTITUDE
const AdsbFlags adsbFlagsValidAltitude = 2;

///
/// ADSB_FLAGS_VALID_HEADING
const AdsbFlags adsbFlagsValidHeading = 4;

///
/// ADSB_FLAGS_VALID_VELOCITY
const AdsbFlags adsbFlagsValidVelocity = 8;

///
/// ADSB_FLAGS_VALID_CALLSIGN
const AdsbFlags adsbFlagsValidCallsign = 16;

///
/// ADSB_FLAGS_VALID_SQUAWK
const AdsbFlags adsbFlagsValidSquawk = 32;

///
/// ADSB_FLAGS_SIMULATED
const AdsbFlags adsbFlagsSimulated = 64;

///
/// ADSB_FLAGS_VERTICAL_VELOCITY_VALID
const AdsbFlags adsbFlagsVerticalVelocityValid = 128;

///
/// ADSB_FLAGS_BARO_VALID
const AdsbFlags adsbFlagsBaroValid = 256;

///
/// ADSB_FLAGS_SOURCE_UAT
const AdsbFlags adsbFlagsSourceUat = 32768;

/// Bitmap of options for the MAV_CMD_DO_REPOSITION
///
/// MAV_DO_REPOSITION_FLAGS
typedef MavDoRepositionFlags = int;

/// The aircraft should immediately transition into guided. This should not be set for follow me applications
///
/// MAV_DO_REPOSITION_FLAGS_CHANGE_MODE
const MavDoRepositionFlags mavDoRepositionFlagsChangeMode = 1;

/// Speed setpoint types used in MAV_CMD_DO_CHANGE_SPEED
///
/// SPEED_TYPE
typedef SpeedType = int;

/// Airspeed
///
/// SPEED_TYPE_AIRSPEED
const SpeedType speedTypeAirspeed = 0;

/// Groundspeed
///
/// SPEED_TYPE_GROUNDSPEED
const SpeedType speedTypeGroundspeed = 1;

/// Climb speed
///
/// SPEED_TYPE_CLIMB_SPEED
const SpeedType speedTypeClimbSpeed = 2;

/// Descent speed
///
/// SPEED_TYPE_DESCENT_SPEED
const SpeedType speedTypeDescentSpeed = 3;

/// Flags in ESTIMATOR_STATUS message
///
/// ESTIMATOR_STATUS_FLAGS
typedef EstimatorStatusFlags = int;

/// True if the attitude estimate is good
///
/// ESTIMATOR_ATTITUDE
const EstimatorStatusFlags estimatorAttitude = 1;

/// True if the horizontal velocity estimate is good
///
/// ESTIMATOR_VELOCITY_HORIZ
const EstimatorStatusFlags estimatorVelocityHoriz = 2;

/// True if the  vertical velocity estimate is good
///
/// ESTIMATOR_VELOCITY_VERT
const EstimatorStatusFlags estimatorVelocityVert = 4;

/// True if the horizontal position (relative) estimate is good
///
/// ESTIMATOR_POS_HORIZ_REL
const EstimatorStatusFlags estimatorPosHorizRel = 8;

/// True if the horizontal position (absolute) estimate is good
///
/// ESTIMATOR_POS_HORIZ_ABS
const EstimatorStatusFlags estimatorPosHorizAbs = 16;

/// True if the vertical position (absolute) estimate is good
///
/// ESTIMATOR_POS_VERT_ABS
const EstimatorStatusFlags estimatorPosVertAbs = 32;

/// True if the vertical position (above ground) estimate is good
///
/// ESTIMATOR_POS_VERT_AGL
const EstimatorStatusFlags estimatorPosVertAgl = 64;

/// True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical flow)
///
/// ESTIMATOR_CONST_POS_MODE
const EstimatorStatusFlags estimatorConstPosMode = 128;

/// True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimate
///
/// ESTIMATOR_PRED_POS_HORIZ_REL
const EstimatorStatusFlags estimatorPredPosHorizRel = 256;

/// True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimate
///
/// ESTIMATOR_PRED_POS_HORIZ_ABS
const EstimatorStatusFlags estimatorPredPosHorizAbs = 512;

/// True if the EKF has detected a GPS glitch
///
/// ESTIMATOR_GPS_GLITCH
const EstimatorStatusFlags estimatorGpsGlitch = 1024;

/// True if the EKF has detected bad accelerometer data
///
/// ESTIMATOR_ACCEL_ERROR
const EstimatorStatusFlags estimatorAccelError = 2048;

/// Sequence that motors are tested when using MAV_CMD_DO_MOTOR_TEST.
///
/// MOTOR_TEST_ORDER
typedef MotorTestOrder = int;

/// Default autopilot motor test method.
///
/// MOTOR_TEST_ORDER_DEFAULT
const MotorTestOrder motorTestOrderDefault = 0;

/// Motor numbers are specified as their index in a predefined vehicle-specific sequence.
///
/// MOTOR_TEST_ORDER_SEQUENCE
const MotorTestOrder motorTestOrderSequence = 1;

/// Motor numbers are specified as the output as labeled on the board.
///
/// MOTOR_TEST_ORDER_BOARD
const MotorTestOrder motorTestOrderBoard = 2;

/// Defines how throttle value is represented in MAV_CMD_DO_MOTOR_TEST.
///
/// MOTOR_TEST_THROTTLE_TYPE
typedef MotorTestThrottleType = int;

/// Throttle as a percentage (0 ~ 100)
///
/// MOTOR_TEST_THROTTLE_PERCENT
const MotorTestThrottleType motorTestThrottlePercent = 0;

/// Throttle as an absolute PWM value (normally in range of 1000~2000).
///
/// MOTOR_TEST_THROTTLE_PWM
const MotorTestThrottleType motorTestThrottlePwm = 1;

/// Throttle pass-through from pilot's transmitter.
///
/// MOTOR_TEST_THROTTLE_PILOT
const MotorTestThrottleType motorTestThrottlePilot = 2;

/// Per-motor compass calibration test.
///
/// MOTOR_TEST_COMPASS_CAL
const MotorTestThrottleType motorTestCompassCal = 3;

///
/// GPS_INPUT_IGNORE_FLAGS
typedef GpsInputIgnoreFlags = int;

/// ignore altitude field
///
/// GPS_INPUT_IGNORE_FLAG_ALT
const GpsInputIgnoreFlags gpsInputIgnoreFlagAlt = 1;

/// ignore hdop field
///
/// GPS_INPUT_IGNORE_FLAG_HDOP
const GpsInputIgnoreFlags gpsInputIgnoreFlagHdop = 2;

/// ignore vdop field
///
/// GPS_INPUT_IGNORE_FLAG_VDOP
const GpsInputIgnoreFlags gpsInputIgnoreFlagVdop = 4;

/// ignore horizontal velocity field (vn and ve)
///
/// GPS_INPUT_IGNORE_FLAG_VEL_HORIZ
const GpsInputIgnoreFlags gpsInputIgnoreFlagVelHoriz = 8;

/// ignore vertical velocity field (vd)
///
/// GPS_INPUT_IGNORE_FLAG_VEL_VERT
const GpsInputIgnoreFlags gpsInputIgnoreFlagVelVert = 16;

/// ignore speed accuracy field
///
/// GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY
const GpsInputIgnoreFlags gpsInputIgnoreFlagSpeedAccuracy = 32;

/// ignore horizontal accuracy field
///
/// GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY
const GpsInputIgnoreFlags gpsInputIgnoreFlagHorizontalAccuracy = 64;

/// ignore vertical accuracy field
///
/// GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY
const GpsInputIgnoreFlags gpsInputIgnoreFlagVerticalAccuracy = 128;

/// Possible actions an aircraft can take to avoid a collision.
///
/// MAV_COLLISION_ACTION
typedef MavCollisionAction = int;

/// Ignore any potential collisions
///
/// MAV_COLLISION_ACTION_NONE
const MavCollisionAction mavCollisionActionNone = 0;

/// Report potential collision
///
/// MAV_COLLISION_ACTION_REPORT
const MavCollisionAction mavCollisionActionReport = 1;

/// Ascend or Descend to avoid threat
///
/// MAV_COLLISION_ACTION_ASCEND_OR_DESCEND
const MavCollisionAction mavCollisionActionAscendOrDescend = 2;

/// Move horizontally to avoid threat
///
/// MAV_COLLISION_ACTION_MOVE_HORIZONTALLY
const MavCollisionAction mavCollisionActionMoveHorizontally = 3;

/// Aircraft to move perpendicular to the collision's velocity vector
///
/// MAV_COLLISION_ACTION_MOVE_PERPENDICULAR
const MavCollisionAction mavCollisionActionMovePerpendicular = 4;

/// Aircraft to fly directly back to its launch point
///
/// MAV_COLLISION_ACTION_RTL
const MavCollisionAction mavCollisionActionRtl = 5;

/// Aircraft to stop in place
///
/// MAV_COLLISION_ACTION_HOVER
const MavCollisionAction mavCollisionActionHover = 6;

/// Aircraft-rated danger from this threat.
///
/// MAV_COLLISION_THREAT_LEVEL
typedef MavCollisionThreatLevel = int;

/// Not a threat
///
/// MAV_COLLISION_THREAT_LEVEL_NONE
const MavCollisionThreatLevel mavCollisionThreatLevelNone = 0;

/// Craft is mildly concerned about this threat
///
/// MAV_COLLISION_THREAT_LEVEL_LOW
const MavCollisionThreatLevel mavCollisionThreatLevelLow = 1;

/// Craft is panicking, and may take actions to avoid threat
///
/// MAV_COLLISION_THREAT_LEVEL_HIGH
const MavCollisionThreatLevel mavCollisionThreatLevelHigh = 2;

/// Source of information about this collision.
///
/// MAV_COLLISION_SRC
typedef MavCollisionSrc = int;

/// ID field references ADSB_VEHICLE packets
///
/// MAV_COLLISION_SRC_ADSB
const MavCollisionSrc mavCollisionSrcAdsb = 0;

/// ID field references MAVLink SRC ID
///
/// MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT
const MavCollisionSrc mavCollisionSrcMavlinkGpsGlobalInt = 1;

/// Type of GPS fix
///
/// GPS_FIX_TYPE
typedef GpsFixType = int;

/// No GPS connected
///
/// GPS_FIX_TYPE_NO_GPS
const GpsFixType gpsFixTypeNoGps = 0;

/// No position information, GPS is connected
///
/// GPS_FIX_TYPE_NO_FIX
const GpsFixType gpsFixTypeNoFix = 1;

/// 2D position
///
/// GPS_FIX_TYPE_2D_FIX
const GpsFixType gpsFixType2dFix = 2;

/// 3D position
///
/// GPS_FIX_TYPE_3D_FIX
const GpsFixType gpsFixType3dFix = 3;

/// DGPS/SBAS aided 3D position
///
/// GPS_FIX_TYPE_DGPS
const GpsFixType gpsFixTypeDgps = 4;

/// RTK float, 3D position
///
/// GPS_FIX_TYPE_RTK_FLOAT
const GpsFixType gpsFixTypeRtkFloat = 5;

/// RTK Fixed, 3D position
///
/// GPS_FIX_TYPE_RTK_FIXED
const GpsFixType gpsFixTypeRtkFixed = 6;

/// Static fixed, typically used for base stations
///
/// GPS_FIX_TYPE_STATIC
const GpsFixType gpsFixTypeStatic = 7;

/// PPP, 3D position.
///
/// GPS_FIX_TYPE_PPP
const GpsFixType gpsFixTypePpp = 8;

/// RTK GPS baseline coordinate system, used for RTK corrections
///
/// RTK_BASELINE_COORDINATE_SYSTEM
typedef RtkBaselineCoordinateSystem = int;

/// Earth-centered, Earth-fixed
///
/// RTK_BASELINE_COORDINATE_SYSTEM_ECEF
const RtkBaselineCoordinateSystem rtkBaselineCoordinateSystemEcef = 0;

/// RTK basestation centered, north, east, down
///
/// RTK_BASELINE_COORDINATE_SYSTEM_NED
const RtkBaselineCoordinateSystem rtkBaselineCoordinateSystemNed = 1;

/// Type of landing target
///
/// LANDING_TARGET_TYPE
typedef LandingTargetType = int;

/// Landing target signaled by light beacon (ex: IR-LOCK)
///
/// LANDING_TARGET_TYPE_LIGHT_BEACON
const LandingTargetType landingTargetTypeLightBeacon = 0;

/// Landing target signaled by radio beacon (ex: ILS, NDB)
///
/// LANDING_TARGET_TYPE_RADIO_BEACON
const LandingTargetType landingTargetTypeRadioBeacon = 1;

/// Landing target represented by a fiducial marker (ex: ARTag)
///
/// LANDING_TARGET_TYPE_VISION_FIDUCIAL
const LandingTargetType landingTargetTypeVisionFiducial = 2;

/// Landing target represented by a pre-defined visual shape/feature (ex: X-marker, H-marker, square)
///
/// LANDING_TARGET_TYPE_VISION_OTHER
const LandingTargetType landingTargetTypeVisionOther = 3;

/// Direction of VTOL transition
///
/// VTOL_TRANSITION_HEADING
typedef VtolTransitionHeading = int;

/// Respect the heading configuration of the vehicle.
///
/// VTOL_TRANSITION_HEADING_VEHICLE_DEFAULT
const VtolTransitionHeading vtolTransitionHeadingVehicleDefault = 0;

/// Use the heading pointing towards the next waypoint.
///
/// VTOL_TRANSITION_HEADING_NEXT_WAYPOINT
const VtolTransitionHeading vtolTransitionHeadingNextWaypoint = 1;

/// Use the heading on takeoff (while sitting on the ground).
///
/// VTOL_TRANSITION_HEADING_TAKEOFF
const VtolTransitionHeading vtolTransitionHeadingTakeoff = 2;

/// Use the specified heading in parameter 4.
///
/// VTOL_TRANSITION_HEADING_SPECIFIED
const VtolTransitionHeading vtolTransitionHeadingSpecified = 3;

/// Use the current heading when reaching takeoff altitude (potentially facing the wind when weather-vaning is active).
///
/// VTOL_TRANSITION_HEADING_ANY
const VtolTransitionHeading vtolTransitionHeadingAny = 4;

/// Camera capability flags (Bitmap)
///
/// CAMERA_CAP_FLAGS
typedef CameraCapFlags = int;

/// Camera is able to record video
///
/// CAMERA_CAP_FLAGS_CAPTURE_VIDEO
const CameraCapFlags cameraCapFlagsCaptureVideo = 1;

/// Camera is able to capture images
///
/// CAMERA_CAP_FLAGS_CAPTURE_IMAGE
const CameraCapFlags cameraCapFlagsCaptureImage = 2;

/// Camera has separate Video and Image/Photo modes (MAV_CMD_SET_CAMERA_MODE)
///
/// CAMERA_CAP_FLAGS_HAS_MODES
const CameraCapFlags cameraCapFlagsHasModes = 4;

/// Camera can capture images while in video mode
///
/// CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE
const CameraCapFlags cameraCapFlagsCanCaptureImageInVideoMode = 8;

/// Camera can capture videos while in Photo/Image mode
///
/// CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE
const CameraCapFlags cameraCapFlagsCanCaptureVideoInImageMode = 16;

/// Camera has image survey mode (MAV_CMD_SET_CAMERA_MODE)
///
/// CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE
const CameraCapFlags cameraCapFlagsHasImageSurveyMode = 32;

/// Camera has basic zoom control (MAV_CMD_SET_CAMERA_ZOOM)
///
/// CAMERA_CAP_FLAGS_HAS_BASIC_ZOOM
const CameraCapFlags cameraCapFlagsHasBasicZoom = 64;

/// Camera has basic focus control (MAV_CMD_SET_CAMERA_FOCUS)
///
/// CAMERA_CAP_FLAGS_HAS_BASIC_FOCUS
const CameraCapFlags cameraCapFlagsHasBasicFocus = 128;

/// Camera has video streaming capabilities (request VIDEO_STREAM_INFORMATION with MAV_CMD_REQUEST_MESSAGE for video streaming info)
///
/// CAMERA_CAP_FLAGS_HAS_VIDEO_STREAM
const CameraCapFlags cameraCapFlagsHasVideoStream = 256;

/// Camera supports tracking of a point on the camera view.
///
/// CAMERA_CAP_FLAGS_HAS_TRACKING_POINT
const CameraCapFlags cameraCapFlagsHasTrackingPoint = 512;

/// Camera supports tracking of a selection rectangle on the camera view.
///
/// CAMERA_CAP_FLAGS_HAS_TRACKING_RECTANGLE
const CameraCapFlags cameraCapFlagsHasTrackingRectangle = 1024;

/// Camera supports tracking geo status (CAMERA_TRACKING_GEO_STATUS).
///
/// CAMERA_CAP_FLAGS_HAS_TRACKING_GEO_STATUS
const CameraCapFlags cameraCapFlagsHasTrackingGeoStatus = 2048;

/// Camera supports absolute thermal range (request CAMERA_THERMAL_RANGE with MAV_CMD_REQUEST_MESSAGE) (WIP).
///
/// CAMERA_CAP_FLAGS_HAS_THERMAL_RANGE
const CameraCapFlags cameraCapFlagsHasThermalRange = 4096;

/// Stream status flags (Bitmap)
///
/// VIDEO_STREAM_STATUS_FLAGS
typedef VideoStreamStatusFlags = int;

/// Stream is active (running)
///
/// VIDEO_STREAM_STATUS_FLAGS_RUNNING
const VideoStreamStatusFlags videoStreamStatusFlagsRunning = 1;

/// Stream is thermal imaging
///
/// VIDEO_STREAM_STATUS_FLAGS_THERMAL
const VideoStreamStatusFlags videoStreamStatusFlagsThermal = 2;

/// Stream can report absolute thermal range (see CAMERA_THERMAL_RANGE). (WIP).
///
/// VIDEO_STREAM_STATUS_FLAGS_THERMAL_RANGE_ENABLED
const VideoStreamStatusFlags videoStreamStatusFlagsThermalRangeEnabled = 4;

/// Video stream types
///
/// VIDEO_STREAM_TYPE
typedef VideoStreamType = int;

/// Stream is RTSP
///
/// VIDEO_STREAM_TYPE_RTSP
const VideoStreamType videoStreamTypeRtsp = 0;

/// Stream is RTP UDP (URI gives the port number)
///
/// VIDEO_STREAM_TYPE_RTPUDP
const VideoStreamType videoStreamTypeRtpudp = 1;

/// Stream is MPEG on TCP
///
/// VIDEO_STREAM_TYPE_TCP_MPEG
const VideoStreamType videoStreamTypeTcpMpeg = 2;

/// Stream is MPEG TS (URI gives the port number)
///
/// VIDEO_STREAM_TYPE_MPEG_TS
const VideoStreamType videoStreamTypeMpegTs = 3;

/// Video stream encodings
///
/// VIDEO_STREAM_ENCODING
typedef VideoStreamEncoding = int;

/// Stream encoding is unknown
///
/// VIDEO_STREAM_ENCODING_UNKNOWN
const VideoStreamEncoding videoStreamEncodingUnknown = 0;

/// Stream encoding is H.264
///
/// VIDEO_STREAM_ENCODING_H264
const VideoStreamEncoding videoStreamEncodingH264 = 1;

/// Stream encoding is H.265
///
/// VIDEO_STREAM_ENCODING_H265
const VideoStreamEncoding videoStreamEncodingH265 = 2;

/// Camera tracking status flags
///
/// CAMERA_TRACKING_STATUS_FLAGS
typedef CameraTrackingStatusFlags = int;

/// Camera is not tracking
///
/// CAMERA_TRACKING_STATUS_FLAGS_IDLE
const CameraTrackingStatusFlags cameraTrackingStatusFlagsIdle = 0;

/// Camera is tracking
///
/// CAMERA_TRACKING_STATUS_FLAGS_ACTIVE
const CameraTrackingStatusFlags cameraTrackingStatusFlagsActive = 1;

/// Camera tracking in error state
///
/// CAMERA_TRACKING_STATUS_FLAGS_ERROR
const CameraTrackingStatusFlags cameraTrackingStatusFlagsError = 2;

/// Camera tracking modes
///
/// CAMERA_TRACKING_MODE
typedef CameraTrackingMode = int;

/// Not tracking
///
/// CAMERA_TRACKING_MODE_NONE
const CameraTrackingMode cameraTrackingModeNone = 0;

/// Target is a point
///
/// CAMERA_TRACKING_MODE_POINT
const CameraTrackingMode cameraTrackingModePoint = 1;

/// Target is a rectangle
///
/// CAMERA_TRACKING_MODE_RECTANGLE
const CameraTrackingMode cameraTrackingModeRectangle = 2;

/// Camera tracking target data (shows where tracked target is within image)
///
/// CAMERA_TRACKING_TARGET_DATA
typedef CameraTrackingTargetData = int;

/// No target data
///
/// CAMERA_TRACKING_TARGET_DATA_NONE
const CameraTrackingTargetData cameraTrackingTargetDataNone = 0;

/// Target data embedded in image data (proprietary)
///
/// CAMERA_TRACKING_TARGET_DATA_EMBEDDED
const CameraTrackingTargetData cameraTrackingTargetDataEmbedded = 1;

/// Target data rendered in image
///
/// CAMERA_TRACKING_TARGET_DATA_RENDERED
const CameraTrackingTargetData cameraTrackingTargetDataRendered = 2;

/// Target data within status message (Point or Rectangle)
///
/// CAMERA_TRACKING_TARGET_DATA_IN_STATUS
const CameraTrackingTargetData cameraTrackingTargetDataInStatus = 4;

/// Zoom types for MAV_CMD_SET_CAMERA_ZOOM
///
/// CAMERA_ZOOM_TYPE
typedef CameraZoomType = int;

/// Zoom one step increment (-1 for wide, 1 for tele)
///
/// ZOOM_TYPE_STEP
const CameraZoomType zoomTypeStep = 0;

/// Continuous zoom up/down until stopped (-1 for wide, 1 for tele, 0 to stop zooming)
///
/// ZOOM_TYPE_CONTINUOUS
const CameraZoomType zoomTypeContinuous = 1;

/// Zoom value as proportion of full camera range (a percentage value between 0.0 and 100.0)
///
/// ZOOM_TYPE_RANGE
const CameraZoomType zoomTypeRange = 2;

/// Zoom value/variable focal length in millimetres. Note that there is no message to get the valid zoom range of the camera, so this can type can only be used for cameras where the zoom range is known (implying that this cannot reliably be used in a GCS for an arbitrary camera)
///
/// ZOOM_TYPE_FOCAL_LENGTH
const CameraZoomType zoomTypeFocalLength = 3;

/// Zoom value as horizontal field of view in degrees.
///
/// ZOOM_TYPE_HORIZONTAL_FOV
const CameraZoomType zoomTypeHorizontalFov = 4;

/// Focus types for MAV_CMD_SET_CAMERA_FOCUS
///
/// SET_FOCUS_TYPE
typedef SetFocusType = int;

/// Focus one step increment (-1 for focusing in, 1 for focusing out towards infinity).
///
/// FOCUS_TYPE_STEP
const SetFocusType focusTypeStep = 0;

/// Continuous focus up/down until stopped (-1 for focusing in, 1 for focusing out towards infinity, 0 to stop focusing)
///
/// FOCUS_TYPE_CONTINUOUS
const SetFocusType focusTypeContinuous = 1;

/// Focus value as proportion of full camera focus range (a value between 0.0 and 100.0)
///
/// FOCUS_TYPE_RANGE
const SetFocusType focusTypeRange = 2;

/// Focus value in metres. Note that there is no message to get the valid focus range of the camera, so this can type can only be used for cameras where the range is known (implying that this cannot reliably be used in a GCS for an arbitrary camera).
///
/// FOCUS_TYPE_METERS
const SetFocusType focusTypeMeters = 3;

/// Focus automatically.
///
/// FOCUS_TYPE_AUTO
const SetFocusType focusTypeAuto = 4;

/// Single auto focus. Mainly used for still pictures. Usually abbreviated as AF-S.
///
/// FOCUS_TYPE_AUTO_SINGLE
const SetFocusType focusTypeAutoSingle = 5;

/// Continuous auto focus. Mainly used for dynamic scenes. Abbreviated as AF-C.
///
/// FOCUS_TYPE_AUTO_CONTINUOUS
const SetFocusType focusTypeAutoContinuous = 6;

/// Camera sources for MAV_CMD_SET_CAMERA_SOURCE
///
/// CAMERA_SOURCE
typedef CameraSource = int;

/// Default camera source.
///
/// CAMERA_SOURCE_DEFAULT
const CameraSource cameraSourceDefault = 0;

/// RGB camera source.
///
/// CAMERA_SOURCE_RGB
const CameraSource cameraSourceRgb = 1;

/// IR camera source.
///
/// CAMERA_SOURCE_IR
const CameraSource cameraSourceIr = 2;

/// NDVI camera source.
///
/// CAMERA_SOURCE_NDVI
const CameraSource cameraSourceNdvi = 3;

/// Result from PARAM_EXT_SET message (or a PARAM_SET within a transaction).
///
/// PARAM_ACK
typedef ParamAck = int;

/// Parameter value ACCEPTED and SET
///
/// PARAM_ACK_ACCEPTED
const ParamAck paramAckAccepted = 0;

/// Parameter value UNKNOWN/UNSUPPORTED
///
/// PARAM_ACK_VALUE_UNSUPPORTED
const ParamAck paramAckValueUnsupported = 1;

/// Parameter failed to set
///
/// PARAM_ACK_FAILED
const ParamAck paramAckFailed = 2;

/// Parameter value received but not yet set/accepted. A subsequent PARAM_ACK_TRANSACTION or PARAM_EXT_ACK with the final result will follow once operation is completed. This is returned immediately for parameters that take longer to set, indicating that the the parameter was received and does not need to be resent.
///
/// PARAM_ACK_IN_PROGRESS
const ParamAck paramAckInProgress = 3;

/// Camera Modes.
///
/// CAMERA_MODE
typedef CameraMode = int;

/// Camera is in image/photo capture mode.
///
/// CAMERA_MODE_IMAGE
const CameraMode cameraModeImage = 0;

/// Camera is in video capture mode.
///
/// CAMERA_MODE_VIDEO
const CameraMode cameraModeVideo = 1;

/// Camera is in image survey capture mode. It allows for camera controller to do specific settings for surveys.
///
/// CAMERA_MODE_IMAGE_SURVEY
const CameraMode cameraModeImageSurvey = 2;

///
/// MAV_ARM_AUTH_DENIED_REASON
typedef MavArmAuthDeniedReason = int;

/// Not a specific reason
///
/// MAV_ARM_AUTH_DENIED_REASON_GENERIC
const MavArmAuthDeniedReason mavArmAuthDeniedReasonGeneric = 0;

/// Authorizer will send the error as string to GCS
///
/// MAV_ARM_AUTH_DENIED_REASON_NONE
const MavArmAuthDeniedReason mavArmAuthDeniedReasonNone = 1;

/// At least one waypoint have a invalid value
///
/// MAV_ARM_AUTH_DENIED_REASON_INVALID_WAYPOINT
const MavArmAuthDeniedReason mavArmAuthDeniedReasonInvalidWaypoint = 2;

/// Timeout in the authorizer process(in case it depends on network)
///
/// MAV_ARM_AUTH_DENIED_REASON_TIMEOUT
const MavArmAuthDeniedReason mavArmAuthDeniedReasonTimeout = 3;

/// Airspace of the mission in use by another vehicle, second result parameter can have the waypoint id that caused it to be denied.
///
/// MAV_ARM_AUTH_DENIED_REASON_AIRSPACE_IN_USE
const MavArmAuthDeniedReason mavArmAuthDeniedReasonAirspaceInUse = 4;

/// Weather is not good to fly
///
/// MAV_ARM_AUTH_DENIED_REASON_BAD_WEATHER
const MavArmAuthDeniedReason mavArmAuthDeniedReasonBadWeather = 5;

/// RC type. Used in MAV_CMD_START_RX_PAIR.
///
/// RC_TYPE
typedef RcType = int;

/// Spektrum
///
/// RC_TYPE_SPEKTRUM
const RcType rcTypeSpektrum = 0;

/// CRSF
///
/// RC_TYPE_CRSF
const RcType rcTypeCrsf = 1;

/// RC sub-type of types defined in RC_TYPE. Used in MAV_CMD_START_RX_PAIR. Ignored if value does not correspond to the set RC_TYPE.
///
/// RC_SUB_TYPE
typedef RcSubType = int;

/// Spektrum DSM2
///
/// RC_SUB_TYPE_SPEKTRUM_DSM2
const RcSubType rcSubTypeSpektrumDsm2 = 0;

/// Spektrum DSMX
///
/// RC_SUB_TYPE_SPEKTRUM_DSMX
const RcSubType rcSubTypeSpektrumDsmx = 1;

/// Spektrum DSMX8
///
/// RC_SUB_TYPE_SPEKTRUM_DSMX8
const RcSubType rcSubTypeSpektrumDsmx8 = 2;

/// Bitmap to indicate which dimensions should be ignored by the vehicle: a value of 0b0000000000000000 or 0b0000001000000000 indicates that none of the setpoint dimensions should be ignored. If bit 9 is set the floats afx afy afz should be interpreted as force instead of acceleration.
///
/// POSITION_TARGET_TYPEMASK
typedef PositionTargetTypemask = int;

/// Ignore position x
///
/// POSITION_TARGET_TYPEMASK_X_IGNORE
const PositionTargetTypemask positionTargetTypemaskXIgnore = 1;

/// Ignore position y
///
/// POSITION_TARGET_TYPEMASK_Y_IGNORE
const PositionTargetTypemask positionTargetTypemaskYIgnore = 2;

/// Ignore position z
///
/// POSITION_TARGET_TYPEMASK_Z_IGNORE
const PositionTargetTypemask positionTargetTypemaskZIgnore = 4;

/// Ignore velocity x
///
/// POSITION_TARGET_TYPEMASK_VX_IGNORE
const PositionTargetTypemask positionTargetTypemaskVxIgnore = 8;

/// Ignore velocity y
///
/// POSITION_TARGET_TYPEMASK_VY_IGNORE
const PositionTargetTypemask positionTargetTypemaskVyIgnore = 16;

/// Ignore velocity z
///
/// POSITION_TARGET_TYPEMASK_VZ_IGNORE
const PositionTargetTypemask positionTargetTypemaskVzIgnore = 32;

/// Ignore acceleration x
///
/// POSITION_TARGET_TYPEMASK_AX_IGNORE
const PositionTargetTypemask positionTargetTypemaskAxIgnore = 64;

/// Ignore acceleration y
///
/// POSITION_TARGET_TYPEMASK_AY_IGNORE
const PositionTargetTypemask positionTargetTypemaskAyIgnore = 128;

/// Ignore acceleration z
///
/// POSITION_TARGET_TYPEMASK_AZ_IGNORE
const PositionTargetTypemask positionTargetTypemaskAzIgnore = 256;

/// Use force instead of acceleration
///
/// POSITION_TARGET_TYPEMASK_FORCE_SET
const PositionTargetTypemask positionTargetTypemaskForceSet = 512;

/// Ignore yaw
///
/// POSITION_TARGET_TYPEMASK_YAW_IGNORE
const PositionTargetTypemask positionTargetTypemaskYawIgnore = 1024;

/// Ignore yaw rate
///
/// POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE
const PositionTargetTypemask positionTargetTypemaskYawRateIgnore = 2048;

/// Bitmap to indicate which dimensions should be ignored by the vehicle: a value of 0b00000000 indicates that none of the setpoint dimensions should be ignored.
///
/// ATTITUDE_TARGET_TYPEMASK
typedef AttitudeTargetTypemask = int;

/// Ignore body roll rate
///
/// ATTITUDE_TARGET_TYPEMASK_BODY_ROLL_RATE_IGNORE
const AttitudeTargetTypemask attitudeTargetTypemaskBodyRollRateIgnore = 1;

/// Ignore body pitch rate
///
/// ATTITUDE_TARGET_TYPEMASK_BODY_PITCH_RATE_IGNORE
const AttitudeTargetTypemask attitudeTargetTypemaskBodyPitchRateIgnore = 2;

/// Ignore body yaw rate
///
/// ATTITUDE_TARGET_TYPEMASK_BODY_YAW_RATE_IGNORE
const AttitudeTargetTypemask attitudeTargetTypemaskBodyYawRateIgnore = 4;

/// Use 3D body thrust setpoint instead of throttle
///
/// ATTITUDE_TARGET_TYPEMASK_THRUST_BODY_SET
const AttitudeTargetTypemask attitudeTargetTypemaskThrustBodySet = 32;

/// Ignore throttle
///
/// ATTITUDE_TARGET_TYPEMASK_THROTTLE_IGNORE
const AttitudeTargetTypemask attitudeTargetTypemaskThrottleIgnore = 64;

/// Ignore attitude
///
/// ATTITUDE_TARGET_TYPEMASK_ATTITUDE_IGNORE
const AttitudeTargetTypemask attitudeTargetTypemaskAttitudeIgnore = 128;

/// Airborne status of UAS.
///
/// UTM_FLIGHT_STATE
typedef UtmFlightState = int;

/// The flight state can't be determined.
///
/// UTM_FLIGHT_STATE_UNKNOWN
const UtmFlightState utmFlightStateUnknown = 1;

/// UAS on ground.
///
/// UTM_FLIGHT_STATE_GROUND
const UtmFlightState utmFlightStateGround = 2;

/// UAS airborne.
///
/// UTM_FLIGHT_STATE_AIRBORNE
const UtmFlightState utmFlightStateAirborne = 3;

/// UAS is in an emergency flight state.
///
/// UTM_FLIGHT_STATE_EMERGENCY
const UtmFlightState utmFlightStateEmergency = 16;

/// UAS has no active controls.
///
/// UTM_FLIGHT_STATE_NOCTRL
const UtmFlightState utmFlightStateNoctrl = 32;

/// Flags for the global position report.
///
/// UTM_DATA_AVAIL_FLAGS
typedef UtmDataAvailFlags = int;

/// The field time contains valid data.
///
/// UTM_DATA_AVAIL_FLAGS_TIME_VALID
const UtmDataAvailFlags utmDataAvailFlagsTimeValid = 1;

/// The field uas_id contains valid data.
///
/// UTM_DATA_AVAIL_FLAGS_UAS_ID_AVAILABLE
const UtmDataAvailFlags utmDataAvailFlagsUasIdAvailable = 2;

/// The fields lat, lon and h_acc contain valid data.
///
/// UTM_DATA_AVAIL_FLAGS_POSITION_AVAILABLE
const UtmDataAvailFlags utmDataAvailFlagsPositionAvailable = 4;

/// The fields alt and v_acc contain valid data.
///
/// UTM_DATA_AVAIL_FLAGS_ALTITUDE_AVAILABLE
const UtmDataAvailFlags utmDataAvailFlagsAltitudeAvailable = 8;

/// The field relative_alt contains valid data.
///
/// UTM_DATA_AVAIL_FLAGS_RELATIVE_ALTITUDE_AVAILABLE
const UtmDataAvailFlags utmDataAvailFlagsRelativeAltitudeAvailable = 16;

/// The fields vx and vy contain valid data.
///
/// UTM_DATA_AVAIL_FLAGS_HORIZONTAL_VELO_AVAILABLE
const UtmDataAvailFlags utmDataAvailFlagsHorizontalVeloAvailable = 32;

/// The field vz contains valid data.
///
/// UTM_DATA_AVAIL_FLAGS_VERTICAL_VELO_AVAILABLE
const UtmDataAvailFlags utmDataAvailFlagsVerticalVeloAvailable = 64;

/// The fields next_lat, next_lon and next_alt contain valid data.
///
/// UTM_DATA_AVAIL_FLAGS_NEXT_WAYPOINT_AVAILABLE
const UtmDataAvailFlags utmDataAvailFlagsNextWaypointAvailable = 128;

/// These flags encode the cellular network status
///
/// CELLULAR_STATUS_FLAG
typedef CellularStatusFlag = int;

/// State unknown or not reportable.
///
/// CELLULAR_STATUS_FLAG_UNKNOWN
const CellularStatusFlag cellularStatusFlagUnknown = 0;

/// Modem is unusable
///
/// CELLULAR_STATUS_FLAG_FAILED
const CellularStatusFlag cellularStatusFlagFailed = 1;

/// Modem is being initialized
///
/// CELLULAR_STATUS_FLAG_INITIALIZING
const CellularStatusFlag cellularStatusFlagInitializing = 2;

/// Modem is locked
///
/// CELLULAR_STATUS_FLAG_LOCKED
const CellularStatusFlag cellularStatusFlagLocked = 3;

/// Modem is not enabled and is powered down
///
/// CELLULAR_STATUS_FLAG_DISABLED
const CellularStatusFlag cellularStatusFlagDisabled = 4;

/// Modem is currently transitioning to the CELLULAR_STATUS_FLAG_DISABLED state
///
/// CELLULAR_STATUS_FLAG_DISABLING
const CellularStatusFlag cellularStatusFlagDisabling = 5;

/// Modem is currently transitioning to the CELLULAR_STATUS_FLAG_ENABLED state
///
/// CELLULAR_STATUS_FLAG_ENABLING
const CellularStatusFlag cellularStatusFlagEnabling = 6;

/// Modem is enabled and powered on but not registered with a network provider and not available for data connections
///
/// CELLULAR_STATUS_FLAG_ENABLED
const CellularStatusFlag cellularStatusFlagEnabled = 7;

/// Modem is searching for a network provider to register
///
/// CELLULAR_STATUS_FLAG_SEARCHING
const CellularStatusFlag cellularStatusFlagSearching = 8;

/// Modem is registered with a network provider, and data connections and messaging may be available for use
///
/// CELLULAR_STATUS_FLAG_REGISTERED
const CellularStatusFlag cellularStatusFlagRegistered = 9;

/// Modem is disconnecting and deactivating the last active packet data bearer. This state will not be entered if more than one packet data bearer is active and one of the active bearers is deactivated
///
/// CELLULAR_STATUS_FLAG_DISCONNECTING
const CellularStatusFlag cellularStatusFlagDisconnecting = 10;

/// Modem is activating and connecting the first packet data bearer. Subsequent bearer activations when another bearer is already active do not cause this state to be entered
///
/// CELLULAR_STATUS_FLAG_CONNECTING
const CellularStatusFlag cellularStatusFlagConnecting = 11;

/// One or more packet data bearers is active and connected
///
/// CELLULAR_STATUS_FLAG_CONNECTED
const CellularStatusFlag cellularStatusFlagConnected = 12;

/// These flags are used to diagnose the failure state of CELLULAR_STATUS
///
/// CELLULAR_NETWORK_FAILED_REASON
typedef CellularNetworkFailedReason = int;

/// No error
///
/// CELLULAR_NETWORK_FAILED_REASON_NONE
const CellularNetworkFailedReason cellularNetworkFailedReasonNone = 0;

/// Error state is unknown
///
/// CELLULAR_NETWORK_FAILED_REASON_UNKNOWN
const CellularNetworkFailedReason cellularNetworkFailedReasonUnknown = 1;

/// SIM is required for the modem but missing
///
/// CELLULAR_NETWORK_FAILED_REASON_SIM_MISSING
const CellularNetworkFailedReason cellularNetworkFailedReasonSimMissing = 2;

/// SIM is available, but not usable for connection
///
/// CELLULAR_NETWORK_FAILED_REASON_SIM_ERROR
const CellularNetworkFailedReason cellularNetworkFailedReasonSimError = 3;

/// Cellular network radio type
///
/// CELLULAR_NETWORK_RADIO_TYPE
typedef CellularNetworkRadioType = int;

///
/// CELLULAR_NETWORK_RADIO_TYPE_NONE
const CellularNetworkRadioType cellularNetworkRadioTypeNone = 0;

///
/// CELLULAR_NETWORK_RADIO_TYPE_GSM
const CellularNetworkRadioType cellularNetworkRadioTypeGsm = 1;

///
/// CELLULAR_NETWORK_RADIO_TYPE_CDMA
const CellularNetworkRadioType cellularNetworkRadioTypeCdma = 2;

///
/// CELLULAR_NETWORK_RADIO_TYPE_WCDMA
const CellularNetworkRadioType cellularNetworkRadioTypeWcdma = 3;

///
/// CELLULAR_NETWORK_RADIO_TYPE_LTE
const CellularNetworkRadioType cellularNetworkRadioTypeLte = 4;

/// Precision land modes (used in MAV_CMD_NAV_LAND).
///
/// PRECISION_LAND_MODE
typedef PrecisionLandMode = int;

/// Normal (non-precision) landing.
///
/// PRECISION_LAND_MODE_DISABLED
const PrecisionLandMode precisionLandModeDisabled = 0;

/// Use precision landing if beacon detected when land command accepted, otherwise land normally.
///
/// PRECISION_LAND_MODE_OPPORTUNISTIC
const PrecisionLandMode precisionLandModeOpportunistic = 1;

/// Use precision landing, searching for beacon if not found when land command accepted (land normally if beacon cannot be found).
///
/// PRECISION_LAND_MODE_REQUIRED
const PrecisionLandMode precisionLandModeRequired = 2;

/// Parachute actions. Trigger release and enable/disable auto-release.
///
/// PARACHUTE_ACTION
typedef ParachuteAction = int;

/// Disable auto-release of parachute (i.e. release triggered by crash detectors).
///
/// PARACHUTE_DISABLE
const ParachuteAction parachuteDisable = 0;

/// Enable auto-release of parachute.
///
/// PARACHUTE_ENABLE
const ParachuteAction parachuteEnable = 1;

/// Release parachute and kill motors.
///
/// PARACHUTE_RELEASE
const ParachuteAction parachuteRelease = 2;

///
/// MAV_TUNNEL_PAYLOAD_TYPE
typedef MavTunnelPayloadType = int;

/// Encoding of payload unknown.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_UNKNOWN
const MavTunnelPayloadType mavTunnelPayloadTypeUnknown = 0;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED0
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved0 = 200;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED1
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved1 = 201;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED2
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved2 = 202;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED3
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved3 = 203;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED4
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved4 = 204;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED5
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved5 = 205;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED6
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved6 = 206;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED7
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved7 = 207;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED8
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved8 = 208;

/// Registered for STorM32 gimbal controller.
///
/// MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED9
const MavTunnelPayloadType mavTunnelPayloadTypeStorm32Reserved9 = 209;

///
/// MAV_ODID_ID_TYPE
typedef MavOdidIdType = int;

/// No type defined.
///
/// MAV_ODID_ID_TYPE_NONE
const MavOdidIdType mavOdidIdTypeNone = 0;

/// Manufacturer Serial Number (ANSI/CTA-2063 format).
///
/// MAV_ODID_ID_TYPE_SERIAL_NUMBER
const MavOdidIdType mavOdidIdTypeSerialNumber = 1;

/// CAA (Civil Aviation Authority) registered ID. Format: [ICAO Country Code].[CAA Assigned ID].
///
/// MAV_ODID_ID_TYPE_CAA_REGISTRATION_ID
const MavOdidIdType mavOdidIdTypeCaaRegistrationId = 2;

/// UTM (Unmanned Traffic Management) assigned UUID (RFC4122).
///
/// MAV_ODID_ID_TYPE_UTM_ASSIGNED_UUID
const MavOdidIdType mavOdidIdTypeUtmAssignedUuid = 3;

/// A 20 byte ID for a specific flight/session. The exact ID type is indicated by the first byte of uas_id and these type values are managed by ICAO.
///
/// MAV_ODID_ID_TYPE_SPECIFIC_SESSION_ID
const MavOdidIdType mavOdidIdTypeSpecificSessionId = 4;

///
/// MAV_ODID_UA_TYPE
typedef MavOdidUaType = int;

/// No UA (Unmanned Aircraft) type defined.
///
/// MAV_ODID_UA_TYPE_NONE
const MavOdidUaType mavOdidUaTypeNone = 0;

/// Aeroplane/Airplane. Fixed wing.
///
/// MAV_ODID_UA_TYPE_AEROPLANE
const MavOdidUaType mavOdidUaTypeAeroplane = 1;

/// Helicopter or multirotor.
///
/// MAV_ODID_UA_TYPE_HELICOPTER_OR_MULTIROTOR
const MavOdidUaType mavOdidUaTypeHelicopterOrMultirotor = 2;

/// Gyroplane.
///
/// MAV_ODID_UA_TYPE_GYROPLANE
const MavOdidUaType mavOdidUaTypeGyroplane = 3;

/// VTOL (Vertical Take-Off and Landing). Fixed wing aircraft that can take off vertically.
///
/// MAV_ODID_UA_TYPE_HYBRID_LIFT
const MavOdidUaType mavOdidUaTypeHybridLift = 4;

/// Ornithopter.
///
/// MAV_ODID_UA_TYPE_ORNITHOPTER
const MavOdidUaType mavOdidUaTypeOrnithopter = 5;

/// Glider.
///
/// MAV_ODID_UA_TYPE_GLIDER
const MavOdidUaType mavOdidUaTypeGlider = 6;

/// Kite.
///
/// MAV_ODID_UA_TYPE_KITE
const MavOdidUaType mavOdidUaTypeKite = 7;

/// Free Balloon.
///
/// MAV_ODID_UA_TYPE_FREE_BALLOON
const MavOdidUaType mavOdidUaTypeFreeBalloon = 8;

/// Captive Balloon.
///
/// MAV_ODID_UA_TYPE_CAPTIVE_BALLOON
const MavOdidUaType mavOdidUaTypeCaptiveBalloon = 9;

/// Airship. E.g. a blimp.
///
/// MAV_ODID_UA_TYPE_AIRSHIP
const MavOdidUaType mavOdidUaTypeAirship = 10;

/// Free Fall/Parachute (unpowered).
///
/// MAV_ODID_UA_TYPE_FREE_FALL_PARACHUTE
const MavOdidUaType mavOdidUaTypeFreeFallParachute = 11;

/// Rocket.
///
/// MAV_ODID_UA_TYPE_ROCKET
const MavOdidUaType mavOdidUaTypeRocket = 12;

/// Tethered powered aircraft.
///
/// MAV_ODID_UA_TYPE_TETHERED_POWERED_AIRCRAFT
const MavOdidUaType mavOdidUaTypeTetheredPoweredAircraft = 13;

/// Ground Obstacle.
///
/// MAV_ODID_UA_TYPE_GROUND_OBSTACLE
const MavOdidUaType mavOdidUaTypeGroundObstacle = 14;

/// Other type of aircraft not listed earlier.
///
/// MAV_ODID_UA_TYPE_OTHER
const MavOdidUaType mavOdidUaTypeOther = 15;

///
/// MAV_ODID_STATUS
typedef MavOdidStatus = int;

/// The status of the (UA) Unmanned Aircraft is undefined.
///
/// MAV_ODID_STATUS_UNDECLARED
const MavOdidStatus mavOdidStatusUndeclared = 0;

/// The UA is on the ground.
///
/// MAV_ODID_STATUS_GROUND
const MavOdidStatus mavOdidStatusGround = 1;

/// The UA is in the air.
///
/// MAV_ODID_STATUS_AIRBORNE
const MavOdidStatus mavOdidStatusAirborne = 2;

/// The UA is having an emergency.
///
/// MAV_ODID_STATUS_EMERGENCY
const MavOdidStatus mavOdidStatusEmergency = 3;

/// The remote ID system is failing or unreliable in some way.
///
/// MAV_ODID_STATUS_REMOTE_ID_SYSTEM_FAILURE
const MavOdidStatus mavOdidStatusRemoteIdSystemFailure = 4;

///
/// MAV_ODID_HEIGHT_REF
typedef MavOdidHeightRef = int;

/// The height field is relative to the take-off location.
///
/// MAV_ODID_HEIGHT_REF_OVER_TAKEOFF
const MavOdidHeightRef mavOdidHeightRefOverTakeoff = 0;

/// The height field is relative to ground.
///
/// MAV_ODID_HEIGHT_REF_OVER_GROUND
const MavOdidHeightRef mavOdidHeightRefOverGround = 1;

///
/// MAV_ODID_HOR_ACC
typedef MavOdidHorAcc = int;

/// The horizontal accuracy is unknown.
///
/// MAV_ODID_HOR_ACC_UNKNOWN
const MavOdidHorAcc mavOdidHorAccUnknown = 0;

/// The horizontal accuracy is smaller than 10 Nautical Miles. 18.52 km.
///
/// MAV_ODID_HOR_ACC_10NM
const MavOdidHorAcc mavOdidHorAcc10nm = 1;

/// The horizontal accuracy is smaller than 4 Nautical Miles. 7.408 km.
///
/// MAV_ODID_HOR_ACC_4NM
const MavOdidHorAcc mavOdidHorAcc4nm = 2;

/// The horizontal accuracy is smaller than 2 Nautical Miles. 3.704 km.
///
/// MAV_ODID_HOR_ACC_2NM
const MavOdidHorAcc mavOdidHorAcc2nm = 3;

/// The horizontal accuracy is smaller than 1 Nautical Miles. 1.852 km.
///
/// MAV_ODID_HOR_ACC_1NM
const MavOdidHorAcc mavOdidHorAcc1nm = 4;

/// The horizontal accuracy is smaller than 0.5 Nautical Miles. 926 m.
///
/// MAV_ODID_HOR_ACC_0_5NM
const MavOdidHorAcc mavOdidHorAcc05nm = 5;

/// The horizontal accuracy is smaller than 0.3 Nautical Miles. 555.6 m.
///
/// MAV_ODID_HOR_ACC_0_3NM
const MavOdidHorAcc mavOdidHorAcc03nm = 6;

/// The horizontal accuracy is smaller than 0.1 Nautical Miles. 185.2 m.
///
/// MAV_ODID_HOR_ACC_0_1NM
const MavOdidHorAcc mavOdidHorAcc01nm = 7;

/// The horizontal accuracy is smaller than 0.05 Nautical Miles. 92.6 m.
///
/// MAV_ODID_HOR_ACC_0_05NM
const MavOdidHorAcc mavOdidHorAcc005nm = 8;

/// The horizontal accuracy is smaller than 30 meter.
///
/// MAV_ODID_HOR_ACC_30_METER
const MavOdidHorAcc mavOdidHorAcc30Meter = 9;

/// The horizontal accuracy is smaller than 10 meter.
///
/// MAV_ODID_HOR_ACC_10_METER
const MavOdidHorAcc mavOdidHorAcc10Meter = 10;

/// The horizontal accuracy is smaller than 3 meter.
///
/// MAV_ODID_HOR_ACC_3_METER
const MavOdidHorAcc mavOdidHorAcc3Meter = 11;

/// The horizontal accuracy is smaller than 1 meter.
///
/// MAV_ODID_HOR_ACC_1_METER
const MavOdidHorAcc mavOdidHorAcc1Meter = 12;

///
/// MAV_ODID_VER_ACC
typedef MavOdidVerAcc = int;

/// The vertical accuracy is unknown.
///
/// MAV_ODID_VER_ACC_UNKNOWN
const MavOdidVerAcc mavOdidVerAccUnknown = 0;

/// The vertical accuracy is smaller than 150 meter.
///
/// MAV_ODID_VER_ACC_150_METER
const MavOdidVerAcc mavOdidVerAcc150Meter = 1;

/// The vertical accuracy is smaller than 45 meter.
///
/// MAV_ODID_VER_ACC_45_METER
const MavOdidVerAcc mavOdidVerAcc45Meter = 2;

/// The vertical accuracy is smaller than 25 meter.
///
/// MAV_ODID_VER_ACC_25_METER
const MavOdidVerAcc mavOdidVerAcc25Meter = 3;

/// The vertical accuracy is smaller than 10 meter.
///
/// MAV_ODID_VER_ACC_10_METER
const MavOdidVerAcc mavOdidVerAcc10Meter = 4;

/// The vertical accuracy is smaller than 3 meter.
///
/// MAV_ODID_VER_ACC_3_METER
const MavOdidVerAcc mavOdidVerAcc3Meter = 5;

/// The vertical accuracy is smaller than 1 meter.
///
/// MAV_ODID_VER_ACC_1_METER
const MavOdidVerAcc mavOdidVerAcc1Meter = 6;

///
/// MAV_ODID_SPEED_ACC
typedef MavOdidSpeedAcc = int;

/// The speed accuracy is unknown.
///
/// MAV_ODID_SPEED_ACC_UNKNOWN
const MavOdidSpeedAcc mavOdidSpeedAccUnknown = 0;

/// The speed accuracy is smaller than 10 meters per second.
///
/// MAV_ODID_SPEED_ACC_10_METERS_PER_SECOND
const MavOdidSpeedAcc mavOdidSpeedAcc10MetersPerSecond = 1;

/// The speed accuracy is smaller than 3 meters per second.
///
/// MAV_ODID_SPEED_ACC_3_METERS_PER_SECOND
const MavOdidSpeedAcc mavOdidSpeedAcc3MetersPerSecond = 2;

/// The speed accuracy is smaller than 1 meters per second.
///
/// MAV_ODID_SPEED_ACC_1_METERS_PER_SECOND
const MavOdidSpeedAcc mavOdidSpeedAcc1MetersPerSecond = 3;

/// The speed accuracy is smaller than 0.3 meters per second.
///
/// MAV_ODID_SPEED_ACC_0_3_METERS_PER_SECOND
const MavOdidSpeedAcc mavOdidSpeedAcc03MetersPerSecond = 4;

///
/// MAV_ODID_TIME_ACC
typedef MavOdidTimeAcc = int;

/// The timestamp accuracy is unknown.
///
/// MAV_ODID_TIME_ACC_UNKNOWN
const MavOdidTimeAcc mavOdidTimeAccUnknown = 0;

/// The timestamp accuracy is smaller than or equal to 0.1 second.
///
/// MAV_ODID_TIME_ACC_0_1_SECOND
const MavOdidTimeAcc mavOdidTimeAcc01Second = 1;

/// The timestamp accuracy is smaller than or equal to 0.2 second.
///
/// MAV_ODID_TIME_ACC_0_2_SECOND
const MavOdidTimeAcc mavOdidTimeAcc02Second = 2;

/// The timestamp accuracy is smaller than or equal to 0.3 second.
///
/// MAV_ODID_TIME_ACC_0_3_SECOND
const MavOdidTimeAcc mavOdidTimeAcc03Second = 3;

/// The timestamp accuracy is smaller than or equal to 0.4 second.
///
/// MAV_ODID_TIME_ACC_0_4_SECOND
const MavOdidTimeAcc mavOdidTimeAcc04Second = 4;

/// The timestamp accuracy is smaller than or equal to 0.5 second.
///
/// MAV_ODID_TIME_ACC_0_5_SECOND
const MavOdidTimeAcc mavOdidTimeAcc05Second = 5;

/// The timestamp accuracy is smaller than or equal to 0.6 second.
///
/// MAV_ODID_TIME_ACC_0_6_SECOND
const MavOdidTimeAcc mavOdidTimeAcc06Second = 6;

/// The timestamp accuracy is smaller than or equal to 0.7 second.
///
/// MAV_ODID_TIME_ACC_0_7_SECOND
const MavOdidTimeAcc mavOdidTimeAcc07Second = 7;

/// The timestamp accuracy is smaller than or equal to 0.8 second.
///
/// MAV_ODID_TIME_ACC_0_8_SECOND
const MavOdidTimeAcc mavOdidTimeAcc08Second = 8;

/// The timestamp accuracy is smaller than or equal to 0.9 second.
///
/// MAV_ODID_TIME_ACC_0_9_SECOND
const MavOdidTimeAcc mavOdidTimeAcc09Second = 9;

/// The timestamp accuracy is smaller than or equal to 1.0 second.
///
/// MAV_ODID_TIME_ACC_1_0_SECOND
const MavOdidTimeAcc mavOdidTimeAcc10Second = 10;

/// The timestamp accuracy is smaller than or equal to 1.1 second.
///
/// MAV_ODID_TIME_ACC_1_1_SECOND
const MavOdidTimeAcc mavOdidTimeAcc11Second = 11;

/// The timestamp accuracy is smaller than or equal to 1.2 second.
///
/// MAV_ODID_TIME_ACC_1_2_SECOND
const MavOdidTimeAcc mavOdidTimeAcc12Second = 12;

/// The timestamp accuracy is smaller than or equal to 1.3 second.
///
/// MAV_ODID_TIME_ACC_1_3_SECOND
const MavOdidTimeAcc mavOdidTimeAcc13Second = 13;

/// The timestamp accuracy is smaller than or equal to 1.4 second.
///
/// MAV_ODID_TIME_ACC_1_4_SECOND
const MavOdidTimeAcc mavOdidTimeAcc14Second = 14;

/// The timestamp accuracy is smaller than or equal to 1.5 second.
///
/// MAV_ODID_TIME_ACC_1_5_SECOND
const MavOdidTimeAcc mavOdidTimeAcc15Second = 15;

///
/// MAV_ODID_AUTH_TYPE
typedef MavOdidAuthType = int;

/// No authentication type is specified.
///
/// MAV_ODID_AUTH_TYPE_NONE
const MavOdidAuthType mavOdidAuthTypeNone = 0;

/// Signature for the UAS (Unmanned Aircraft System) ID.
///
/// MAV_ODID_AUTH_TYPE_UAS_ID_SIGNATURE
const MavOdidAuthType mavOdidAuthTypeUasIdSignature = 1;

/// Signature for the Operator ID.
///
/// MAV_ODID_AUTH_TYPE_OPERATOR_ID_SIGNATURE
const MavOdidAuthType mavOdidAuthTypeOperatorIdSignature = 2;

/// Signature for the entire message set.
///
/// MAV_ODID_AUTH_TYPE_MESSAGE_SET_SIGNATURE
const MavOdidAuthType mavOdidAuthTypeMessageSetSignature = 3;

/// Authentication is provided by Network Remote ID.
///
/// MAV_ODID_AUTH_TYPE_NETWORK_REMOTE_ID
const MavOdidAuthType mavOdidAuthTypeNetworkRemoteId = 4;

/// The exact authentication type is indicated by the first byte of authentication_data and these type values are managed by ICAO.
///
/// MAV_ODID_AUTH_TYPE_SPECIFIC_AUTHENTICATION
const MavOdidAuthType mavOdidAuthTypeSpecificAuthentication = 5;

///
/// MAV_ODID_DESC_TYPE
typedef MavOdidDescType = int;

/// Optional free-form text description of the purpose of the flight.
///
/// MAV_ODID_DESC_TYPE_TEXT
const MavOdidDescType mavOdidDescTypeText = 0;

/// Optional additional clarification when status == MAV_ODID_STATUS_EMERGENCY.
///
/// MAV_ODID_DESC_TYPE_EMERGENCY
const MavOdidDescType mavOdidDescTypeEmergency = 1;

/// Optional additional clarification when status != MAV_ODID_STATUS_EMERGENCY.
///
/// MAV_ODID_DESC_TYPE_EXTENDED_STATUS
const MavOdidDescType mavOdidDescTypeExtendedStatus = 2;

///
/// MAV_ODID_OPERATOR_LOCATION_TYPE
typedef MavOdidOperatorLocationType = int;

/// The location/altitude of the operator is the same as the take-off location.
///
/// MAV_ODID_OPERATOR_LOCATION_TYPE_TAKEOFF
const MavOdidOperatorLocationType mavOdidOperatorLocationTypeTakeoff = 0;

/// The location/altitude of the operator is dynamic. E.g. based on live GNSS data.
///
/// MAV_ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS
const MavOdidOperatorLocationType mavOdidOperatorLocationTypeLiveGnss = 1;

/// The location/altitude of the operator are fixed values.
///
/// MAV_ODID_OPERATOR_LOCATION_TYPE_FIXED
const MavOdidOperatorLocationType mavOdidOperatorLocationTypeFixed = 2;

///
/// MAV_ODID_CLASSIFICATION_TYPE
typedef MavOdidClassificationType = int;

/// The classification type for the UA is undeclared.
///
/// MAV_ODID_CLASSIFICATION_TYPE_UNDECLARED
const MavOdidClassificationType mavOdidClassificationTypeUndeclared = 0;

/// The classification type for the UA follows EU (European Union) specifications.
///
/// MAV_ODID_CLASSIFICATION_TYPE_EU
const MavOdidClassificationType mavOdidClassificationTypeEu = 1;

///
/// MAV_ODID_CATEGORY_EU
typedef MavOdidCategoryEu = int;

/// The category for the UA, according to the EU specification, is undeclared.
///
/// MAV_ODID_CATEGORY_EU_UNDECLARED
const MavOdidCategoryEu mavOdidCategoryEuUndeclared = 0;

/// The category for the UA, according to the EU specification, is the Open category.
///
/// MAV_ODID_CATEGORY_EU_OPEN
const MavOdidCategoryEu mavOdidCategoryEuOpen = 1;

/// The category for the UA, according to the EU specification, is the Specific category.
///
/// MAV_ODID_CATEGORY_EU_SPECIFIC
const MavOdidCategoryEu mavOdidCategoryEuSpecific = 2;

/// The category for the UA, according to the EU specification, is the Certified category.
///
/// MAV_ODID_CATEGORY_EU_CERTIFIED
const MavOdidCategoryEu mavOdidCategoryEuCertified = 3;

///
/// MAV_ODID_CLASS_EU
typedef MavOdidClassEu = int;

/// The class for the UA, according to the EU specification, is undeclared.
///
/// MAV_ODID_CLASS_EU_UNDECLARED
const MavOdidClassEu mavOdidClassEuUndeclared = 0;

/// The class for the UA, according to the EU specification, is Class 0.
///
/// MAV_ODID_CLASS_EU_CLASS_0
const MavOdidClassEu mavOdidClassEuClass0 = 1;

/// The class for the UA, according to the EU specification, is Class 1.
///
/// MAV_ODID_CLASS_EU_CLASS_1
const MavOdidClassEu mavOdidClassEuClass1 = 2;

/// The class for the UA, according to the EU specification, is Class 2.
///
/// MAV_ODID_CLASS_EU_CLASS_2
const MavOdidClassEu mavOdidClassEuClass2 = 3;

/// The class for the UA, according to the EU specification, is Class 3.
///
/// MAV_ODID_CLASS_EU_CLASS_3
const MavOdidClassEu mavOdidClassEuClass3 = 4;

/// The class for the UA, according to the EU specification, is Class 4.
///
/// MAV_ODID_CLASS_EU_CLASS_4
const MavOdidClassEu mavOdidClassEuClass4 = 5;

/// The class for the UA, according to the EU specification, is Class 5.
///
/// MAV_ODID_CLASS_EU_CLASS_5
const MavOdidClassEu mavOdidClassEuClass5 = 6;

/// The class for the UA, according to the EU specification, is Class 6.
///
/// MAV_ODID_CLASS_EU_CLASS_6
const MavOdidClassEu mavOdidClassEuClass6 = 7;

///
/// MAV_ODID_OPERATOR_ID_TYPE
typedef MavOdidOperatorIdType = int;

/// CAA (Civil Aviation Authority) registered operator ID.
///
/// MAV_ODID_OPERATOR_ID_TYPE_CAA
const MavOdidOperatorIdType mavOdidOperatorIdTypeCaa = 0;

///
/// MAV_ODID_ARM_STATUS
typedef MavOdidArmStatus = int;

/// Passing arming checks.
///
/// MAV_ODID_ARM_STATUS_GOOD_TO_ARM
const MavOdidArmStatus mavOdidArmStatusGoodToArm = 0;

/// Generic arming failure, see error string for details.
///
/// MAV_ODID_ARM_STATUS_PRE_ARM_FAIL_GENERIC
const MavOdidArmStatus mavOdidArmStatusPreArmFailGeneric = 1;

/// Tune formats (used for vehicle buzzer/tone generation).
///
/// TUNE_FORMAT
typedef TuneFormat = int;

/// Format is QBasic 1.1 Play: https://www.qbasic.net/en/reference/qb11/Statement/PLAY-006.htm.
///
/// TUNE_FORMAT_QBASIC1_1
const TuneFormat tuneFormatQbasic11 = 1;

/// Format is Modern Music Markup Language (MML): https://en.wikipedia.org/wiki/Music_Macro_Language#Modern_MML.
///
/// TUNE_FORMAT_MML_MODERN
const TuneFormat tuneFormatMmlModern = 2;

/// Type of AIS vessel, enum duplicated from AIS standard, https://gpsd.gitlab.io/gpsd/AIVDM.html
///
/// AIS_TYPE
typedef AisType = int;

/// Not available (default).
///
/// AIS_TYPE_UNKNOWN
const AisType aisTypeUnknown = 0;

///
/// AIS_TYPE_RESERVED_1
const AisType aisTypeReserved1 = 1;

///
/// AIS_TYPE_RESERVED_2
const AisType aisTypeReserved2 = 2;

///
/// AIS_TYPE_RESERVED_3
const AisType aisTypeReserved3 = 3;

///
/// AIS_TYPE_RESERVED_4
const AisType aisTypeReserved4 = 4;

///
/// AIS_TYPE_RESERVED_5
const AisType aisTypeReserved5 = 5;

///
/// AIS_TYPE_RESERVED_6
const AisType aisTypeReserved6 = 6;

///
/// AIS_TYPE_RESERVED_7
const AisType aisTypeReserved7 = 7;

///
/// AIS_TYPE_RESERVED_8
const AisType aisTypeReserved8 = 8;

///
/// AIS_TYPE_RESERVED_9
const AisType aisTypeReserved9 = 9;

///
/// AIS_TYPE_RESERVED_10
const AisType aisTypeReserved10 = 10;

///
/// AIS_TYPE_RESERVED_11
const AisType aisTypeReserved11 = 11;

///
/// AIS_TYPE_RESERVED_12
const AisType aisTypeReserved12 = 12;

///
/// AIS_TYPE_RESERVED_13
const AisType aisTypeReserved13 = 13;

///
/// AIS_TYPE_RESERVED_14
const AisType aisTypeReserved14 = 14;

///
/// AIS_TYPE_RESERVED_15
const AisType aisTypeReserved15 = 15;

///
/// AIS_TYPE_RESERVED_16
const AisType aisTypeReserved16 = 16;

///
/// AIS_TYPE_RESERVED_17
const AisType aisTypeReserved17 = 17;

///
/// AIS_TYPE_RESERVED_18
const AisType aisTypeReserved18 = 18;

///
/// AIS_TYPE_RESERVED_19
const AisType aisTypeReserved19 = 19;

/// Wing In Ground effect.
///
/// AIS_TYPE_WIG
const AisType aisTypeWig = 20;

///
/// AIS_TYPE_WIG_HAZARDOUS_A
const AisType aisTypeWigHazardousA = 21;

///
/// AIS_TYPE_WIG_HAZARDOUS_B
const AisType aisTypeWigHazardousB = 22;

///
/// AIS_TYPE_WIG_HAZARDOUS_C
const AisType aisTypeWigHazardousC = 23;

///
/// AIS_TYPE_WIG_HAZARDOUS_D
const AisType aisTypeWigHazardousD = 24;

///
/// AIS_TYPE_WIG_RESERVED_1
const AisType aisTypeWigReserved1 = 25;

///
/// AIS_TYPE_WIG_RESERVED_2
const AisType aisTypeWigReserved2 = 26;

///
/// AIS_TYPE_WIG_RESERVED_3
const AisType aisTypeWigReserved3 = 27;

///
/// AIS_TYPE_WIG_RESERVED_4
const AisType aisTypeWigReserved4 = 28;

///
/// AIS_TYPE_WIG_RESERVED_5
const AisType aisTypeWigReserved5 = 29;

///
/// AIS_TYPE_FISHING
const AisType aisTypeFishing = 30;

///
/// AIS_TYPE_TOWING
const AisType aisTypeTowing = 31;

/// Towing: length exceeds 200m or breadth exceeds 25m.
///
/// AIS_TYPE_TOWING_LARGE
const AisType aisTypeTowingLarge = 32;

/// Dredging or other underwater ops.
///
/// AIS_TYPE_DREDGING
const AisType aisTypeDredging = 33;

///
/// AIS_TYPE_DIVING
const AisType aisTypeDiving = 34;

///
/// AIS_TYPE_MILITARY
const AisType aisTypeMilitary = 35;

///
/// AIS_TYPE_SAILING
const AisType aisTypeSailing = 36;

///
/// AIS_TYPE_PLEASURE
const AisType aisTypePleasure = 37;

///
/// AIS_TYPE_RESERVED_20
const AisType aisTypeReserved20 = 38;

///
/// AIS_TYPE_RESERVED_21
const AisType aisTypeReserved21 = 39;

/// High Speed Craft.
///
/// AIS_TYPE_HSC
const AisType aisTypeHsc = 40;

///
/// AIS_TYPE_HSC_HAZARDOUS_A
const AisType aisTypeHscHazardousA = 41;

///
/// AIS_TYPE_HSC_HAZARDOUS_B
const AisType aisTypeHscHazardousB = 42;

///
/// AIS_TYPE_HSC_HAZARDOUS_C
const AisType aisTypeHscHazardousC = 43;

///
/// AIS_TYPE_HSC_HAZARDOUS_D
const AisType aisTypeHscHazardousD = 44;

///
/// AIS_TYPE_HSC_RESERVED_1
const AisType aisTypeHscReserved1 = 45;

///
/// AIS_TYPE_HSC_RESERVED_2
const AisType aisTypeHscReserved2 = 46;

///
/// AIS_TYPE_HSC_RESERVED_3
const AisType aisTypeHscReserved3 = 47;

///
/// AIS_TYPE_HSC_RESERVED_4
const AisType aisTypeHscReserved4 = 48;

///
/// AIS_TYPE_HSC_UNKNOWN
const AisType aisTypeHscUnknown = 49;

///
/// AIS_TYPE_PILOT
const AisType aisTypePilot = 50;

/// Search And Rescue vessel.
///
/// AIS_TYPE_SAR
const AisType aisTypeSar = 51;

///
/// AIS_TYPE_TUG
const AisType aisTypeTug = 52;

///
/// AIS_TYPE_PORT_TENDER
const AisType aisTypePortTender = 53;

/// Anti-pollution equipment.
///
/// AIS_TYPE_ANTI_POLLUTION
const AisType aisTypeAntiPollution = 54;

///
/// AIS_TYPE_LAW_ENFORCEMENT
const AisType aisTypeLawEnforcement = 55;

///
/// AIS_TYPE_SPARE_LOCAL_1
const AisType aisTypeSpareLocal1 = 56;

///
/// AIS_TYPE_SPARE_LOCAL_2
const AisType aisTypeSpareLocal2 = 57;

///
/// AIS_TYPE_MEDICAL_TRANSPORT
const AisType aisTypeMedicalTransport = 58;

/// Noncombatant ship according to RR Resolution No. 18.
///
/// AIS_TYPE_NONECOMBATANT
const AisType aisTypeNonecombatant = 59;

///
/// AIS_TYPE_PASSENGER
const AisType aisTypePassenger = 60;

///
/// AIS_TYPE_PASSENGER_HAZARDOUS_A
const AisType aisTypePassengerHazardousA = 61;

///
/// AIS_TYPE_PASSENGER_HAZARDOUS_B
const AisType aisTypePassengerHazardousB = 62;

///
/// AIS_TYPE_PASSENGER_HAZARDOUS_C
const AisType aisTypePassengerHazardousC = 63;

///
/// AIS_TYPE_PASSENGER_HAZARDOUS_D
const AisType aisTypePassengerHazardousD = 64;

///
/// AIS_TYPE_PASSENGER_RESERVED_1
const AisType aisTypePassengerReserved1 = 65;

///
/// AIS_TYPE_PASSENGER_RESERVED_2
const AisType aisTypePassengerReserved2 = 66;

///
/// AIS_TYPE_PASSENGER_RESERVED_3
const AisType aisTypePassengerReserved3 = 67;

///
/// AIS_TYPE_PASSENGER_RESERVED_4
const AisType aisTypePassengerReserved4 = 68;

///
/// AIS_TYPE_PASSENGER_UNKNOWN
const AisType aisTypePassengerUnknown = 69;

///
/// AIS_TYPE_CARGO
const AisType aisTypeCargo = 70;

///
/// AIS_TYPE_CARGO_HAZARDOUS_A
const AisType aisTypeCargoHazardousA = 71;

///
/// AIS_TYPE_CARGO_HAZARDOUS_B
const AisType aisTypeCargoHazardousB = 72;

///
/// AIS_TYPE_CARGO_HAZARDOUS_C
const AisType aisTypeCargoHazardousC = 73;

///
/// AIS_TYPE_CARGO_HAZARDOUS_D
const AisType aisTypeCargoHazardousD = 74;

///
/// AIS_TYPE_CARGO_RESERVED_1
const AisType aisTypeCargoReserved1 = 75;

///
/// AIS_TYPE_CARGO_RESERVED_2
const AisType aisTypeCargoReserved2 = 76;

///
/// AIS_TYPE_CARGO_RESERVED_3
const AisType aisTypeCargoReserved3 = 77;

///
/// AIS_TYPE_CARGO_RESERVED_4
const AisType aisTypeCargoReserved4 = 78;

///
/// AIS_TYPE_CARGO_UNKNOWN
const AisType aisTypeCargoUnknown = 79;

///
/// AIS_TYPE_TANKER
const AisType aisTypeTanker = 80;

///
/// AIS_TYPE_TANKER_HAZARDOUS_A
const AisType aisTypeTankerHazardousA = 81;

///
/// AIS_TYPE_TANKER_HAZARDOUS_B
const AisType aisTypeTankerHazardousB = 82;

///
/// AIS_TYPE_TANKER_HAZARDOUS_C
const AisType aisTypeTankerHazardousC = 83;

///
/// AIS_TYPE_TANKER_HAZARDOUS_D
const AisType aisTypeTankerHazardousD = 84;

///
/// AIS_TYPE_TANKER_RESERVED_1
const AisType aisTypeTankerReserved1 = 85;

///
/// AIS_TYPE_TANKER_RESERVED_2
const AisType aisTypeTankerReserved2 = 86;

///
/// AIS_TYPE_TANKER_RESERVED_3
const AisType aisTypeTankerReserved3 = 87;

///
/// AIS_TYPE_TANKER_RESERVED_4
const AisType aisTypeTankerReserved4 = 88;

///
/// AIS_TYPE_TANKER_UNKNOWN
const AisType aisTypeTankerUnknown = 89;

///
/// AIS_TYPE_OTHER
const AisType aisTypeOther = 90;

///
/// AIS_TYPE_OTHER_HAZARDOUS_A
const AisType aisTypeOtherHazardousA = 91;

///
/// AIS_TYPE_OTHER_HAZARDOUS_B
const AisType aisTypeOtherHazardousB = 92;

///
/// AIS_TYPE_OTHER_HAZARDOUS_C
const AisType aisTypeOtherHazardousC = 93;

///
/// AIS_TYPE_OTHER_HAZARDOUS_D
const AisType aisTypeOtherHazardousD = 94;

///
/// AIS_TYPE_OTHER_RESERVED_1
const AisType aisTypeOtherReserved1 = 95;

///
/// AIS_TYPE_OTHER_RESERVED_2
const AisType aisTypeOtherReserved2 = 96;

///
/// AIS_TYPE_OTHER_RESERVED_3
const AisType aisTypeOtherReserved3 = 97;

///
/// AIS_TYPE_OTHER_RESERVED_4
const AisType aisTypeOtherReserved4 = 98;

///
/// AIS_TYPE_OTHER_UNKNOWN
const AisType aisTypeOtherUnknown = 99;

/// Navigational status of AIS vessel, enum duplicated from AIS standard, https://gpsd.gitlab.io/gpsd/AIVDM.html
///
/// AIS_NAV_STATUS
typedef AisNavStatus = int;

/// Under way using engine.
///
/// UNDER_WAY
const AisNavStatus underWay = 0;

///
/// AIS_NAV_ANCHORED
const AisNavStatus aisNavAnchored = 1;

///
/// AIS_NAV_UN_COMMANDED
const AisNavStatus aisNavUnCommanded = 2;

///
/// AIS_NAV_RESTRICTED_MANOEUVERABILITY
const AisNavStatus aisNavRestrictedManoeuverability = 3;

///
/// AIS_NAV_DRAUGHT_CONSTRAINED
const AisNavStatus aisNavDraughtConstrained = 4;

///
/// AIS_NAV_MOORED
const AisNavStatus aisNavMoored = 5;

///
/// AIS_NAV_AGROUND
const AisNavStatus aisNavAground = 6;

///
/// AIS_NAV_FISHING
const AisNavStatus aisNavFishing = 7;

///
/// AIS_NAV_SAILING
const AisNavStatus aisNavSailing = 8;

///
/// AIS_NAV_RESERVED_HSC
const AisNavStatus aisNavReservedHsc = 9;

///
/// AIS_NAV_RESERVED_WIG
const AisNavStatus aisNavReservedWig = 10;

///
/// AIS_NAV_RESERVED_1
const AisNavStatus aisNavReserved1 = 11;

///
/// AIS_NAV_RESERVED_2
const AisNavStatus aisNavReserved2 = 12;

///
/// AIS_NAV_RESERVED_3
const AisNavStatus aisNavReserved3 = 13;

/// Search And Rescue Transponder.
///
/// AIS_NAV_AIS_SART
const AisNavStatus aisNavAisSart = 14;

/// Not available (default).
///
/// AIS_NAV_UNKNOWN
const AisNavStatus aisNavUnknown = 15;

/// These flags are used in the AIS_VESSEL.fields bitmask to indicate validity of data in the other message fields. When set, the data is valid.
///
/// AIS_FLAGS
typedef AisFlags = int;

/// 1 = Position accuracy less than 10m, 0 = position accuracy greater than 10m.
///
/// AIS_FLAGS_POSITION_ACCURACY
const AisFlags aisFlagsPositionAccuracy = 1;

///
/// AIS_FLAGS_VALID_COG
const AisFlags aisFlagsValidCog = 2;

///
/// AIS_FLAGS_VALID_VELOCITY
const AisFlags aisFlagsValidVelocity = 4;

/// 1 = Velocity over 52.5765m/s (102.2 knots)
///
/// AIS_FLAGS_HIGH_VELOCITY
const AisFlags aisFlagsHighVelocity = 8;

///
/// AIS_FLAGS_VALID_TURN_RATE
const AisFlags aisFlagsValidTurnRate = 16;

/// Only the sign of the returned turn rate value is valid, either greater than 5deg/30s or less than -5deg/30s
///
/// AIS_FLAGS_TURN_RATE_SIGN_ONLY
const AisFlags aisFlagsTurnRateSignOnly = 32;

///
/// AIS_FLAGS_VALID_DIMENSIONS
const AisFlags aisFlagsValidDimensions = 64;

/// Distance to bow is larger than 511m
///
/// AIS_FLAGS_LARGE_BOW_DIMENSION
const AisFlags aisFlagsLargeBowDimension = 128;

/// Distance to stern is larger than 511m
///
/// AIS_FLAGS_LARGE_STERN_DIMENSION
const AisFlags aisFlagsLargeSternDimension = 256;

/// Distance to port side is larger than 63m
///
/// AIS_FLAGS_LARGE_PORT_DIMENSION
const AisFlags aisFlagsLargePortDimension = 512;

/// Distance to starboard side is larger than 63m
///
/// AIS_FLAGS_LARGE_STARBOARD_DIMENSION
const AisFlags aisFlagsLargeStarboardDimension = 1024;

///
/// AIS_FLAGS_VALID_CALLSIGN
const AisFlags aisFlagsValidCallsign = 2048;

///
/// AIS_FLAGS_VALID_NAME
const AisFlags aisFlagsValidName = 4096;

/// List of possible units where failures can be injected.
///
/// FAILURE_UNIT
typedef FailureUnit = int;

///
/// FAILURE_UNIT_SENSOR_GYRO
const FailureUnit failureUnitSensorGyro = 0;

///
/// FAILURE_UNIT_SENSOR_ACCEL
const FailureUnit failureUnitSensorAccel = 1;

///
/// FAILURE_UNIT_SENSOR_MAG
const FailureUnit failureUnitSensorMag = 2;

///
/// FAILURE_UNIT_SENSOR_BARO
const FailureUnit failureUnitSensorBaro = 3;

///
/// FAILURE_UNIT_SENSOR_GPS
const FailureUnit failureUnitSensorGps = 4;

///
/// FAILURE_UNIT_SENSOR_OPTICAL_FLOW
const FailureUnit failureUnitSensorOpticalFlow = 5;

///
/// FAILURE_UNIT_SENSOR_VIO
const FailureUnit failureUnitSensorVio = 6;

///
/// FAILURE_UNIT_SENSOR_DISTANCE_SENSOR
const FailureUnit failureUnitSensorDistanceSensor = 7;

///
/// FAILURE_UNIT_SENSOR_AIRSPEED
const FailureUnit failureUnitSensorAirspeed = 8;

///
/// FAILURE_UNIT_SYSTEM_BATTERY
const FailureUnit failureUnitSystemBattery = 100;

///
/// FAILURE_UNIT_SYSTEM_MOTOR
const FailureUnit failureUnitSystemMotor = 101;

///
/// FAILURE_UNIT_SYSTEM_SERVO
const FailureUnit failureUnitSystemServo = 102;

///
/// FAILURE_UNIT_SYSTEM_AVOIDANCE
const FailureUnit failureUnitSystemAvoidance = 103;

///
/// FAILURE_UNIT_SYSTEM_RC_SIGNAL
const FailureUnit failureUnitSystemRcSignal = 104;

///
/// FAILURE_UNIT_SYSTEM_MAVLINK_SIGNAL
const FailureUnit failureUnitSystemMavlinkSignal = 105;

/// List of possible failure type to inject.
///
/// FAILURE_TYPE
typedef FailureType = int;

/// No failure injected, used to reset a previous failure.
///
/// FAILURE_TYPE_OK
const FailureType failureTypeOk = 0;

/// Sets unit off, so completely non-responsive.
///
/// FAILURE_TYPE_OFF
const FailureType failureTypeOff = 1;

/// Unit is stuck e.g. keeps reporting the same value.
///
/// FAILURE_TYPE_STUCK
const FailureType failureTypeStuck = 2;

/// Unit is reporting complete garbage.
///
/// FAILURE_TYPE_GARBAGE
const FailureType failureTypeGarbage = 3;

/// Unit is consistently wrong.
///
/// FAILURE_TYPE_WRONG
const FailureType failureTypeWrong = 4;

/// Unit is slow, so e.g. reporting at slower than expected rate.
///
/// FAILURE_TYPE_SLOW
const FailureType failureTypeSlow = 5;

/// Data of unit is delayed in time.
///
/// FAILURE_TYPE_DELAYED
const FailureType failureTypeDelayed = 6;

/// Unit is sometimes working, sometimes not.
///
/// FAILURE_TYPE_INTERMITTENT
const FailureType failureTypeIntermittent = 7;

///
/// NAV_VTOL_LAND_OPTIONS
typedef NavVtolLandOptions = int;

/// Default autopilot landing behaviour.
///
/// NAV_VTOL_LAND_OPTIONS_DEFAULT
const NavVtolLandOptions navVtolLandOptionsDefault = 0;

/// Descend in fixed wing mode, transitioning to multicopter mode for vertical landing when close to the ground.
/// The fixed wing descent pattern is at the discretion of the vehicle (e.g. transition altitude, loiter direction, radius, and speed, etc.).
///
///
/// NAV_VTOL_LAND_OPTIONS_FW_DESCENT
const NavVtolLandOptions navVtolLandOptionsFwDescent = 1;

/// Land in multicopter mode on reaching the landing coordinates (the whole landing is by "hover descent").
///
/// NAV_VTOL_LAND_OPTIONS_HOVER_DESCENT
const NavVtolLandOptions navVtolLandOptionsHoverDescent = 2;

/// Winch status flags used in WINCH_STATUS
///
/// MAV_WINCH_STATUS_FLAG
typedef MavWinchStatusFlag = int;

/// Winch is healthy
///
/// MAV_WINCH_STATUS_HEALTHY
const MavWinchStatusFlag mavWinchStatusHealthy = 1;

/// Winch line is fully retracted
///
/// MAV_WINCH_STATUS_FULLY_RETRACTED
const MavWinchStatusFlag mavWinchStatusFullyRetracted = 2;

/// Winch motor is moving
///
/// MAV_WINCH_STATUS_MOVING
const MavWinchStatusFlag mavWinchStatusMoving = 4;

/// Winch clutch is engaged allowing motor to move freely.
///
/// MAV_WINCH_STATUS_CLUTCH_ENGAGED
const MavWinchStatusFlag mavWinchStatusClutchEngaged = 8;

/// Winch is locked by locking mechanism.
///
/// MAV_WINCH_STATUS_LOCKED
const MavWinchStatusFlag mavWinchStatusLocked = 16;

/// Winch is gravity dropping payload.
///
/// MAV_WINCH_STATUS_DROPPING
const MavWinchStatusFlag mavWinchStatusDropping = 32;

/// Winch is arresting payload descent.
///
/// MAV_WINCH_STATUS_ARRESTING
const MavWinchStatusFlag mavWinchStatusArresting = 64;

/// Winch is using torque measurements to sense the ground.
///
/// MAV_WINCH_STATUS_GROUND_SENSE
const MavWinchStatusFlag mavWinchStatusGroundSense = 128;

/// Winch is returning to the fully retracted position.
///
/// MAV_WINCH_STATUS_RETRACTING
const MavWinchStatusFlag mavWinchStatusRetracting = 256;

/// Winch is redelivering the payload. This is a failover state if the line tension goes above a threshold during RETRACTING.
///
/// MAV_WINCH_STATUS_REDELIVER
const MavWinchStatusFlag mavWinchStatusRedeliver = 512;

/// Winch is abandoning the line and possibly payload. Winch unspools the entire calculated line length. This is a failover state from REDELIVER if the number of attempts exceeds a threshold.
///
/// MAV_WINCH_STATUS_ABANDON_LINE
const MavWinchStatusFlag mavWinchStatusAbandonLine = 1024;

/// Winch is engaging the locking mechanism.
///
/// MAV_WINCH_STATUS_LOCKING
const MavWinchStatusFlag mavWinchStatusLocking = 2048;

/// Winch is spooling on line.
///
/// MAV_WINCH_STATUS_LOAD_LINE
const MavWinchStatusFlag mavWinchStatusLoadLine = 4096;

/// Winch is loading a payload.
///
/// MAV_WINCH_STATUS_LOAD_PAYLOAD
const MavWinchStatusFlag mavWinchStatusLoadPayload = 8192;

///
/// MAG_CAL_STATUS
typedef MagCalStatus = int;

///
/// MAG_CAL_NOT_STARTED
const MagCalStatus magCalNotStarted = 0;

///
/// MAG_CAL_WAITING_TO_START
const MagCalStatus magCalWaitingToStart = 1;

///
/// MAG_CAL_RUNNING_STEP_ONE
const MagCalStatus magCalRunningStepOne = 2;

///
/// MAG_CAL_RUNNING_STEP_TWO
const MagCalStatus magCalRunningStepTwo = 3;

///
/// MAG_CAL_SUCCESS
const MagCalStatus magCalSuccess = 4;

///
/// MAG_CAL_FAILED
const MagCalStatus magCalFailed = 5;

///
/// MAG_CAL_BAD_ORIENTATION
const MagCalStatus magCalBadOrientation = 6;

///
/// MAG_CAL_BAD_RADIUS
const MagCalStatus magCalBadRadius = 7;

/// Reason for an event error response.
///
/// MAV_EVENT_ERROR_REASON
typedef MavEventErrorReason = int;

/// The requested event is not available (anymore).
///
/// MAV_EVENT_ERROR_REASON_UNAVAILABLE
const MavEventErrorReason mavEventErrorReasonUnavailable = 0;

/// Flags for CURRENT_EVENT_SEQUENCE.
///
/// MAV_EVENT_CURRENT_SEQUENCE_FLAGS
typedef MavEventCurrentSequenceFlags = int;

/// A sequence reset has happened (e.g. vehicle reboot).
///
/// MAV_EVENT_CURRENT_SEQUENCE_FLAGS_RESET
const MavEventCurrentSequenceFlags mavEventCurrentSequenceFlagsReset = 1;

/// Flags in the HIL_SENSOR message indicate which fields have updated since the last message
///
/// HIL_SENSOR_UPDATED_FLAGS
typedef HilSensorUpdatedFlags = int;

/// None of the fields in HIL_SENSOR have been updated
///
/// HIL_SENSOR_UPDATED_NONE
const HilSensorUpdatedFlags hilSensorUpdatedNone = 0;

/// The value in the xacc field has been updated
///
/// HIL_SENSOR_UPDATED_XACC
const HilSensorUpdatedFlags hilSensorUpdatedXacc = 1;

/// The value in the yacc field has been updated
///
/// HIL_SENSOR_UPDATED_YACC
const HilSensorUpdatedFlags hilSensorUpdatedYacc = 2;

/// The value in the zacc field has been updated
///
/// HIL_SENSOR_UPDATED_ZACC
const HilSensorUpdatedFlags hilSensorUpdatedZacc = 4;

/// The value in the xgyro field has been updated
///
/// HIL_SENSOR_UPDATED_XGYRO
const HilSensorUpdatedFlags hilSensorUpdatedXgyro = 8;

/// The value in the ygyro field has been updated
///
/// HIL_SENSOR_UPDATED_YGYRO
const HilSensorUpdatedFlags hilSensorUpdatedYgyro = 16;

/// The value in the zgyro field has been updated
///
/// HIL_SENSOR_UPDATED_ZGYRO
const HilSensorUpdatedFlags hilSensorUpdatedZgyro = 32;

/// The value in the xmag field has been updated
///
/// HIL_SENSOR_UPDATED_XMAG
const HilSensorUpdatedFlags hilSensorUpdatedXmag = 64;

/// The value in the ymag field has been updated
///
/// HIL_SENSOR_UPDATED_YMAG
const HilSensorUpdatedFlags hilSensorUpdatedYmag = 128;

/// The value in the zmag field has been updated
///
/// HIL_SENSOR_UPDATED_ZMAG
const HilSensorUpdatedFlags hilSensorUpdatedZmag = 256;

/// The value in the abs_pressure field has been updated
///
/// HIL_SENSOR_UPDATED_ABS_PRESSURE
const HilSensorUpdatedFlags hilSensorUpdatedAbsPressure = 512;

/// The value in the diff_pressure field has been updated
///
/// HIL_SENSOR_UPDATED_DIFF_PRESSURE
const HilSensorUpdatedFlags hilSensorUpdatedDiffPressure = 1024;

/// The value in the pressure_alt field has been updated
///
/// HIL_SENSOR_UPDATED_PRESSURE_ALT
const HilSensorUpdatedFlags hilSensorUpdatedPressureAlt = 2048;

/// The value in the temperature field has been updated
///
/// HIL_SENSOR_UPDATED_TEMPERATURE
const HilSensorUpdatedFlags hilSensorUpdatedTemperature = 4096;

/// Full reset of attitude/position/velocities/etc was performed in sim (Bit 31).
///
/// HIL_SENSOR_UPDATED_RESET
const HilSensorUpdatedFlags hilSensorUpdatedReset = 2147483648;

/// Flags in the HIGHRES_IMU message indicate which fields have updated since the last message
///
/// HIGHRES_IMU_UPDATED_FLAGS
typedef HighresImuUpdatedFlags = int;

/// None of the fields in HIGHRES_IMU have been updated
///
/// HIGHRES_IMU_UPDATED_NONE
const HighresImuUpdatedFlags highresImuUpdatedNone = 0;

/// The value in the xacc field has been updated
///
/// HIGHRES_IMU_UPDATED_XACC
const HighresImuUpdatedFlags highresImuUpdatedXacc = 1;

/// The value in the yacc field has been updated
///
/// HIGHRES_IMU_UPDATED_YACC
const HighresImuUpdatedFlags highresImuUpdatedYacc = 2;

/// The value in the zacc field has been updated since
///
/// HIGHRES_IMU_UPDATED_ZACC
const HighresImuUpdatedFlags highresImuUpdatedZacc = 4;

/// The value in the xgyro field has been updated
///
/// HIGHRES_IMU_UPDATED_XGYRO
const HighresImuUpdatedFlags highresImuUpdatedXgyro = 8;

/// The value in the ygyro field has been updated
///
/// HIGHRES_IMU_UPDATED_YGYRO
const HighresImuUpdatedFlags highresImuUpdatedYgyro = 16;

/// The value in the zgyro field has been updated
///
/// HIGHRES_IMU_UPDATED_ZGYRO
const HighresImuUpdatedFlags highresImuUpdatedZgyro = 32;

/// The value in the xmag field has been updated
///
/// HIGHRES_IMU_UPDATED_XMAG
const HighresImuUpdatedFlags highresImuUpdatedXmag = 64;

/// The value in the ymag field has been updated
///
/// HIGHRES_IMU_UPDATED_YMAG
const HighresImuUpdatedFlags highresImuUpdatedYmag = 128;

/// The value in the zmag field has been updated
///
/// HIGHRES_IMU_UPDATED_ZMAG
const HighresImuUpdatedFlags highresImuUpdatedZmag = 256;

/// The value in the abs_pressure field has been updated
///
/// HIGHRES_IMU_UPDATED_ABS_PRESSURE
const HighresImuUpdatedFlags highresImuUpdatedAbsPressure = 512;

/// The value in the diff_pressure field has been updated
///
/// HIGHRES_IMU_UPDATED_DIFF_PRESSURE
const HighresImuUpdatedFlags highresImuUpdatedDiffPressure = 1024;

/// The value in the pressure_alt field has been updated
///
/// HIGHRES_IMU_UPDATED_PRESSURE_ALT
const HighresImuUpdatedFlags highresImuUpdatedPressureAlt = 2048;

/// The value in the temperature field has been updated
///
/// HIGHRES_IMU_UPDATED_TEMPERATURE
const HighresImuUpdatedFlags highresImuUpdatedTemperature = 4096;

/// All fields in HIGHRES_IMU have been updated.
///
/// HIGHRES_IMU_UPDATED_ALL
const HighresImuUpdatedFlags highresImuUpdatedAll = 65535;

///
/// CAN_FILTER_OP
typedef CanFilterOp = int;

///
/// CAN_FILTER_REPLACE
const CanFilterOp canFilterReplace = 0;

///
/// CAN_FILTER_ADD
const CanFilterOp canFilterAdd = 1;

///
/// CAN_FILTER_REMOVE
const CanFilterOp canFilterRemove = 2;

/// MAV FTP error codes (https://mavlink.io/en/services/ftp.html)
///
/// MAV_FTP_ERR
typedef MavFtpErr = int;

/// None: No error
///
/// MAV_FTP_ERR_NONE
const MavFtpErr mavFtpErrNone = 0;

/// Fail: Unknown failure
///
/// MAV_FTP_ERR_FAIL
const MavFtpErr mavFtpErrFail = 1;

/// FailErrno: Command failed, Err number sent back in PayloadHeader.data[1].
/// This is a file-system error number understood by the server operating system.
///
/// MAV_FTP_ERR_FAILERRNO
const MavFtpErr mavFtpErrFailerrno = 2;

/// InvalidDataSize: Payload size is invalid
///
/// MAV_FTP_ERR_INVALIDDATASIZE
const MavFtpErr mavFtpErrInvaliddatasize = 3;

/// InvalidSession: Session is not currently open
///
/// MAV_FTP_ERR_INVALIDSESSION
const MavFtpErr mavFtpErrInvalidsession = 4;

/// NoSessionsAvailable: All available sessions are already in use
///
/// MAV_FTP_ERR_NOSESSIONSAVAILABLE
const MavFtpErr mavFtpErrNosessionsavailable = 5;

/// EOF: Offset past end of file for ListDirectory and ReadFile commands
///
/// MAV_FTP_ERR_EOF
const MavFtpErr mavFtpErrEof = 6;

/// UnknownCommand: Unknown command / opcode
///
/// MAV_FTP_ERR_UNKNOWNCOMMAND
const MavFtpErr mavFtpErrUnknowncommand = 7;

/// FileExists: File/directory already exists
///
/// MAV_FTP_ERR_FILEEXISTS
const MavFtpErr mavFtpErrFileexists = 8;

/// FileProtected: File/directory is write protected
///
/// MAV_FTP_ERR_FILEPROTECTED
const MavFtpErr mavFtpErrFileprotected = 9;

/// FileNotFound: File/directory not found
///
/// MAV_FTP_ERR_FILENOTFOUND
const MavFtpErr mavFtpErrFilenotfound = 10;

/// MAV FTP opcodes: https://mavlink.io/en/services/ftp.html
///
/// MAV_FTP_OPCODE
typedef MavFtpOpcode = int;

/// None. Ignored, always ACKed
///
/// MAV_FTP_OPCODE_NONE
const MavFtpOpcode mavFtpOpcodeNone = 0;

/// TerminateSession: Terminates open Read session
///
/// MAV_FTP_OPCODE_TERMINATESESSION
const MavFtpOpcode mavFtpOpcodeTerminatesession = 1;

/// ResetSessions: Terminates all open read sessions
///
/// MAV_FTP_OPCODE_RESETSESSION
const MavFtpOpcode mavFtpOpcodeResetsession = 2;

/// ListDirectory. List files and directories in path from offset
///
/// MAV_FTP_OPCODE_LISTDIRECTORY
const MavFtpOpcode mavFtpOpcodeListdirectory = 3;

/// OpenFileRO: Opens file at path for reading, returns session
///
/// MAV_FTP_OPCODE_OPENFILERO
const MavFtpOpcode mavFtpOpcodeOpenfilero = 4;

/// ReadFile: Reads size bytes from offset in session
///
/// MAV_FTP_OPCODE_READFILE
const MavFtpOpcode mavFtpOpcodeReadfile = 5;

/// CreateFile: Creates file at path for writing, returns session
///
/// MAV_FTP_OPCODE_CREATEFILE
const MavFtpOpcode mavFtpOpcodeCreatefile = 6;

/// WriteFile: Writes size bytes to offset in session
///
/// MAV_FTP_OPCODE_WRITEFILE
const MavFtpOpcode mavFtpOpcodeWritefile = 7;

/// RemoveFile: Remove file at path
///
/// MAV_FTP_OPCODE_REMOVEFILE
const MavFtpOpcode mavFtpOpcodeRemovefile = 8;

/// CreateDirectory: Creates directory at path
///
/// MAV_FTP_OPCODE_CREATEDIRECTORY
const MavFtpOpcode mavFtpOpcodeCreatedirectory = 9;

/// RemoveDirectory: Removes directory at path. The directory must be empty.
///
/// MAV_FTP_OPCODE_REMOVEDIRECTORY
const MavFtpOpcode mavFtpOpcodeRemovedirectory = 10;

/// OpenFileWO: Opens file at path for writing, returns session
///
/// MAV_FTP_OPCODE_OPENFILEWO
const MavFtpOpcode mavFtpOpcodeOpenfilewo = 11;

/// TruncateFile: Truncate file at path to offset length
///
/// MAV_FTP_OPCODE_TRUNCATEFILE
const MavFtpOpcode mavFtpOpcodeTruncatefile = 12;

/// Rename: Rename path1 to path2
///
/// MAV_FTP_OPCODE_RENAME
const MavFtpOpcode mavFtpOpcodeRename = 13;

/// CalcFileCRC32: Calculate CRC32 for file at path
///
/// MAV_FTP_OPCODE_CALCFILECRC
const MavFtpOpcode mavFtpOpcodeCalcfilecrc = 14;

/// BurstReadFile: Burst download session file
///
/// MAV_FTP_OPCODE_BURSTREADFILE
const MavFtpOpcode mavFtpOpcodeBurstreadfile = 15;

/// ACK: ACK response
///
/// MAV_FTP_OPCODE_ACK
const MavFtpOpcode mavFtpOpcodeAck = 128;

/// NAK: NAK response
///
/// MAV_FTP_OPCODE_NAK
const MavFtpOpcode mavFtpOpcodeNak = 129;

///
/// States of the mission state machine.
/// Note that these states are independent of whether the mission is in a mode that can execute mission items or not (is suspended).
/// They may not all be relevant on all vehicles.
///
///
/// MISSION_STATE
typedef MissionState = int;

/// The mission status reporting is not supported.
///
/// MISSION_STATE_UNKNOWN
const MissionState missionStateUnknown = 0;

/// No mission on the vehicle.
///
/// MISSION_STATE_NO_MISSION
const MissionState missionStateNoMission = 1;

/// Mission has not started. This is the case after a mission has uploaded but not yet started executing.
///
/// MISSION_STATE_NOT_STARTED
const MissionState missionStateNotStarted = 2;

/// Mission is active, and will execute mission items when in auto mode.
///
/// MISSION_STATE_ACTIVE
const MissionState missionStateActive = 3;

/// Mission is paused when in auto mode.
///
/// MISSION_STATE_PAUSED
const MissionState missionStatePaused = 4;

/// Mission has executed all mission items.
///
/// MISSION_STATE_COMPLETE
const MissionState missionStateComplete = 5;

///
/// Possible safety switch states.
///
///
/// SAFETY_SWITCH_STATE
typedef SafetySwitchState = int;

/// Safety switch is engaged and vehicle should be safe to approach.
///
/// SAFETY_SWITCH_STATE_SAFE
const SafetySwitchState safetySwitchStateSafe = 0;

/// Safety switch is NOT engaged and motors, propellers and other actuators should be considered active.
///
/// SAFETY_SWITCH_STATE_DANGEROUS
const SafetySwitchState safetySwitchStateDangerous = 1;

/// Modes of illuminator
///
/// ILLUMINATOR_MODE
typedef IlluminatorMode = int;

/// Illuminator mode is not specified/unknown
///
/// ILLUMINATOR_MODE_UNKNOWN
const IlluminatorMode illuminatorModeUnknown = 0;

/// Illuminator behavior is controlled by MAV_CMD_DO_ILLUMINATOR_CONFIGURE settings
///
/// ILLUMINATOR_MODE_INTERNAL_CONTROL
const IlluminatorMode illuminatorModeInternalControl = 1;

/// Illuminator behavior is controlled by external factors: e.g. an external hardware signal
///
/// ILLUMINATOR_MODE_EXTERNAL_SYNC
const IlluminatorMode illuminatorModeExternalSync = 2;

/// Illuminator module error flags (bitmap, 0 means no error)
///
/// ILLUMINATOR_ERROR_FLAGS
typedef IlluminatorErrorFlags = int;

/// Illuminator thermal throttling error.
///
/// ILLUMINATOR_ERROR_FLAGS_THERMAL_THROTTLING
const IlluminatorErrorFlags illuminatorErrorFlagsThermalThrottling = 1;

/// Illuminator over temperature shutdown error.
///
/// ILLUMINATOR_ERROR_FLAGS_OVER_TEMPERATURE_SHUTDOWN
const IlluminatorErrorFlags illuminatorErrorFlagsOverTemperatureShutdown = 2;

/// Illuminator thermistor failure.
///
/// ILLUMINATOR_ERROR_FLAGS_THERMISTOR_FAILURE
const IlluminatorErrorFlags illuminatorErrorFlagsThermistorFailure = 4;

/// State flags for ADS-B transponder dynamic report
///
/// UAVIONIX_ADSB_OUT_DYNAMIC_STATE
typedef UavionixAdsbOutDynamicState = int;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE
const UavionixAdsbOutDynamicState uavionixAdsbOutDynamicStateIntentChange = 1;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED
const UavionixAdsbOutDynamicState uavionixAdsbOutDynamicStateAutopilotEnabled =
    2;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED
const UavionixAdsbOutDynamicState
    uavionixAdsbOutDynamicStateNicbaroCrosschecked = 4;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND
const UavionixAdsbOutDynamicState uavionixAdsbOutDynamicStateOnGround = 8;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT
const UavionixAdsbOutDynamicState uavionixAdsbOutDynamicStateIdent = 16;

/// Transceiver RF control flags for ADS-B transponder dynamic reports
///
/// UAVIONIX_ADSB_OUT_RF_SELECT
typedef UavionixAdsbOutRfSelect = int;

///
/// UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY
const UavionixAdsbOutRfSelect uavionixAdsbOutRfSelectStandby = 0;

///
/// UAVIONIX_ADSB_OUT_RF_SELECT_RX_ENABLED
const UavionixAdsbOutRfSelect uavionixAdsbOutRfSelectRxEnabled = 1;

///
/// UAVIONIX_ADSB_OUT_RF_SELECT_TX_ENABLED
const UavionixAdsbOutRfSelect uavionixAdsbOutRfSelectTxEnabled = 2;

/// Status for ADS-B transponder dynamic input
///
/// UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX
typedef UavionixAdsbOutDynamicGpsFix = int;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0
const UavionixAdsbOutDynamicGpsFix uavionixAdsbOutDynamicGpsFixNone0 = 0;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_1
const UavionixAdsbOutDynamicGpsFix uavionixAdsbOutDynamicGpsFixNone1 = 1;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_2D
const UavionixAdsbOutDynamicGpsFix uavionixAdsbOutDynamicGpsFix2d = 2;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_3D
const UavionixAdsbOutDynamicGpsFix uavionixAdsbOutDynamicGpsFix3d = 3;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_DGPS
const UavionixAdsbOutDynamicGpsFix uavionixAdsbOutDynamicGpsFixDgps = 4;

///
/// UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_RTK
const UavionixAdsbOutDynamicGpsFix uavionixAdsbOutDynamicGpsFixRtk = 5;

/// Status flags for ADS-B transponder dynamic output
///
/// UAVIONIX_ADSB_RF_HEALTH
typedef UavionixAdsbRfHealth = int;

///
/// UAVIONIX_ADSB_RF_HEALTH_INITIALIZING
const UavionixAdsbRfHealth uavionixAdsbRfHealthInitializing = 0;

///
/// UAVIONIX_ADSB_RF_HEALTH_OK
const UavionixAdsbRfHealth uavionixAdsbRfHealthOk = 1;

///
/// UAVIONIX_ADSB_RF_HEALTH_FAIL_TX
const UavionixAdsbRfHealth uavionixAdsbRfHealthFailTx = 2;

///
/// UAVIONIX_ADSB_RF_HEALTH_FAIL_RX
const UavionixAdsbRfHealth uavionixAdsbRfHealthFailRx = 16;

/// Definitions for aircraft size
///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE
typedef UavionixAdsbOutCfgAircraftSize = int;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeNoData = 0;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L15M_W23M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL15mW23m = 1;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25M_W28P5M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL25mW28p5m =
    2;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25_34M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL2534m = 3;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_33M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL3533m = 4;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_38M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL3538m = 5;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_39P5M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL4539p5m = 6;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_45M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL4545m = 7;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_45M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL5545m = 8;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_52M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL5552m = 9;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_59P5M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL6559p5m =
    10;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_67M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL6567m = 11;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W72P5M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL75W72p5m =
    12;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W80M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL75W80m = 13;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W80M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL85W80m = 14;

///
/// UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W90M
const UavionixAdsbOutCfgAircraftSize uavionixAdsbOutCfgAircraftSizeL85W90m = 15;

/// GPS lataral offset encoding
///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT
typedef UavionixAdsbOutCfgGpsOffsetLat = int;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_NO_DATA
const UavionixAdsbOutCfgGpsOffsetLat uavionixAdsbOutCfgGpsOffsetLatNoData = 0;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_2M
const UavionixAdsbOutCfgGpsOffsetLat uavionixAdsbOutCfgGpsOffsetLatLeft2m = 1;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_4M
const UavionixAdsbOutCfgGpsOffsetLat uavionixAdsbOutCfgGpsOffsetLatLeft4m = 2;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_6M
const UavionixAdsbOutCfgGpsOffsetLat uavionixAdsbOutCfgGpsOffsetLatLeft6m = 3;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_0M
const UavionixAdsbOutCfgGpsOffsetLat uavionixAdsbOutCfgGpsOffsetLatRight0m = 4;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_2M
const UavionixAdsbOutCfgGpsOffsetLat uavionixAdsbOutCfgGpsOffsetLatRight2m = 5;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_4M
const UavionixAdsbOutCfgGpsOffsetLat uavionixAdsbOutCfgGpsOffsetLatRight4m = 6;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_6M
const UavionixAdsbOutCfgGpsOffsetLat uavionixAdsbOutCfgGpsOffsetLatRight6m = 7;

/// GPS longitudinal offset encoding
///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON
typedef UavionixAdsbOutCfgGpsOffsetLon = int;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA
const UavionixAdsbOutCfgGpsOffsetLon uavionixAdsbOutCfgGpsOffsetLonNoData = 0;

///
/// UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_APPLIED_BY_SENSOR
const UavionixAdsbOutCfgGpsOffsetLon
    uavionixAdsbOutCfgGpsOffsetLonAppliedBySensor = 1;

/// Emergency status encoding
///
/// UAVIONIX_ADSB_EMERGENCY_STATUS
typedef UavionixAdsbEmergencyStatus = int;

///
/// UAVIONIX_ADSB_OUT_NO_EMERGENCY
const UavionixAdsbEmergencyStatus uavionixAdsbOutNoEmergency = 0;

///
/// UAVIONIX_ADSB_OUT_GENERAL_EMERGENCY
const UavionixAdsbEmergencyStatus uavionixAdsbOutGeneralEmergency = 1;

///
/// UAVIONIX_ADSB_OUT_LIFEGUARD_EMERGENCY
const UavionixAdsbEmergencyStatus uavionixAdsbOutLifeguardEmergency = 2;

///
/// UAVIONIX_ADSB_OUT_MINIMUM_FUEL_EMERGENCY
const UavionixAdsbEmergencyStatus uavionixAdsbOutMinimumFuelEmergency = 3;

///
/// UAVIONIX_ADSB_OUT_NO_COMM_EMERGENCY
const UavionixAdsbEmergencyStatus uavionixAdsbOutNoCommEmergency = 4;

///
/// UAVIONIX_ADSB_OUT_UNLAWFUL_INTERFERANCE_EMERGENCY
const UavionixAdsbEmergencyStatus uavionixAdsbOutUnlawfulInterferanceEmergency =
    5;

///
/// UAVIONIX_ADSB_OUT_DOWNED_AIRCRAFT_EMERGENCY
const UavionixAdsbEmergencyStatus uavionixAdsbOutDownedAircraftEmergency = 6;

///
/// UAVIONIX_ADSB_OUT_RESERVED
const UavionixAdsbEmergencyStatus uavionixAdsbOutReserved = 7;

///
/// ICAROUS_TRACK_BAND_TYPES
typedef IcarousTrackBandTypes = int;

///
/// ICAROUS_TRACK_BAND_TYPE_NONE
const IcarousTrackBandTypes icarousTrackBandTypeNone = 0;

///
/// ICAROUS_TRACK_BAND_TYPE_NEAR
const IcarousTrackBandTypes icarousTrackBandTypeNear = 1;

///
/// ICAROUS_TRACK_BAND_TYPE_RECOVERY
const IcarousTrackBandTypes icarousTrackBandTypeRecovery = 2;

///
/// ICAROUS_FMS_STATE
typedef IcarousFmsState = int;

///
/// ICAROUS_FMS_STATE_IDLE
const IcarousFmsState icarousFmsStateIdle = 0;

///
/// ICAROUS_FMS_STATE_TAKEOFF
const IcarousFmsState icarousFmsStateTakeoff = 1;

///
/// ICAROUS_FMS_STATE_CLIMB
const IcarousFmsState icarousFmsStateClimb = 2;

///
/// ICAROUS_FMS_STATE_CRUISE
const IcarousFmsState icarousFmsStateCruise = 3;

///
/// ICAROUS_FMS_STATE_APPROACH
const IcarousFmsState icarousFmsStateApproach = 4;

///
/// ICAROUS_FMS_STATE_LAND
const IcarousFmsState icarousFmsStateLand = 5;

///
/// AIRLINK_AUTH_RESPONSE_TYPE
typedef AirlinkAuthResponseType = int;

/// Login or password error
///
/// AIRLINK_ERROR_LOGIN_OR_PASS
const AirlinkAuthResponseType airlinkErrorLoginOrPass = 0;

/// Auth successful
///
/// AIRLINK_AUTH_OK
const AirlinkAuthResponseType airlinkAuthOk = 1;

///
/// AIRLINK_EYE_GS_HOLE_PUSH_RESP_TYPE
typedef AirlinkEyeGsHolePushRespType = int;

///
/// AIRLINK_HPR_PARTNER_NOT_READY
const AirlinkEyeGsHolePushRespType airlinkHprPartnerNotReady = 0;

///
/// AIRLINK_HPR_PARTNER_READY
const AirlinkEyeGsHolePushRespType airlinkHprPartnerReady = 1;

///
/// AIRLINK_EYE_IP_VERSION
typedef AirlinkEyeIpVersion = int;

///
/// AIRLINK_IP_V4
const AirlinkEyeIpVersion airlinkIpV4 = 0;

///
/// AIRLINK_IP_V6
const AirlinkEyeIpVersion airlinkIpV6 = 1;

///
/// AIRLINK_EYE_HOLE_PUSH_TYPE
typedef AirlinkEyeHolePushType = int;

///
/// AIRLINK_HP_NOT_PENETRATED
const AirlinkEyeHolePushType airlinkHpNotPenetrated = 0;

///
/// AIRLINK_HP_BROKEN
const AirlinkEyeHolePushType airlinkHpBroken = 1;

///
/// AIRLINK_EYE_TURN_INIT_TYPE
typedef AirlinkEyeTurnInitType = int;

///
/// AIRLINK_TURN_INIT_START
const AirlinkEyeTurnInitType airlinkTurnInitStart = 0;

///
/// AIRLINK_TURN_INIT_OK
const AirlinkEyeTurnInitType airlinkTurnInitOk = 1;

///
/// AIRLINK_TURN_INIT_BAD
const AirlinkEyeTurnInitType airlinkTurnInitBad = 2;

///
/// ACCELCAL_VEHICLE_POS
typedef AccelcalVehiclePos = int;

///
/// ACCELCAL_VEHICLE_POS_LEVEL
const AccelcalVehiclePos accelcalVehiclePosLevel = 1;

///
/// ACCELCAL_VEHICLE_POS_LEFT
const AccelcalVehiclePos accelcalVehiclePosLeft = 2;

///
/// ACCELCAL_VEHICLE_POS_RIGHT
const AccelcalVehiclePos accelcalVehiclePosRight = 3;

///
/// ACCELCAL_VEHICLE_POS_NOSEDOWN
const AccelcalVehiclePos accelcalVehiclePosNosedown = 4;

///
/// ACCELCAL_VEHICLE_POS_NOSEUP
const AccelcalVehiclePos accelcalVehiclePosNoseup = 5;

///
/// ACCELCAL_VEHICLE_POS_BACK
const AccelcalVehiclePos accelcalVehiclePosBack = 6;

///
/// ACCELCAL_VEHICLE_POS_SUCCESS
const AccelcalVehiclePos accelcalVehiclePosSuccess = 16777215;

///
/// ACCELCAL_VEHICLE_POS_FAILED
const AccelcalVehiclePos accelcalVehiclePosFailed = 16777216;

///
/// HEADING_TYPE
typedef HeadingType = int;

///
/// HEADING_TYPE_COURSE_OVER_GROUND
const HeadingType headingTypeCourseOverGround = 0;

///
/// HEADING_TYPE_HEADING
const HeadingType headingTypeHeading = 1;

///
/// SCRIPTING_CMD
typedef ScriptingCmd = int;

/// Start a REPL session.
///
/// SCRIPTING_CMD_REPL_START
const ScriptingCmd scriptingCmdReplStart = 0;

/// End a REPL session.
///
/// SCRIPTING_CMD_REPL_STOP
const ScriptingCmd scriptingCmdReplStop = 1;

/// Stop execution of scripts.
///
/// SCRIPTING_CMD_STOP
const ScriptingCmd scriptingCmdStop = 2;

/// Stop execution of scripts and restart.
///
/// SCRIPTING_CMD_STOP_AND_RESTART
const ScriptingCmd scriptingCmdStopAndRestart = 3;

///
/// LIMITS_STATE
typedef LimitsState = int;

/// Pre-initialization.
///
/// LIMITS_INIT
const LimitsState limitsInit = 0;

/// Disabled.
///
/// LIMITS_DISABLED
const LimitsState limitsDisabled = 1;

/// Checking limits.
///
/// LIMITS_ENABLED
const LimitsState limitsEnabled = 2;

/// A limit has been breached.
///
/// LIMITS_TRIGGERED
const LimitsState limitsTriggered = 3;

/// Taking action e.g. Return/RTL.
///
/// LIMITS_RECOVERING
const LimitsState limitsRecovering = 4;

/// We're no longer in breach of a limit.
///
/// LIMITS_RECOVERED
const LimitsState limitsRecovered = 5;

///
/// LIMIT_MODULE
typedef LimitModule = int;

/// Pre-initialization.
///
/// LIMIT_GPSLOCK
const LimitModule limitGpslock = 1;

/// Disabled.
///
/// LIMIT_GEOFENCE
const LimitModule limitGeofence = 2;

/// Checking limits.
///
/// LIMIT_ALTITUDE
const LimitModule limitAltitude = 4;

/// Flags in RALLY_POINT message.
///
/// RALLY_FLAGS
typedef RallyFlags = int;

/// Flag set when requiring favorable winds for landing.
///
/// FAVORABLE_WIND
const RallyFlags favorableWind = 1;

/// Flag set when plane is to immediately descend to break altitude and land without GCS intervention. Flag not set when plane is to loiter at Rally point until commanded to land.
///
/// LAND_IMMEDIATELY
const RallyFlags landImmediately = 2;

///
/// CAMERA_STATUS_TYPES
typedef CameraStatusTypes = int;

/// Camera heartbeat, announce camera component ID at 1Hz.
///
/// CAMERA_STATUS_TYPE_HEARTBEAT
const CameraStatusTypes cameraStatusTypeHeartbeat = 0;

/// Camera image triggered.
///
/// CAMERA_STATUS_TYPE_TRIGGER
const CameraStatusTypes cameraStatusTypeTrigger = 1;

/// Camera connection lost.
///
/// CAMERA_STATUS_TYPE_DISCONNECT
const CameraStatusTypes cameraStatusTypeDisconnect = 2;

/// Camera unknown error.
///
/// CAMERA_STATUS_TYPE_ERROR
const CameraStatusTypes cameraStatusTypeError = 3;

/// Camera battery low. Parameter p1 shows reported voltage.
///
/// CAMERA_STATUS_TYPE_LOWBATT
const CameraStatusTypes cameraStatusTypeLowbatt = 4;

/// Camera storage low. Parameter p1 shows reported shots remaining.
///
/// CAMERA_STATUS_TYPE_LOWSTORE
const CameraStatusTypes cameraStatusTypeLowstore = 5;

/// Camera storage low. Parameter p1 shows reported video minutes remaining.
///
/// CAMERA_STATUS_TYPE_LOWSTOREV
const CameraStatusTypes cameraStatusTypeLowstorev = 6;

///
/// CAMERA_FEEDBACK_FLAGS
typedef CameraFeedbackFlags = int;

/// Shooting photos, not video.
///
/// CAMERA_FEEDBACK_PHOTO
const CameraFeedbackFlags cameraFeedbackPhoto = 0;

/// Shooting video, not stills.
///
/// CAMERA_FEEDBACK_VIDEO
const CameraFeedbackFlags cameraFeedbackVideo = 1;

/// Unable to achieve requested exposure (e.g. shutter speed too low).
///
/// CAMERA_FEEDBACK_BADEXPOSURE
const CameraFeedbackFlags cameraFeedbackBadexposure = 2;

/// Closed loop feedback from camera, we know for sure it has successfully taken a picture.
///
/// CAMERA_FEEDBACK_CLOSEDLOOP
const CameraFeedbackFlags cameraFeedbackClosedloop = 3;

/// Open loop camera, an image trigger has been requested but we can't know for sure it has successfully taken a picture.
///
/// CAMERA_FEEDBACK_OPENLOOP
const CameraFeedbackFlags cameraFeedbackOpenloop = 4;

///
/// MAV_MODE_GIMBAL
typedef MavModeGimbal = int;

/// Gimbal is powered on but has not started initializing yet.
///
/// MAV_MODE_GIMBAL_UNINITIALIZED
const MavModeGimbal mavModeGimbalUninitialized = 0;

/// Gimbal is currently running calibration on the pitch axis.
///
/// MAV_MODE_GIMBAL_CALIBRATING_PITCH
const MavModeGimbal mavModeGimbalCalibratingPitch = 1;

/// Gimbal is currently running calibration on the roll axis.
///
/// MAV_MODE_GIMBAL_CALIBRATING_ROLL
const MavModeGimbal mavModeGimbalCalibratingRoll = 2;

/// Gimbal is currently running calibration on the yaw axis.
///
/// MAV_MODE_GIMBAL_CALIBRATING_YAW
const MavModeGimbal mavModeGimbalCalibratingYaw = 3;

/// Gimbal has finished calibrating and initializing, but is relaxed pending reception of first rate command from copter.
///
/// MAV_MODE_GIMBAL_INITIALIZED
const MavModeGimbal mavModeGimbalInitialized = 4;

/// Gimbal is actively stabilizing.
///
/// MAV_MODE_GIMBAL_ACTIVE
const MavModeGimbal mavModeGimbalActive = 5;

/// Gimbal is relaxed because it missed more than 10 expected rate command messages in a row. Gimbal will move back to active mode when it receives a new rate command.
///
/// MAV_MODE_GIMBAL_RATE_CMD_TIMEOUT
const MavModeGimbal mavModeGimbalRateCmdTimeout = 6;

///
/// GIMBAL_AXIS
typedef GimbalAxis = int;

/// Gimbal yaw axis.
///
/// GIMBAL_AXIS_YAW
const GimbalAxis gimbalAxisYaw = 0;

/// Gimbal pitch axis.
///
/// GIMBAL_AXIS_PITCH
const GimbalAxis gimbalAxisPitch = 1;

/// Gimbal roll axis.
///
/// GIMBAL_AXIS_ROLL
const GimbalAxis gimbalAxisRoll = 2;

///
/// GIMBAL_AXIS_CALIBRATION_STATUS
typedef GimbalAxisCalibrationStatus = int;

/// Axis calibration is in progress.
///
/// GIMBAL_AXIS_CALIBRATION_STATUS_IN_PROGRESS
const GimbalAxisCalibrationStatus gimbalAxisCalibrationStatusInProgress = 0;

/// Axis calibration succeeded.
///
/// GIMBAL_AXIS_CALIBRATION_STATUS_SUCCEEDED
const GimbalAxisCalibrationStatus gimbalAxisCalibrationStatusSucceeded = 1;

/// Axis calibration failed.
///
/// GIMBAL_AXIS_CALIBRATION_STATUS_FAILED
const GimbalAxisCalibrationStatus gimbalAxisCalibrationStatusFailed = 2;

///
/// GIMBAL_AXIS_CALIBRATION_REQUIRED
typedef GimbalAxisCalibrationRequired = int;

/// Whether or not this axis requires calibration is unknown at this time.
///
/// GIMBAL_AXIS_CALIBRATION_REQUIRED_UNKNOWN
const GimbalAxisCalibrationRequired gimbalAxisCalibrationRequiredUnknown = 0;

/// This axis requires calibration.
///
/// GIMBAL_AXIS_CALIBRATION_REQUIRED_TRUE
const GimbalAxisCalibrationRequired gimbalAxisCalibrationRequiredTrue = 1;

/// This axis does not require calibration.
///
/// GIMBAL_AXIS_CALIBRATION_REQUIRED_FALSE
const GimbalAxisCalibrationRequired gimbalAxisCalibrationRequiredFalse = 2;

///
/// GOPRO_HEARTBEAT_STATUS
typedef GoproHeartbeatStatus = int;

/// No GoPro connected.
///
/// GOPRO_HEARTBEAT_STATUS_DISCONNECTED
const GoproHeartbeatStatus goproHeartbeatStatusDisconnected = 0;

/// The detected GoPro is not HeroBus compatible.
///
/// GOPRO_HEARTBEAT_STATUS_INCOMPATIBLE
const GoproHeartbeatStatus goproHeartbeatStatusIncompatible = 1;

/// A HeroBus compatible GoPro is connected.
///
/// GOPRO_HEARTBEAT_STATUS_CONNECTED
const GoproHeartbeatStatus goproHeartbeatStatusConnected = 2;

/// An unrecoverable error was encountered with the connected GoPro, it may require a power cycle.
///
/// GOPRO_HEARTBEAT_STATUS_ERROR
const GoproHeartbeatStatus goproHeartbeatStatusError = 3;

///
/// GOPRO_HEARTBEAT_FLAGS
typedef GoproHeartbeatFlags = int;

/// GoPro is currently recording.
///
/// GOPRO_FLAG_RECORDING
const GoproHeartbeatFlags goproFlagRecording = 1;

///
/// GOPRO_REQUEST_STATUS
typedef GoproRequestStatus = int;

/// The write message with ID indicated succeeded.
///
/// GOPRO_REQUEST_SUCCESS
const GoproRequestStatus goproRequestSuccess = 0;

/// The write message with ID indicated failed.
///
/// GOPRO_REQUEST_FAILED
const GoproRequestStatus goproRequestFailed = 1;

///
/// GOPRO_COMMAND
typedef GoproCommand = int;

/// (Get/Set).
///
/// GOPRO_COMMAND_POWER
const GoproCommand goproCommandPower = 0;

/// (Get/Set).
///
/// GOPRO_COMMAND_CAPTURE_MODE
const GoproCommand goproCommandCaptureMode = 1;

/// (___/Set).
///
/// GOPRO_COMMAND_SHUTTER
const GoproCommand goproCommandShutter = 2;

/// (Get/___).
///
/// GOPRO_COMMAND_BATTERY
const GoproCommand goproCommandBattery = 3;

/// (Get/___).
///
/// GOPRO_COMMAND_MODEL
const GoproCommand goproCommandModel = 4;

/// (Get/Set).
///
/// GOPRO_COMMAND_VIDEO_SETTINGS
const GoproCommand goproCommandVideoSettings = 5;

/// (Get/Set).
///
/// GOPRO_COMMAND_LOW_LIGHT
const GoproCommand goproCommandLowLight = 6;

/// (Get/Set).
///
/// GOPRO_COMMAND_PHOTO_RESOLUTION
const GoproCommand goproCommandPhotoResolution = 7;

/// (Get/Set).
///
/// GOPRO_COMMAND_PHOTO_BURST_RATE
const GoproCommand goproCommandPhotoBurstRate = 8;

/// (Get/Set).
///
/// GOPRO_COMMAND_PROTUNE
const GoproCommand goproCommandProtune = 9;

/// (Get/Set) Hero 3+ Only.
///
/// GOPRO_COMMAND_PROTUNE_WHITE_BALANCE
const GoproCommand goproCommandProtuneWhiteBalance = 10;

/// (Get/Set) Hero 3+ Only.
///
/// GOPRO_COMMAND_PROTUNE_COLOUR
const GoproCommand goproCommandProtuneColour = 11;

/// (Get/Set) Hero 3+ Only.
///
/// GOPRO_COMMAND_PROTUNE_GAIN
const GoproCommand goproCommandProtuneGain = 12;

/// (Get/Set) Hero 3+ Only.
///
/// GOPRO_COMMAND_PROTUNE_SHARPNESS
const GoproCommand goproCommandProtuneSharpness = 13;

/// (Get/Set) Hero 3+ Only.
///
/// GOPRO_COMMAND_PROTUNE_EXPOSURE
const GoproCommand goproCommandProtuneExposure = 14;

/// (Get/Set).
///
/// GOPRO_COMMAND_TIME
const GoproCommand goproCommandTime = 15;

/// (Get/Set).
///
/// GOPRO_COMMAND_CHARGING
const GoproCommand goproCommandCharging = 16;

///
/// GOPRO_CAPTURE_MODE
typedef GoproCaptureMode = int;

/// Video mode.
///
/// GOPRO_CAPTURE_MODE_VIDEO
const GoproCaptureMode goproCaptureModeVideo = 0;

/// Photo mode.
///
/// GOPRO_CAPTURE_MODE_PHOTO
const GoproCaptureMode goproCaptureModePhoto = 1;

/// Burst mode, Hero 3+ only.
///
/// GOPRO_CAPTURE_MODE_BURST
const GoproCaptureMode goproCaptureModeBurst = 2;

/// Time lapse mode, Hero 3+ only.
///
/// GOPRO_CAPTURE_MODE_TIME_LAPSE
const GoproCaptureMode goproCaptureModeTimeLapse = 3;

/// Multi shot mode, Hero 4 only.
///
/// GOPRO_CAPTURE_MODE_MULTI_SHOT
const GoproCaptureMode goproCaptureModeMultiShot = 4;

/// Playback mode, Hero 4 only, silver only except when LCD or HDMI is connected to black.
///
/// GOPRO_CAPTURE_MODE_PLAYBACK
const GoproCaptureMode goproCaptureModePlayback = 5;

/// Playback mode, Hero 4 only.
///
/// GOPRO_CAPTURE_MODE_SETUP
const GoproCaptureMode goproCaptureModeSetup = 6;

/// Mode not yet known.
///
/// GOPRO_CAPTURE_MODE_UNKNOWN
const GoproCaptureMode goproCaptureModeUnknown = 255;

///
/// GOPRO_RESOLUTION
typedef GoproResolution = int;

/// 848 x 480 (480p).
///
/// GOPRO_RESOLUTION_480p
const GoproResolution goproResolution480p = 0;

/// 1280 x 720 (720p).
///
/// GOPRO_RESOLUTION_720p
const GoproResolution goproResolution720p = 1;

/// 1280 x 960 (960p).
///
/// GOPRO_RESOLUTION_960p
const GoproResolution goproResolution960p = 2;

/// 1920 x 1080 (1080p).
///
/// GOPRO_RESOLUTION_1080p
const GoproResolution goproResolution1080p = 3;

/// 1920 x 1440 (1440p).
///
/// GOPRO_RESOLUTION_1440p
const GoproResolution goproResolution1440p = 4;

/// 2704 x 1440 (2.7k-17:9).
///
/// GOPRO_RESOLUTION_2_7k_17_9
const GoproResolution goproResolution27k179 = 5;

/// 2704 x 1524 (2.7k-16:9).
///
/// GOPRO_RESOLUTION_2_7k_16_9
const GoproResolution goproResolution27k169 = 6;

/// 2704 x 2028 (2.7k-4:3).
///
/// GOPRO_RESOLUTION_2_7k_4_3
const GoproResolution goproResolution27k43 = 7;

/// 3840 x 2160 (4k-16:9).
///
/// GOPRO_RESOLUTION_4k_16_9
const GoproResolution goproResolution4k169 = 8;

/// 4096 x 2160 (4k-17:9).
///
/// GOPRO_RESOLUTION_4k_17_9
const GoproResolution goproResolution4k179 = 9;

/// 1280 x 720 (720p-SuperView).
///
/// GOPRO_RESOLUTION_720p_SUPERVIEW
const GoproResolution goproResolution720pSuperview = 10;

/// 1920 x 1080 (1080p-SuperView).
///
/// GOPRO_RESOLUTION_1080p_SUPERVIEW
const GoproResolution goproResolution1080pSuperview = 11;

/// 2704 x 1520 (2.7k-SuperView).
///
/// GOPRO_RESOLUTION_2_7k_SUPERVIEW
const GoproResolution goproResolution27kSuperview = 12;

/// 3840 x 2160 (4k-SuperView).
///
/// GOPRO_RESOLUTION_4k_SUPERVIEW
const GoproResolution goproResolution4kSuperview = 13;

///
/// GOPRO_FRAME_RATE
typedef GoproFrameRate = int;

/// 12 FPS.
///
/// GOPRO_FRAME_RATE_12
const GoproFrameRate goproFrameRate12 = 0;

/// 15 FPS.
///
/// GOPRO_FRAME_RATE_15
const GoproFrameRate goproFrameRate15 = 1;

/// 24 FPS.
///
/// GOPRO_FRAME_RATE_24
const GoproFrameRate goproFrameRate24 = 2;

/// 25 FPS.
///
/// GOPRO_FRAME_RATE_25
const GoproFrameRate goproFrameRate25 = 3;

/// 30 FPS.
///
/// GOPRO_FRAME_RATE_30
const GoproFrameRate goproFrameRate30 = 4;

/// 48 FPS.
///
/// GOPRO_FRAME_RATE_48
const GoproFrameRate goproFrameRate48 = 5;

/// 50 FPS.
///
/// GOPRO_FRAME_RATE_50
const GoproFrameRate goproFrameRate50 = 6;

/// 60 FPS.
///
/// GOPRO_FRAME_RATE_60
const GoproFrameRate goproFrameRate60 = 7;

/// 80 FPS.
///
/// GOPRO_FRAME_RATE_80
const GoproFrameRate goproFrameRate80 = 8;

/// 90 FPS.
///
/// GOPRO_FRAME_RATE_90
const GoproFrameRate goproFrameRate90 = 9;

/// 100 FPS.
///
/// GOPRO_FRAME_RATE_100
const GoproFrameRate goproFrameRate100 = 10;

/// 120 FPS.
///
/// GOPRO_FRAME_RATE_120
const GoproFrameRate goproFrameRate120 = 11;

/// 240 FPS.
///
/// GOPRO_FRAME_RATE_240
const GoproFrameRate goproFrameRate240 = 12;

/// 12.5 FPS.
///
/// GOPRO_FRAME_RATE_12_5
const GoproFrameRate goproFrameRate125 = 13;

///
/// GOPRO_FIELD_OF_VIEW
typedef GoproFieldOfView = int;

/// 0x00: Wide.
///
/// GOPRO_FIELD_OF_VIEW_WIDE
const GoproFieldOfView goproFieldOfViewWide = 0;

/// 0x01: Medium.
///
/// GOPRO_FIELD_OF_VIEW_MEDIUM
const GoproFieldOfView goproFieldOfViewMedium = 1;

/// 0x02: Narrow.
///
/// GOPRO_FIELD_OF_VIEW_NARROW
const GoproFieldOfView goproFieldOfViewNarrow = 2;

///
/// GOPRO_VIDEO_SETTINGS_FLAGS
typedef GoproVideoSettingsFlags = int;

/// 0=NTSC, 1=PAL.
///
/// GOPRO_VIDEO_SETTINGS_TV_MODE
const GoproVideoSettingsFlags goproVideoSettingsTvMode = 1;

///
/// GOPRO_PHOTO_RESOLUTION
typedef GoproPhotoResolution = int;

/// 5MP Medium.
///
/// GOPRO_PHOTO_RESOLUTION_5MP_MEDIUM
const GoproPhotoResolution goproPhotoResolution5mpMedium = 0;

/// 7MP Medium.
///
/// GOPRO_PHOTO_RESOLUTION_7MP_MEDIUM
const GoproPhotoResolution goproPhotoResolution7mpMedium = 1;

/// 7MP Wide.
///
/// GOPRO_PHOTO_RESOLUTION_7MP_WIDE
const GoproPhotoResolution goproPhotoResolution7mpWide = 2;

/// 10MP Wide.
///
/// GOPRO_PHOTO_RESOLUTION_10MP_WIDE
const GoproPhotoResolution goproPhotoResolution10mpWide = 3;

/// 12MP Wide.
///
/// GOPRO_PHOTO_RESOLUTION_12MP_WIDE
const GoproPhotoResolution goproPhotoResolution12mpWide = 4;

///
/// GOPRO_PROTUNE_WHITE_BALANCE
typedef GoproProtuneWhiteBalance = int;

/// Auto.
///
/// GOPRO_PROTUNE_WHITE_BALANCE_AUTO
const GoproProtuneWhiteBalance goproProtuneWhiteBalanceAuto = 0;

/// 3000K.
///
/// GOPRO_PROTUNE_WHITE_BALANCE_3000K
const GoproProtuneWhiteBalance goproProtuneWhiteBalance3000k = 1;

/// 5500K.
///
/// GOPRO_PROTUNE_WHITE_BALANCE_5500K
const GoproProtuneWhiteBalance goproProtuneWhiteBalance5500k = 2;

/// 6500K.
///
/// GOPRO_PROTUNE_WHITE_BALANCE_6500K
const GoproProtuneWhiteBalance goproProtuneWhiteBalance6500k = 3;

/// Camera Raw.
///
/// GOPRO_PROTUNE_WHITE_BALANCE_RAW
const GoproProtuneWhiteBalance goproProtuneWhiteBalanceRaw = 4;

///
/// GOPRO_PROTUNE_COLOUR
typedef GoproProtuneColour = int;

/// Auto.
///
/// GOPRO_PROTUNE_COLOUR_STANDARD
const GoproProtuneColour goproProtuneColourStandard = 0;

/// Neutral.
///
/// GOPRO_PROTUNE_COLOUR_NEUTRAL
const GoproProtuneColour goproProtuneColourNeutral = 1;

///
/// GOPRO_PROTUNE_GAIN
typedef GoproProtuneGain = int;

/// ISO 400.
///
/// GOPRO_PROTUNE_GAIN_400
const GoproProtuneGain goproProtuneGain400 = 0;

/// ISO 800 (Only Hero 4).
///
/// GOPRO_PROTUNE_GAIN_800
const GoproProtuneGain goproProtuneGain800 = 1;

/// ISO 1600.
///
/// GOPRO_PROTUNE_GAIN_1600
const GoproProtuneGain goproProtuneGain1600 = 2;

/// ISO 3200 (Only Hero 4).
///
/// GOPRO_PROTUNE_GAIN_3200
const GoproProtuneGain goproProtuneGain3200 = 3;

/// ISO 6400.
///
/// GOPRO_PROTUNE_GAIN_6400
const GoproProtuneGain goproProtuneGain6400 = 4;

///
/// GOPRO_PROTUNE_SHARPNESS
typedef GoproProtuneSharpness = int;

/// Low Sharpness.
///
/// GOPRO_PROTUNE_SHARPNESS_LOW
const GoproProtuneSharpness goproProtuneSharpnessLow = 0;

/// Medium Sharpness.
///
/// GOPRO_PROTUNE_SHARPNESS_MEDIUM
const GoproProtuneSharpness goproProtuneSharpnessMedium = 1;

/// High Sharpness.
///
/// GOPRO_PROTUNE_SHARPNESS_HIGH
const GoproProtuneSharpness goproProtuneSharpnessHigh = 2;

///
/// GOPRO_PROTUNE_EXPOSURE
typedef GoproProtuneExposure = int;

/// -5.0 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_5_0
const GoproProtuneExposure goproProtuneExposureNeg50 = 0;

/// -4.5 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_4_5
const GoproProtuneExposure goproProtuneExposureNeg45 = 1;

/// -4.0 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_4_0
const GoproProtuneExposure goproProtuneExposureNeg40 = 2;

/// -3.5 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_3_5
const GoproProtuneExposure goproProtuneExposureNeg35 = 3;

/// -3.0 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_3_0
const GoproProtuneExposure goproProtuneExposureNeg30 = 4;

/// -2.5 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_2_5
const GoproProtuneExposure goproProtuneExposureNeg25 = 5;

/// -2.0 EV.
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_2_0
const GoproProtuneExposure goproProtuneExposureNeg20 = 6;

/// -1.5 EV.
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_1_5
const GoproProtuneExposure goproProtuneExposureNeg15 = 7;

/// -1.0 EV.
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_1_0
const GoproProtuneExposure goproProtuneExposureNeg10 = 8;

/// -0.5 EV.
///
/// GOPRO_PROTUNE_EXPOSURE_NEG_0_5
const GoproProtuneExposure goproProtuneExposureNeg05 = 9;

/// 0.0 EV.
///
/// GOPRO_PROTUNE_EXPOSURE_ZERO
const GoproProtuneExposure goproProtuneExposureZero = 10;

/// +0.5 EV.
///
/// GOPRO_PROTUNE_EXPOSURE_POS_0_5
const GoproProtuneExposure goproProtuneExposurePos05 = 11;

/// +1.0 EV.
///
/// GOPRO_PROTUNE_EXPOSURE_POS_1_0
const GoproProtuneExposure goproProtuneExposurePos10 = 12;

/// +1.5 EV.
///
/// GOPRO_PROTUNE_EXPOSURE_POS_1_5
const GoproProtuneExposure goproProtuneExposurePos15 = 13;

/// +2.0 EV.
///
/// GOPRO_PROTUNE_EXPOSURE_POS_2_0
const GoproProtuneExposure goproProtuneExposurePos20 = 14;

/// +2.5 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_POS_2_5
const GoproProtuneExposure goproProtuneExposurePos25 = 15;

/// +3.0 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_POS_3_0
const GoproProtuneExposure goproProtuneExposurePos30 = 16;

/// +3.5 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_POS_3_5
const GoproProtuneExposure goproProtuneExposurePos35 = 17;

/// +4.0 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_POS_4_0
const GoproProtuneExposure goproProtuneExposurePos40 = 18;

/// +4.5 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_POS_4_5
const GoproProtuneExposure goproProtuneExposurePos45 = 19;

/// +5.0 EV (Hero 3+ Only).
///
/// GOPRO_PROTUNE_EXPOSURE_POS_5_0
const GoproProtuneExposure goproProtuneExposurePos50 = 20;

///
/// GOPRO_CHARGING
typedef GoproCharging = int;

/// Charging disabled.
///
/// GOPRO_CHARGING_DISABLED
const GoproCharging goproChargingDisabled = 0;

/// Charging enabled.
///
/// GOPRO_CHARGING_ENABLED
const GoproCharging goproChargingEnabled = 1;

///
/// GOPRO_MODEL
typedef GoproModel = int;

/// Unknown gopro model.
///
/// GOPRO_MODEL_UNKNOWN
const GoproModel goproModelUnknown = 0;

/// Hero 3+ Silver (HeroBus not supported by GoPro).
///
/// GOPRO_MODEL_HERO_3_PLUS_SILVER
const GoproModel goproModelHero3PlusSilver = 1;

/// Hero 3+ Black.
///
/// GOPRO_MODEL_HERO_3_PLUS_BLACK
const GoproModel goproModelHero3PlusBlack = 2;

/// Hero 4 Silver.
///
/// GOPRO_MODEL_HERO_4_SILVER
const GoproModel goproModelHero4Silver = 3;

/// Hero 4 Black.
///
/// GOPRO_MODEL_HERO_4_BLACK
const GoproModel goproModelHero4Black = 4;

///
/// GOPRO_BURST_RATE
typedef GoproBurstRate = int;

/// 3 Shots / 1 Second.
///
/// GOPRO_BURST_RATE_3_IN_1_SECOND
const GoproBurstRate goproBurstRate3In1Second = 0;

/// 5 Shots / 1 Second.
///
/// GOPRO_BURST_RATE_5_IN_1_SECOND
const GoproBurstRate goproBurstRate5In1Second = 1;

/// 10 Shots / 1 Second.
///
/// GOPRO_BURST_RATE_10_IN_1_SECOND
const GoproBurstRate goproBurstRate10In1Second = 2;

/// 10 Shots / 2 Second.
///
/// GOPRO_BURST_RATE_10_IN_2_SECOND
const GoproBurstRate goproBurstRate10In2Second = 3;

/// 10 Shots / 3 Second (Hero 4 Only).
///
/// GOPRO_BURST_RATE_10_IN_3_SECOND
const GoproBurstRate goproBurstRate10In3Second = 4;

/// 30 Shots / 1 Second.
///
/// GOPRO_BURST_RATE_30_IN_1_SECOND
const GoproBurstRate goproBurstRate30In1Second = 5;

/// 30 Shots / 2 Second.
///
/// GOPRO_BURST_RATE_30_IN_2_SECOND
const GoproBurstRate goproBurstRate30In2Second = 6;

/// 30 Shots / 3 Second.
///
/// GOPRO_BURST_RATE_30_IN_3_SECOND
const GoproBurstRate goproBurstRate30In3Second = 7;

/// 30 Shots / 6 Second.
///
/// GOPRO_BURST_RATE_30_IN_6_SECOND
const GoproBurstRate goproBurstRate30In6Second = 8;

///
/// MAV_CMD_DO_AUX_FUNCTION_SWITCH_LEVEL
typedef MavCmdDoAuxFunctionSwitchLevel = int;

/// Switch Low.
///
/// MAV_CMD_DO_AUX_FUNCTION_SWITCH_LEVEL_LOW
const MavCmdDoAuxFunctionSwitchLevel mavCmdDoAuxFunctionSwitchLevelLow = 0;

/// Switch Middle.
///
/// MAV_CMD_DO_AUX_FUNCTION_SWITCH_LEVEL_MIDDLE
const MavCmdDoAuxFunctionSwitchLevel mavCmdDoAuxFunctionSwitchLevelMiddle = 1;

/// Switch High.
///
/// MAV_CMD_DO_AUX_FUNCTION_SWITCH_LEVEL_HIGH
const MavCmdDoAuxFunctionSwitchLevel mavCmdDoAuxFunctionSwitchLevelHigh = 2;

///
/// LED_CONTROL_PATTERN
typedef LedControlPattern = int;

/// LED patterns off (return control to regular vehicle control).
///
/// LED_CONTROL_PATTERN_OFF
const LedControlPattern ledControlPatternOff = 0;

/// LEDs show pattern during firmware update.
///
/// LED_CONTROL_PATTERN_FIRMWAREUPDATE
const LedControlPattern ledControlPatternFirmwareupdate = 1;

/// Custom Pattern using custom bytes fields.
///
/// LED_CONTROL_PATTERN_CUSTOM
const LedControlPattern ledControlPatternCustom = 255;

/// Flags in EKF_STATUS message.
///
/// EKF_STATUS_FLAGS
typedef EkfStatusFlags = int;

/// Set if EKF's attitude estimate is good.
///
/// EKF_ATTITUDE
const EkfStatusFlags ekfAttitude = 1;

/// Set if EKF's horizontal velocity estimate is good.
///
/// EKF_VELOCITY_HORIZ
const EkfStatusFlags ekfVelocityHoriz = 2;

/// Set if EKF's vertical velocity estimate is good.
///
/// EKF_VELOCITY_VERT
const EkfStatusFlags ekfVelocityVert = 4;

/// Set if EKF's horizontal position (relative) estimate is good.
///
/// EKF_POS_HORIZ_REL
const EkfStatusFlags ekfPosHorizRel = 8;

/// Set if EKF's horizontal position (absolute) estimate is good.
///
/// EKF_POS_HORIZ_ABS
const EkfStatusFlags ekfPosHorizAbs = 16;

/// Set if EKF's vertical position (absolute) estimate is good.
///
/// EKF_POS_VERT_ABS
const EkfStatusFlags ekfPosVertAbs = 32;

/// Set if EKF's vertical position (above ground) estimate is good.
///
/// EKF_POS_VERT_AGL
const EkfStatusFlags ekfPosVertAgl = 64;

/// EKF is in constant position mode and does not know it's absolute or relative position.
///
/// EKF_CONST_POS_MODE
const EkfStatusFlags ekfConstPosMode = 128;

/// Set if EKF's predicted horizontal position (relative) estimate is good.
///
/// EKF_PRED_POS_HORIZ_REL
const EkfStatusFlags ekfPredPosHorizRel = 256;

/// Set if EKF's predicted horizontal position (absolute) estimate is good.
///
/// EKF_PRED_POS_HORIZ_ABS
const EkfStatusFlags ekfPredPosHorizAbs = 512;

/// Set if EKF has never been healthy.
///
/// EKF_UNINITIALIZED
const EkfStatusFlags ekfUninitialized = 1024;

///
/// PID_TUNING_AXIS
typedef PidTuningAxis = int;

///
/// PID_TUNING_ROLL
const PidTuningAxis pidTuningRoll = 1;

///
/// PID_TUNING_PITCH
const PidTuningAxis pidTuningPitch = 2;

///
/// PID_TUNING_YAW
const PidTuningAxis pidTuningYaw = 3;

///
/// PID_TUNING_ACCZ
const PidTuningAxis pidTuningAccz = 4;

///
/// PID_TUNING_STEER
const PidTuningAxis pidTuningSteer = 5;

///
/// PID_TUNING_LANDING
const PidTuningAxis pidTuningLanding = 6;

/// Special ACK block numbers control activation of dataflash log streaming.
///
/// MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS
typedef MavRemoteLogDataBlockCommands = int;

/// UAV to stop sending DataFlash blocks.
///
/// MAV_REMOTE_LOG_DATA_BLOCK_STOP
const MavRemoteLogDataBlockCommands mavRemoteLogDataBlockStop = 2147483645;

/// UAV to start sending DataFlash blocks.
///
/// MAV_REMOTE_LOG_DATA_BLOCK_START
const MavRemoteLogDataBlockCommands mavRemoteLogDataBlockStart = 2147483646;

/// Possible remote log data block statuses.
///
/// MAV_REMOTE_LOG_DATA_BLOCK_STATUSES
typedef MavRemoteLogDataBlockStatuses = int;

/// This block has NOT been received.
///
/// MAV_REMOTE_LOG_DATA_BLOCK_NACK
const MavRemoteLogDataBlockStatuses mavRemoteLogDataBlockNack = 0;

/// This block has been received.
///
/// MAV_REMOTE_LOG_DATA_BLOCK_ACK
const MavRemoteLogDataBlockStatuses mavRemoteLogDataBlockAck = 1;

/// Bus types for device operations.
///
/// DEVICE_OP_BUSTYPE
typedef DeviceOpBustype = int;

/// I2C Device operation.
///
/// DEVICE_OP_BUSTYPE_I2C
const DeviceOpBustype deviceOpBustypeI2c = 0;

/// SPI Device operation.
///
/// DEVICE_OP_BUSTYPE_SPI
const DeviceOpBustype deviceOpBustypeSpi = 1;

/// Deepstall flight stage.
///
/// DEEPSTALL_STAGE
typedef DeepstallStage = int;

/// Flying to the landing point.
///
/// DEEPSTALL_STAGE_FLY_TO_LANDING
const DeepstallStage deepstallStageFlyToLanding = 0;

/// Building an estimate of the wind.
///
/// DEEPSTALL_STAGE_ESTIMATE_WIND
const DeepstallStage deepstallStageEstimateWind = 1;

/// Waiting to breakout of the loiter to fly the approach.
///
/// DEEPSTALL_STAGE_WAIT_FOR_BREAKOUT
const DeepstallStage deepstallStageWaitForBreakout = 2;

/// Flying to the first arc point to turn around to the landing point.
///
/// DEEPSTALL_STAGE_FLY_TO_ARC
const DeepstallStage deepstallStageFlyToArc = 3;

/// Turning around back to the deepstall landing point.
///
/// DEEPSTALL_STAGE_ARC
const DeepstallStage deepstallStageArc = 4;

/// Approaching the landing point.
///
/// DEEPSTALL_STAGE_APPROACH
const DeepstallStage deepstallStageApproach = 5;

/// Stalling and steering towards the land point.
///
/// DEEPSTALL_STAGE_LAND
const DeepstallStage deepstallStageLand = 6;

/// A mapping of plane flight modes for custom_mode field of heartbeat.
///
/// PLANE_MODE
typedef PlaneMode = int;

///
/// PLANE_MODE_MANUAL
const PlaneMode planeModeManual = 0;

///
/// PLANE_MODE_CIRCLE
const PlaneMode planeModeCircle = 1;

///
/// PLANE_MODE_STABILIZE
const PlaneMode planeModeStabilize = 2;

///
/// PLANE_MODE_TRAINING
const PlaneMode planeModeTraining = 3;

///
/// PLANE_MODE_ACRO
const PlaneMode planeModeAcro = 4;

///
/// PLANE_MODE_FLY_BY_WIRE_A
const PlaneMode planeModeFlyByWireA = 5;

///
/// PLANE_MODE_FLY_BY_WIRE_B
const PlaneMode planeModeFlyByWireB = 6;

///
/// PLANE_MODE_CRUISE
const PlaneMode planeModeCruise = 7;

///
/// PLANE_MODE_AUTOTUNE
const PlaneMode planeModeAutotune = 8;

///
/// PLANE_MODE_AUTO
const PlaneMode planeModeAuto = 10;

///
/// PLANE_MODE_RTL
const PlaneMode planeModeRtl = 11;

///
/// PLANE_MODE_LOITER
const PlaneMode planeModeLoiter = 12;

///
/// PLANE_MODE_TAKEOFF
const PlaneMode planeModeTakeoff = 13;

///
/// PLANE_MODE_AVOID_ADSB
const PlaneMode planeModeAvoidAdsb = 14;

///
/// PLANE_MODE_GUIDED
const PlaneMode planeModeGuided = 15;

///
/// PLANE_MODE_INITIALIZING
const PlaneMode planeModeInitializing = 16;

///
/// PLANE_MODE_QSTABILIZE
const PlaneMode planeModeQstabilize = 17;

///
/// PLANE_MODE_QHOVER
const PlaneMode planeModeQhover = 18;

///
/// PLANE_MODE_QLOITER
const PlaneMode planeModeQloiter = 19;

///
/// PLANE_MODE_QLAND
const PlaneMode planeModeQland = 20;

///
/// PLANE_MODE_QRTL
const PlaneMode planeModeQrtl = 21;

///
/// PLANE_MODE_QAUTOTUNE
const PlaneMode planeModeQautotune = 22;

///
/// PLANE_MODE_QACRO
const PlaneMode planeModeQacro = 23;

///
/// PLANE_MODE_THERMAL
const PlaneMode planeModeThermal = 24;

/// A mapping of copter flight modes for custom_mode field of heartbeat.
///
/// COPTER_MODE
typedef CopterMode = int;

///
/// COPTER_MODE_STABILIZE
const CopterMode copterModeStabilize = 0;

///
/// COPTER_MODE_ACRO
const CopterMode copterModeAcro = 1;

///
/// COPTER_MODE_ALT_HOLD
const CopterMode copterModeAltHold = 2;

///
/// COPTER_MODE_AUTO
const CopterMode copterModeAuto = 3;

///
/// COPTER_MODE_GUIDED
const CopterMode copterModeGuided = 4;

///
/// COPTER_MODE_LOITER
const CopterMode copterModeLoiter = 5;

///
/// COPTER_MODE_RTL
const CopterMode copterModeRtl = 6;

///
/// COPTER_MODE_CIRCLE
const CopterMode copterModeCircle = 7;

///
/// COPTER_MODE_LAND
const CopterMode copterModeLand = 9;

///
/// COPTER_MODE_DRIFT
const CopterMode copterModeDrift = 11;

///
/// COPTER_MODE_SPORT
const CopterMode copterModeSport = 13;

///
/// COPTER_MODE_FLIP
const CopterMode copterModeFlip = 14;

///
/// COPTER_MODE_AUTOTUNE
const CopterMode copterModeAutotune = 15;

///
/// COPTER_MODE_POSHOLD
const CopterMode copterModePoshold = 16;

///
/// COPTER_MODE_BRAKE
const CopterMode copterModeBrake = 17;

///
/// COPTER_MODE_THROW
const CopterMode copterModeThrow = 18;

///
/// COPTER_MODE_AVOID_ADSB
const CopterMode copterModeAvoidAdsb = 19;

///
/// COPTER_MODE_GUIDED_NOGPS
const CopterMode copterModeGuidedNogps = 20;

///
/// COPTER_MODE_SMART_RTL
const CopterMode copterModeSmartRtl = 21;

///
/// COPTER_MODE_FLOWHOLD
const CopterMode copterModeFlowhold = 22;

///
/// COPTER_MODE_FOLLOW
const CopterMode copterModeFollow = 23;

///
/// COPTER_MODE_ZIGZAG
const CopterMode copterModeZigzag = 24;

///
/// COPTER_MODE_SYSTEMID
const CopterMode copterModeSystemid = 25;

///
/// COPTER_MODE_AUTOROTATE
const CopterMode copterModeAutorotate = 26;

///
/// COPTER_MODE_AUTO_RTL
const CopterMode copterModeAutoRtl = 27;

/// A mapping of sub flight modes for custom_mode field of heartbeat.
///
/// SUB_MODE
typedef SubMode = int;

///
/// SUB_MODE_STABILIZE
const SubMode subModeStabilize = 0;

///
/// SUB_MODE_ACRO
const SubMode subModeAcro = 1;

///
/// SUB_MODE_ALT_HOLD
const SubMode subModeAltHold = 2;

///
/// SUB_MODE_AUTO
const SubMode subModeAuto = 3;

///
/// SUB_MODE_GUIDED
const SubMode subModeGuided = 4;

///
/// SUB_MODE_CIRCLE
const SubMode subModeCircle = 7;

///
/// SUB_MODE_SURFACE
const SubMode subModeSurface = 9;

///
/// SUB_MODE_POSHOLD
const SubMode subModePoshold = 16;

///
/// SUB_MODE_MANUAL
const SubMode subModeManual = 19;

/// A mapping of rover flight modes for custom_mode field of heartbeat.
///
/// ROVER_MODE
typedef RoverMode = int;

///
/// ROVER_MODE_MANUAL
const RoverMode roverModeManual = 0;

///
/// ROVER_MODE_ACRO
const RoverMode roverModeAcro = 1;

///
/// ROVER_MODE_STEERING
const RoverMode roverModeSteering = 3;

///
/// ROVER_MODE_HOLD
const RoverMode roverModeHold = 4;

///
/// ROVER_MODE_LOITER
const RoverMode roverModeLoiter = 5;

///
/// ROVER_MODE_FOLLOW
const RoverMode roverModeFollow = 6;

///
/// ROVER_MODE_SIMPLE
const RoverMode roverModeSimple = 7;

///
/// ROVER_MODE_AUTO
const RoverMode roverModeAuto = 10;

///
/// ROVER_MODE_RTL
const RoverMode roverModeRtl = 11;

///
/// ROVER_MODE_SMART_RTL
const RoverMode roverModeSmartRtl = 12;

///
/// ROVER_MODE_GUIDED
const RoverMode roverModeGuided = 15;

///
/// ROVER_MODE_INITIALIZING
const RoverMode roverModeInitializing = 16;

/// A mapping of antenna tracker flight modes for custom_mode field of heartbeat.
///
/// TRACKER_MODE
typedef TrackerMode = int;

///
/// TRACKER_MODE_MANUAL
const TrackerMode trackerModeManual = 0;

///
/// TRACKER_MODE_STOP
const TrackerMode trackerModeStop = 1;

///
/// TRACKER_MODE_SCAN
const TrackerMode trackerModeScan = 2;

///
/// TRACKER_MODE_SERVO_TEST
const TrackerMode trackerModeServoTest = 3;

///
/// TRACKER_MODE_AUTO
const TrackerMode trackerModeAuto = 10;

///
/// TRACKER_MODE_INITIALIZING
const TrackerMode trackerModeInitializing = 16;

/// The type of parameter for the OSD parameter editor.
///
/// OSD_PARAM_CONFIG_TYPE
typedef OsdParamConfigType = int;

///
/// OSD_PARAM_NONE
const OsdParamConfigType osdParamNone = 0;

///
/// OSD_PARAM_SERIAL_PROTOCOL
const OsdParamConfigType osdParamSerialProtocol = 1;

///
/// OSD_PARAM_SERVO_FUNCTION
const OsdParamConfigType osdParamServoFunction = 2;

///
/// OSD_PARAM_AUX_FUNCTION
const OsdParamConfigType osdParamAuxFunction = 3;

///
/// OSD_PARAM_FLIGHT_MODE
const OsdParamConfigType osdParamFlightMode = 4;

///
/// OSD_PARAM_FAILSAFE_ACTION
const OsdParamConfigType osdParamFailsafeAction = 5;

///
/// OSD_PARAM_FAILSAFE_ACTION_1
const OsdParamConfigType osdParamFailsafeAction1 = 6;

///
/// OSD_PARAM_FAILSAFE_ACTION_2
const OsdParamConfigType osdParamFailsafeAction2 = 7;

///
/// OSD_PARAM_NUM_TYPES
const OsdParamConfigType osdParamNumTypes = 8;

/// The error type for the OSD parameter editor.
///
/// OSD_PARAM_CONFIG_ERROR
typedef OsdParamConfigError = int;

///
/// OSD_PARAM_SUCCESS
const OsdParamConfigError osdParamSuccess = 0;

///
/// OSD_PARAM_INVALID_SCREEN
const OsdParamConfigError osdParamInvalidScreen = 1;

///
/// OSD_PARAM_INVALID_PARAMETER_INDEX
const OsdParamConfigError osdParamInvalidParameterIndex = 2;

///
/// OSD_PARAM_INVALID_PARAMETER
const OsdParamConfigError osdParamInvalidParameter = 3;

///
/// MAV_STORM32_TUNNEL_PAYLOAD_TYPE
typedef MavStorm32TunnelPayloadType = int;

/// Registered for STorM32 gimbal controller. For communication with gimbal or camera.
///
/// MAV_STORM32_TUNNEL_PAYLOAD_TYPE_STORM32_CH1_IN
const MavStorm32TunnelPayloadType mavStorm32TunnelPayloadTypeStorm32Ch1In = 200;

/// Registered for STorM32 gimbal controller. For communication with gimbal or camera.
///
/// MAV_STORM32_TUNNEL_PAYLOAD_TYPE_STORM32_CH1_OUT
const MavStorm32TunnelPayloadType mavStorm32TunnelPayloadTypeStorm32Ch1Out =
    201;

/// Registered for STorM32 gimbal controller. For communication with gimbal.
///
/// MAV_STORM32_TUNNEL_PAYLOAD_TYPE_STORM32_CH2_IN
const MavStorm32TunnelPayloadType mavStorm32TunnelPayloadTypeStorm32Ch2In = 202;

/// Registered for STorM32 gimbal controller. For communication with gimbal.
///
/// MAV_STORM32_TUNNEL_PAYLOAD_TYPE_STORM32_CH2_OUT
const MavStorm32TunnelPayloadType mavStorm32TunnelPayloadTypeStorm32Ch2Out =
    203;

/// Registered for STorM32 gimbal controller. For communication with camera.
///
/// MAV_STORM32_TUNNEL_PAYLOAD_TYPE_STORM32_CH3_IN
const MavStorm32TunnelPayloadType mavStorm32TunnelPayloadTypeStorm32Ch3In = 204;

/// Registered for STorM32 gimbal controller. For communication with camera.
///
/// MAV_STORM32_TUNNEL_PAYLOAD_TYPE_STORM32_CH3_OUT
const MavStorm32TunnelPayloadType mavStorm32TunnelPayloadTypeStorm32Ch3Out =
    205;

/// STorM32 gimbal prearm check flags.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS
typedef MavStorm32GimbalPrearmFlags = int;

/// STorM32 gimbal is in normal state.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_IS_NORMAL
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsIsNormal = 1;

/// The IMUs are healthy and working normally.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_IMUS_WORKING
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsImusWorking = 2;

/// The motors are active and working normally.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_MOTORS_WORKING
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsMotorsWorking = 4;

/// The encoders are healthy and working normally.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_ENCODERS_WORKING
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsEncodersWorking =
    8;

/// A battery voltage is applied and is in range.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_VOLTAGE_OK
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsVoltageOk = 16;

/// Virtual input channels are receiving data.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_VIRTUALCHANNELS_RECEIVING
const MavStorm32GimbalPrearmFlags
    mavStorm32GimbalPrearmFlagsVirtualchannelsReceiving = 32;

/// Mavlink messages are being received.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_MAVLINK_RECEIVING
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsMavlinkReceiving =
    64;

/// The STorM32Link data indicates QFix.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_STORM32LINK_QFIX
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsStorm32linkQfix =
    128;

/// The STorM32Link is working.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_STORM32LINK_WORKING
const MavStorm32GimbalPrearmFlags
    mavStorm32GimbalPrearmFlagsStorm32linkWorking = 256;

/// The camera has been found and is connected.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_CAMERA_CONNECTED
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsCameraConnected =
    512;

/// The signal on the AUX0 input pin is low.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_AUX0_LOW
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsAux0Low = 1024;

/// The signal on the AUX1 input pin is low.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_AUX1_LOW
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsAux1Low = 2048;

/// The NTLogger is working normally.
///
/// MAV_STORM32_GIMBAL_PREARM_FLAGS_NTLOGGER_WORKING
const MavStorm32GimbalPrearmFlags mavStorm32GimbalPrearmFlagsNtloggerWorking =
    4096;

/// STorM32 camera prearm check flags.
///
/// MAV_STORM32_CAMERA_PREARM_FLAGS
typedef MavStorm32CameraPrearmFlags = int;

/// The camera has been found and is connected.
///
/// MAV_STORM32_CAMERA_PREARM_FLAGS_CONNECTED
const MavStorm32CameraPrearmFlags mavStorm32CameraPrearmFlagsConnected = 1;

/// Gimbal manager capability flags.
///
/// MAV_STORM32_GIMBAL_MANAGER_CAP_FLAGS
typedef MavStorm32GimbalManagerCapFlags = int;

/// The gimbal manager supports several profiles.
///
/// MAV_STORM32_GIMBAL_MANAGER_CAP_FLAGS_HAS_PROFILES
const MavStorm32GimbalManagerCapFlags
    mavStorm32GimbalManagerCapFlagsHasProfiles = 1;

/// Flags for gimbal manager operation. Used for setting and reporting, unless specified otherwise. If a setting has been accepted by the gimbal manager is reported in the STORM32_GIMBAL_MANAGER_STATUS message.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS
typedef MavStorm32GimbalManagerFlags = int;

/// 0 = ignore.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_NONE
const MavStorm32GimbalManagerFlags mavStorm32GimbalManagerFlagsNone = 0;

/// Request to set RC input to active, or report RC input is active. Implies RC mixed. RC exclusive is achieved by setting all clients to inactive.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_RC_ACTIVE
const MavStorm32GimbalManagerFlags mavStorm32GimbalManagerFlagsRcActive = 1;

/// Request to set onboard/companion computer client to active, or report this client is active.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_CLIENT_ONBOARD_ACTIVE
const MavStorm32GimbalManagerFlags
    mavStorm32GimbalManagerFlagsClientOnboardActive = 2;

/// Request to set autopliot client to active, or report this client is active.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_CLIENT_AUTOPILOT_ACTIVE
const MavStorm32GimbalManagerFlags
    mavStorm32GimbalManagerFlagsClientAutopilotActive = 4;

/// Request to set GCS client to active, or report this client is active.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_CLIENT_GCS_ACTIVE
const MavStorm32GimbalManagerFlags mavStorm32GimbalManagerFlagsClientGcsActive =
    8;

/// Request to set camera client to active, or report this client is active.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_CLIENT_CAMERA_ACTIVE
const MavStorm32GimbalManagerFlags
    mavStorm32GimbalManagerFlagsClientCameraActive = 16;

/// Request to set GCS2 client to active, or report this client is active.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_CLIENT_GCS2_ACTIVE
const MavStorm32GimbalManagerFlags
    mavStorm32GimbalManagerFlagsClientGcs2Active = 32;

/// Request to set camera2 client to active, or report this client is active.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_CLIENT_CAMERA2_ACTIVE
const MavStorm32GimbalManagerFlags
    mavStorm32GimbalManagerFlagsClientCamera2Active = 64;

/// Request to set custom client to active, or report this client is active.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_CLIENT_CUSTOM_ACTIVE
const MavStorm32GimbalManagerFlags
    mavStorm32GimbalManagerFlagsClientCustomActive = 128;

/// Request to set custom2 client to active, or report this client is active.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_CLIENT_CUSTOM2_ACTIVE
const MavStorm32GimbalManagerFlags
    mavStorm32GimbalManagerFlagsClientCustom2Active = 256;

/// Request supervision. This flag is only for setting, it is not reported.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_SET_SUPERVISON
const MavStorm32GimbalManagerFlags mavStorm32GimbalManagerFlagsSetSupervison =
    512;

/// Release supervision. This flag is only for setting, it is not reported.
///
/// MAV_STORM32_GIMBAL_MANAGER_FLAGS_SET_RELEASE
const MavStorm32GimbalManagerFlags mavStorm32GimbalManagerFlagsSetRelease =
    1024;

/// Gimbal manager client ID. In a prioritizing profile, the priorities are determined by the implementation; they could e.g. be custom1 > onboard > GCS > autopilot/camera > GCS2 > custom2.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT
typedef MavStorm32GimbalManagerClient = int;

/// For convenience.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT_NONE
const MavStorm32GimbalManagerClient mavStorm32GimbalManagerClientNone = 0;

/// This is the onboard/companion computer client.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT_ONBOARD
const MavStorm32GimbalManagerClient mavStorm32GimbalManagerClientOnboard = 1;

/// This is the autopilot client.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT_AUTOPILOT
const MavStorm32GimbalManagerClient mavStorm32GimbalManagerClientAutopilot = 2;

/// This is the GCS client.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT_GCS
const MavStorm32GimbalManagerClient mavStorm32GimbalManagerClientGcs = 3;

/// This is the camera client.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT_CAMERA
const MavStorm32GimbalManagerClient mavStorm32GimbalManagerClientCamera = 4;

/// This is the GCS2 client.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT_GCS2
const MavStorm32GimbalManagerClient mavStorm32GimbalManagerClientGcs2 = 5;

/// This is the camera2 client.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT_CAMERA2
const MavStorm32GimbalManagerClient mavStorm32GimbalManagerClientCamera2 = 6;

/// This is the custom client.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT_CUSTOM
const MavStorm32GimbalManagerClient mavStorm32GimbalManagerClientCustom = 7;

/// This is the custom2 client.
///
/// MAV_STORM32_GIMBAL_MANAGER_CLIENT_CUSTOM2
const MavStorm32GimbalManagerClient mavStorm32GimbalManagerClientCustom2 = 8;

/// Gimbal manager profiles. Only standard profiles are defined. Any implementation can define its own profile(s) in addition, and should use enum values > 16.
///
/// MAV_STORM32_GIMBAL_MANAGER_PROFILE
typedef MavStorm32GimbalManagerProfile = int;

/// Default profile. Implementation specific.
///
/// MAV_STORM32_GIMBAL_MANAGER_PROFILE_DEFAULT
const MavStorm32GimbalManagerProfile mavStorm32GimbalManagerProfileDefault = 0;

/// Not supported/deprecated.
///
/// MAV_STORM32_GIMBAL_MANAGER_PROFILE_CUSTOM
const MavStorm32GimbalManagerProfile mavStorm32GimbalManagerProfileCustom = 1;

/// Profile with cooperative behavior.
///
/// MAV_STORM32_GIMBAL_MANAGER_PROFILE_COOPERATIVE
const MavStorm32GimbalManagerProfile mavStorm32GimbalManagerProfileCooperative =
    2;

/// Profile with exclusive behavior.
///
/// MAV_STORM32_GIMBAL_MANAGER_PROFILE_EXCLUSIVE
const MavStorm32GimbalManagerProfile mavStorm32GimbalManagerProfileExclusive =
    3;

/// Profile with priority and cooperative behavior for equal priority.
///
/// MAV_STORM32_GIMBAL_MANAGER_PROFILE_PRIORITY_COOPERATIVE
const MavStorm32GimbalManagerProfile
    mavStorm32GimbalManagerProfilePriorityCooperative = 4;

/// Profile with priority and exclusive behavior for equal priority.
///
/// MAV_STORM32_GIMBAL_MANAGER_PROFILE_PRIORITY_EXCLUSIVE
const MavStorm32GimbalManagerProfile
    mavStorm32GimbalManagerProfilePriorityExclusive = 5;

/// Enumeration of possible shot modes.
///
/// MAV_QSHOT_MODE
typedef MavQshotMode = int;

/// Undefined shot mode. Can be used to determine if qshots should be used or not.
///
/// MAV_QSHOT_MODE_UNDEFINED
const MavQshotMode mavQshotModeUndefined = 0;

/// Start normal gimbal operation. Is usually used to return back from a shot.
///
/// MAV_QSHOT_MODE_DEFAULT
const MavQshotMode mavQshotModeDefault = 1;

/// Load and keep safe gimbal position and stop stabilization.
///
/// MAV_QSHOT_MODE_GIMBAL_RETRACT
const MavQshotMode mavQshotModeGimbalRetract = 2;

/// Load neutral gimbal position and keep it while stabilizing.
///
/// MAV_QSHOT_MODE_GIMBAL_NEUTRAL
const MavQshotMode mavQshotModeGimbalNeutral = 3;

/// Start mission with gimbal control.
///
/// MAV_QSHOT_MODE_GIMBAL_MISSION
const MavQshotMode mavQshotModeGimbalMission = 4;

/// Start RC gimbal control.
///
/// MAV_QSHOT_MODE_GIMBAL_RC_CONTROL
const MavQshotMode mavQshotModeGimbalRcControl = 5;

/// Start gimbal tracking the point specified by Lat, Lon, Alt.
///
/// MAV_QSHOT_MODE_POI_TARGETING
const MavQshotMode mavQshotModePoiTargeting = 6;

/// Start gimbal tracking the system with specified system ID.
///
/// MAV_QSHOT_MODE_SYSID_TARGETING
const MavQshotMode mavQshotModeSysidTargeting = 7;

/// Start 2-point cable cam quick shot.
///
/// MAV_QSHOT_MODE_CABLECAM_2POINT
const MavQshotMode mavQshotModeCablecam2point = 8;

/// Start gimbal tracking the home location.
///
/// MAV_QSHOT_MODE_HOME_TARGETING
const MavQshotMode mavQshotModeHomeTargeting = 9;

/// The heartbeat message shows that a system or component is present and responding. The type and autopilot fields (along with the message component id), allow the receiving system to treat further messages from this system appropriately (e.g. by laying out the user interface based on the autopilot). This microservice is documented at https://mavlink.io/en/services/heartbeat.html
///
/// HEARTBEAT
class Heartbeat implements MavlinkMessage {
  static const int _mavlinkMessageId = 0;

  static const int _mavlinkCrcExtra = 50;

  static const int mavlinkEncodedLength = 9;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// A bitfield for use for autopilot-specific flags
  ///
  /// MAVLink type: uint32_t
  ///
  /// custom_mode
  final uint32_t customMode;

  /// Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavType]
  ///
  /// type
  final MavType type;

  /// Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavAutopilot]
  ///
  /// autopilot
  final MavAutopilot autopilot;

  /// System mode bitmap.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavModeFlag]
  ///
  /// base_mode
  final MavModeFlag baseMode;

  /// System status flag.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavState]
  ///
  /// system_status
  final MavState systemStatus;

  /// MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version
  ///
  /// MAVLink type: uint8_t
  ///
  /// mavlink_version
  final uint8_t mavlinkVersion;

  Heartbeat({
    required this.customMode,
    required this.type,
    required this.autopilot,
    required this.baseMode,
    required this.systemStatus,
    required this.mavlinkVersion,
  });

  Heartbeat copyWith({
    uint32_t? customMode,
    MavType? type,
    MavAutopilot? autopilot,
    MavModeFlag? baseMode,
    MavState? systemStatus,
    uint8_t? mavlinkVersion,
  }) {
    return Heartbeat(
      customMode: customMode ?? this.customMode,
      type: type ?? this.type,
      autopilot: autopilot ?? this.autopilot,
      baseMode: baseMode ?? this.baseMode,
      systemStatus: systemStatus ?? this.systemStatus,
      mavlinkVersion: mavlinkVersion ?? this.mavlinkVersion,
    );
  }

  factory Heartbeat.parse(ByteData data_) {
    if (data_.lengthInBytes < Heartbeat.mavlinkEncodedLength) {
      var len = Heartbeat.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var customMode = data_.getUint32(0, Endian.little);
    var type = data_.getUint8(4);
    var autopilot = data_.getUint8(5);
    var baseMode = data_.getUint8(6);
    var systemStatus = data_.getUint8(7);
    var mavlinkVersion = data_.getUint8(8);

    return Heartbeat(
        customMode: customMode,
        type: type,
        autopilot: autopilot,
        baseMode: baseMode,
        systemStatus: systemStatus,
        mavlinkVersion: mavlinkVersion);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, customMode, Endian.little);
    data_.setUint8(4, type);
    data_.setUint8(5, autopilot);
    data_.setUint8(6, baseMode);
    data_.setUint8(7, systemStatus);
    data_.setUint8(8, mavlinkVersion);
    return data_;
  }
}

/// Version and capability of protocol version. This message can be requested with MAV_CMD_REQUEST_MESSAGE and is used as part of the handshaking to establish which MAVLink version should be used on the network. Every node should respond to a request for PROTOCOL_VERSION to enable the handshaking. Library implementers should consider adding this into the default decoding state machine to allow the protocol core to respond directly.
///
/// PROTOCOL_VERSION
class ProtocolVersion implements MavlinkMessage {
  static const int _mavlinkMessageId = 300;

  static const int _mavlinkCrcExtra = 217;

  static const int mavlinkEncodedLength = 22;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Currently active MAVLink version number * 100: v1.0 is 100, v2.0 is 200, etc.
  ///
  /// MAVLink type: uint16_t
  ///
  /// version
  final uint16_t version;

  /// Minimum MAVLink version supported
  ///
  /// MAVLink type: uint16_t
  ///
  /// min_version
  final uint16_t minVersion;

  /// Maximum MAVLink version supported (set to the same value as version by default)
  ///
  /// MAVLink type: uint16_t
  ///
  /// max_version
  final uint16_t maxVersion;

  /// The first 8 bytes (not characters printed in hex!) of the git hash.
  ///
  /// MAVLink type: uint8_t[8]
  ///
  /// spec_version_hash
  final List<int8_t> specVersionHash;

  /// The first 8 bytes (not characters printed in hex!) of the git hash.
  ///
  /// MAVLink type: uint8_t[8]
  ///
  /// library_version_hash
  final List<int8_t> libraryVersionHash;

  ProtocolVersion({
    required this.version,
    required this.minVersion,
    required this.maxVersion,
    required this.specVersionHash,
    required this.libraryVersionHash,
  });

  ProtocolVersion copyWith({
    uint16_t? version,
    uint16_t? minVersion,
    uint16_t? maxVersion,
    List<int8_t>? specVersionHash,
    List<int8_t>? libraryVersionHash,
  }) {
    return ProtocolVersion(
      version: version ?? this.version,
      minVersion: minVersion ?? this.minVersion,
      maxVersion: maxVersion ?? this.maxVersion,
      specVersionHash: specVersionHash ?? this.specVersionHash,
      libraryVersionHash: libraryVersionHash ?? this.libraryVersionHash,
    );
  }

  factory ProtocolVersion.parse(ByteData data_) {
    if (data_.lengthInBytes < ProtocolVersion.mavlinkEncodedLength) {
      var len = ProtocolVersion.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var version = data_.getUint16(0, Endian.little);
    var minVersion = data_.getUint16(2, Endian.little);
    var maxVersion = data_.getUint16(4, Endian.little);
    var specVersionHash = MavlinkMessage.asUint8List(data_, 6, 8);
    var libraryVersionHash = MavlinkMessage.asUint8List(data_, 14, 8);

    return ProtocolVersion(
        version: version,
        minVersion: minVersion,
        maxVersion: maxVersion,
        specVersionHash: specVersionHash,
        libraryVersionHash: libraryVersionHash);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, version, Endian.little);
    data_.setUint16(2, minVersion, Endian.little);
    data_.setUint16(4, maxVersion, Endian.little);
    MavlinkMessage.setUint8List(data_, 6, specVersionHash);
    MavlinkMessage.setUint8List(data_, 14, libraryVersionHash);
    return data_;
  }
}

/// The general system state. If the system is following the MAVLink standard, the system state is mainly defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents the internal navigation state machine. The system status shows whether the system is currently active or not and if an emergency occurred. During the CRITICAL and EMERGENCY states the MAV is still considered to be active, but should start emergency procedures autonomously. After a failure occurred it should first move from active to critical to allow manual intervention and then move to emergency after a certain timeout.
///
/// SYS_STATUS
class SysStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 1;

  static const int _mavlinkCrcExtra = 124;

  static const int mavlinkEncodedLength = 43;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Bitmap showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavSysStatusSensor]
  ///
  /// onboard_control_sensors_present
  final MavSysStatusSensor onboardControlSensorsPresent;

  /// Bitmap showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavSysStatusSensor]
  ///
  /// onboard_control_sensors_enabled
  final MavSysStatusSensor onboardControlSensorsEnabled;

  /// Bitmap showing which onboard controllers and sensors have an error (or are operational). Value of 0: error. Value of 1: healthy.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavSysStatusSensor]
  ///
  /// onboard_control_sensors_health
  final MavSysStatusSensor onboardControlSensorsHealth;

  /// Maximum usage in percent of the mainloop time. Values: [0-1000] - should always be below 1000
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: d%
  ///
  /// load
  final uint16_t load;

  /// Battery voltage, UINT16_MAX: Voltage not sent by autopilot
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mV
  ///
  /// voltage_battery
  final uint16_t voltageBattery;

  /// Battery current, -1: Current not sent by autopilot
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cA
  ///
  /// current_battery
  final int16_t currentBattery;

  /// Communication drop rate, (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: c%
  ///
  /// drop_rate_comm
  final uint16_t dropRateComm;

  /// Communication errors (UART, I2C, SPI, CAN), dropped packets on all links (packets that were corrupted on reception on the MAV)
  ///
  /// MAVLink type: uint16_t
  ///
  /// errors_comm
  final uint16_t errorsComm;

  /// Autopilot-specific errors
  ///
  /// MAVLink type: uint16_t
  ///
  /// errors_count1
  final uint16_t errorsCount1;

  /// Autopilot-specific errors
  ///
  /// MAVLink type: uint16_t
  ///
  /// errors_count2
  final uint16_t errorsCount2;

  /// Autopilot-specific errors
  ///
  /// MAVLink type: uint16_t
  ///
  /// errors_count3
  final uint16_t errorsCount3;

  /// Autopilot-specific errors
  ///
  /// MAVLink type: uint16_t
  ///
  /// errors_count4
  final uint16_t errorsCount4;

  /// Battery energy remaining, -1: Battery remaining energy not sent by autopilot
  ///
  /// MAVLink type: int8_t
  ///
  /// units: %
  ///
  /// battery_remaining
  final int8_t batteryRemaining;

  /// Bitmap showing which onboard controllers and sensors are present. Value of 0: not present. Value of 1: present.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavSysStatusSensorExtended]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// onboard_control_sensors_present_extended
  final MavSysStatusSensorExtended onboardControlSensorsPresentExtended;

  /// Bitmap showing which onboard controllers and sensors are enabled:  Value of 0: not enabled. Value of 1: enabled.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavSysStatusSensorExtended]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// onboard_control_sensors_enabled_extended
  final MavSysStatusSensorExtended onboardControlSensorsEnabledExtended;

  /// Bitmap showing which onboard controllers and sensors have an error (or are operational). Value of 0: error. Value of 1: healthy.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavSysStatusSensorExtended]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// onboard_control_sensors_health_extended
  final MavSysStatusSensorExtended onboardControlSensorsHealthExtended;

  SysStatus({
    required this.onboardControlSensorsPresent,
    required this.onboardControlSensorsEnabled,
    required this.onboardControlSensorsHealth,
    required this.load,
    required this.voltageBattery,
    required this.currentBattery,
    required this.dropRateComm,
    required this.errorsComm,
    required this.errorsCount1,
    required this.errorsCount2,
    required this.errorsCount3,
    required this.errorsCount4,
    required this.batteryRemaining,
    required this.onboardControlSensorsPresentExtended,
    required this.onboardControlSensorsEnabledExtended,
    required this.onboardControlSensorsHealthExtended,
  });

  SysStatus copyWith({
    MavSysStatusSensor? onboardControlSensorsPresent,
    MavSysStatusSensor? onboardControlSensorsEnabled,
    MavSysStatusSensor? onboardControlSensorsHealth,
    uint16_t? load,
    uint16_t? voltageBattery,
    int16_t? currentBattery,
    uint16_t? dropRateComm,
    uint16_t? errorsComm,
    uint16_t? errorsCount1,
    uint16_t? errorsCount2,
    uint16_t? errorsCount3,
    uint16_t? errorsCount4,
    int8_t? batteryRemaining,
    MavSysStatusSensorExtended? onboardControlSensorsPresentExtended,
    MavSysStatusSensorExtended? onboardControlSensorsEnabledExtended,
    MavSysStatusSensorExtended? onboardControlSensorsHealthExtended,
  }) {
    return SysStatus(
      onboardControlSensorsPresent:
          onboardControlSensorsPresent ?? this.onboardControlSensorsPresent,
      onboardControlSensorsEnabled:
          onboardControlSensorsEnabled ?? this.onboardControlSensorsEnabled,
      onboardControlSensorsHealth:
          onboardControlSensorsHealth ?? this.onboardControlSensorsHealth,
      load: load ?? this.load,
      voltageBattery: voltageBattery ?? this.voltageBattery,
      currentBattery: currentBattery ?? this.currentBattery,
      dropRateComm: dropRateComm ?? this.dropRateComm,
      errorsComm: errorsComm ?? this.errorsComm,
      errorsCount1: errorsCount1 ?? this.errorsCount1,
      errorsCount2: errorsCount2 ?? this.errorsCount2,
      errorsCount3: errorsCount3 ?? this.errorsCount3,
      errorsCount4: errorsCount4 ?? this.errorsCount4,
      batteryRemaining: batteryRemaining ?? this.batteryRemaining,
      onboardControlSensorsPresentExtended:
          onboardControlSensorsPresentExtended ??
              this.onboardControlSensorsPresentExtended,
      onboardControlSensorsEnabledExtended:
          onboardControlSensorsEnabledExtended ??
              this.onboardControlSensorsEnabledExtended,
      onboardControlSensorsHealthExtended:
          onboardControlSensorsHealthExtended ??
              this.onboardControlSensorsHealthExtended,
    );
  }

  factory SysStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < SysStatus.mavlinkEncodedLength) {
      var len = SysStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var onboardControlSensorsPresent = data_.getUint32(0, Endian.little);
    var onboardControlSensorsEnabled = data_.getUint32(4, Endian.little);
    var onboardControlSensorsHealth = data_.getUint32(8, Endian.little);
    var load = data_.getUint16(12, Endian.little);
    var voltageBattery = data_.getUint16(14, Endian.little);
    var currentBattery = data_.getInt16(16, Endian.little);
    var dropRateComm = data_.getUint16(18, Endian.little);
    var errorsComm = data_.getUint16(20, Endian.little);
    var errorsCount1 = data_.getUint16(22, Endian.little);
    var errorsCount2 = data_.getUint16(24, Endian.little);
    var errorsCount3 = data_.getUint16(26, Endian.little);
    var errorsCount4 = data_.getUint16(28, Endian.little);
    var batteryRemaining = data_.getInt8(30);
    var onboardControlSensorsPresentExtended =
        data_.getUint32(31, Endian.little);
    var onboardControlSensorsEnabledExtended =
        data_.getUint32(35, Endian.little);
    var onboardControlSensorsHealthExtended =
        data_.getUint32(39, Endian.little);

    return SysStatus(
        onboardControlSensorsPresent: onboardControlSensorsPresent,
        onboardControlSensorsEnabled: onboardControlSensorsEnabled,
        onboardControlSensorsHealth: onboardControlSensorsHealth,
        load: load,
        voltageBattery: voltageBattery,
        currentBattery: currentBattery,
        dropRateComm: dropRateComm,
        errorsComm: errorsComm,
        errorsCount1: errorsCount1,
        errorsCount2: errorsCount2,
        errorsCount3: errorsCount3,
        errorsCount4: errorsCount4,
        batteryRemaining: batteryRemaining,
        onboardControlSensorsPresentExtended:
            onboardControlSensorsPresentExtended,
        onboardControlSensorsEnabledExtended:
            onboardControlSensorsEnabledExtended,
        onboardControlSensorsHealthExtended:
            onboardControlSensorsHealthExtended);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, onboardControlSensorsPresent, Endian.little);
    data_.setUint32(4, onboardControlSensorsEnabled, Endian.little);
    data_.setUint32(8, onboardControlSensorsHealth, Endian.little);
    data_.setUint16(12, load, Endian.little);
    data_.setUint16(14, voltageBattery, Endian.little);
    data_.setInt16(16, currentBattery, Endian.little);
    data_.setUint16(18, dropRateComm, Endian.little);
    data_.setUint16(20, errorsComm, Endian.little);
    data_.setUint16(22, errorsCount1, Endian.little);
    data_.setUint16(24, errorsCount2, Endian.little);
    data_.setUint16(26, errorsCount3, Endian.little);
    data_.setUint16(28, errorsCount4, Endian.little);
    data_.setInt8(30, batteryRemaining);
    data_.setUint32(31, onboardControlSensorsPresentExtended, Endian.little);
    data_.setUint32(35, onboardControlSensorsEnabledExtended, Endian.little);
    data_.setUint32(39, onboardControlSensorsHealthExtended, Endian.little);
    return data_;
  }
}

/// The system time is the time of the master clock, typically the computer clock of the main onboard computer.
///
/// SYSTEM_TIME
class SystemTime implements MavlinkMessage {
  static const int _mavlinkMessageId = 2;

  static const int _mavlinkCrcExtra = 137;

  static const int mavlinkEncodedLength = 12;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX epoch time).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_unix_usec
  final uint64_t timeUnixUsec;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  SystemTime({
    required this.timeUnixUsec,
    required this.timeBootMs,
  });

  SystemTime copyWith({
    uint64_t? timeUnixUsec,
    uint32_t? timeBootMs,
  }) {
    return SystemTime(
      timeUnixUsec: timeUnixUsec ?? this.timeUnixUsec,
      timeBootMs: timeBootMs ?? this.timeBootMs,
    );
  }

  factory SystemTime.parse(ByteData data_) {
    if (data_.lengthInBytes < SystemTime.mavlinkEncodedLength) {
      var len = SystemTime.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUnixUsec = data_.getUint64(0, Endian.little);
    var timeBootMs = data_.getUint32(8, Endian.little);

    return SystemTime(timeUnixUsec: timeUnixUsec, timeBootMs: timeBootMs);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUnixUsec, Endian.little);
    data_.setUint32(8, timeBootMs, Endian.little);
    return data_;
  }
}

/// A ping message either requesting or responding to a ping. This allows to measure the system latencies, including serial port, radio modem and UDP connections. The ping microservice is documented at https://mavlink.io/en/services/ping.html
///
/// PING
class Ping implements MavlinkMessage {
  static const int _mavlinkMessageId = 4;

  static const int _mavlinkCrcExtra = 237;

  static const int mavlinkEncodedLength = 14;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// PING sequence
  ///
  /// MAVLink type: uint32_t
  ///
  /// seq
  final uint32_t seq;

  /// 0: request ping from all receiving systems. If greater than 0: message is a ping response and number is the system id of the requesting system
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// 0: request ping from all receiving components. If greater than 0: message is a ping response and number is the component id of the requesting component.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  Ping({
    required this.timeUsec,
    required this.seq,
    required this.targetSystem,
    required this.targetComponent,
  });

  Ping copyWith({
    uint64_t? timeUsec,
    uint32_t? seq,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return Ping(
      timeUsec: timeUsec ?? this.timeUsec,
      seq: seq ?? this.seq,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory Ping.parse(ByteData data_) {
    if (data_.lengthInBytes < Ping.mavlinkEncodedLength) {
      var len = Ping.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var seq = data_.getUint32(8, Endian.little);
    var targetSystem = data_.getUint8(12);
    var targetComponent = data_.getUint8(13);

    return Ping(
        timeUsec: timeUsec,
        seq: seq,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint32(8, seq, Endian.little);
    data_.setUint8(12, targetSystem);
    data_.setUint8(13, targetComponent);
    return data_;
  }
}

/// Request to control this MAV
///
/// CHANGE_OPERATOR_CONTROL
class ChangeOperatorControl implements MavlinkMessage {
  static const int _mavlinkMessageId = 5;

  static const int _mavlinkCrcExtra = 217;

  static const int mavlinkEncodedLength = 28;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System the GCS requests control for
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// 0: request control of this MAV, 1: Release control of this MAV
  ///
  /// MAVLink type: uint8_t
  ///
  /// control_request
  final uint8_t controlRequest;

  /// 0: key as plaintext, 1-255: future, different hashing/encryption variants. The GCS should in general use the safest mode possible initially and then gradually move down the encryption level if it gets a NACK message indicating an encryption mismatch.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: rad
  ///
  /// version
  final uint8_t version;

  /// Password / Key, depending on version plaintext or encrypted. 25 or less characters, NULL terminated. The characters may involve A-Z, a-z, 0-9, and "!?,.-"
  ///
  /// MAVLink type: char[25]
  ///
  /// passkey
  final List<char> passkey;

  ChangeOperatorControl({
    required this.targetSystem,
    required this.controlRequest,
    required this.version,
    required this.passkey,
  });

  ChangeOperatorControl copyWith({
    uint8_t? targetSystem,
    uint8_t? controlRequest,
    uint8_t? version,
    List<char>? passkey,
  }) {
    return ChangeOperatorControl(
      targetSystem: targetSystem ?? this.targetSystem,
      controlRequest: controlRequest ?? this.controlRequest,
      version: version ?? this.version,
      passkey: passkey ?? this.passkey,
    );
  }

  factory ChangeOperatorControl.parse(ByteData data_) {
    if (data_.lengthInBytes < ChangeOperatorControl.mavlinkEncodedLength) {
      var len =
          ChangeOperatorControl.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var controlRequest = data_.getUint8(1);
    var version = data_.getUint8(2);
    var passkey = MavlinkMessage.asInt8List(data_, 3, 25);

    return ChangeOperatorControl(
        targetSystem: targetSystem,
        controlRequest: controlRequest,
        version: version,
        passkey: passkey);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, controlRequest);
    data_.setUint8(2, version);
    MavlinkMessage.setInt8List(data_, 3, passkey);
    return data_;
  }
}

/// Accept / deny control of this MAV
///
/// CHANGE_OPERATOR_CONTROL_ACK
class ChangeOperatorControlAck implements MavlinkMessage {
  static const int _mavlinkMessageId = 6;

  static const int _mavlinkCrcExtra = 104;

  static const int mavlinkEncodedLength = 3;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// ID of the GCS this message
  ///
  /// MAVLink type: uint8_t
  ///
  /// gcs_system_id
  final uint8_t gcsSystemId;

  /// 0: request control of this MAV, 1: Release control of this MAV
  ///
  /// MAVLink type: uint8_t
  ///
  /// control_request
  final uint8_t controlRequest;

  /// 0: ACK, 1: NACK: Wrong passkey, 2: NACK: Unsupported passkey encryption method, 3: NACK: Already under control
  ///
  /// MAVLink type: uint8_t
  ///
  /// ack
  final uint8_t ack;

  ChangeOperatorControlAck({
    required this.gcsSystemId,
    required this.controlRequest,
    required this.ack,
  });

  ChangeOperatorControlAck copyWith({
    uint8_t? gcsSystemId,
    uint8_t? controlRequest,
    uint8_t? ack,
  }) {
    return ChangeOperatorControlAck(
      gcsSystemId: gcsSystemId ?? this.gcsSystemId,
      controlRequest: controlRequest ?? this.controlRequest,
      ack: ack ?? this.ack,
    );
  }

  factory ChangeOperatorControlAck.parse(ByteData data_) {
    if (data_.lengthInBytes < ChangeOperatorControlAck.mavlinkEncodedLength) {
      var len =
          ChangeOperatorControlAck.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var gcsSystemId = data_.getUint8(0);
    var controlRequest = data_.getUint8(1);
    var ack = data_.getUint8(2);

    return ChangeOperatorControlAck(
        gcsSystemId: gcsSystemId, controlRequest: controlRequest, ack: ack);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, gcsSystemId);
    data_.setUint8(1, controlRequest);
    data_.setUint8(2, ack);
    return data_;
  }
}

/// Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple, so transmitting the key requires an encrypted channel for true safety.
///
/// AUTH_KEY
class AuthKey implements MavlinkMessage {
  static const int _mavlinkMessageId = 7;

  static const int _mavlinkCrcExtra = 119;

  static const int mavlinkEncodedLength = 32;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// key
  ///
  /// MAVLink type: char[32]
  ///
  /// key
  final List<char> key;

  AuthKey({
    required this.key,
  });

  AuthKey copyWith({
    List<char>? key,
  }) {
    return AuthKey(
      key: key ?? this.key,
    );
  }

  factory AuthKey.parse(ByteData data_) {
    if (data_.lengthInBytes < AuthKey.mavlinkEncodedLength) {
      var len = AuthKey.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var key = MavlinkMessage.asInt8List(data_, 0, 32);

    return AuthKey(key: key);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setInt8List(data_, 0, key);
    return data_;
  }
}

/// Status generated in each node in the communication chain and injected into MAVLink stream.
///
/// LINK_NODE_STATUS
class LinkNodeStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 8;

  static const int _mavlinkCrcExtra = 117;

  static const int mavlinkEncodedLength = 36;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: ms
  ///
  /// timestamp
  final uint64_t timestamp;

  /// Transmit rate
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bytes/s
  ///
  /// tx_rate
  final uint32_t txRate;

  /// Receive rate
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bytes/s
  ///
  /// rx_rate
  final uint32_t rxRate;

  /// Messages sent
  ///
  /// MAVLink type: uint32_t
  ///
  /// messages_sent
  final uint32_t messagesSent;

  /// Messages received (estimated from counting seq)
  ///
  /// MAVLink type: uint32_t
  ///
  /// messages_received
  final uint32_t messagesReceived;

  /// Messages lost (estimated from counting seq)
  ///
  /// MAVLink type: uint32_t
  ///
  /// messages_lost
  final uint32_t messagesLost;

  /// Number of bytes that could not be parsed correctly.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: bytes
  ///
  /// rx_parse_err
  final uint16_t rxParseErr;

  /// Transmit buffer overflows. This number wraps around as it reaches UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: bytes
  ///
  /// tx_overflows
  final uint16_t txOverflows;

  /// Receive buffer overflows. This number wraps around as it reaches UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: bytes
  ///
  /// rx_overflows
  final uint16_t rxOverflows;

  /// Remaining free transmit buffer space
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// tx_buf
  final uint8_t txBuf;

  /// Remaining free receive buffer space
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// rx_buf
  final uint8_t rxBuf;

  LinkNodeStatus({
    required this.timestamp,
    required this.txRate,
    required this.rxRate,
    required this.messagesSent,
    required this.messagesReceived,
    required this.messagesLost,
    required this.rxParseErr,
    required this.txOverflows,
    required this.rxOverflows,
    required this.txBuf,
    required this.rxBuf,
  });

  LinkNodeStatus copyWith({
    uint64_t? timestamp,
    uint32_t? txRate,
    uint32_t? rxRate,
    uint32_t? messagesSent,
    uint32_t? messagesReceived,
    uint32_t? messagesLost,
    uint16_t? rxParseErr,
    uint16_t? txOverflows,
    uint16_t? rxOverflows,
    uint8_t? txBuf,
    uint8_t? rxBuf,
  }) {
    return LinkNodeStatus(
      timestamp: timestamp ?? this.timestamp,
      txRate: txRate ?? this.txRate,
      rxRate: rxRate ?? this.rxRate,
      messagesSent: messagesSent ?? this.messagesSent,
      messagesReceived: messagesReceived ?? this.messagesReceived,
      messagesLost: messagesLost ?? this.messagesLost,
      rxParseErr: rxParseErr ?? this.rxParseErr,
      txOverflows: txOverflows ?? this.txOverflows,
      rxOverflows: rxOverflows ?? this.rxOverflows,
      txBuf: txBuf ?? this.txBuf,
      rxBuf: rxBuf ?? this.rxBuf,
    );
  }

  factory LinkNodeStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < LinkNodeStatus.mavlinkEncodedLength) {
      var len = LinkNodeStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timestamp = data_.getUint64(0, Endian.little);
    var txRate = data_.getUint32(8, Endian.little);
    var rxRate = data_.getUint32(12, Endian.little);
    var messagesSent = data_.getUint32(16, Endian.little);
    var messagesReceived = data_.getUint32(20, Endian.little);
    var messagesLost = data_.getUint32(24, Endian.little);
    var rxParseErr = data_.getUint16(28, Endian.little);
    var txOverflows = data_.getUint16(30, Endian.little);
    var rxOverflows = data_.getUint16(32, Endian.little);
    var txBuf = data_.getUint8(34);
    var rxBuf = data_.getUint8(35);

    return LinkNodeStatus(
        timestamp: timestamp,
        txRate: txRate,
        rxRate: rxRate,
        messagesSent: messagesSent,
        messagesReceived: messagesReceived,
        messagesLost: messagesLost,
        rxParseErr: rxParseErr,
        txOverflows: txOverflows,
        rxOverflows: rxOverflows,
        txBuf: txBuf,
        rxBuf: rxBuf);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timestamp, Endian.little);
    data_.setUint32(8, txRate, Endian.little);
    data_.setUint32(12, rxRate, Endian.little);
    data_.setUint32(16, messagesSent, Endian.little);
    data_.setUint32(20, messagesReceived, Endian.little);
    data_.setUint32(24, messagesLost, Endian.little);
    data_.setUint16(28, rxParseErr, Endian.little);
    data_.setUint16(30, txOverflows, Endian.little);
    data_.setUint16(32, rxOverflows, Endian.little);
    data_.setUint8(34, txBuf);
    data_.setUint8(35, rxBuf);
    return data_;
  }
}

/// Set the system mode, as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall aircraft, not only for one component.
///
/// SET_MODE
class SetMode implements MavlinkMessage {
  static const int _mavlinkMessageId = 11;

  static const int _mavlinkCrcExtra = 89;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// The new autopilot-specific mode. This field can be ignored by an autopilot.
  ///
  /// MAVLink type: uint32_t
  ///
  /// custom_mode
  final uint32_t customMode;

  /// The system setting the mode
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// The new base mode.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMode]
  ///
  /// base_mode
  final MavMode baseMode;

  SetMode({
    required this.customMode,
    required this.targetSystem,
    required this.baseMode,
  });

  SetMode copyWith({
    uint32_t? customMode,
    uint8_t? targetSystem,
    MavMode? baseMode,
  }) {
    return SetMode(
      customMode: customMode ?? this.customMode,
      targetSystem: targetSystem ?? this.targetSystem,
      baseMode: baseMode ?? this.baseMode,
    );
  }

  factory SetMode.parse(ByteData data_) {
    if (data_.lengthInBytes < SetMode.mavlinkEncodedLength) {
      var len = SetMode.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var customMode = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var baseMode = data_.getUint8(5);

    return SetMode(
        customMode: customMode, targetSystem: targetSystem, baseMode: baseMode);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, customMode, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, baseMode);
    return data_;
  }
}

/// Request to read the onboard parameter with the param_id string id. Onboard parameters are stored as key[const char*] -> value[float]. This allows to send a parameter to any other component (such as the GCS) without the need of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for different autopilots. See also https://mavlink.io/en/services/parameter.html for a full documentation of QGroundControl and IMU code.
///
/// PARAM_REQUEST_READ
class ParamRequestRead implements MavlinkMessage {
  static const int _mavlinkMessageId = 20;

  static const int _mavlinkCrcExtra = 214;

  static const int mavlinkEncodedLength = 20;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored)
  ///
  /// MAVLink type: int16_t
  ///
  /// param_index
  final int16_t paramIndex;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  ParamRequestRead({
    required this.paramIndex,
    required this.targetSystem,
    required this.targetComponent,
    required this.paramId,
  });

  ParamRequestRead copyWith({
    int16_t? paramIndex,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<char>? paramId,
  }) {
    return ParamRequestRead(
      paramIndex: paramIndex ?? this.paramIndex,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      paramId: paramId ?? this.paramId,
    );
  }

  factory ParamRequestRead.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamRequestRead.mavlinkEncodedLength) {
      var len = ParamRequestRead.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var paramIndex = data_.getInt16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);
    var paramId = MavlinkMessage.asInt8List(data_, 4, 16);

    return ParamRequestRead(
        paramIndex: paramIndex,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        paramId: paramId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt16(0, paramIndex, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    MavlinkMessage.setInt8List(data_, 4, paramId);
    return data_;
  }
}

/// Request all parameters of this component. After this request, all parameters are emitted. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html
///
/// PARAM_REQUEST_LIST
class ParamRequestList implements MavlinkMessage {
  static const int _mavlinkMessageId = 21;

  static const int _mavlinkCrcExtra = 159;

  static const int mavlinkEncodedLength = 2;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  ParamRequestList({
    required this.targetSystem,
    required this.targetComponent,
  });

  ParamRequestList copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return ParamRequestList(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory ParamRequestList.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamRequestList.mavlinkEncodedLength) {
      var len = ParamRequestList.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);

    return ParamRequestList(
        targetSystem: targetSystem, targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    return data_;
  }
}

/// Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows him to re-request missing parameters after a loss or timeout. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html
///
/// PARAM_VALUE
class ParamValue implements MavlinkMessage {
  static const int _mavlinkMessageId = 22;

  static const int _mavlinkCrcExtra = 220;

  static const int mavlinkEncodedLength = 25;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Onboard parameter value
  ///
  /// MAVLink type: float
  ///
  /// param_value
  final float paramValue;

  /// Total number of onboard parameters
  ///
  /// MAVLink type: uint16_t
  ///
  /// param_count
  final uint16_t paramCount;

  /// Index of this onboard parameter
  ///
  /// MAVLink type: uint16_t
  ///
  /// param_index
  final uint16_t paramIndex;

  /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  /// Onboard parameter type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavParamType]
  ///
  /// param_type
  final MavParamType paramType;

  ParamValue({
    required this.paramValue,
    required this.paramCount,
    required this.paramIndex,
    required this.paramId,
    required this.paramType,
  });

  ParamValue copyWith({
    float? paramValue,
    uint16_t? paramCount,
    uint16_t? paramIndex,
    List<char>? paramId,
    MavParamType? paramType,
  }) {
    return ParamValue(
      paramValue: paramValue ?? this.paramValue,
      paramCount: paramCount ?? this.paramCount,
      paramIndex: paramIndex ?? this.paramIndex,
      paramId: paramId ?? this.paramId,
      paramType: paramType ?? this.paramType,
    );
  }

  factory ParamValue.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamValue.mavlinkEncodedLength) {
      var len = ParamValue.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var paramValue = data_.getFloat32(0, Endian.little);
    var paramCount = data_.getUint16(4, Endian.little);
    var paramIndex = data_.getUint16(6, Endian.little);
    var paramId = MavlinkMessage.asInt8List(data_, 8, 16);
    var paramType = data_.getUint8(24);

    return ParamValue(
        paramValue: paramValue,
        paramCount: paramCount,
        paramIndex: paramIndex,
        paramId: paramId,
        paramType: paramType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, paramValue, Endian.little);
    data_.setUint16(4, paramCount, Endian.little);
    data_.setUint16(6, paramIndex, Endian.little);
    MavlinkMessage.setInt8List(data_, 8, paramId);
    data_.setUint8(24, paramType);
    return data_;
  }
}

/// Set a parameter value (write new value to permanent storage).
/// The receiving component should acknowledge the new parameter value by broadcasting a PARAM_VALUE message (broadcasting ensures that multiple GCS all have an up-to-date list of all parameters). If the sending GCS did not receive a PARAM_VALUE within its timeout time, it should re-send the PARAM_SET message. The parameter microservice is documented at https://mavlink.io/en/services/parameter.html.
/// PARAM_SET may also be called within the context of a transaction (started with MAV_CMD_PARAM_TRANSACTION). Within a transaction the receiving component should respond with PARAM_ACK_TRANSACTION to the setter component (instead of broadcasting PARAM_VALUE), and PARAM_SET should be re-sent if this is ACK not received.
///
/// PARAM_SET
class ParamSet implements MavlinkMessage {
  static const int _mavlinkMessageId = 23;

  static const int _mavlinkCrcExtra = 168;

  static const int mavlinkEncodedLength = 23;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Onboard parameter value
  ///
  /// MAVLink type: float
  ///
  /// param_value
  final float paramValue;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  /// Onboard parameter type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavParamType]
  ///
  /// param_type
  final MavParamType paramType;

  ParamSet({
    required this.paramValue,
    required this.targetSystem,
    required this.targetComponent,
    required this.paramId,
    required this.paramType,
  });

  ParamSet copyWith({
    float? paramValue,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<char>? paramId,
    MavParamType? paramType,
  }) {
    return ParamSet(
      paramValue: paramValue ?? this.paramValue,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      paramId: paramId ?? this.paramId,
      paramType: paramType ?? this.paramType,
    );
  }

  factory ParamSet.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamSet.mavlinkEncodedLength) {
      var len = ParamSet.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var paramValue = data_.getFloat32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var paramId = MavlinkMessage.asInt8List(data_, 6, 16);
    var paramType = data_.getUint8(22);

    return ParamSet(
        paramValue: paramValue,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        paramId: paramId,
        paramType: paramType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, paramValue, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    MavlinkMessage.setInt8List(data_, 6, paramId);
    data_.setUint8(22, paramType);
    return data_;
  }
}

/// The global position, as returned by the Global Positioning System (GPS). This is
/// NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION_INT for the global position estimate.
///
/// GPS_RAW_INT
class GpsRawInt implements MavlinkMessage {
  static const int _mavlinkMessageId = 24;

  static const int _mavlinkCrcExtra = 24;

  static const int mavlinkEncodedLength = 52;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Latitude (WGS84, EGM96 ellipsoid)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude (WGS84, EGM96 ellipsoid)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude (MSL). Positive for up. Note that virtually all GPS modules provide the MSL altitude in addition to the WGS84 altitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt
  final int32_t alt;

  /// GPS HDOP horizontal dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// eph
  final uint16_t eph;

  /// GPS VDOP vertical dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// epv
  final uint16_t epv;

  /// GPS ground speed. If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// vel
  final uint16_t vel;

  /// Course over ground (NOT heading, but direction of movement) in degrees * 100, 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// cog
  final uint16_t cog;

  /// GPS fix type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GpsFixType]
  ///
  /// fix_type
  final GpsFixType fixType;

  /// Number of satellites visible. If unknown, set to UINT8_MAX
  ///
  /// MAVLink type: uint8_t
  ///
  /// satellites_visible
  final uint8_t satellitesVisible;

  /// Altitude (above WGS84, EGM96 ellipsoid). Positive for up.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// alt_ellipsoid
  final int32_t altEllipsoid;

  /// Position uncertainty.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: mm
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// h_acc
  final uint32_t hAcc;

  /// Altitude uncertainty.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: mm
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// v_acc
  final uint32_t vAcc;

  /// Speed uncertainty.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: mm
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// vel_acc
  final uint32_t velAcc;

  /// Heading / track uncertainty
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: degE5
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// hdg_acc
  final uint32_t hdgAcc;

  /// Yaw in earth frame from north. Use 0 if this GPS does not provide yaw. Use UINT16_MAX if this GPS is configured to provide yaw and is currently unable to provide it. Use 36000 for north.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// yaw
  final uint16_t yaw;

  GpsRawInt({
    required this.timeUsec,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.eph,
    required this.epv,
    required this.vel,
    required this.cog,
    required this.fixType,
    required this.satellitesVisible,
    required this.altEllipsoid,
    required this.hAcc,
    required this.vAcc,
    required this.velAcc,
    required this.hdgAcc,
    required this.yaw,
  });

  GpsRawInt copyWith({
    uint64_t? timeUsec,
    int32_t? lat,
    int32_t? lon,
    int32_t? alt,
    uint16_t? eph,
    uint16_t? epv,
    uint16_t? vel,
    uint16_t? cog,
    GpsFixType? fixType,
    uint8_t? satellitesVisible,
    int32_t? altEllipsoid,
    uint32_t? hAcc,
    uint32_t? vAcc,
    uint32_t? velAcc,
    uint32_t? hdgAcc,
    uint16_t? yaw,
  }) {
    return GpsRawInt(
      timeUsec: timeUsec ?? this.timeUsec,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      eph: eph ?? this.eph,
      epv: epv ?? this.epv,
      vel: vel ?? this.vel,
      cog: cog ?? this.cog,
      fixType: fixType ?? this.fixType,
      satellitesVisible: satellitesVisible ?? this.satellitesVisible,
      altEllipsoid: altEllipsoid ?? this.altEllipsoid,
      hAcc: hAcc ?? this.hAcc,
      vAcc: vAcc ?? this.vAcc,
      velAcc: velAcc ?? this.velAcc,
      hdgAcc: hdgAcc ?? this.hdgAcc,
      yaw: yaw ?? this.yaw,
    );
  }

  factory GpsRawInt.parse(ByteData data_) {
    if (data_.lengthInBytes < GpsRawInt.mavlinkEncodedLength) {
      var len = GpsRawInt.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var lat = data_.getInt32(8, Endian.little);
    var lon = data_.getInt32(12, Endian.little);
    var alt = data_.getInt32(16, Endian.little);
    var eph = data_.getUint16(20, Endian.little);
    var epv = data_.getUint16(22, Endian.little);
    var vel = data_.getUint16(24, Endian.little);
    var cog = data_.getUint16(26, Endian.little);
    var fixType = data_.getUint8(28);
    var satellitesVisible = data_.getUint8(29);
    var altEllipsoid = data_.getInt32(30, Endian.little);
    var hAcc = data_.getUint32(34, Endian.little);
    var vAcc = data_.getUint32(38, Endian.little);
    var velAcc = data_.getUint32(42, Endian.little);
    var hdgAcc = data_.getUint32(46, Endian.little);
    var yaw = data_.getUint16(50, Endian.little);

    return GpsRawInt(
        timeUsec: timeUsec,
        lat: lat,
        lon: lon,
        alt: alt,
        eph: eph,
        epv: epv,
        vel: vel,
        cog: cog,
        fixType: fixType,
        satellitesVisible: satellitesVisible,
        altEllipsoid: altEllipsoid,
        hAcc: hAcc,
        vAcc: vAcc,
        velAcc: velAcc,
        hdgAcc: hdgAcc,
        yaw: yaw);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setInt32(8, lat, Endian.little);
    data_.setInt32(12, lon, Endian.little);
    data_.setInt32(16, alt, Endian.little);
    data_.setUint16(20, eph, Endian.little);
    data_.setUint16(22, epv, Endian.little);
    data_.setUint16(24, vel, Endian.little);
    data_.setUint16(26, cog, Endian.little);
    data_.setUint8(28, fixType);
    data_.setUint8(29, satellitesVisible);
    data_.setInt32(30, altEllipsoid, Endian.little);
    data_.setUint32(34, hAcc, Endian.little);
    data_.setUint32(38, vAcc, Endian.little);
    data_.setUint32(42, velAcc, Endian.little);
    data_.setUint32(46, hdgAcc, Endian.little);
    data_.setUint16(50, yaw, Endian.little);
    return data_;
  }
}

/// The positioning status, as reported by GPS. This message is intended to display status information about each satellite visible to the receiver. See message GLOBAL_POSITION_INT for the global position estimate. This message can contain information for up to 20 satellites.
///
/// GPS_STATUS
class GpsStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 25;

  static const int _mavlinkCrcExtra = 23;

  static const int mavlinkEncodedLength = 101;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Number of satellites visible
  ///
  /// MAVLink type: uint8_t
  ///
  /// satellites_visible
  final uint8_t satellitesVisible;

  /// Global satellite ID
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// satellite_prn
  final List<int8_t> satellitePrn;

  /// 0: Satellite not used, 1: used for localization
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// satellite_used
  final List<int8_t> satelliteUsed;

  /// Elevation (0: right on top of receiver, 90: on the horizon) of satellite
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// units: deg
  ///
  /// satellite_elevation
  final List<int8_t> satelliteElevation;

  /// Direction of satellite, 0: 0 deg, 255: 360 deg.
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// units: deg
  ///
  /// satellite_azimuth
  final List<int8_t> satelliteAzimuth;

  /// Signal to noise ratio of satellite
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// units: dB
  ///
  /// satellite_snr
  final List<int8_t> satelliteSnr;

  GpsStatus({
    required this.satellitesVisible,
    required this.satellitePrn,
    required this.satelliteUsed,
    required this.satelliteElevation,
    required this.satelliteAzimuth,
    required this.satelliteSnr,
  });

  GpsStatus copyWith({
    uint8_t? satellitesVisible,
    List<int8_t>? satellitePrn,
    List<int8_t>? satelliteUsed,
    List<int8_t>? satelliteElevation,
    List<int8_t>? satelliteAzimuth,
    List<int8_t>? satelliteSnr,
  }) {
    return GpsStatus(
      satellitesVisible: satellitesVisible ?? this.satellitesVisible,
      satellitePrn: satellitePrn ?? this.satellitePrn,
      satelliteUsed: satelliteUsed ?? this.satelliteUsed,
      satelliteElevation: satelliteElevation ?? this.satelliteElevation,
      satelliteAzimuth: satelliteAzimuth ?? this.satelliteAzimuth,
      satelliteSnr: satelliteSnr ?? this.satelliteSnr,
    );
  }

  factory GpsStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < GpsStatus.mavlinkEncodedLength) {
      var len = GpsStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var satellitesVisible = data_.getUint8(0);
    var satellitePrn = MavlinkMessage.asUint8List(data_, 1, 20);
    var satelliteUsed = MavlinkMessage.asUint8List(data_, 21, 20);
    var satelliteElevation = MavlinkMessage.asUint8List(data_, 41, 20);
    var satelliteAzimuth = MavlinkMessage.asUint8List(data_, 61, 20);
    var satelliteSnr = MavlinkMessage.asUint8List(data_, 81, 20);

    return GpsStatus(
        satellitesVisible: satellitesVisible,
        satellitePrn: satellitePrn,
        satelliteUsed: satelliteUsed,
        satelliteElevation: satelliteElevation,
        satelliteAzimuth: satelliteAzimuth,
        satelliteSnr: satelliteSnr);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, satellitesVisible);
    MavlinkMessage.setUint8List(data_, 1, satellitePrn);
    MavlinkMessage.setUint8List(data_, 21, satelliteUsed);
    MavlinkMessage.setUint8List(data_, 41, satelliteElevation);
    MavlinkMessage.setUint8List(data_, 61, satelliteAzimuth);
    MavlinkMessage.setUint8List(data_, 81, satelliteSnr);
    return data_;
  }
}

/// The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to the described units
///
/// SCALED_IMU
class ScaledImu implements MavlinkMessage {
  static const int _mavlinkMessageId = 26;

  static const int _mavlinkCrcExtra = 170;

  static const int mavlinkEncodedLength = 24;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// X acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// xacc
  final int16_t xacc;

  /// Y acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// yacc
  final int16_t yacc;

  /// Z acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// zacc
  final int16_t zacc;

  /// Angular speed around X axis
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mrad/s
  ///
  /// xgyro
  final int16_t xgyro;

  /// Angular speed around Y axis
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mrad/s
  ///
  /// ygyro
  final int16_t ygyro;

  /// Angular speed around Z axis
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mrad/s
  ///
  /// zgyro
  final int16_t zgyro;

  /// X Magnetic field
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mgauss
  ///
  /// xmag
  final int16_t xmag;

  /// Y Magnetic field
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mgauss
  ///
  /// ymag
  final int16_t ymag;

  /// Z Magnetic field
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mgauss
  ///
  /// zmag
  final int16_t zmag;

  /// Temperature, 0: IMU does not provide temperature values. If the IMU is at 0C it must send 1 (0.01C).
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// temperature
  final int16_t temperature;

  ScaledImu({
    required this.timeBootMs,
    required this.xacc,
    required this.yacc,
    required this.zacc,
    required this.xgyro,
    required this.ygyro,
    required this.zgyro,
    required this.xmag,
    required this.ymag,
    required this.zmag,
    required this.temperature,
  });

  ScaledImu copyWith({
    uint32_t? timeBootMs,
    int16_t? xacc,
    int16_t? yacc,
    int16_t? zacc,
    int16_t? xgyro,
    int16_t? ygyro,
    int16_t? zgyro,
    int16_t? xmag,
    int16_t? ymag,
    int16_t? zmag,
    int16_t? temperature,
  }) {
    return ScaledImu(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
      xgyro: xgyro ?? this.xgyro,
      ygyro: ygyro ?? this.ygyro,
      zgyro: zgyro ?? this.zgyro,
      xmag: xmag ?? this.xmag,
      ymag: ymag ?? this.ymag,
      zmag: zmag ?? this.zmag,
      temperature: temperature ?? this.temperature,
    );
  }

  factory ScaledImu.parse(ByteData data_) {
    if (data_.lengthInBytes < ScaledImu.mavlinkEncodedLength) {
      var len = ScaledImu.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var xacc = data_.getInt16(4, Endian.little);
    var yacc = data_.getInt16(6, Endian.little);
    var zacc = data_.getInt16(8, Endian.little);
    var xgyro = data_.getInt16(10, Endian.little);
    var ygyro = data_.getInt16(12, Endian.little);
    var zgyro = data_.getInt16(14, Endian.little);
    var xmag = data_.getInt16(16, Endian.little);
    var ymag = data_.getInt16(18, Endian.little);
    var zmag = data_.getInt16(20, Endian.little);
    var temperature = data_.getInt16(22, Endian.little);

    return ScaledImu(
        timeBootMs: timeBootMs,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc,
        xgyro: xgyro,
        ygyro: ygyro,
        zgyro: zgyro,
        xmag: xmag,
        ymag: ymag,
        zmag: zmag,
        temperature: temperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt16(4, xacc, Endian.little);
    data_.setInt16(6, yacc, Endian.little);
    data_.setInt16(8, zacc, Endian.little);
    data_.setInt16(10, xgyro, Endian.little);
    data_.setInt16(12, ygyro, Endian.little);
    data_.setInt16(14, zgyro, Endian.little);
    data_.setInt16(16, xmag, Endian.little);
    data_.setInt16(18, ymag, Endian.little);
    data_.setInt16(20, zmag, Endian.little);
    data_.setInt16(22, temperature, Endian.little);
    return data_;
  }
}

/// The RAW IMU readings for a 9DOF sensor, which is identified by the id (default IMU1). This message should always contain the true raw values without any scaling to allow data capture and system debugging.
///
/// RAW_IMU
class RawImu implements MavlinkMessage {
  static const int _mavlinkMessageId = 27;

  static const int _mavlinkCrcExtra = 144;

  static const int mavlinkEncodedLength = 29;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// X acceleration (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// xacc
  final int16_t xacc;

  /// Y acceleration (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// yacc
  final int16_t yacc;

  /// Z acceleration (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// zacc
  final int16_t zacc;

  /// Angular speed around X axis (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// xgyro
  final int16_t xgyro;

  /// Angular speed around Y axis (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// ygyro
  final int16_t ygyro;

  /// Angular speed around Z axis (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// zgyro
  final int16_t zgyro;

  /// X Magnetic field (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// xmag
  final int16_t xmag;

  /// Y Magnetic field (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// ymag
  final int16_t ymag;

  /// Z Magnetic field (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// zmag
  final int16_t zmag;

  /// Id. Ids are numbered from 0 and map to IMUs numbered from 1 (e.g. IMU1 will have a message with id=0)
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// id
  final uint8_t id;

  /// Temperature, 0: IMU does not provide temperature values. If the IMU is at 0C it must send 1 (0.01C).
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// temperature
  final int16_t temperature;

  RawImu({
    required this.timeUsec,
    required this.xacc,
    required this.yacc,
    required this.zacc,
    required this.xgyro,
    required this.ygyro,
    required this.zgyro,
    required this.xmag,
    required this.ymag,
    required this.zmag,
    required this.id,
    required this.temperature,
  });

  RawImu copyWith({
    uint64_t? timeUsec,
    int16_t? xacc,
    int16_t? yacc,
    int16_t? zacc,
    int16_t? xgyro,
    int16_t? ygyro,
    int16_t? zgyro,
    int16_t? xmag,
    int16_t? ymag,
    int16_t? zmag,
    uint8_t? id,
    int16_t? temperature,
  }) {
    return RawImu(
      timeUsec: timeUsec ?? this.timeUsec,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
      xgyro: xgyro ?? this.xgyro,
      ygyro: ygyro ?? this.ygyro,
      zgyro: zgyro ?? this.zgyro,
      xmag: xmag ?? this.xmag,
      ymag: ymag ?? this.ymag,
      zmag: zmag ?? this.zmag,
      id: id ?? this.id,
      temperature: temperature ?? this.temperature,
    );
  }

  factory RawImu.parse(ByteData data_) {
    if (data_.lengthInBytes < RawImu.mavlinkEncodedLength) {
      var len = RawImu.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var xacc = data_.getInt16(8, Endian.little);
    var yacc = data_.getInt16(10, Endian.little);
    var zacc = data_.getInt16(12, Endian.little);
    var xgyro = data_.getInt16(14, Endian.little);
    var ygyro = data_.getInt16(16, Endian.little);
    var zgyro = data_.getInt16(18, Endian.little);
    var xmag = data_.getInt16(20, Endian.little);
    var ymag = data_.getInt16(22, Endian.little);
    var zmag = data_.getInt16(24, Endian.little);
    var id = data_.getUint8(26);
    var temperature = data_.getInt16(27, Endian.little);

    return RawImu(
        timeUsec: timeUsec,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc,
        xgyro: xgyro,
        ygyro: ygyro,
        zgyro: zgyro,
        xmag: xmag,
        ymag: ymag,
        zmag: zmag,
        id: id,
        temperature: temperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setInt16(8, xacc, Endian.little);
    data_.setInt16(10, yacc, Endian.little);
    data_.setInt16(12, zacc, Endian.little);
    data_.setInt16(14, xgyro, Endian.little);
    data_.setInt16(16, ygyro, Endian.little);
    data_.setInt16(18, zgyro, Endian.little);
    data_.setInt16(20, xmag, Endian.little);
    data_.setInt16(22, ymag, Endian.little);
    data_.setInt16(24, zmag, Endian.little);
    data_.setUint8(26, id);
    data_.setInt16(27, temperature, Endian.little);
    return data_;
  }
}

/// The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure sensor. The sensor values should be the raw, UNSCALED ADC values.
///
/// RAW_PRESSURE
class RawPressure implements MavlinkMessage {
  static const int _mavlinkMessageId = 28;

  static const int _mavlinkCrcExtra = 67;

  static const int mavlinkEncodedLength = 16;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Absolute pressure (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// press_abs
  final int16_t pressAbs;

  /// Differential pressure 1 (raw, 0 if nonexistent)
  ///
  /// MAVLink type: int16_t
  ///
  /// press_diff1
  final int16_t pressDiff1;

  /// Differential pressure 2 (raw, 0 if nonexistent)
  ///
  /// MAVLink type: int16_t
  ///
  /// press_diff2
  final int16_t pressDiff2;

  /// Raw Temperature measurement (raw)
  ///
  /// MAVLink type: int16_t
  ///
  /// temperature
  final int16_t temperature;

  RawPressure({
    required this.timeUsec,
    required this.pressAbs,
    required this.pressDiff1,
    required this.pressDiff2,
    required this.temperature,
  });

  RawPressure copyWith({
    uint64_t? timeUsec,
    int16_t? pressAbs,
    int16_t? pressDiff1,
    int16_t? pressDiff2,
    int16_t? temperature,
  }) {
    return RawPressure(
      timeUsec: timeUsec ?? this.timeUsec,
      pressAbs: pressAbs ?? this.pressAbs,
      pressDiff1: pressDiff1 ?? this.pressDiff1,
      pressDiff2: pressDiff2 ?? this.pressDiff2,
      temperature: temperature ?? this.temperature,
    );
  }

  factory RawPressure.parse(ByteData data_) {
    if (data_.lengthInBytes < RawPressure.mavlinkEncodedLength) {
      var len = RawPressure.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var pressAbs = data_.getInt16(8, Endian.little);
    var pressDiff1 = data_.getInt16(10, Endian.little);
    var pressDiff2 = data_.getInt16(12, Endian.little);
    var temperature = data_.getInt16(14, Endian.little);

    return RawPressure(
        timeUsec: timeUsec,
        pressAbs: pressAbs,
        pressDiff1: pressDiff1,
        pressDiff2: pressDiff2,
        temperature: temperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setInt16(8, pressAbs, Endian.little);
    data_.setInt16(10, pressDiff1, Endian.little);
    data_.setInt16(12, pressDiff2, Endian.little);
    data_.setInt16(14, temperature, Endian.little);
    return data_;
  }
}

/// The pressure readings for the typical setup of one absolute and differential pressure sensor. The units are as specified in each field.
///
/// SCALED_PRESSURE
class ScaledPressure implements MavlinkMessage {
  static const int _mavlinkMessageId = 29;

  static const int _mavlinkCrcExtra = 115;

  static const int mavlinkEncodedLength = 16;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Absolute pressure
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// press_abs
  final float pressAbs;

  /// Differential pressure 1
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// press_diff
  final float pressDiff;

  /// Absolute pressure temperature
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// temperature
  final int16_t temperature;

  /// Differential pressure temperature (0, if not available). Report values of 0 (or 1) as 1 cdegC.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// temperature_press_diff
  final int16_t temperaturePressDiff;

  ScaledPressure({
    required this.timeBootMs,
    required this.pressAbs,
    required this.pressDiff,
    required this.temperature,
    required this.temperaturePressDiff,
  });

  ScaledPressure copyWith({
    uint32_t? timeBootMs,
    float? pressAbs,
    float? pressDiff,
    int16_t? temperature,
    int16_t? temperaturePressDiff,
  }) {
    return ScaledPressure(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      pressAbs: pressAbs ?? this.pressAbs,
      pressDiff: pressDiff ?? this.pressDiff,
      temperature: temperature ?? this.temperature,
      temperaturePressDiff: temperaturePressDiff ?? this.temperaturePressDiff,
    );
  }

  factory ScaledPressure.parse(ByteData data_) {
    if (data_.lengthInBytes < ScaledPressure.mavlinkEncodedLength) {
      var len = ScaledPressure.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var pressAbs = data_.getFloat32(4, Endian.little);
    var pressDiff = data_.getFloat32(8, Endian.little);
    var temperature = data_.getInt16(12, Endian.little);
    var temperaturePressDiff = data_.getInt16(14, Endian.little);

    return ScaledPressure(
        timeBootMs: timeBootMs,
        pressAbs: pressAbs,
        pressDiff: pressDiff,
        temperature: temperature,
        temperaturePressDiff: temperaturePressDiff);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, pressAbs, Endian.little);
    data_.setFloat32(8, pressDiff, Endian.little);
    data_.setInt16(12, temperature, Endian.little);
    data_.setInt16(14, temperaturePressDiff, Endian.little);
    return data_;
  }
}

/// The attitude in the aeronautical frame (right-handed, Z-down, Y-right, X-front, ZYX, intrinsic).
///
/// ATTITUDE
class Attitude implements MavlinkMessage {
  static const int _mavlinkMessageId = 30;

  static const int _mavlinkCrcExtra = 39;

  static const int mavlinkEncodedLength = 28;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Roll angle (-pi..+pi)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch angle (-pi..+pi)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle (-pi..+pi)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Roll angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// rollspeed
  final float rollspeed;

  /// Pitch angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitchspeed
  final float pitchspeed;

  /// Yaw angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yawspeed
  final float yawspeed;

  Attitude({
    required this.timeBootMs,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.rollspeed,
    required this.pitchspeed,
    required this.yawspeed,
  });

  Attitude copyWith({
    uint32_t? timeBootMs,
    float? roll,
    float? pitch,
    float? yaw,
    float? rollspeed,
    float? pitchspeed,
    float? yawspeed,
  }) {
    return Attitude(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      rollspeed: rollspeed ?? this.rollspeed,
      pitchspeed: pitchspeed ?? this.pitchspeed,
      yawspeed: yawspeed ?? this.yawspeed,
    );
  }

  factory Attitude.parse(ByteData data_) {
    if (data_.lengthInBytes < Attitude.mavlinkEncodedLength) {
      var len = Attitude.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var roll = data_.getFloat32(4, Endian.little);
    var pitch = data_.getFloat32(8, Endian.little);
    var yaw = data_.getFloat32(12, Endian.little);
    var rollspeed = data_.getFloat32(16, Endian.little);
    var pitchspeed = data_.getFloat32(20, Endian.little);
    var yawspeed = data_.getFloat32(24, Endian.little);

    return Attitude(
        timeBootMs: timeBootMs,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        rollspeed: rollspeed,
        pitchspeed: pitchspeed,
        yawspeed: yawspeed);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, roll, Endian.little);
    data_.setFloat32(8, pitch, Endian.little);
    data_.setFloat32(12, yaw, Endian.little);
    data_.setFloat32(16, rollspeed, Endian.little);
    data_.setFloat32(20, pitchspeed, Endian.little);
    data_.setFloat32(24, yawspeed, Endian.little);
    return data_;
  }
}

/// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
///
/// ATTITUDE_QUATERNION
class AttitudeQuaternion implements MavlinkMessage {
  static const int _mavlinkMessageId = 31;

  static const int _mavlinkCrcExtra = 246;

  static const int mavlinkEncodedLength = 48;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Quaternion component 1, w (1 in null-rotation)
  ///
  /// MAVLink type: float
  ///
  /// q1
  final float q1;

  /// Quaternion component 2, x (0 in null-rotation)
  ///
  /// MAVLink type: float
  ///
  /// q2
  final float q2;

  /// Quaternion component 3, y (0 in null-rotation)
  ///
  /// MAVLink type: float
  ///
  /// q3
  final float q3;

  /// Quaternion component 4, z (0 in null-rotation)
  ///
  /// MAVLink type: float
  ///
  /// q4
  final float q4;

  /// Roll angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// rollspeed
  final float rollspeed;

  /// Pitch angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitchspeed
  final float pitchspeed;

  /// Yaw angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yawspeed
  final float yawspeed;

  /// Rotation offset by which the attitude quaternion and angular speed vector should be rotated for user display (quaternion with [w, x, y, z] order, zero-rotation is [1, 0, 0, 0], send [0, 0, 0, 0] if field not supported). This field is intended for systems in which the reference attitude may change during flight. For example, tailsitters VTOLs rotate their reference attitude by 90 degrees between hover mode and fixed wing mode, thus repr_offset_q is equal to [1, 0, 0, 0] in hover mode and equal to [0.7071, 0, 0.7071, 0] in fixed wing mode.
  ///
  /// MAVLink type: float[4]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// repr_offset_q
  final List<float> reprOffsetQ;

  AttitudeQuaternion({
    required this.timeBootMs,
    required this.q1,
    required this.q2,
    required this.q3,
    required this.q4,
    required this.rollspeed,
    required this.pitchspeed,
    required this.yawspeed,
    required this.reprOffsetQ,
  });

  AttitudeQuaternion copyWith({
    uint32_t? timeBootMs,
    float? q1,
    float? q2,
    float? q3,
    float? q4,
    float? rollspeed,
    float? pitchspeed,
    float? yawspeed,
    List<float>? reprOffsetQ,
  }) {
    return AttitudeQuaternion(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      q1: q1 ?? this.q1,
      q2: q2 ?? this.q2,
      q3: q3 ?? this.q3,
      q4: q4 ?? this.q4,
      rollspeed: rollspeed ?? this.rollspeed,
      pitchspeed: pitchspeed ?? this.pitchspeed,
      yawspeed: yawspeed ?? this.yawspeed,
      reprOffsetQ: reprOffsetQ ?? this.reprOffsetQ,
    );
  }

  factory AttitudeQuaternion.parse(ByteData data_) {
    if (data_.lengthInBytes < AttitudeQuaternion.mavlinkEncodedLength) {
      var len = AttitudeQuaternion.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var q1 = data_.getFloat32(4, Endian.little);
    var q2 = data_.getFloat32(8, Endian.little);
    var q3 = data_.getFloat32(12, Endian.little);
    var q4 = data_.getFloat32(16, Endian.little);
    var rollspeed = data_.getFloat32(20, Endian.little);
    var pitchspeed = data_.getFloat32(24, Endian.little);
    var yawspeed = data_.getFloat32(28, Endian.little);
    var reprOffsetQ = MavlinkMessage.asFloat32List(data_, 32, 4);

    return AttitudeQuaternion(
        timeBootMs: timeBootMs,
        q1: q1,
        q2: q2,
        q3: q3,
        q4: q4,
        rollspeed: rollspeed,
        pitchspeed: pitchspeed,
        yawspeed: yawspeed,
        reprOffsetQ: reprOffsetQ);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, q1, Endian.little);
    data_.setFloat32(8, q2, Endian.little);
    data_.setFloat32(12, q3, Endian.little);
    data_.setFloat32(16, q4, Endian.little);
    data_.setFloat32(20, rollspeed, Endian.little);
    data_.setFloat32(24, pitchspeed, Endian.little);
    data_.setFloat32(28, yawspeed, Endian.little);
    MavlinkMessage.setFloat32List(data_, 32, reprOffsetQ);
    return data_;
  }
}

/// The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
///
/// LOCAL_POSITION_NED
class LocalPositionNed implements MavlinkMessage {
  static const int _mavlinkMessageId = 32;

  static const int _mavlinkCrcExtra = 185;

  static const int mavlinkEncodedLength = 28;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// X Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Y Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Z Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// X Speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// Y Speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// Z Speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  LocalPositionNed({
    required this.timeBootMs,
    required this.x,
    required this.y,
    required this.z,
    required this.vx,
    required this.vy,
    required this.vz,
  });

  LocalPositionNed copyWith({
    uint32_t? timeBootMs,
    float? x,
    float? y,
    float? z,
    float? vx,
    float? vy,
    float? vz,
  }) {
    return LocalPositionNed(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
    );
  }

  factory LocalPositionNed.parse(ByteData data_) {
    if (data_.lengthInBytes < LocalPositionNed.mavlinkEncodedLength) {
      var len = LocalPositionNed.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var x = data_.getFloat32(4, Endian.little);
    var y = data_.getFloat32(8, Endian.little);
    var z = data_.getFloat32(12, Endian.little);
    var vx = data_.getFloat32(16, Endian.little);
    var vy = data_.getFloat32(20, Endian.little);
    var vz = data_.getFloat32(24, Endian.little);

    return LocalPositionNed(
        timeBootMs: timeBootMs, x: x, y: y, z: z, vx: vx, vy: vy, vz: vz);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, x, Endian.little);
    data_.setFloat32(8, y, Endian.little);
    data_.setFloat32(12, z, Endian.little);
    data_.setFloat32(16, vx, Endian.little);
    data_.setFloat32(20, vy, Endian.little);
    data_.setFloat32(24, vz, Endian.little);
    return data_;
  }
}

/// The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It
/// is designed as scaled integer message since the resolution of float is not sufficient.
///
/// GLOBAL_POSITION_INT
class GlobalPositionInt implements MavlinkMessage {
  static const int _mavlinkMessageId = 33;

  static const int _mavlinkCrcExtra = 104;

  static const int mavlinkEncodedLength = 28;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Latitude, expressed
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude, expressed
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude (MSL). Note that virtually all GPS modules provide both WGS84 and MSL.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt
  final int32_t alt;

  /// Altitude above home
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// relative_alt
  final int32_t relativeAlt;

  /// Ground X Speed (Latitude, positive north)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vx
  final int16_t vx;

  /// Ground Y Speed (Longitude, positive east)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vy
  final int16_t vy;

  /// Ground Z Speed (Altitude, positive down)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vz
  final int16_t vz;

  /// Vehicle heading (yaw angle), 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// hdg
  final uint16_t hdg;

  GlobalPositionInt({
    required this.timeBootMs,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.relativeAlt,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.hdg,
  });

  GlobalPositionInt copyWith({
    uint32_t? timeBootMs,
    int32_t? lat,
    int32_t? lon,
    int32_t? alt,
    int32_t? relativeAlt,
    int16_t? vx,
    int16_t? vy,
    int16_t? vz,
    uint16_t? hdg,
  }) {
    return GlobalPositionInt(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      relativeAlt: relativeAlt ?? this.relativeAlt,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      hdg: hdg ?? this.hdg,
    );
  }

  factory GlobalPositionInt.parse(ByteData data_) {
    if (data_.lengthInBytes < GlobalPositionInt.mavlinkEncodedLength) {
      var len = GlobalPositionInt.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var lat = data_.getInt32(4, Endian.little);
    var lon = data_.getInt32(8, Endian.little);
    var alt = data_.getInt32(12, Endian.little);
    var relativeAlt = data_.getInt32(16, Endian.little);
    var vx = data_.getInt16(20, Endian.little);
    var vy = data_.getInt16(22, Endian.little);
    var vz = data_.getInt16(24, Endian.little);
    var hdg = data_.getUint16(26, Endian.little);

    return GlobalPositionInt(
        timeBootMs: timeBootMs,
        lat: lat,
        lon: lon,
        alt: alt,
        relativeAlt: relativeAlt,
        vx: vx,
        vy: vy,
        vz: vz,
        hdg: hdg);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt32(4, lat, Endian.little);
    data_.setInt32(8, lon, Endian.little);
    data_.setInt32(12, alt, Endian.little);
    data_.setInt32(16, relativeAlt, Endian.little);
    data_.setInt16(20, vx, Endian.little);
    data_.setInt16(22, vy, Endian.little);
    data_.setInt16(24, vz, Endian.little);
    data_.setUint16(26, hdg, Endian.little);
    return data_;
  }
}

/// The scaled values of the RC channels received: (-100%) -10000, (0%) 0, (100%) 10000. Channels that are inactive should be set to INT16_MAX.
///
/// RC_CHANNELS_SCALED
class RcChannelsScaled implements MavlinkMessage {
  static const int _mavlinkMessageId = 34;

  static const int _mavlinkCrcExtra = 237;

  static const int mavlinkEncodedLength = 22;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// RC channel 1 value scaled.
  ///
  /// MAVLink type: int16_t
  ///
  /// chan1_scaled
  final int16_t chan1Scaled;

  /// RC channel 2 value scaled.
  ///
  /// MAVLink type: int16_t
  ///
  /// chan2_scaled
  final int16_t chan2Scaled;

  /// RC channel 3 value scaled.
  ///
  /// MAVLink type: int16_t
  ///
  /// chan3_scaled
  final int16_t chan3Scaled;

  /// RC channel 4 value scaled.
  ///
  /// MAVLink type: int16_t
  ///
  /// chan4_scaled
  final int16_t chan4Scaled;

  /// RC channel 5 value scaled.
  ///
  /// MAVLink type: int16_t
  ///
  /// chan5_scaled
  final int16_t chan5Scaled;

  /// RC channel 6 value scaled.
  ///
  /// MAVLink type: int16_t
  ///
  /// chan6_scaled
  final int16_t chan6Scaled;

  /// RC channel 7 value scaled.
  ///
  /// MAVLink type: int16_t
  ///
  /// chan7_scaled
  final int16_t chan7Scaled;

  /// RC channel 8 value scaled.
  ///
  /// MAVLink type: int16_t
  ///
  /// chan8_scaled
  final int16_t chan8Scaled;

  /// Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.
  ///
  /// MAVLink type: uint8_t
  ///
  /// port
  final uint8_t port;

  /// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rssi
  final uint8_t rssi;

  RcChannelsScaled({
    required this.timeBootMs,
    required this.chan1Scaled,
    required this.chan2Scaled,
    required this.chan3Scaled,
    required this.chan4Scaled,
    required this.chan5Scaled,
    required this.chan6Scaled,
    required this.chan7Scaled,
    required this.chan8Scaled,
    required this.port,
    required this.rssi,
  });

  RcChannelsScaled copyWith({
    uint32_t? timeBootMs,
    int16_t? chan1Scaled,
    int16_t? chan2Scaled,
    int16_t? chan3Scaled,
    int16_t? chan4Scaled,
    int16_t? chan5Scaled,
    int16_t? chan6Scaled,
    int16_t? chan7Scaled,
    int16_t? chan8Scaled,
    uint8_t? port,
    uint8_t? rssi,
  }) {
    return RcChannelsScaled(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      chan1Scaled: chan1Scaled ?? this.chan1Scaled,
      chan2Scaled: chan2Scaled ?? this.chan2Scaled,
      chan3Scaled: chan3Scaled ?? this.chan3Scaled,
      chan4Scaled: chan4Scaled ?? this.chan4Scaled,
      chan5Scaled: chan5Scaled ?? this.chan5Scaled,
      chan6Scaled: chan6Scaled ?? this.chan6Scaled,
      chan7Scaled: chan7Scaled ?? this.chan7Scaled,
      chan8Scaled: chan8Scaled ?? this.chan8Scaled,
      port: port ?? this.port,
      rssi: rssi ?? this.rssi,
    );
  }

  factory RcChannelsScaled.parse(ByteData data_) {
    if (data_.lengthInBytes < RcChannelsScaled.mavlinkEncodedLength) {
      var len = RcChannelsScaled.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var chan1Scaled = data_.getInt16(4, Endian.little);
    var chan2Scaled = data_.getInt16(6, Endian.little);
    var chan3Scaled = data_.getInt16(8, Endian.little);
    var chan4Scaled = data_.getInt16(10, Endian.little);
    var chan5Scaled = data_.getInt16(12, Endian.little);
    var chan6Scaled = data_.getInt16(14, Endian.little);
    var chan7Scaled = data_.getInt16(16, Endian.little);
    var chan8Scaled = data_.getInt16(18, Endian.little);
    var port = data_.getUint8(20);
    var rssi = data_.getUint8(21);

    return RcChannelsScaled(
        timeBootMs: timeBootMs,
        chan1Scaled: chan1Scaled,
        chan2Scaled: chan2Scaled,
        chan3Scaled: chan3Scaled,
        chan4Scaled: chan4Scaled,
        chan5Scaled: chan5Scaled,
        chan6Scaled: chan6Scaled,
        chan7Scaled: chan7Scaled,
        chan8Scaled: chan8Scaled,
        port: port,
        rssi: rssi);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt16(4, chan1Scaled, Endian.little);
    data_.setInt16(6, chan2Scaled, Endian.little);
    data_.setInt16(8, chan3Scaled, Endian.little);
    data_.setInt16(10, chan4Scaled, Endian.little);
    data_.setInt16(12, chan5Scaled, Endian.little);
    data_.setInt16(14, chan6Scaled, Endian.little);
    data_.setInt16(16, chan7Scaled, Endian.little);
    data_.setInt16(18, chan8Scaled, Endian.little);
    data_.setUint8(20, port);
    data_.setUint8(21, rssi);
    return data_;
  }
}

/// The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification.
///
/// RC_CHANNELS_RAW
class RcChannelsRaw implements MavlinkMessage {
  static const int _mavlinkMessageId = 35;

  static const int _mavlinkCrcExtra = 244;

  static const int mavlinkEncodedLength = 22;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// RC channel 1 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan1_raw
  final uint16_t chan1Raw;

  /// RC channel 2 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan2_raw
  final uint16_t chan2Raw;

  /// RC channel 3 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan3_raw
  final uint16_t chan3Raw;

  /// RC channel 4 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan4_raw
  final uint16_t chan4Raw;

  /// RC channel 5 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan5_raw
  final uint16_t chan5Raw;

  /// RC channel 6 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan6_raw
  final uint16_t chan6Raw;

  /// RC channel 7 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan7_raw
  final uint16_t chan7Raw;

  /// RC channel 8 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan8_raw
  final uint16_t chan8Raw;

  /// Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.
  ///
  /// MAVLink type: uint8_t
  ///
  /// port
  final uint8_t port;

  /// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rssi
  final uint8_t rssi;

  RcChannelsRaw({
    required this.timeBootMs,
    required this.chan1Raw,
    required this.chan2Raw,
    required this.chan3Raw,
    required this.chan4Raw,
    required this.chan5Raw,
    required this.chan6Raw,
    required this.chan7Raw,
    required this.chan8Raw,
    required this.port,
    required this.rssi,
  });

  RcChannelsRaw copyWith({
    uint32_t? timeBootMs,
    uint16_t? chan1Raw,
    uint16_t? chan2Raw,
    uint16_t? chan3Raw,
    uint16_t? chan4Raw,
    uint16_t? chan5Raw,
    uint16_t? chan6Raw,
    uint16_t? chan7Raw,
    uint16_t? chan8Raw,
    uint8_t? port,
    uint8_t? rssi,
  }) {
    return RcChannelsRaw(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      chan1Raw: chan1Raw ?? this.chan1Raw,
      chan2Raw: chan2Raw ?? this.chan2Raw,
      chan3Raw: chan3Raw ?? this.chan3Raw,
      chan4Raw: chan4Raw ?? this.chan4Raw,
      chan5Raw: chan5Raw ?? this.chan5Raw,
      chan6Raw: chan6Raw ?? this.chan6Raw,
      chan7Raw: chan7Raw ?? this.chan7Raw,
      chan8Raw: chan8Raw ?? this.chan8Raw,
      port: port ?? this.port,
      rssi: rssi ?? this.rssi,
    );
  }

  factory RcChannelsRaw.parse(ByteData data_) {
    if (data_.lengthInBytes < RcChannelsRaw.mavlinkEncodedLength) {
      var len = RcChannelsRaw.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var chan1Raw = data_.getUint16(4, Endian.little);
    var chan2Raw = data_.getUint16(6, Endian.little);
    var chan3Raw = data_.getUint16(8, Endian.little);
    var chan4Raw = data_.getUint16(10, Endian.little);
    var chan5Raw = data_.getUint16(12, Endian.little);
    var chan6Raw = data_.getUint16(14, Endian.little);
    var chan7Raw = data_.getUint16(16, Endian.little);
    var chan8Raw = data_.getUint16(18, Endian.little);
    var port = data_.getUint8(20);
    var rssi = data_.getUint8(21);

    return RcChannelsRaw(
        timeBootMs: timeBootMs,
        chan1Raw: chan1Raw,
        chan2Raw: chan2Raw,
        chan3Raw: chan3Raw,
        chan4Raw: chan4Raw,
        chan5Raw: chan5Raw,
        chan6Raw: chan6Raw,
        chan7Raw: chan7Raw,
        chan8Raw: chan8Raw,
        port: port,
        rssi: rssi);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint16(4, chan1Raw, Endian.little);
    data_.setUint16(6, chan2Raw, Endian.little);
    data_.setUint16(8, chan3Raw, Endian.little);
    data_.setUint16(10, chan4Raw, Endian.little);
    data_.setUint16(12, chan5Raw, Endian.little);
    data_.setUint16(14, chan6Raw, Endian.little);
    data_.setUint16(16, chan7Raw, Endian.little);
    data_.setUint16(18, chan8Raw, Endian.little);
    data_.setUint8(20, port);
    data_.setUint8(21, rssi);
    return data_;
  }
}

/// Superseded by ACTUATOR_OUTPUT_STATUS. The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.
///
/// SERVO_OUTPUT_RAW
class ServoOutputRaw implements MavlinkMessage {
  static const int _mavlinkMessageId = 36;

  static const int _mavlinkCrcExtra = 222;

  static const int mavlinkEncodedLength = 37;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint32_t timeUsec;

  /// Servo output 1 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// servo1_raw
  final uint16_t servo1Raw;

  /// Servo output 2 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// servo2_raw
  final uint16_t servo2Raw;

  /// Servo output 3 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// servo3_raw
  final uint16_t servo3Raw;

  /// Servo output 4 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// servo4_raw
  final uint16_t servo4Raw;

  /// Servo output 5 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// servo5_raw
  final uint16_t servo5Raw;

  /// Servo output 6 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// servo6_raw
  final uint16_t servo6Raw;

  /// Servo output 7 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// servo7_raw
  final uint16_t servo7Raw;

  /// Servo output 8 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// servo8_raw
  final uint16_t servo8Raw;

  /// Servo output port (set of 8 outputs = 1 port). Flight stacks running on Pixhawk should use: 0 = MAIN, 1 = AUX.
  ///
  /// MAVLink type: uint8_t
  ///
  /// port
  final uint8_t port;

  /// Servo output 9 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// servo9_raw
  final uint16_t servo9Raw;

  /// Servo output 10 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// servo10_raw
  final uint16_t servo10Raw;

  /// Servo output 11 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// servo11_raw
  final uint16_t servo11Raw;

  /// Servo output 12 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// servo12_raw
  final uint16_t servo12Raw;

  /// Servo output 13 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// servo13_raw
  final uint16_t servo13Raw;

  /// Servo output 14 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// servo14_raw
  final uint16_t servo14Raw;

  /// Servo output 15 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// servo15_raw
  final uint16_t servo15Raw;

  /// Servo output 16 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// servo16_raw
  final uint16_t servo16Raw;

  ServoOutputRaw({
    required this.timeUsec,
    required this.servo1Raw,
    required this.servo2Raw,
    required this.servo3Raw,
    required this.servo4Raw,
    required this.servo5Raw,
    required this.servo6Raw,
    required this.servo7Raw,
    required this.servo8Raw,
    required this.port,
    required this.servo9Raw,
    required this.servo10Raw,
    required this.servo11Raw,
    required this.servo12Raw,
    required this.servo13Raw,
    required this.servo14Raw,
    required this.servo15Raw,
    required this.servo16Raw,
  });

  ServoOutputRaw copyWith({
    uint32_t? timeUsec,
    uint16_t? servo1Raw,
    uint16_t? servo2Raw,
    uint16_t? servo3Raw,
    uint16_t? servo4Raw,
    uint16_t? servo5Raw,
    uint16_t? servo6Raw,
    uint16_t? servo7Raw,
    uint16_t? servo8Raw,
    uint8_t? port,
    uint16_t? servo9Raw,
    uint16_t? servo10Raw,
    uint16_t? servo11Raw,
    uint16_t? servo12Raw,
    uint16_t? servo13Raw,
    uint16_t? servo14Raw,
    uint16_t? servo15Raw,
    uint16_t? servo16Raw,
  }) {
    return ServoOutputRaw(
      timeUsec: timeUsec ?? this.timeUsec,
      servo1Raw: servo1Raw ?? this.servo1Raw,
      servo2Raw: servo2Raw ?? this.servo2Raw,
      servo3Raw: servo3Raw ?? this.servo3Raw,
      servo4Raw: servo4Raw ?? this.servo4Raw,
      servo5Raw: servo5Raw ?? this.servo5Raw,
      servo6Raw: servo6Raw ?? this.servo6Raw,
      servo7Raw: servo7Raw ?? this.servo7Raw,
      servo8Raw: servo8Raw ?? this.servo8Raw,
      port: port ?? this.port,
      servo9Raw: servo9Raw ?? this.servo9Raw,
      servo10Raw: servo10Raw ?? this.servo10Raw,
      servo11Raw: servo11Raw ?? this.servo11Raw,
      servo12Raw: servo12Raw ?? this.servo12Raw,
      servo13Raw: servo13Raw ?? this.servo13Raw,
      servo14Raw: servo14Raw ?? this.servo14Raw,
      servo15Raw: servo15Raw ?? this.servo15Raw,
      servo16Raw: servo16Raw ?? this.servo16Raw,
    );
  }

  factory ServoOutputRaw.parse(ByteData data_) {
    if (data_.lengthInBytes < ServoOutputRaw.mavlinkEncodedLength) {
      var len = ServoOutputRaw.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint32(0, Endian.little);
    var servo1Raw = data_.getUint16(4, Endian.little);
    var servo2Raw = data_.getUint16(6, Endian.little);
    var servo3Raw = data_.getUint16(8, Endian.little);
    var servo4Raw = data_.getUint16(10, Endian.little);
    var servo5Raw = data_.getUint16(12, Endian.little);
    var servo6Raw = data_.getUint16(14, Endian.little);
    var servo7Raw = data_.getUint16(16, Endian.little);
    var servo8Raw = data_.getUint16(18, Endian.little);
    var port = data_.getUint8(20);
    var servo9Raw = data_.getUint16(21, Endian.little);
    var servo10Raw = data_.getUint16(23, Endian.little);
    var servo11Raw = data_.getUint16(25, Endian.little);
    var servo12Raw = data_.getUint16(27, Endian.little);
    var servo13Raw = data_.getUint16(29, Endian.little);
    var servo14Raw = data_.getUint16(31, Endian.little);
    var servo15Raw = data_.getUint16(33, Endian.little);
    var servo16Raw = data_.getUint16(35, Endian.little);

    return ServoOutputRaw(
        timeUsec: timeUsec,
        servo1Raw: servo1Raw,
        servo2Raw: servo2Raw,
        servo3Raw: servo3Raw,
        servo4Raw: servo4Raw,
        servo5Raw: servo5Raw,
        servo6Raw: servo6Raw,
        servo7Raw: servo7Raw,
        servo8Raw: servo8Raw,
        port: port,
        servo9Raw: servo9Raw,
        servo10Raw: servo10Raw,
        servo11Raw: servo11Raw,
        servo12Raw: servo12Raw,
        servo13Raw: servo13Raw,
        servo14Raw: servo14Raw,
        servo15Raw: servo15Raw,
        servo16Raw: servo16Raw);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeUsec, Endian.little);
    data_.setUint16(4, servo1Raw, Endian.little);
    data_.setUint16(6, servo2Raw, Endian.little);
    data_.setUint16(8, servo3Raw, Endian.little);
    data_.setUint16(10, servo4Raw, Endian.little);
    data_.setUint16(12, servo5Raw, Endian.little);
    data_.setUint16(14, servo6Raw, Endian.little);
    data_.setUint16(16, servo7Raw, Endian.little);
    data_.setUint16(18, servo8Raw, Endian.little);
    data_.setUint8(20, port);
    data_.setUint16(21, servo9Raw, Endian.little);
    data_.setUint16(23, servo10Raw, Endian.little);
    data_.setUint16(25, servo11Raw, Endian.little);
    data_.setUint16(27, servo12Raw, Endian.little);
    data_.setUint16(29, servo13Raw, Endian.little);
    data_.setUint16(31, servo14Raw, Endian.little);
    data_.setUint16(33, servo15Raw, Endian.little);
    data_.setUint16(35, servo16Raw, Endian.little);
    return data_;
  }
}

/// Request a partial list of mission items from the system/component. https://mavlink.io/en/services/mission.html. If start and end index are the same, just send one waypoint.
///
/// MISSION_REQUEST_PARTIAL_LIST
class MissionRequestPartialList implements MavlinkMessage {
  static const int _mavlinkMessageId = 37;

  static const int _mavlinkCrcExtra = 212;

  static const int mavlinkEncodedLength = 7;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Start index
  ///
  /// MAVLink type: int16_t
  ///
  /// start_index
  final int16_t startIndex;

  /// End index, -1 by default (-1: send list to end). Else a valid index of the list
  ///
  /// MAVLink type: int16_t
  ///
  /// end_index
  final int16_t endIndex;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  MissionRequestPartialList({
    required this.startIndex,
    required this.endIndex,
    required this.targetSystem,
    required this.targetComponent,
    required this.missionType,
  });

  MissionRequestPartialList copyWith({
    int16_t? startIndex,
    int16_t? endIndex,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMissionType? missionType,
  }) {
    return MissionRequestPartialList(
      startIndex: startIndex ?? this.startIndex,
      endIndex: endIndex ?? this.endIndex,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      missionType: missionType ?? this.missionType,
    );
  }

  factory MissionRequestPartialList.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionRequestPartialList.mavlinkEncodedLength) {
      var len =
          MissionRequestPartialList.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var startIndex = data_.getInt16(0, Endian.little);
    var endIndex = data_.getInt16(2, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var missionType = data_.getUint8(6);

    return MissionRequestPartialList(
        startIndex: startIndex,
        endIndex: endIndex,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        missionType: missionType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt16(0, startIndex, Endian.little);
    data_.setInt16(2, endIndex, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, missionType);
    return data_;
  }
}

/// This message is sent to the MAV to write a partial list. If start index == end index, only one item will be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should be REJECTED!
///
/// MISSION_WRITE_PARTIAL_LIST
class MissionWritePartialList implements MavlinkMessage {
  static const int _mavlinkMessageId = 38;

  static const int _mavlinkCrcExtra = 9;

  static const int mavlinkEncodedLength = 7;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Start index. Must be smaller / equal to the largest index of the current onboard list.
  ///
  /// MAVLink type: int16_t
  ///
  /// start_index
  final int16_t startIndex;

  /// End index, equal or greater than start index.
  ///
  /// MAVLink type: int16_t
  ///
  /// end_index
  final int16_t endIndex;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  MissionWritePartialList({
    required this.startIndex,
    required this.endIndex,
    required this.targetSystem,
    required this.targetComponent,
    required this.missionType,
  });

  MissionWritePartialList copyWith({
    int16_t? startIndex,
    int16_t? endIndex,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMissionType? missionType,
  }) {
    return MissionWritePartialList(
      startIndex: startIndex ?? this.startIndex,
      endIndex: endIndex ?? this.endIndex,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      missionType: missionType ?? this.missionType,
    );
  }

  factory MissionWritePartialList.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionWritePartialList.mavlinkEncodedLength) {
      var len =
          MissionWritePartialList.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var startIndex = data_.getInt16(0, Endian.little);
    var endIndex = data_.getInt16(2, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var missionType = data_.getUint8(6);

    return MissionWritePartialList(
        startIndex: startIndex,
        endIndex: endIndex,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        missionType: missionType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt16(0, startIndex, Endian.little);
    data_.setInt16(2, endIndex, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, missionType);
    return data_;
  }
}

/// Message encoding a mission item. This message is emitted to announce
/// the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN may be used to indicate an optional/default value (e.g. to use the system's current latitude or yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html.
///
/// MISSION_ITEM
class MissionItem implements MavlinkMessage {
  static const int _mavlinkMessageId = 39;

  static const int _mavlinkCrcExtra = 254;

  static const int mavlinkEncodedLength = 38;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// PARAM1, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param1
  final float param1;

  /// PARAM2, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param2
  final float param2;

  /// PARAM3, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param3
  final float param3;

  /// PARAM4, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param4
  final float param4;

  /// PARAM5 / local: X coordinate, global: latitude
  ///
  /// MAVLink type: float
  ///
  /// x
  final float x;

  /// PARAM6 / local: Y coordinate, global: longitude
  ///
  /// MAVLink type: float
  ///
  /// y
  final float y;

  /// PARAM7 / local: Z coordinate, global: altitude (relative or absolute, depending on frame).
  ///
  /// MAVLink type: float
  ///
  /// z
  final float z;

  /// Sequence
  ///
  /// MAVLink type: uint16_t
  ///
  /// seq
  final uint16_t seq;

  /// The scheduled action for the waypoint.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavCmd]
  ///
  /// command
  final MavCmd command;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// The coordinate system of the waypoint.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// frame
  final MavFrame frame;

  /// false:0, true:1
  ///
  /// MAVLink type: uint8_t
  ///
  /// current
  final uint8_t current;

  /// Autocontinue to next waypoint. 0: false, 1: true. Set false to pause mission after the item completes.
  ///
  /// MAVLink type: uint8_t
  ///
  /// autocontinue
  final uint8_t autocontinue;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  MissionItem({
    required this.param1,
    required this.param2,
    required this.param3,
    required this.param4,
    required this.x,
    required this.y,
    required this.z,
    required this.seq,
    required this.command,
    required this.targetSystem,
    required this.targetComponent,
    required this.frame,
    required this.current,
    required this.autocontinue,
    required this.missionType,
  });

  MissionItem copyWith({
    float? param1,
    float? param2,
    float? param3,
    float? param4,
    float? x,
    float? y,
    float? z,
    uint16_t? seq,
    MavCmd? command,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavFrame? frame,
    uint8_t? current,
    uint8_t? autocontinue,
    MavMissionType? missionType,
  }) {
    return MissionItem(
      param1: param1 ?? this.param1,
      param2: param2 ?? this.param2,
      param3: param3 ?? this.param3,
      param4: param4 ?? this.param4,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      seq: seq ?? this.seq,
      command: command ?? this.command,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      frame: frame ?? this.frame,
      current: current ?? this.current,
      autocontinue: autocontinue ?? this.autocontinue,
      missionType: missionType ?? this.missionType,
    );
  }

  factory MissionItem.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionItem.mavlinkEncodedLength) {
      var len = MissionItem.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var param1 = data_.getFloat32(0, Endian.little);
    var param2 = data_.getFloat32(4, Endian.little);
    var param3 = data_.getFloat32(8, Endian.little);
    var param4 = data_.getFloat32(12, Endian.little);
    var x = data_.getFloat32(16, Endian.little);
    var y = data_.getFloat32(20, Endian.little);
    var z = data_.getFloat32(24, Endian.little);
    var seq = data_.getUint16(28, Endian.little);
    var command = data_.getUint16(30, Endian.little);
    var targetSystem = data_.getUint8(32);
    var targetComponent = data_.getUint8(33);
    var frame = data_.getUint8(34);
    var current = data_.getUint8(35);
    var autocontinue = data_.getUint8(36);
    var missionType = data_.getUint8(37);

    return MissionItem(
        param1: param1,
        param2: param2,
        param3: param3,
        param4: param4,
        x: x,
        y: y,
        z: z,
        seq: seq,
        command: command,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        frame: frame,
        current: current,
        autocontinue: autocontinue,
        missionType: missionType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, param1, Endian.little);
    data_.setFloat32(4, param2, Endian.little);
    data_.setFloat32(8, param3, Endian.little);
    data_.setFloat32(12, param4, Endian.little);
    data_.setFloat32(16, x, Endian.little);
    data_.setFloat32(20, y, Endian.little);
    data_.setFloat32(24, z, Endian.little);
    data_.setUint16(28, seq, Endian.little);
    data_.setUint16(30, command, Endian.little);
    data_.setUint8(32, targetSystem);
    data_.setUint8(33, targetComponent);
    data_.setUint8(34, frame);
    data_.setUint8(35, current);
    data_.setUint8(36, autocontinue);
    data_.setUint8(37, missionType);
    return data_;
  }
}

/// Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM message. https://mavlink.io/en/services/mission.html
///
/// MISSION_REQUEST
class MissionRequest implements MavlinkMessage {
  static const int _mavlinkMessageId = 40;

  static const int _mavlinkCrcExtra = 230;

  static const int mavlinkEncodedLength = 5;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Sequence
  ///
  /// MAVLink type: uint16_t
  ///
  /// seq
  final uint16_t seq;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  MissionRequest({
    required this.seq,
    required this.targetSystem,
    required this.targetComponent,
    required this.missionType,
  });

  MissionRequest copyWith({
    uint16_t? seq,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMissionType? missionType,
  }) {
    return MissionRequest(
      seq: seq ?? this.seq,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      missionType: missionType ?? this.missionType,
    );
  }

  factory MissionRequest.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionRequest.mavlinkEncodedLength) {
      var len = MissionRequest.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var seq = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);
    var missionType = data_.getUint8(4);

    return MissionRequest(
        seq: seq,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        missionType: missionType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, seq, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    data_.setUint8(4, missionType);
    return data_;
  }
}

///
/// Set the mission item with sequence number seq as the current item and emit MISSION_CURRENT (whether or not the mission number changed).
/// If a mission is currently being executed, the system will continue to this new mission item on the shortest path, skipping any intermediate mission items.
/// Note that mission jump repeat counters are not reset (see MAV_CMD_DO_JUMP param2).
///
/// This message may trigger a mission state-machine change on some systems: for example from MISSION_STATE_NOT_STARTED or MISSION_STATE_PAUSED to MISSION_STATE_ACTIVE.
/// If the system is in mission mode, on those systems this command might therefore start, restart or resume the mission.
/// If the system is not in mission mode this message must not trigger a switch to mission mode.
///
///
/// MISSION_SET_CURRENT
class MissionSetCurrent implements MavlinkMessage {
  static const int _mavlinkMessageId = 41;

  static const int _mavlinkCrcExtra = 28;

  static const int mavlinkEncodedLength = 4;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Sequence
  ///
  /// MAVLink type: uint16_t
  ///
  /// seq
  final uint16_t seq;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  MissionSetCurrent({
    required this.seq,
    required this.targetSystem,
    required this.targetComponent,
  });

  MissionSetCurrent copyWith({
    uint16_t? seq,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return MissionSetCurrent(
      seq: seq ?? this.seq,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory MissionSetCurrent.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionSetCurrent.mavlinkEncodedLength) {
      var len = MissionSetCurrent.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var seq = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);

    return MissionSetCurrent(
        seq: seq, targetSystem: targetSystem, targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, seq, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    return data_;
  }
}

///
/// Message that announces the sequence number of the current target mission item (that the system will fly towards/execute when the mission is running).
/// This message should be streamed all the time (nominally at 1Hz).
/// This message should be emitted following a call to MAV_CMD_DO_SET_MISSION_CURRENT or SET_MISSION_CURRENT.
///
///
/// MISSION_CURRENT
class MissionCurrent implements MavlinkMessage {
  static const int _mavlinkMessageId = 42;

  static const int _mavlinkCrcExtra = 28;

  static const int mavlinkEncodedLength = 18;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Sequence
  ///
  /// MAVLink type: uint16_t
  ///
  /// seq
  final uint16_t seq;

  /// Total number of mission items on vehicle (on last item, sequence == total). If the autopilot stores its home location as part of the mission this will be excluded from the total. 0: Not supported, UINT16_MAX if no mission is present on the vehicle.
  ///
  /// MAVLink type: uint16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// total
  final uint16_t total;

  /// Mission state machine state. MISSION_STATE_UNKNOWN if state reporting not supported.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MissionState]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_state
  final MissionState missionState;

  /// Vehicle is in a mode that can execute mission items or suspended. 0: Unknown, 1: In mission mode, 2: Suspended (not in mission mode).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_mode
  final uint8_t missionMode;

  /// Id of current on-vehicle mission plan, or 0 if IDs are not supported or there is no mission loaded. GCS can use this to track changes to the mission plan type. The same value is returned on mission upload (in the MISSION_ACK).
  ///
  /// MAVLink type: uint32_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_id
  final uint32_t missionId;

  /// Id of current on-vehicle fence plan, or 0 if IDs are not supported or there is no fence loaded. GCS can use this to track changes to the fence plan type. The same value is returned on fence upload (in the MISSION_ACK).
  ///
  /// MAVLink type: uint32_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// fence_id
  final uint32_t fenceId;

  /// Id of current on-vehicle rally point plan, or 0 if IDs are not supported or there are no rally points loaded. GCS can use this to track changes to the rally point plan type. The same value is returned on rally point upload (in the MISSION_ACK).
  ///
  /// MAVLink type: uint32_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// rally_points_id
  final uint32_t rallyPointsId;

  MissionCurrent({
    required this.seq,
    required this.total,
    required this.missionState,
    required this.missionMode,
    required this.missionId,
    required this.fenceId,
    required this.rallyPointsId,
  });

  MissionCurrent copyWith({
    uint16_t? seq,
    uint16_t? total,
    MissionState? missionState,
    uint8_t? missionMode,
    uint32_t? missionId,
    uint32_t? fenceId,
    uint32_t? rallyPointsId,
  }) {
    return MissionCurrent(
      seq: seq ?? this.seq,
      total: total ?? this.total,
      missionState: missionState ?? this.missionState,
      missionMode: missionMode ?? this.missionMode,
      missionId: missionId ?? this.missionId,
      fenceId: fenceId ?? this.fenceId,
      rallyPointsId: rallyPointsId ?? this.rallyPointsId,
    );
  }

  factory MissionCurrent.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionCurrent.mavlinkEncodedLength) {
      var len = MissionCurrent.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var seq = data_.getUint16(0, Endian.little);
    var total = data_.getUint16(2, Endian.little);
    var missionState = data_.getUint8(4);
    var missionMode = data_.getUint8(5);
    var missionId = data_.getUint32(6, Endian.little);
    var fenceId = data_.getUint32(10, Endian.little);
    var rallyPointsId = data_.getUint32(14, Endian.little);

    return MissionCurrent(
        seq: seq,
        total: total,
        missionState: missionState,
        missionMode: missionMode,
        missionId: missionId,
        fenceId: fenceId,
        rallyPointsId: rallyPointsId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, seq, Endian.little);
    data_.setUint16(2, total, Endian.little);
    data_.setUint8(4, missionState);
    data_.setUint8(5, missionMode);
    data_.setUint32(6, missionId, Endian.little);
    data_.setUint32(10, fenceId, Endian.little);
    data_.setUint32(14, rallyPointsId, Endian.little);
    return data_;
  }
}

/// Request the overall list of mission items from the system/component.
///
/// MISSION_REQUEST_LIST
class MissionRequestList implements MavlinkMessage {
  static const int _mavlinkMessageId = 43;

  static const int _mavlinkCrcExtra = 132;

  static const int mavlinkEncodedLength = 3;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  MissionRequestList({
    required this.targetSystem,
    required this.targetComponent,
    required this.missionType,
  });

  MissionRequestList copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMissionType? missionType,
  }) {
    return MissionRequestList(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      missionType: missionType ?? this.missionType,
    );
  }

  factory MissionRequestList.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionRequestList.mavlinkEncodedLength) {
      var len = MissionRequestList.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var missionType = data_.getUint8(2);

    return MissionRequestList(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        missionType: missionType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, missionType);
    return data_;
  }
}

/// This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction. The GCS can then request the individual mission item based on the knowledge of the total number of waypoints.
///
/// MISSION_COUNT
class MissionCount implements MavlinkMessage {
  static const int _mavlinkMessageId = 44;

  static const int _mavlinkCrcExtra = 221;

  static const int mavlinkEncodedLength = 9;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Number of mission items in the sequence
  ///
  /// MAVLink type: uint16_t
  ///
  /// count
  final uint16_t count;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  /// Id of current on-vehicle mission, fence, or rally point plan (on download from vehicle).
  /// This field is used when downloading a plan from a vehicle to a GCS.
  /// 0 on upload to the vehicle from GCS.
  /// 0 if plan ids are not supported.
  /// The current on-vehicle plan ids are streamed in `MISSION_CURRENT`, allowing a GCS to determine if any part of the plan has changed and needs to be re-uploaded.
  /// The ids are recalculated by the vehicle when any part of the on-vehicle plan changes (when a new plan is uploaded, the vehicle returns the new id to the GCS in MISSION_ACK).
  ///
  ///
  /// MAVLink type: uint32_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// opaque_id
  final uint32_t opaqueId;

  MissionCount({
    required this.count,
    required this.targetSystem,
    required this.targetComponent,
    required this.missionType,
    required this.opaqueId,
  });

  MissionCount copyWith({
    uint16_t? count,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMissionType? missionType,
    uint32_t? opaqueId,
  }) {
    return MissionCount(
      count: count ?? this.count,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      missionType: missionType ?? this.missionType,
      opaqueId: opaqueId ?? this.opaqueId,
    );
  }

  factory MissionCount.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionCount.mavlinkEncodedLength) {
      var len = MissionCount.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var count = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);
    var missionType = data_.getUint8(4);
    var opaqueId = data_.getUint32(5, Endian.little);

    return MissionCount(
        count: count,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        missionType: missionType,
        opaqueId: opaqueId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, count, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    data_.setUint8(4, missionType);
    data_.setUint32(5, opaqueId, Endian.little);
    return data_;
  }
}

/// Delete all mission items at once.
///
/// MISSION_CLEAR_ALL
class MissionClearAll implements MavlinkMessage {
  static const int _mavlinkMessageId = 45;

  static const int _mavlinkCrcExtra = 232;

  static const int mavlinkEncodedLength = 3;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  MissionClearAll({
    required this.targetSystem,
    required this.targetComponent,
    required this.missionType,
  });

  MissionClearAll copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMissionType? missionType,
  }) {
    return MissionClearAll(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      missionType: missionType ?? this.missionType,
    );
  }

  factory MissionClearAll.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionClearAll.mavlinkEncodedLength) {
      var len = MissionClearAll.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var missionType = data_.getUint8(2);

    return MissionClearAll(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        missionType: missionType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, missionType);
    return data_;
  }
}

/// A certain mission item has been reached. The system will either hold this position (or circle on the orbit) or (if the autocontinue on the WP was set) continue to the next waypoint.
///
/// MISSION_ITEM_REACHED
class MissionItemReached implements MavlinkMessage {
  static const int _mavlinkMessageId = 46;

  static const int _mavlinkCrcExtra = 11;

  static const int mavlinkEncodedLength = 2;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Sequence
  ///
  /// MAVLink type: uint16_t
  ///
  /// seq
  final uint16_t seq;

  MissionItemReached({
    required this.seq,
  });

  MissionItemReached copyWith({
    uint16_t? seq,
  }) {
    return MissionItemReached(
      seq: seq ?? this.seq,
    );
  }

  factory MissionItemReached.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionItemReached.mavlinkEncodedLength) {
      var len = MissionItemReached.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var seq = data_.getUint16(0, Endian.little);

    return MissionItemReached(seq: seq);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, seq, Endian.little);
    return data_;
  }
}

/// Acknowledgment message during waypoint handling. The type field states if this message is a positive ack (type=0) or if an error happened (type=non-zero).
///
/// MISSION_ACK
class MissionAck implements MavlinkMessage {
  static const int _mavlinkMessageId = 47;

  static const int _mavlinkCrcExtra = 153;

  static const int mavlinkEncodedLength = 8;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mission result.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionResult]
  ///
  /// type
  final MavMissionResult type;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  /// Id of new on-vehicle mission, fence, or rally point plan (on upload to vehicle).
  /// The id is calculated and returned by a vehicle when a new plan is uploaded by a GCS.
  /// The only requirement on the id is that it must change when there is any change to the on-vehicle plan type (there is no requirement that the id be globally unique).
  /// 0 on download from the vehicle to the GCS (on download the ID is set in MISSION_COUNT).
  /// 0 if plan ids are not supported.
  /// The current on-vehicle plan ids are streamed in `MISSION_CURRENT`, allowing a GCS to determine if any part of the plan has changed and needs to be re-uploaded.
  ///
  ///
  /// MAVLink type: uint32_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// opaque_id
  final uint32_t opaqueId;

  MissionAck({
    required this.targetSystem,
    required this.targetComponent,
    required this.type,
    required this.missionType,
    required this.opaqueId,
  });

  MissionAck copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMissionResult? type,
    MavMissionType? missionType,
    uint32_t? opaqueId,
  }) {
    return MissionAck(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      type: type ?? this.type,
      missionType: missionType ?? this.missionType,
      opaqueId: opaqueId ?? this.opaqueId,
    );
  }

  factory MissionAck.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionAck.mavlinkEncodedLength) {
      var len = MissionAck.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var type = data_.getUint8(2);
    var missionType = data_.getUint8(3);
    var opaqueId = data_.getUint32(4, Endian.little);

    return MissionAck(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        type: type,
        missionType: missionType,
        opaqueId: opaqueId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, type);
    data_.setUint8(3, missionType);
    data_.setUint32(4, opaqueId, Endian.little);
    return data_;
  }
}

/// Sets the GPS coordinates of the vehicle local origin (0,0,0) position. Vehicle should emit GPS_GLOBAL_ORIGIN irrespective of whether the origin is changed. This enables transform between the local coordinate frame and the global (GPS) coordinate frame, which may be necessary when (for example) indoor and outdoor settings are connected and the MAV should move from in- to outdoor.
///
/// SET_GPS_GLOBAL_ORIGIN
class SetGpsGlobalOrigin implements MavlinkMessage {
  static const int _mavlinkMessageId = 48;

  static const int _mavlinkCrcExtra = 41;

  static const int mavlinkEncodedLength = 21;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// latitude
  final int32_t latitude;

  /// Longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// longitude
  final int32_t longitude;

  /// Altitude (MSL). Positive for up.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// altitude
  final int32_t altitude;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// time_usec
  final uint64_t timeUsec;

  SetGpsGlobalOrigin({
    required this.latitude,
    required this.longitude,
    required this.altitude,
    required this.targetSystem,
    required this.timeUsec,
  });

  SetGpsGlobalOrigin copyWith({
    int32_t? latitude,
    int32_t? longitude,
    int32_t? altitude,
    uint8_t? targetSystem,
    uint64_t? timeUsec,
  }) {
    return SetGpsGlobalOrigin(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      altitude: altitude ?? this.altitude,
      targetSystem: targetSystem ?? this.targetSystem,
      timeUsec: timeUsec ?? this.timeUsec,
    );
  }

  factory SetGpsGlobalOrigin.parse(ByteData data_) {
    if (data_.lengthInBytes < SetGpsGlobalOrigin.mavlinkEncodedLength) {
      var len = SetGpsGlobalOrigin.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var latitude = data_.getInt32(0, Endian.little);
    var longitude = data_.getInt32(4, Endian.little);
    var altitude = data_.getInt32(8, Endian.little);
    var targetSystem = data_.getUint8(12);
    var timeUsec = data_.getUint64(13, Endian.little);

    return SetGpsGlobalOrigin(
        latitude: latitude,
        longitude: longitude,
        altitude: altitude,
        targetSystem: targetSystem,
        timeUsec: timeUsec);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, latitude, Endian.little);
    data_.setInt32(4, longitude, Endian.little);
    data_.setInt32(8, altitude, Endian.little);
    data_.setUint8(12, targetSystem);
    data_.setUint64(13, timeUsec, Endian.little);
    return data_;
  }
}

/// Publishes the GPS coordinates of the vehicle local origin (0,0,0) position. Emitted whenever a new GPS-Local position mapping is requested or set - e.g. following SET_GPS_GLOBAL_ORIGIN message.
///
/// GPS_GLOBAL_ORIGIN
class GpsGlobalOrigin implements MavlinkMessage {
  static const int _mavlinkMessageId = 49;

  static const int _mavlinkCrcExtra = 39;

  static const int mavlinkEncodedLength = 20;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// latitude
  final int32_t latitude;

  /// Longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// longitude
  final int32_t longitude;

  /// Altitude (MSL). Positive for up.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// altitude
  final int32_t altitude;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// time_usec
  final uint64_t timeUsec;

  GpsGlobalOrigin({
    required this.latitude,
    required this.longitude,
    required this.altitude,
    required this.timeUsec,
  });

  GpsGlobalOrigin copyWith({
    int32_t? latitude,
    int32_t? longitude,
    int32_t? altitude,
    uint64_t? timeUsec,
  }) {
    return GpsGlobalOrigin(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      altitude: altitude ?? this.altitude,
      timeUsec: timeUsec ?? this.timeUsec,
    );
  }

  factory GpsGlobalOrigin.parse(ByteData data_) {
    if (data_.lengthInBytes < GpsGlobalOrigin.mavlinkEncodedLength) {
      var len = GpsGlobalOrigin.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var latitude = data_.getInt32(0, Endian.little);
    var longitude = data_.getInt32(4, Endian.little);
    var altitude = data_.getInt32(8, Endian.little);
    var timeUsec = data_.getUint64(12, Endian.little);

    return GpsGlobalOrigin(
        latitude: latitude,
        longitude: longitude,
        altitude: altitude,
        timeUsec: timeUsec);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, latitude, Endian.little);
    data_.setInt32(4, longitude, Endian.little);
    data_.setInt32(8, altitude, Endian.little);
    data_.setUint64(12, timeUsec, Endian.little);
    return data_;
  }
}

/// Bind a RC channel to a parameter. The parameter should change according to the RC channel value.
///
/// PARAM_MAP_RC
class ParamMapRc implements MavlinkMessage {
  static const int _mavlinkMessageId = 50;

  static const int _mavlinkCrcExtra = 78;

  static const int mavlinkEncodedLength = 37;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Initial parameter value
  ///
  /// MAVLink type: float
  ///
  /// param_value0
  final float paramValue0;

  /// Scale, maps the RC range [-1, 1] to a parameter value
  ///
  /// MAVLink type: float
  ///
  /// scale
  final float scale;

  /// Minimum param value. The protocol does not define if this overwrites an onboard minimum value. (Depends on implementation)
  ///
  /// MAVLink type: float
  ///
  /// param_value_min
  final float paramValueMin;

  /// Maximum param value. The protocol does not define if this overwrites an onboard maximum value. (Depends on implementation)
  ///
  /// MAVLink type: float
  ///
  /// param_value_max
  final float paramValueMax;

  /// Parameter index. Send -1 to use the param ID field as identifier (else the param id will be ignored), send -2 to disable any existing map for this rc_channel_index.
  ///
  /// MAVLink type: int16_t
  ///
  /// param_index
  final int16_t paramIndex;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  /// Index of parameter RC channel. Not equal to the RC channel id. Typically corresponds to a potentiometer-knob on the RC.
  ///
  /// MAVLink type: uint8_t
  ///
  /// parameter_rc_channel_index
  final uint8_t parameterRcChannelIndex;

  ParamMapRc({
    required this.paramValue0,
    required this.scale,
    required this.paramValueMin,
    required this.paramValueMax,
    required this.paramIndex,
    required this.targetSystem,
    required this.targetComponent,
    required this.paramId,
    required this.parameterRcChannelIndex,
  });

  ParamMapRc copyWith({
    float? paramValue0,
    float? scale,
    float? paramValueMin,
    float? paramValueMax,
    int16_t? paramIndex,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<char>? paramId,
    uint8_t? parameterRcChannelIndex,
  }) {
    return ParamMapRc(
      paramValue0: paramValue0 ?? this.paramValue0,
      scale: scale ?? this.scale,
      paramValueMin: paramValueMin ?? this.paramValueMin,
      paramValueMax: paramValueMax ?? this.paramValueMax,
      paramIndex: paramIndex ?? this.paramIndex,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      paramId: paramId ?? this.paramId,
      parameterRcChannelIndex:
          parameterRcChannelIndex ?? this.parameterRcChannelIndex,
    );
  }

  factory ParamMapRc.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamMapRc.mavlinkEncodedLength) {
      var len = ParamMapRc.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var paramValue0 = data_.getFloat32(0, Endian.little);
    var scale = data_.getFloat32(4, Endian.little);
    var paramValueMin = data_.getFloat32(8, Endian.little);
    var paramValueMax = data_.getFloat32(12, Endian.little);
    var paramIndex = data_.getInt16(16, Endian.little);
    var targetSystem = data_.getUint8(18);
    var targetComponent = data_.getUint8(19);
    var paramId = MavlinkMessage.asInt8List(data_, 20, 16);
    var parameterRcChannelIndex = data_.getUint8(36);

    return ParamMapRc(
        paramValue0: paramValue0,
        scale: scale,
        paramValueMin: paramValueMin,
        paramValueMax: paramValueMax,
        paramIndex: paramIndex,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        paramId: paramId,
        parameterRcChannelIndex: parameterRcChannelIndex);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, paramValue0, Endian.little);
    data_.setFloat32(4, scale, Endian.little);
    data_.setFloat32(8, paramValueMin, Endian.little);
    data_.setFloat32(12, paramValueMax, Endian.little);
    data_.setInt16(16, paramIndex, Endian.little);
    data_.setUint8(18, targetSystem);
    data_.setUint8(19, targetComponent);
    MavlinkMessage.setInt8List(data_, 20, paramId);
    data_.setUint8(36, parameterRcChannelIndex);
    return data_;
  }
}

/// Request the information of the mission item with the sequence number seq. The response of the system to this message should be a MISSION_ITEM_INT message. https://mavlink.io/en/services/mission.html
///
/// MISSION_REQUEST_INT
class MissionRequestInt implements MavlinkMessage {
  static const int _mavlinkMessageId = 51;

  static const int _mavlinkCrcExtra = 196;

  static const int mavlinkEncodedLength = 5;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Sequence
  ///
  /// MAVLink type: uint16_t
  ///
  /// seq
  final uint16_t seq;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  MissionRequestInt({
    required this.seq,
    required this.targetSystem,
    required this.targetComponent,
    required this.missionType,
  });

  MissionRequestInt copyWith({
    uint16_t? seq,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMissionType? missionType,
  }) {
    return MissionRequestInt(
      seq: seq ?? this.seq,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      missionType: missionType ?? this.missionType,
    );
  }

  factory MissionRequestInt.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionRequestInt.mavlinkEncodedLength) {
      var len = MissionRequestInt.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var seq = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);
    var missionType = data_.getUint8(4);

    return MissionRequestInt(
        seq: seq,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        missionType: missionType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, seq, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    data_.setUint8(4, missionType);
    return data_;
  }
}

/// Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell the MAV which setpoints/waypoints to accept and which to reject. Safety areas are often enforced by national or competition regulations.
///
/// SAFETY_SET_ALLOWED_AREA
class SafetySetAllowedArea implements MavlinkMessage {
  static const int _mavlinkMessageId = 54;

  static const int _mavlinkCrcExtra = 15;

  static const int mavlinkEncodedLength = 27;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// x position 1 / Latitude 1
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p1x
  final float p1x;

  /// y position 1 / Longitude 1
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p1y
  final float p1y;

  /// z position 1 / Altitude 1
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p1z
  final float p1z;

  /// x position 2 / Latitude 2
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p2x
  final float p2x;

  /// y position 2 / Longitude 2
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p2y
  final float p2y;

  /// z position 2 / Altitude 2
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p2z
  final float p2z;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// frame
  final MavFrame frame;

  SafetySetAllowedArea({
    required this.p1x,
    required this.p1y,
    required this.p1z,
    required this.p2x,
    required this.p2y,
    required this.p2z,
    required this.targetSystem,
    required this.targetComponent,
    required this.frame,
  });

  SafetySetAllowedArea copyWith({
    float? p1x,
    float? p1y,
    float? p1z,
    float? p2x,
    float? p2y,
    float? p2z,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavFrame? frame,
  }) {
    return SafetySetAllowedArea(
      p1x: p1x ?? this.p1x,
      p1y: p1y ?? this.p1y,
      p1z: p1z ?? this.p1z,
      p2x: p2x ?? this.p2x,
      p2y: p2y ?? this.p2y,
      p2z: p2z ?? this.p2z,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      frame: frame ?? this.frame,
    );
  }

  factory SafetySetAllowedArea.parse(ByteData data_) {
    if (data_.lengthInBytes < SafetySetAllowedArea.mavlinkEncodedLength) {
      var len = SafetySetAllowedArea.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var p1x = data_.getFloat32(0, Endian.little);
    var p1y = data_.getFloat32(4, Endian.little);
    var p1z = data_.getFloat32(8, Endian.little);
    var p2x = data_.getFloat32(12, Endian.little);
    var p2y = data_.getFloat32(16, Endian.little);
    var p2z = data_.getFloat32(20, Endian.little);
    var targetSystem = data_.getUint8(24);
    var targetComponent = data_.getUint8(25);
    var frame = data_.getUint8(26);

    return SafetySetAllowedArea(
        p1x: p1x,
        p1y: p1y,
        p1z: p1z,
        p2x: p2x,
        p2y: p2y,
        p2z: p2z,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        frame: frame);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, p1x, Endian.little);
    data_.setFloat32(4, p1y, Endian.little);
    data_.setFloat32(8, p1z, Endian.little);
    data_.setFloat32(12, p2x, Endian.little);
    data_.setFloat32(16, p2y, Endian.little);
    data_.setFloat32(20, p2z, Endian.little);
    data_.setUint8(24, targetSystem);
    data_.setUint8(25, targetComponent);
    data_.setUint8(26, frame);
    return data_;
  }
}

/// Read out the safety zone the MAV currently assumes.
///
/// SAFETY_ALLOWED_AREA
class SafetyAllowedArea implements MavlinkMessage {
  static const int _mavlinkMessageId = 55;

  static const int _mavlinkCrcExtra = 3;

  static const int mavlinkEncodedLength = 25;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// x position 1 / Latitude 1
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p1x
  final float p1x;

  /// y position 1 / Longitude 1
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p1y
  final float p1y;

  /// z position 1 / Altitude 1
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p1z
  final float p1z;

  /// x position 2 / Latitude 2
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p2x
  final float p2x;

  /// y position 2 / Longitude 2
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p2y
  final float p2y;

  /// z position 2 / Altitude 2
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// p2z
  final float p2z;

  /// Coordinate frame. Can be either global, GPS, right-handed with Z axis up or local, right handed, Z axis down.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// frame
  final MavFrame frame;

  SafetyAllowedArea({
    required this.p1x,
    required this.p1y,
    required this.p1z,
    required this.p2x,
    required this.p2y,
    required this.p2z,
    required this.frame,
  });

  SafetyAllowedArea copyWith({
    float? p1x,
    float? p1y,
    float? p1z,
    float? p2x,
    float? p2y,
    float? p2z,
    MavFrame? frame,
  }) {
    return SafetyAllowedArea(
      p1x: p1x ?? this.p1x,
      p1y: p1y ?? this.p1y,
      p1z: p1z ?? this.p1z,
      p2x: p2x ?? this.p2x,
      p2y: p2y ?? this.p2y,
      p2z: p2z ?? this.p2z,
      frame: frame ?? this.frame,
    );
  }

  factory SafetyAllowedArea.parse(ByteData data_) {
    if (data_.lengthInBytes < SafetyAllowedArea.mavlinkEncodedLength) {
      var len = SafetyAllowedArea.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var p1x = data_.getFloat32(0, Endian.little);
    var p1y = data_.getFloat32(4, Endian.little);
    var p1z = data_.getFloat32(8, Endian.little);
    var p2x = data_.getFloat32(12, Endian.little);
    var p2y = data_.getFloat32(16, Endian.little);
    var p2z = data_.getFloat32(20, Endian.little);
    var frame = data_.getUint8(24);

    return SafetyAllowedArea(
        p1x: p1x,
        p1y: p1y,
        p1z: p1z,
        p2x: p2x,
        p2y: p2y,
        p2z: p2z,
        frame: frame);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, p1x, Endian.little);
    data_.setFloat32(4, p1y, Endian.little);
    data_.setFloat32(8, p1z, Endian.little);
    data_.setFloat32(12, p2x, Endian.little);
    data_.setFloat32(16, p2y, Endian.little);
    data_.setFloat32(20, p2z, Endian.little);
    data_.setUint8(24, frame);
    return data_;
  }
}

/// The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion. Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0).
///
/// ATTITUDE_QUATERNION_COV
class AttitudeQuaternionCov implements MavlinkMessage {
  static const int _mavlinkMessageId = 61;

  static const int _mavlinkCrcExtra = 167;

  static const int mavlinkEncodedLength = 72;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// Roll angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// rollspeed
  final float rollspeed;

  /// Pitch angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitchspeed
  final float pitchspeed;

  /// Yaw angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yawspeed
  final float yawspeed;

  /// Row-major representation of a 3x3 attitude covariance matrix (states: roll, pitch, yaw; first three entries are the first ROW, next three entries are the second row, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[9]
  ///
  /// covariance
  final List<float> covariance;

  AttitudeQuaternionCov({
    required this.timeUsec,
    required this.q,
    required this.rollspeed,
    required this.pitchspeed,
    required this.yawspeed,
    required this.covariance,
  });

  AttitudeQuaternionCov copyWith({
    uint64_t? timeUsec,
    List<float>? q,
    float? rollspeed,
    float? pitchspeed,
    float? yawspeed,
    List<float>? covariance,
  }) {
    return AttitudeQuaternionCov(
      timeUsec: timeUsec ?? this.timeUsec,
      q: q ?? this.q,
      rollspeed: rollspeed ?? this.rollspeed,
      pitchspeed: pitchspeed ?? this.pitchspeed,
      yawspeed: yawspeed ?? this.yawspeed,
      covariance: covariance ?? this.covariance,
    );
  }

  factory AttitudeQuaternionCov.parse(ByteData data_) {
    if (data_.lengthInBytes < AttitudeQuaternionCov.mavlinkEncodedLength) {
      var len =
          AttitudeQuaternionCov.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 8, 4);
    var rollspeed = data_.getFloat32(24, Endian.little);
    var pitchspeed = data_.getFloat32(28, Endian.little);
    var yawspeed = data_.getFloat32(32, Endian.little);
    var covariance = MavlinkMessage.asFloat32List(data_, 36, 9);

    return AttitudeQuaternionCov(
        timeUsec: timeUsec,
        q: q,
        rollspeed: rollspeed,
        pitchspeed: pitchspeed,
        yawspeed: yawspeed,
        covariance: covariance);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setFloat32List(data_, 8, q);
    data_.setFloat32(24, rollspeed, Endian.little);
    data_.setFloat32(28, pitchspeed, Endian.little);
    data_.setFloat32(32, yawspeed, Endian.little);
    MavlinkMessage.setFloat32List(data_, 36, covariance);
    return data_;
  }
}

/// The state of the navigation and position controller.
///
/// NAV_CONTROLLER_OUTPUT
class NavControllerOutput implements MavlinkMessage {
  static const int _mavlinkMessageId = 62;

  static const int _mavlinkCrcExtra = 183;

  static const int mavlinkEncodedLength = 26;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Current desired roll
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// nav_roll
  final float navRoll;

  /// Current desired pitch
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// nav_pitch
  final float navPitch;

  /// Current altitude error
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt_error
  final float altError;

  /// Current airspeed error
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// aspd_error
  final float aspdError;

  /// Current crosstrack error on x-y plane
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// xtrack_error
  final float xtrackError;

  /// Current desired heading
  ///
  /// MAVLink type: int16_t
  ///
  /// units: deg
  ///
  /// nav_bearing
  final int16_t navBearing;

  /// Bearing to current waypoint/target
  ///
  /// MAVLink type: int16_t
  ///
  /// units: deg
  ///
  /// target_bearing
  final int16_t targetBearing;

  /// Distance to active waypoint
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: m
  ///
  /// wp_dist
  final uint16_t wpDist;

  NavControllerOutput({
    required this.navRoll,
    required this.navPitch,
    required this.altError,
    required this.aspdError,
    required this.xtrackError,
    required this.navBearing,
    required this.targetBearing,
    required this.wpDist,
  });

  NavControllerOutput copyWith({
    float? navRoll,
    float? navPitch,
    float? altError,
    float? aspdError,
    float? xtrackError,
    int16_t? navBearing,
    int16_t? targetBearing,
    uint16_t? wpDist,
  }) {
    return NavControllerOutput(
      navRoll: navRoll ?? this.navRoll,
      navPitch: navPitch ?? this.navPitch,
      altError: altError ?? this.altError,
      aspdError: aspdError ?? this.aspdError,
      xtrackError: xtrackError ?? this.xtrackError,
      navBearing: navBearing ?? this.navBearing,
      targetBearing: targetBearing ?? this.targetBearing,
      wpDist: wpDist ?? this.wpDist,
    );
  }

  factory NavControllerOutput.parse(ByteData data_) {
    if (data_.lengthInBytes < NavControllerOutput.mavlinkEncodedLength) {
      var len = NavControllerOutput.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var navRoll = data_.getFloat32(0, Endian.little);
    var navPitch = data_.getFloat32(4, Endian.little);
    var altError = data_.getFloat32(8, Endian.little);
    var aspdError = data_.getFloat32(12, Endian.little);
    var xtrackError = data_.getFloat32(16, Endian.little);
    var navBearing = data_.getInt16(20, Endian.little);
    var targetBearing = data_.getInt16(22, Endian.little);
    var wpDist = data_.getUint16(24, Endian.little);

    return NavControllerOutput(
        navRoll: navRoll,
        navPitch: navPitch,
        altError: altError,
        aspdError: aspdError,
        xtrackError: xtrackError,
        navBearing: navBearing,
        targetBearing: targetBearing,
        wpDist: wpDist);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, navRoll, Endian.little);
    data_.setFloat32(4, navPitch, Endian.little);
    data_.setFloat32(8, altError, Endian.little);
    data_.setFloat32(12, aspdError, Endian.little);
    data_.setFloat32(16, xtrackError, Endian.little);
    data_.setInt16(20, navBearing, Endian.little);
    data_.setInt16(22, targetBearing, Endian.little);
    data_.setUint16(24, wpDist, Endian.little);
    return data_;
  }
}

/// The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed, Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE: This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset.
///
/// GLOBAL_POSITION_INT_COV
class GlobalPositionIntCov implements MavlinkMessage {
  static const int _mavlinkMessageId = 63;

  static const int _mavlinkCrcExtra = 119;

  static const int mavlinkEncodedLength = 181;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude in meters above MSL
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt
  final int32_t alt;

  /// Altitude above ground
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// relative_alt
  final int32_t relativeAlt;

  /// Ground X Speed (Latitude)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// Ground Y Speed (Longitude)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// Ground Z Speed (Altitude)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  /// Row-major representation of a 6x6 position and velocity 6x6 cross-covariance matrix (states: lat, lon, alt, vx, vy, vz; first six entries are the first ROW, next six entries are the second row, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[36]
  ///
  /// covariance
  final List<float> covariance;

  /// Class id of the estimator this estimate originated from.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavEstimatorType]
  ///
  /// estimator_type
  final MavEstimatorType estimatorType;

  GlobalPositionIntCov({
    required this.timeUsec,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.relativeAlt,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.covariance,
    required this.estimatorType,
  });

  GlobalPositionIntCov copyWith({
    uint64_t? timeUsec,
    int32_t? lat,
    int32_t? lon,
    int32_t? alt,
    int32_t? relativeAlt,
    float? vx,
    float? vy,
    float? vz,
    List<float>? covariance,
    MavEstimatorType? estimatorType,
  }) {
    return GlobalPositionIntCov(
      timeUsec: timeUsec ?? this.timeUsec,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      relativeAlt: relativeAlt ?? this.relativeAlt,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      covariance: covariance ?? this.covariance,
      estimatorType: estimatorType ?? this.estimatorType,
    );
  }

  factory GlobalPositionIntCov.parse(ByteData data_) {
    if (data_.lengthInBytes < GlobalPositionIntCov.mavlinkEncodedLength) {
      var len = GlobalPositionIntCov.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var lat = data_.getInt32(8, Endian.little);
    var lon = data_.getInt32(12, Endian.little);
    var alt = data_.getInt32(16, Endian.little);
    var relativeAlt = data_.getInt32(20, Endian.little);
    var vx = data_.getFloat32(24, Endian.little);
    var vy = data_.getFloat32(28, Endian.little);
    var vz = data_.getFloat32(32, Endian.little);
    var covariance = MavlinkMessage.asFloat32List(data_, 36, 36);
    var estimatorType = data_.getUint8(180);

    return GlobalPositionIntCov(
        timeUsec: timeUsec,
        lat: lat,
        lon: lon,
        alt: alt,
        relativeAlt: relativeAlt,
        vx: vx,
        vy: vy,
        vz: vz,
        covariance: covariance,
        estimatorType: estimatorType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setInt32(8, lat, Endian.little);
    data_.setInt32(12, lon, Endian.little);
    data_.setInt32(16, alt, Endian.little);
    data_.setInt32(20, relativeAlt, Endian.little);
    data_.setFloat32(24, vx, Endian.little);
    data_.setFloat32(28, vy, Endian.little);
    data_.setFloat32(32, vz, Endian.little);
    MavlinkMessage.setFloat32List(data_, 36, covariance);
    data_.setUint8(180, estimatorType);
    return data_;
  }
}

/// The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
///
/// LOCAL_POSITION_NED_COV
class LocalPositionNedCov implements MavlinkMessage {
  static const int _mavlinkMessageId = 64;

  static const int _mavlinkCrcExtra = 191;

  static const int mavlinkEncodedLength = 225;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// X Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Y Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Z Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// X Speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// Y Speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// Z Speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  /// X Acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// ax
  final float ax;

  /// Y Acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// ay
  final float ay;

  /// Z Acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// az
  final float az;

  /// Row-major representation of position, velocity and acceleration 9x9 cross-covariance matrix upper right triangle (states: x, y, z, vx, vy, vz, ax, ay, az; first nine entries are the first ROW, next eight entries are the second row, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[45]
  ///
  /// covariance
  final List<float> covariance;

  /// Class id of the estimator this estimate originated from.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavEstimatorType]
  ///
  /// estimator_type
  final MavEstimatorType estimatorType;

  LocalPositionNedCov({
    required this.timeUsec,
    required this.x,
    required this.y,
    required this.z,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.ax,
    required this.ay,
    required this.az,
    required this.covariance,
    required this.estimatorType,
  });

  LocalPositionNedCov copyWith({
    uint64_t? timeUsec,
    float? x,
    float? y,
    float? z,
    float? vx,
    float? vy,
    float? vz,
    float? ax,
    float? ay,
    float? az,
    List<float>? covariance,
    MavEstimatorType? estimatorType,
  }) {
    return LocalPositionNedCov(
      timeUsec: timeUsec ?? this.timeUsec,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      ax: ax ?? this.ax,
      ay: ay ?? this.ay,
      az: az ?? this.az,
      covariance: covariance ?? this.covariance,
      estimatorType: estimatorType ?? this.estimatorType,
    );
  }

  factory LocalPositionNedCov.parse(ByteData data_) {
    if (data_.lengthInBytes < LocalPositionNedCov.mavlinkEncodedLength) {
      var len = LocalPositionNedCov.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var x = data_.getFloat32(8, Endian.little);
    var y = data_.getFloat32(12, Endian.little);
    var z = data_.getFloat32(16, Endian.little);
    var vx = data_.getFloat32(20, Endian.little);
    var vy = data_.getFloat32(24, Endian.little);
    var vz = data_.getFloat32(28, Endian.little);
    var ax = data_.getFloat32(32, Endian.little);
    var ay = data_.getFloat32(36, Endian.little);
    var az = data_.getFloat32(40, Endian.little);
    var covariance = MavlinkMessage.asFloat32List(data_, 44, 45);
    var estimatorType = data_.getUint8(224);

    return LocalPositionNedCov(
        timeUsec: timeUsec,
        x: x,
        y: y,
        z: z,
        vx: vx,
        vy: vy,
        vz: vz,
        ax: ax,
        ay: ay,
        az: az,
        covariance: covariance,
        estimatorType: estimatorType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, x, Endian.little);
    data_.setFloat32(12, y, Endian.little);
    data_.setFloat32(16, z, Endian.little);
    data_.setFloat32(20, vx, Endian.little);
    data_.setFloat32(24, vy, Endian.little);
    data_.setFloat32(28, vz, Endian.little);
    data_.setFloat32(32, ax, Endian.little);
    data_.setFloat32(36, ay, Endian.little);
    data_.setFloat32(40, az, Endian.little);
    MavlinkMessage.setFloat32List(data_, 44, covariance);
    data_.setUint8(224, estimatorType);
    return data_;
  }
}

/// The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%.  A value of UINT16_MAX implies the channel is unused. Individual receivers/transmitters might violate this specification.
///
/// RC_CHANNELS
class RcChannels implements MavlinkMessage {
  static const int _mavlinkMessageId = 65;

  static const int _mavlinkCrcExtra = 118;

  static const int mavlinkEncodedLength = 42;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// RC channel 1 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan1_raw
  final uint16_t chan1Raw;

  /// RC channel 2 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan2_raw
  final uint16_t chan2Raw;

  /// RC channel 3 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan3_raw
  final uint16_t chan3Raw;

  /// RC channel 4 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan4_raw
  final uint16_t chan4Raw;

  /// RC channel 5 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan5_raw
  final uint16_t chan5Raw;

  /// RC channel 6 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan6_raw
  final uint16_t chan6Raw;

  /// RC channel 7 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan7_raw
  final uint16_t chan7Raw;

  /// RC channel 8 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan8_raw
  final uint16_t chan8Raw;

  /// RC channel 9 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan9_raw
  final uint16_t chan9Raw;

  /// RC channel 10 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan10_raw
  final uint16_t chan10Raw;

  /// RC channel 11 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan11_raw
  final uint16_t chan11Raw;

  /// RC channel 12 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan12_raw
  final uint16_t chan12Raw;

  /// RC channel 13 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan13_raw
  final uint16_t chan13Raw;

  /// RC channel 14 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan14_raw
  final uint16_t chan14Raw;

  /// RC channel 15 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan15_raw
  final uint16_t chan15Raw;

  /// RC channel 16 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan16_raw
  final uint16_t chan16Raw;

  /// RC channel 17 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan17_raw
  final uint16_t chan17Raw;

  /// RC channel 18 value.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan18_raw
  final uint16_t chan18Raw;

  /// Total number of RC channels being received. This can be larger than 18, indicating that more channels are available but not given in this message. This value should be 0 when no RC channels are available.
  ///
  /// MAVLink type: uint8_t
  ///
  /// chancount
  final uint8_t chancount;

  /// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rssi
  final uint8_t rssi;

  RcChannels({
    required this.timeBootMs,
    required this.chan1Raw,
    required this.chan2Raw,
    required this.chan3Raw,
    required this.chan4Raw,
    required this.chan5Raw,
    required this.chan6Raw,
    required this.chan7Raw,
    required this.chan8Raw,
    required this.chan9Raw,
    required this.chan10Raw,
    required this.chan11Raw,
    required this.chan12Raw,
    required this.chan13Raw,
    required this.chan14Raw,
    required this.chan15Raw,
    required this.chan16Raw,
    required this.chan17Raw,
    required this.chan18Raw,
    required this.chancount,
    required this.rssi,
  });

  RcChannels copyWith({
    uint32_t? timeBootMs,
    uint16_t? chan1Raw,
    uint16_t? chan2Raw,
    uint16_t? chan3Raw,
    uint16_t? chan4Raw,
    uint16_t? chan5Raw,
    uint16_t? chan6Raw,
    uint16_t? chan7Raw,
    uint16_t? chan8Raw,
    uint16_t? chan9Raw,
    uint16_t? chan10Raw,
    uint16_t? chan11Raw,
    uint16_t? chan12Raw,
    uint16_t? chan13Raw,
    uint16_t? chan14Raw,
    uint16_t? chan15Raw,
    uint16_t? chan16Raw,
    uint16_t? chan17Raw,
    uint16_t? chan18Raw,
    uint8_t? chancount,
    uint8_t? rssi,
  }) {
    return RcChannels(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      chan1Raw: chan1Raw ?? this.chan1Raw,
      chan2Raw: chan2Raw ?? this.chan2Raw,
      chan3Raw: chan3Raw ?? this.chan3Raw,
      chan4Raw: chan4Raw ?? this.chan4Raw,
      chan5Raw: chan5Raw ?? this.chan5Raw,
      chan6Raw: chan6Raw ?? this.chan6Raw,
      chan7Raw: chan7Raw ?? this.chan7Raw,
      chan8Raw: chan8Raw ?? this.chan8Raw,
      chan9Raw: chan9Raw ?? this.chan9Raw,
      chan10Raw: chan10Raw ?? this.chan10Raw,
      chan11Raw: chan11Raw ?? this.chan11Raw,
      chan12Raw: chan12Raw ?? this.chan12Raw,
      chan13Raw: chan13Raw ?? this.chan13Raw,
      chan14Raw: chan14Raw ?? this.chan14Raw,
      chan15Raw: chan15Raw ?? this.chan15Raw,
      chan16Raw: chan16Raw ?? this.chan16Raw,
      chan17Raw: chan17Raw ?? this.chan17Raw,
      chan18Raw: chan18Raw ?? this.chan18Raw,
      chancount: chancount ?? this.chancount,
      rssi: rssi ?? this.rssi,
    );
  }

  factory RcChannels.parse(ByteData data_) {
    if (data_.lengthInBytes < RcChannels.mavlinkEncodedLength) {
      var len = RcChannels.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var chan1Raw = data_.getUint16(4, Endian.little);
    var chan2Raw = data_.getUint16(6, Endian.little);
    var chan3Raw = data_.getUint16(8, Endian.little);
    var chan4Raw = data_.getUint16(10, Endian.little);
    var chan5Raw = data_.getUint16(12, Endian.little);
    var chan6Raw = data_.getUint16(14, Endian.little);
    var chan7Raw = data_.getUint16(16, Endian.little);
    var chan8Raw = data_.getUint16(18, Endian.little);
    var chan9Raw = data_.getUint16(20, Endian.little);
    var chan10Raw = data_.getUint16(22, Endian.little);
    var chan11Raw = data_.getUint16(24, Endian.little);
    var chan12Raw = data_.getUint16(26, Endian.little);
    var chan13Raw = data_.getUint16(28, Endian.little);
    var chan14Raw = data_.getUint16(30, Endian.little);
    var chan15Raw = data_.getUint16(32, Endian.little);
    var chan16Raw = data_.getUint16(34, Endian.little);
    var chan17Raw = data_.getUint16(36, Endian.little);
    var chan18Raw = data_.getUint16(38, Endian.little);
    var chancount = data_.getUint8(40);
    var rssi = data_.getUint8(41);

    return RcChannels(
        timeBootMs: timeBootMs,
        chan1Raw: chan1Raw,
        chan2Raw: chan2Raw,
        chan3Raw: chan3Raw,
        chan4Raw: chan4Raw,
        chan5Raw: chan5Raw,
        chan6Raw: chan6Raw,
        chan7Raw: chan7Raw,
        chan8Raw: chan8Raw,
        chan9Raw: chan9Raw,
        chan10Raw: chan10Raw,
        chan11Raw: chan11Raw,
        chan12Raw: chan12Raw,
        chan13Raw: chan13Raw,
        chan14Raw: chan14Raw,
        chan15Raw: chan15Raw,
        chan16Raw: chan16Raw,
        chan17Raw: chan17Raw,
        chan18Raw: chan18Raw,
        chancount: chancount,
        rssi: rssi);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint16(4, chan1Raw, Endian.little);
    data_.setUint16(6, chan2Raw, Endian.little);
    data_.setUint16(8, chan3Raw, Endian.little);
    data_.setUint16(10, chan4Raw, Endian.little);
    data_.setUint16(12, chan5Raw, Endian.little);
    data_.setUint16(14, chan6Raw, Endian.little);
    data_.setUint16(16, chan7Raw, Endian.little);
    data_.setUint16(18, chan8Raw, Endian.little);
    data_.setUint16(20, chan9Raw, Endian.little);
    data_.setUint16(22, chan10Raw, Endian.little);
    data_.setUint16(24, chan11Raw, Endian.little);
    data_.setUint16(26, chan12Raw, Endian.little);
    data_.setUint16(28, chan13Raw, Endian.little);
    data_.setUint16(30, chan14Raw, Endian.little);
    data_.setUint16(32, chan15Raw, Endian.little);
    data_.setUint16(34, chan16Raw, Endian.little);
    data_.setUint16(36, chan17Raw, Endian.little);
    data_.setUint16(38, chan18Raw, Endian.little);
    data_.setUint8(40, chancount);
    data_.setUint8(41, rssi);
    return data_;
  }
}

/// Request a data stream.
///
/// REQUEST_DATA_STREAM
class RequestDataStream implements MavlinkMessage {
  static const int _mavlinkMessageId = 66;

  static const int _mavlinkCrcExtra = 148;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// The requested message rate
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: Hz
  ///
  /// req_message_rate
  final uint16_t reqMessageRate;

  /// The target requested to send the message stream.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// The target requested to send the message stream.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// The ID of the requested data stream
  ///
  /// MAVLink type: uint8_t
  ///
  /// req_stream_id
  final uint8_t reqStreamId;

  /// 1 to start sending, 0 to stop sending.
  ///
  /// MAVLink type: uint8_t
  ///
  /// start_stop
  final uint8_t startStop;

  RequestDataStream({
    required this.reqMessageRate,
    required this.targetSystem,
    required this.targetComponent,
    required this.reqStreamId,
    required this.startStop,
  });

  RequestDataStream copyWith({
    uint16_t? reqMessageRate,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? reqStreamId,
    uint8_t? startStop,
  }) {
    return RequestDataStream(
      reqMessageRate: reqMessageRate ?? this.reqMessageRate,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      reqStreamId: reqStreamId ?? this.reqStreamId,
      startStop: startStop ?? this.startStop,
    );
  }

  factory RequestDataStream.parse(ByteData data_) {
    if (data_.lengthInBytes < RequestDataStream.mavlinkEncodedLength) {
      var len = RequestDataStream.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var reqMessageRate = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);
    var reqStreamId = data_.getUint8(4);
    var startStop = data_.getUint8(5);

    return RequestDataStream(
        reqMessageRate: reqMessageRate,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        reqStreamId: reqStreamId,
        startStop: startStop);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, reqMessageRate, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    data_.setUint8(4, reqStreamId);
    data_.setUint8(5, startStop);
    return data_;
  }
}

/// Data stream status information.
///
/// DATA_STREAM
class DataStream implements MavlinkMessage {
  static const int _mavlinkMessageId = 67;

  static const int _mavlinkCrcExtra = 21;

  static const int mavlinkEncodedLength = 4;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// The message rate
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: Hz
  ///
  /// message_rate
  final uint16_t messageRate;

  /// The ID of the requested data stream
  ///
  /// MAVLink type: uint8_t
  ///
  /// stream_id
  final uint8_t streamId;

  /// 1 stream is enabled, 0 stream is stopped.
  ///
  /// MAVLink type: uint8_t
  ///
  /// on_off
  final uint8_t onOff;

  DataStream({
    required this.messageRate,
    required this.streamId,
    required this.onOff,
  });

  DataStream copyWith({
    uint16_t? messageRate,
    uint8_t? streamId,
    uint8_t? onOff,
  }) {
    return DataStream(
      messageRate: messageRate ?? this.messageRate,
      streamId: streamId ?? this.streamId,
      onOff: onOff ?? this.onOff,
    );
  }

  factory DataStream.parse(ByteData data_) {
    if (data_.lengthInBytes < DataStream.mavlinkEncodedLength) {
      var len = DataStream.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var messageRate = data_.getUint16(0, Endian.little);
    var streamId = data_.getUint8(2);
    var onOff = data_.getUint8(3);

    return DataStream(
        messageRate: messageRate, streamId: streamId, onOff: onOff);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, messageRate, Endian.little);
    data_.setUint8(2, streamId);
    data_.setUint8(3, onOff);
    return data_;
  }
}

/// This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature, along with a joystick-like input device. Unused axes can be disabled and buttons states are transmitted as individual on/off bits of a bitmask
///
/// MANUAL_CONTROL
class ManualControl implements MavlinkMessage {
  static const int _mavlinkMessageId = 69;

  static const int _mavlinkCrcExtra = 243;

  static const int mavlinkEncodedLength = 30;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// X-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to forward(1000)-backward(-1000) movement on a joystick and the pitch of a vehicle.
  ///
  /// MAVLink type: int16_t
  ///
  /// x
  final int16_t x;

  /// Y-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to left(-1000)-right(1000) movement on a joystick and the roll of a vehicle.
  ///
  /// MAVLink type: int16_t
  ///
  /// y
  final int16_t y;

  /// Z-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a separate slider movement with maximum being 1000 and minimum being -1000 on a joystick and the thrust of a vehicle. Positive values are positive thrust, negative values are negative thrust.
  ///
  /// MAVLink type: int16_t
  ///
  /// z
  final int16_t z;

  /// R-axis, normalized to the range [-1000,1000]. A value of INT16_MAX indicates that this axis is invalid. Generally corresponds to a twisting of the joystick, with counter-clockwise being 1000 and clockwise being -1000, and the yaw of a vehicle.
  ///
  /// MAVLink type: int16_t
  ///
  /// r
  final int16_t r;

  /// A bitfield corresponding to the joystick buttons' 0-15 current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 1.
  ///
  /// MAVLink type: uint16_t
  ///
  /// buttons
  final uint16_t buttons;

  /// The system to be controlled.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target
  final uint8_t target;

  /// A bitfield corresponding to the joystick buttons' 16-31 current state, 1 for pressed, 0 for released. The lowest bit corresponds to Button 16.
  ///
  /// MAVLink type: uint16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// buttons2
  final uint16_t buttons2;

  /// Set bits to 1 to indicate which of the following extension fields contain valid data: bit 0: pitch, bit 1: roll, bit 2: aux1, bit 3: aux2, bit 4: aux3, bit 5: aux4, bit 6: aux5, bit 7: aux6
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// enabled_extensions
  final uint8_t enabledExtensions;

  /// Pitch-only-axis, normalized to the range [-1000,1000]. Generally corresponds to pitch on vehicles with additional degrees of freedom. Valid if bit 0 of enabled_extensions field is set. Set to 0 if invalid.
  ///
  /// MAVLink type: int16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// s
  final int16_t s;

  /// Roll-only-axis, normalized to the range [-1000,1000]. Generally corresponds to roll on vehicles with additional degrees of freedom. Valid if bit 1 of enabled_extensions field is set. Set to 0 if invalid.
  ///
  /// MAVLink type: int16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// t
  final int16_t t;

  /// Aux continuous input field 1. Normalized in the range [-1000,1000]. Purpose defined by recipient. Valid data if bit 2 of enabled_extensions field is set. 0 if bit 2 is unset.
  ///
  /// MAVLink type: int16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// aux1
  final int16_t aux1;

  /// Aux continuous input field 2. Normalized in the range [-1000,1000]. Purpose defined by recipient. Valid data if bit 3 of enabled_extensions field is set. 0 if bit 3 is unset.
  ///
  /// MAVLink type: int16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// aux2
  final int16_t aux2;

  /// Aux continuous input field 3. Normalized in the range [-1000,1000]. Purpose defined by recipient. Valid data if bit 4 of enabled_extensions field is set. 0 if bit 4 is unset.
  ///
  /// MAVLink type: int16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// aux3
  final int16_t aux3;

  /// Aux continuous input field 4. Normalized in the range [-1000,1000]. Purpose defined by recipient. Valid data if bit 5 of enabled_extensions field is set. 0 if bit 5 is unset.
  ///
  /// MAVLink type: int16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// aux4
  final int16_t aux4;

  /// Aux continuous input field 5. Normalized in the range [-1000,1000]. Purpose defined by recipient. Valid data if bit 6 of enabled_extensions field is set. 0 if bit 6 is unset.
  ///
  /// MAVLink type: int16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// aux5
  final int16_t aux5;

  /// Aux continuous input field 6. Normalized in the range [-1000,1000]. Purpose defined by recipient. Valid data if bit 7 of enabled_extensions field is set. 0 if bit 7 is unset.
  ///
  /// MAVLink type: int16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// aux6
  final int16_t aux6;

  ManualControl({
    required this.x,
    required this.y,
    required this.z,
    required this.r,
    required this.buttons,
    required this.target,
    required this.buttons2,
    required this.enabledExtensions,
    required this.s,
    required this.t,
    required this.aux1,
    required this.aux2,
    required this.aux3,
    required this.aux4,
    required this.aux5,
    required this.aux6,
  });

  ManualControl copyWith({
    int16_t? x,
    int16_t? y,
    int16_t? z,
    int16_t? r,
    uint16_t? buttons,
    uint8_t? target,
    uint16_t? buttons2,
    uint8_t? enabledExtensions,
    int16_t? s,
    int16_t? t,
    int16_t? aux1,
    int16_t? aux2,
    int16_t? aux3,
    int16_t? aux4,
    int16_t? aux5,
    int16_t? aux6,
  }) {
    return ManualControl(
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      r: r ?? this.r,
      buttons: buttons ?? this.buttons,
      target: target ?? this.target,
      buttons2: buttons2 ?? this.buttons2,
      enabledExtensions: enabledExtensions ?? this.enabledExtensions,
      s: s ?? this.s,
      t: t ?? this.t,
      aux1: aux1 ?? this.aux1,
      aux2: aux2 ?? this.aux2,
      aux3: aux3 ?? this.aux3,
      aux4: aux4 ?? this.aux4,
      aux5: aux5 ?? this.aux5,
      aux6: aux6 ?? this.aux6,
    );
  }

  factory ManualControl.parse(ByteData data_) {
    if (data_.lengthInBytes < ManualControl.mavlinkEncodedLength) {
      var len = ManualControl.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var x = data_.getInt16(0, Endian.little);
    var y = data_.getInt16(2, Endian.little);
    var z = data_.getInt16(4, Endian.little);
    var r = data_.getInt16(6, Endian.little);
    var buttons = data_.getUint16(8, Endian.little);
    var target = data_.getUint8(10);
    var buttons2 = data_.getUint16(11, Endian.little);
    var enabledExtensions = data_.getUint8(13);
    var s = data_.getInt16(14, Endian.little);
    var t = data_.getInt16(16, Endian.little);
    var aux1 = data_.getInt16(18, Endian.little);
    var aux2 = data_.getInt16(20, Endian.little);
    var aux3 = data_.getInt16(22, Endian.little);
    var aux4 = data_.getInt16(24, Endian.little);
    var aux5 = data_.getInt16(26, Endian.little);
    var aux6 = data_.getInt16(28, Endian.little);

    return ManualControl(
        x: x,
        y: y,
        z: z,
        r: r,
        buttons: buttons,
        target: target,
        buttons2: buttons2,
        enabledExtensions: enabledExtensions,
        s: s,
        t: t,
        aux1: aux1,
        aux2: aux2,
        aux3: aux3,
        aux4: aux4,
        aux5: aux5,
        aux6: aux6);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt16(0, x, Endian.little);
    data_.setInt16(2, y, Endian.little);
    data_.setInt16(4, z, Endian.little);
    data_.setInt16(6, r, Endian.little);
    data_.setUint16(8, buttons, Endian.little);
    data_.setUint8(10, target);
    data_.setUint16(11, buttons2, Endian.little);
    data_.setUint8(13, enabledExtensions);
    data_.setInt16(14, s, Endian.little);
    data_.setInt16(16, t, Endian.little);
    data_.setInt16(18, aux1, Endian.little);
    data_.setInt16(20, aux2, Endian.little);
    data_.setInt16(22, aux3, Endian.little);
    data_.setInt16(24, aux4, Endian.little);
    data_.setInt16(26, aux5, Endian.little);
    data_.setInt16(28, aux6, Endian.little);
    return data_;
  }
}

/// The RAW values of the RC channels sent to the MAV to override info received from the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.  Note carefully the semantic differences between the first 8 channels and the subsequent channels
///
/// RC_CHANNELS_OVERRIDE
class RcChannelsOverride implements MavlinkMessage {
  static const int _mavlinkMessageId = 70;

  static const int _mavlinkCrcExtra = 124;

  static const int mavlinkEncodedLength = 38;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// RC channel 1 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan1_raw
  final uint16_t chan1Raw;

  /// RC channel 2 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan2_raw
  final uint16_t chan2Raw;

  /// RC channel 3 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan3_raw
  final uint16_t chan3Raw;

  /// RC channel 4 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan4_raw
  final uint16_t chan4Raw;

  /// RC channel 5 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan5_raw
  final uint16_t chan5Raw;

  /// RC channel 6 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan6_raw
  final uint16_t chan6Raw;

  /// RC channel 7 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan7_raw
  final uint16_t chan7Raw;

  /// RC channel 8 value. A value of UINT16_MAX means to ignore this field. A value of 0 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan8_raw
  final uint16_t chan8Raw;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// RC channel 9 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan9_raw
  final uint16_t chan9Raw;

  /// RC channel 10 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan10_raw
  final uint16_t chan10Raw;

  /// RC channel 11 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan11_raw
  final uint16_t chan11Raw;

  /// RC channel 12 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan12_raw
  final uint16_t chan12Raw;

  /// RC channel 13 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan13_raw
  final uint16_t chan13Raw;

  /// RC channel 14 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan14_raw
  final uint16_t chan14Raw;

  /// RC channel 15 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan15_raw
  final uint16_t chan15Raw;

  /// RC channel 16 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan16_raw
  final uint16_t chan16Raw;

  /// RC channel 17 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan17_raw
  final uint16_t chan17Raw;

  /// RC channel 18 value. A value of 0 or UINT16_MAX means to ignore this field. A value of UINT16_MAX-1 means to release this channel back to the RC radio.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chan18_raw
  final uint16_t chan18Raw;

  RcChannelsOverride({
    required this.chan1Raw,
    required this.chan2Raw,
    required this.chan3Raw,
    required this.chan4Raw,
    required this.chan5Raw,
    required this.chan6Raw,
    required this.chan7Raw,
    required this.chan8Raw,
    required this.targetSystem,
    required this.targetComponent,
    required this.chan9Raw,
    required this.chan10Raw,
    required this.chan11Raw,
    required this.chan12Raw,
    required this.chan13Raw,
    required this.chan14Raw,
    required this.chan15Raw,
    required this.chan16Raw,
    required this.chan17Raw,
    required this.chan18Raw,
  });

  RcChannelsOverride copyWith({
    uint16_t? chan1Raw,
    uint16_t? chan2Raw,
    uint16_t? chan3Raw,
    uint16_t? chan4Raw,
    uint16_t? chan5Raw,
    uint16_t? chan6Raw,
    uint16_t? chan7Raw,
    uint16_t? chan8Raw,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint16_t? chan9Raw,
    uint16_t? chan10Raw,
    uint16_t? chan11Raw,
    uint16_t? chan12Raw,
    uint16_t? chan13Raw,
    uint16_t? chan14Raw,
    uint16_t? chan15Raw,
    uint16_t? chan16Raw,
    uint16_t? chan17Raw,
    uint16_t? chan18Raw,
  }) {
    return RcChannelsOverride(
      chan1Raw: chan1Raw ?? this.chan1Raw,
      chan2Raw: chan2Raw ?? this.chan2Raw,
      chan3Raw: chan3Raw ?? this.chan3Raw,
      chan4Raw: chan4Raw ?? this.chan4Raw,
      chan5Raw: chan5Raw ?? this.chan5Raw,
      chan6Raw: chan6Raw ?? this.chan6Raw,
      chan7Raw: chan7Raw ?? this.chan7Raw,
      chan8Raw: chan8Raw ?? this.chan8Raw,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      chan9Raw: chan9Raw ?? this.chan9Raw,
      chan10Raw: chan10Raw ?? this.chan10Raw,
      chan11Raw: chan11Raw ?? this.chan11Raw,
      chan12Raw: chan12Raw ?? this.chan12Raw,
      chan13Raw: chan13Raw ?? this.chan13Raw,
      chan14Raw: chan14Raw ?? this.chan14Raw,
      chan15Raw: chan15Raw ?? this.chan15Raw,
      chan16Raw: chan16Raw ?? this.chan16Raw,
      chan17Raw: chan17Raw ?? this.chan17Raw,
      chan18Raw: chan18Raw ?? this.chan18Raw,
    );
  }

  factory RcChannelsOverride.parse(ByteData data_) {
    if (data_.lengthInBytes < RcChannelsOverride.mavlinkEncodedLength) {
      var len = RcChannelsOverride.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var chan1Raw = data_.getUint16(0, Endian.little);
    var chan2Raw = data_.getUint16(2, Endian.little);
    var chan3Raw = data_.getUint16(4, Endian.little);
    var chan4Raw = data_.getUint16(6, Endian.little);
    var chan5Raw = data_.getUint16(8, Endian.little);
    var chan6Raw = data_.getUint16(10, Endian.little);
    var chan7Raw = data_.getUint16(12, Endian.little);
    var chan8Raw = data_.getUint16(14, Endian.little);
    var targetSystem = data_.getUint8(16);
    var targetComponent = data_.getUint8(17);
    var chan9Raw = data_.getUint16(18, Endian.little);
    var chan10Raw = data_.getUint16(20, Endian.little);
    var chan11Raw = data_.getUint16(22, Endian.little);
    var chan12Raw = data_.getUint16(24, Endian.little);
    var chan13Raw = data_.getUint16(26, Endian.little);
    var chan14Raw = data_.getUint16(28, Endian.little);
    var chan15Raw = data_.getUint16(30, Endian.little);
    var chan16Raw = data_.getUint16(32, Endian.little);
    var chan17Raw = data_.getUint16(34, Endian.little);
    var chan18Raw = data_.getUint16(36, Endian.little);

    return RcChannelsOverride(
        chan1Raw: chan1Raw,
        chan2Raw: chan2Raw,
        chan3Raw: chan3Raw,
        chan4Raw: chan4Raw,
        chan5Raw: chan5Raw,
        chan6Raw: chan6Raw,
        chan7Raw: chan7Raw,
        chan8Raw: chan8Raw,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        chan9Raw: chan9Raw,
        chan10Raw: chan10Raw,
        chan11Raw: chan11Raw,
        chan12Raw: chan12Raw,
        chan13Raw: chan13Raw,
        chan14Raw: chan14Raw,
        chan15Raw: chan15Raw,
        chan16Raw: chan16Raw,
        chan17Raw: chan17Raw,
        chan18Raw: chan18Raw);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, chan1Raw, Endian.little);
    data_.setUint16(2, chan2Raw, Endian.little);
    data_.setUint16(4, chan3Raw, Endian.little);
    data_.setUint16(6, chan4Raw, Endian.little);
    data_.setUint16(8, chan5Raw, Endian.little);
    data_.setUint16(10, chan6Raw, Endian.little);
    data_.setUint16(12, chan7Raw, Endian.little);
    data_.setUint16(14, chan8Raw, Endian.little);
    data_.setUint8(16, targetSystem);
    data_.setUint8(17, targetComponent);
    data_.setUint16(18, chan9Raw, Endian.little);
    data_.setUint16(20, chan10Raw, Endian.little);
    data_.setUint16(22, chan11Raw, Endian.little);
    data_.setUint16(24, chan12Raw, Endian.little);
    data_.setUint16(26, chan13Raw, Endian.little);
    data_.setUint16(28, chan14Raw, Endian.little);
    data_.setUint16(30, chan15Raw, Endian.little);
    data_.setUint16(32, chan16Raw, Endian.little);
    data_.setUint16(34, chan17Raw, Endian.little);
    data_.setUint16(36, chan18Raw, Endian.little);
    return data_;
  }
}

/// Message encoding a mission item. This message is emitted to announce
/// the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). NaN or INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current latitude, yaw rather than a specific value). See also https://mavlink.io/en/services/mission.html.
///
/// MISSION_ITEM_INT
class MissionItemInt implements MavlinkMessage {
  static const int _mavlinkMessageId = 73;

  static const int _mavlinkCrcExtra = 38;

  static const int mavlinkEncodedLength = 38;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// PARAM1, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param1
  final float param1;

  /// PARAM2, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param2
  final float param2;

  /// PARAM3, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param3
  final float param3;

  /// PARAM4, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param4
  final float param4;

  /// PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
  ///
  /// MAVLink type: int32_t
  ///
  /// x
  final int32_t x;

  /// PARAM6 / y position: local: x position in meters * 1e4, global: longitude in degrees *10^7
  ///
  /// MAVLink type: int32_t
  ///
  /// y
  final int32_t y;

  /// PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame.
  ///
  /// MAVLink type: float
  ///
  /// z
  final float z;

  /// Waypoint ID (sequence number). Starts at zero. Increases monotonically for each waypoint, no gaps in the sequence (0,1,2,3,4).
  ///
  /// MAVLink type: uint16_t
  ///
  /// seq
  final uint16_t seq;

  /// The scheduled action for the waypoint.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavCmd]
  ///
  /// command
  final MavCmd command;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// The coordinate system of the waypoint.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// frame
  final MavFrame frame;

  /// false:0, true:1
  ///
  /// MAVLink type: uint8_t
  ///
  /// current
  final uint8_t current;

  /// Autocontinue to next waypoint. 0: false, 1: true. Set false to pause mission after the item completes.
  ///
  /// MAVLink type: uint8_t
  ///
  /// autocontinue
  final uint8_t autocontinue;

  /// Mission type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMissionType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mission_type
  final MavMissionType missionType;

  MissionItemInt({
    required this.param1,
    required this.param2,
    required this.param3,
    required this.param4,
    required this.x,
    required this.y,
    required this.z,
    required this.seq,
    required this.command,
    required this.targetSystem,
    required this.targetComponent,
    required this.frame,
    required this.current,
    required this.autocontinue,
    required this.missionType,
  });

  MissionItemInt copyWith({
    float? param1,
    float? param2,
    float? param3,
    float? param4,
    int32_t? x,
    int32_t? y,
    float? z,
    uint16_t? seq,
    MavCmd? command,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavFrame? frame,
    uint8_t? current,
    uint8_t? autocontinue,
    MavMissionType? missionType,
  }) {
    return MissionItemInt(
      param1: param1 ?? this.param1,
      param2: param2 ?? this.param2,
      param3: param3 ?? this.param3,
      param4: param4 ?? this.param4,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      seq: seq ?? this.seq,
      command: command ?? this.command,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      frame: frame ?? this.frame,
      current: current ?? this.current,
      autocontinue: autocontinue ?? this.autocontinue,
      missionType: missionType ?? this.missionType,
    );
  }

  factory MissionItemInt.parse(ByteData data_) {
    if (data_.lengthInBytes < MissionItemInt.mavlinkEncodedLength) {
      var len = MissionItemInt.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var param1 = data_.getFloat32(0, Endian.little);
    var param2 = data_.getFloat32(4, Endian.little);
    var param3 = data_.getFloat32(8, Endian.little);
    var param4 = data_.getFloat32(12, Endian.little);
    var x = data_.getInt32(16, Endian.little);
    var y = data_.getInt32(20, Endian.little);
    var z = data_.getFloat32(24, Endian.little);
    var seq = data_.getUint16(28, Endian.little);
    var command = data_.getUint16(30, Endian.little);
    var targetSystem = data_.getUint8(32);
    var targetComponent = data_.getUint8(33);
    var frame = data_.getUint8(34);
    var current = data_.getUint8(35);
    var autocontinue = data_.getUint8(36);
    var missionType = data_.getUint8(37);

    return MissionItemInt(
        param1: param1,
        param2: param2,
        param3: param3,
        param4: param4,
        x: x,
        y: y,
        z: z,
        seq: seq,
        command: command,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        frame: frame,
        current: current,
        autocontinue: autocontinue,
        missionType: missionType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, param1, Endian.little);
    data_.setFloat32(4, param2, Endian.little);
    data_.setFloat32(8, param3, Endian.little);
    data_.setFloat32(12, param4, Endian.little);
    data_.setInt32(16, x, Endian.little);
    data_.setInt32(20, y, Endian.little);
    data_.setFloat32(24, z, Endian.little);
    data_.setUint16(28, seq, Endian.little);
    data_.setUint16(30, command, Endian.little);
    data_.setUint8(32, targetSystem);
    data_.setUint8(33, targetComponent);
    data_.setUint8(34, frame);
    data_.setUint8(35, current);
    data_.setUint8(36, autocontinue);
    data_.setUint8(37, missionType);
    return data_;
  }
}

/// Metrics typically displayed on a HUD for fixed wing aircraft.
///
/// VFR_HUD
class VfrHud implements MavlinkMessage {
  static const int _mavlinkMessageId = 74;

  static const int _mavlinkCrcExtra = 20;

  static const int mavlinkEncodedLength = 20;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Vehicle speed in form appropriate for vehicle type. For standard aircraft this is typically calibrated airspeed (CAS) or indicated airspeed (IAS) - either of which can be used by a pilot to estimate stall speed.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// airspeed
  final float airspeed;

  /// Current ground speed.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// groundspeed
  final float groundspeed;

  /// Current altitude (MSL).
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt
  final float alt;

  /// Current climb rate.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// climb
  final float climb;

  /// Current heading in compass units (0-360, 0=north).
  ///
  /// MAVLink type: int16_t
  ///
  /// units: deg
  ///
  /// heading
  final int16_t heading;

  /// Current throttle setting (0 to 100).
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: %
  ///
  /// throttle
  final uint16_t throttle;

  VfrHud({
    required this.airspeed,
    required this.groundspeed,
    required this.alt,
    required this.climb,
    required this.heading,
    required this.throttle,
  });

  VfrHud copyWith({
    float? airspeed,
    float? groundspeed,
    float? alt,
    float? climb,
    int16_t? heading,
    uint16_t? throttle,
  }) {
    return VfrHud(
      airspeed: airspeed ?? this.airspeed,
      groundspeed: groundspeed ?? this.groundspeed,
      alt: alt ?? this.alt,
      climb: climb ?? this.climb,
      heading: heading ?? this.heading,
      throttle: throttle ?? this.throttle,
    );
  }

  factory VfrHud.parse(ByteData data_) {
    if (data_.lengthInBytes < VfrHud.mavlinkEncodedLength) {
      var len = VfrHud.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var airspeed = data_.getFloat32(0, Endian.little);
    var groundspeed = data_.getFloat32(4, Endian.little);
    var alt = data_.getFloat32(8, Endian.little);
    var climb = data_.getFloat32(12, Endian.little);
    var heading = data_.getInt16(16, Endian.little);
    var throttle = data_.getUint16(18, Endian.little);

    return VfrHud(
        airspeed: airspeed,
        groundspeed: groundspeed,
        alt: alt,
        climb: climb,
        heading: heading,
        throttle: throttle);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, airspeed, Endian.little);
    data_.setFloat32(4, groundspeed, Endian.little);
    data_.setFloat32(8, alt, Endian.little);
    data_.setFloat32(12, climb, Endian.little);
    data_.setInt16(16, heading, Endian.little);
    data_.setUint16(18, throttle, Endian.little);
    return data_;
  }
}

/// Send a command with up to seven parameters to the MAV, where params 5 and 6 are integers and the other values are floats. This is preferred over COMMAND_LONG as it allows the MAV_FRAME to be specified for interpreting positional information, such as altitude. COMMAND_INT is also preferred when sending latitude and longitude data in params 5 and 6, as it allows for greater precision. Param 5 and 6 encode positional data as scaled integers, where the scaling depends on the actual command value. NaN or INT32_MAX may be used in float/integer params (respectively) to indicate optional/default values (e.g. to use the component's current latitude, yaw rather than a specific value). The command microservice is documented at https://mavlink.io/en/services/command.html
///
/// COMMAND_INT
class CommandInt implements MavlinkMessage {
  static const int _mavlinkMessageId = 75;

  static const int _mavlinkCrcExtra = 158;

  static const int mavlinkEncodedLength = 35;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// PARAM1, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param1
  final float param1;

  /// PARAM2, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param2
  final float param2;

  /// PARAM3, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param3
  final float param3;

  /// PARAM4, see MAV_CMD enum
  ///
  /// MAVLink type: float
  ///
  /// param4
  final float param4;

  /// PARAM5 / local: x position in meters * 1e4, global: latitude in degrees * 10^7
  ///
  /// MAVLink type: int32_t
  ///
  /// x
  final int32_t x;

  /// PARAM6 / local: y position in meters * 1e4, global: longitude in degrees * 10^7
  ///
  /// MAVLink type: int32_t
  ///
  /// y
  final int32_t y;

  /// PARAM7 / z position: global: altitude in meters (relative or absolute, depending on frame).
  ///
  /// MAVLink type: float
  ///
  /// z
  final float z;

  /// The scheduled action for the mission item.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavCmd]
  ///
  /// command
  final MavCmd command;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// The coordinate system of the COMMAND.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// frame
  final MavFrame frame;

  /// Not used.
  ///
  /// MAVLink type: uint8_t
  ///
  /// current
  final uint8_t current;

  /// Not used (set 0).
  ///
  /// MAVLink type: uint8_t
  ///
  /// autocontinue
  final uint8_t autocontinue;

  CommandInt({
    required this.param1,
    required this.param2,
    required this.param3,
    required this.param4,
    required this.x,
    required this.y,
    required this.z,
    required this.command,
    required this.targetSystem,
    required this.targetComponent,
    required this.frame,
    required this.current,
    required this.autocontinue,
  });

  CommandInt copyWith({
    float? param1,
    float? param2,
    float? param3,
    float? param4,
    int32_t? x,
    int32_t? y,
    float? z,
    MavCmd? command,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavFrame? frame,
    uint8_t? current,
    uint8_t? autocontinue,
  }) {
    return CommandInt(
      param1: param1 ?? this.param1,
      param2: param2 ?? this.param2,
      param3: param3 ?? this.param3,
      param4: param4 ?? this.param4,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      command: command ?? this.command,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      frame: frame ?? this.frame,
      current: current ?? this.current,
      autocontinue: autocontinue ?? this.autocontinue,
    );
  }

  factory CommandInt.parse(ByteData data_) {
    if (data_.lengthInBytes < CommandInt.mavlinkEncodedLength) {
      var len = CommandInt.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var param1 = data_.getFloat32(0, Endian.little);
    var param2 = data_.getFloat32(4, Endian.little);
    var param3 = data_.getFloat32(8, Endian.little);
    var param4 = data_.getFloat32(12, Endian.little);
    var x = data_.getInt32(16, Endian.little);
    var y = data_.getInt32(20, Endian.little);
    var z = data_.getFloat32(24, Endian.little);
    var command = data_.getUint16(28, Endian.little);
    var targetSystem = data_.getUint8(30);
    var targetComponent = data_.getUint8(31);
    var frame = data_.getUint8(32);
    var current = data_.getUint8(33);
    var autocontinue = data_.getUint8(34);

    return CommandInt(
        param1: param1,
        param2: param2,
        param3: param3,
        param4: param4,
        x: x,
        y: y,
        z: z,
        command: command,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        frame: frame,
        current: current,
        autocontinue: autocontinue);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, param1, Endian.little);
    data_.setFloat32(4, param2, Endian.little);
    data_.setFloat32(8, param3, Endian.little);
    data_.setFloat32(12, param4, Endian.little);
    data_.setInt32(16, x, Endian.little);
    data_.setInt32(20, y, Endian.little);
    data_.setFloat32(24, z, Endian.little);
    data_.setUint16(28, command, Endian.little);
    data_.setUint8(30, targetSystem);
    data_.setUint8(31, targetComponent);
    data_.setUint8(32, frame);
    data_.setUint8(33, current);
    data_.setUint8(34, autocontinue);
    return data_;
  }
}

/// Send a command with up to seven parameters to the MAV. COMMAND_INT is generally preferred when sending MAV_CMD commands that include positional information; it offers higher precision and allows the MAV_FRAME to be specified (which may otherwise be ambiguous, particularly for altitude). The command microservice is documented at https://mavlink.io/en/services/command.html
///
/// COMMAND_LONG
class CommandLong implements MavlinkMessage {
  static const int _mavlinkMessageId = 76;

  static const int _mavlinkCrcExtra = 152;

  static const int mavlinkEncodedLength = 33;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Parameter 1 (for the specific command).
  ///
  /// MAVLink type: float
  ///
  /// param1
  final float param1;

  /// Parameter 2 (for the specific command).
  ///
  /// MAVLink type: float
  ///
  /// param2
  final float param2;

  /// Parameter 3 (for the specific command).
  ///
  /// MAVLink type: float
  ///
  /// param3
  final float param3;

  /// Parameter 4 (for the specific command).
  ///
  /// MAVLink type: float
  ///
  /// param4
  final float param4;

  /// Parameter 5 (for the specific command).
  ///
  /// MAVLink type: float
  ///
  /// param5
  final float param5;

  /// Parameter 6 (for the specific command).
  ///
  /// MAVLink type: float
  ///
  /// param6
  final float param6;

  /// Parameter 7 (for the specific command).
  ///
  /// MAVLink type: float
  ///
  /// param7
  final float param7;

  /// Command ID (of command to send).
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavCmd]
  ///
  /// command
  final MavCmd command;

  /// System which should execute the command
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component which should execute the command, 0 for all components
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// 0: First transmission of this command. 1-255: Confirmation transmissions (e.g. for kill command)
  ///
  /// MAVLink type: uint8_t
  ///
  /// confirmation
  final uint8_t confirmation;

  CommandLong({
    required this.param1,
    required this.param2,
    required this.param3,
    required this.param4,
    required this.param5,
    required this.param6,
    required this.param7,
    required this.command,
    required this.targetSystem,
    required this.targetComponent,
    required this.confirmation,
  });

  CommandLong copyWith({
    float? param1,
    float? param2,
    float? param3,
    float? param4,
    float? param5,
    float? param6,
    float? param7,
    MavCmd? command,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? confirmation,
  }) {
    return CommandLong(
      param1: param1 ?? this.param1,
      param2: param2 ?? this.param2,
      param3: param3 ?? this.param3,
      param4: param4 ?? this.param4,
      param5: param5 ?? this.param5,
      param6: param6 ?? this.param6,
      param7: param7 ?? this.param7,
      command: command ?? this.command,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      confirmation: confirmation ?? this.confirmation,
    );
  }

  factory CommandLong.parse(ByteData data_) {
    if (data_.lengthInBytes < CommandLong.mavlinkEncodedLength) {
      var len = CommandLong.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var param1 = data_.getFloat32(0, Endian.little);
    var param2 = data_.getFloat32(4, Endian.little);
    var param3 = data_.getFloat32(8, Endian.little);
    var param4 = data_.getFloat32(12, Endian.little);
    var param5 = data_.getFloat32(16, Endian.little);
    var param6 = data_.getFloat32(20, Endian.little);
    var param7 = data_.getFloat32(24, Endian.little);
    var command = data_.getUint16(28, Endian.little);
    var targetSystem = data_.getUint8(30);
    var targetComponent = data_.getUint8(31);
    var confirmation = data_.getUint8(32);

    return CommandLong(
        param1: param1,
        param2: param2,
        param3: param3,
        param4: param4,
        param5: param5,
        param6: param6,
        param7: param7,
        command: command,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        confirmation: confirmation);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, param1, Endian.little);
    data_.setFloat32(4, param2, Endian.little);
    data_.setFloat32(8, param3, Endian.little);
    data_.setFloat32(12, param4, Endian.little);
    data_.setFloat32(16, param5, Endian.little);
    data_.setFloat32(20, param6, Endian.little);
    data_.setFloat32(24, param7, Endian.little);
    data_.setUint16(28, command, Endian.little);
    data_.setUint8(30, targetSystem);
    data_.setUint8(31, targetComponent);
    data_.setUint8(32, confirmation);
    return data_;
  }
}

/// Report status of a command. Includes feedback whether the command was executed. The command microservice is documented at https://mavlink.io/en/services/command.html
///
/// COMMAND_ACK
class CommandAck implements MavlinkMessage {
  static const int _mavlinkMessageId = 77;

  static const int _mavlinkCrcExtra = 143;

  static const int mavlinkEncodedLength = 10;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Command ID (of acknowledged command).
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavCmd]
  ///
  /// command
  final MavCmd command;

  /// Result of command.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavResult]
  ///
  /// result
  final MavResult result;

  /// The progress percentage when result is MAV_RESULT_IN_PROGRESS. Values: [0-100], or UINT8_MAX if the progress is unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// progress
  final uint8_t progress;

  /// Additional result information. Can be set with a command-specific enum containing command-specific error reasons for why the command might be denied. If used, the associated enum must be documented in the corresponding MAV_CMD (this enum should have a 0 value to indicate "unused" or "unknown").
  ///
  /// MAVLink type: int32_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// result_param2
  final int32_t resultParam2;

  /// System ID of the target recipient. This is the ID of the system that sent the command for which this COMMAND_ACK is an acknowledgement.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID of the target recipient. This is the ID of the system that sent the command for which this COMMAND_ACK is an acknowledgement.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// target_component
  final uint8_t targetComponent;

  CommandAck({
    required this.command,
    required this.result,
    required this.progress,
    required this.resultParam2,
    required this.targetSystem,
    required this.targetComponent,
  });

  CommandAck copyWith({
    MavCmd? command,
    MavResult? result,
    uint8_t? progress,
    int32_t? resultParam2,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return CommandAck(
      command: command ?? this.command,
      result: result ?? this.result,
      progress: progress ?? this.progress,
      resultParam2: resultParam2 ?? this.resultParam2,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory CommandAck.parse(ByteData data_) {
    if (data_.lengthInBytes < CommandAck.mavlinkEncodedLength) {
      var len = CommandAck.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var command = data_.getUint16(0, Endian.little);
    var result = data_.getUint8(2);
    var progress = data_.getUint8(3);
    var resultParam2 = data_.getInt32(4, Endian.little);
    var targetSystem = data_.getUint8(8);
    var targetComponent = data_.getUint8(9);

    return CommandAck(
        command: command,
        result: result,
        progress: progress,
        resultParam2: resultParam2,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, command, Endian.little);
    data_.setUint8(2, result);
    data_.setUint8(3, progress);
    data_.setInt32(4, resultParam2, Endian.little);
    data_.setUint8(8, targetSystem);
    data_.setUint8(9, targetComponent);
    return data_;
  }
}

/// Cancel a long running command. The target system should respond with a COMMAND_ACK to the original command with result=MAV_RESULT_CANCELLED if the long running process was cancelled. If it has already completed, the cancel action can be ignored. The cancel action can be retried until some sort of acknowledgement to the original command has been received. The command microservice is documented at https://mavlink.io/en/services/command.html
///
/// COMMAND_CANCEL
class CommandCancel implements MavlinkMessage {
  static const int _mavlinkMessageId = 80;

  static const int _mavlinkCrcExtra = 14;

  static const int mavlinkEncodedLength = 4;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Command ID (of command to cancel).
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavCmd]
  ///
  /// command
  final MavCmd command;

  /// System executing long running command. Should not be broadcast (0).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component executing long running command.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  CommandCancel({
    required this.command,
    required this.targetSystem,
    required this.targetComponent,
  });

  CommandCancel copyWith({
    MavCmd? command,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return CommandCancel(
      command: command ?? this.command,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory CommandCancel.parse(ByteData data_) {
    if (data_.lengthInBytes < CommandCancel.mavlinkEncodedLength) {
      var len = CommandCancel.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var command = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);

    return CommandCancel(
        command: command,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, command, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    return data_;
  }
}

/// Setpoint in roll, pitch, yaw and thrust from the operator
///
/// MANUAL_SETPOINT
class ManualSetpoint implements MavlinkMessage {
  static const int _mavlinkMessageId = 81;

  static const int _mavlinkCrcExtra = 106;

  static const int mavlinkEncodedLength = 22;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Desired roll rate
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// roll
  final float roll;

  /// Desired pitch rate
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitch
  final float pitch;

  /// Desired yaw rate
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yaw
  final float yaw;

  /// Collective thrust, normalized to 0 .. 1
  ///
  /// MAVLink type: float
  ///
  /// thrust
  final float thrust;

  /// Flight mode switch position, 0.. 255
  ///
  /// MAVLink type: uint8_t
  ///
  /// mode_switch
  final uint8_t modeSwitch;

  /// Override mode switch position, 0.. 255
  ///
  /// MAVLink type: uint8_t
  ///
  /// manual_override_switch
  final uint8_t manualOverrideSwitch;

  ManualSetpoint({
    required this.timeBootMs,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.thrust,
    required this.modeSwitch,
    required this.manualOverrideSwitch,
  });

  ManualSetpoint copyWith({
    uint32_t? timeBootMs,
    float? roll,
    float? pitch,
    float? yaw,
    float? thrust,
    uint8_t? modeSwitch,
    uint8_t? manualOverrideSwitch,
  }) {
    return ManualSetpoint(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      thrust: thrust ?? this.thrust,
      modeSwitch: modeSwitch ?? this.modeSwitch,
      manualOverrideSwitch: manualOverrideSwitch ?? this.manualOverrideSwitch,
    );
  }

  factory ManualSetpoint.parse(ByteData data_) {
    if (data_.lengthInBytes < ManualSetpoint.mavlinkEncodedLength) {
      var len = ManualSetpoint.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var roll = data_.getFloat32(4, Endian.little);
    var pitch = data_.getFloat32(8, Endian.little);
    var yaw = data_.getFloat32(12, Endian.little);
    var thrust = data_.getFloat32(16, Endian.little);
    var modeSwitch = data_.getUint8(20);
    var manualOverrideSwitch = data_.getUint8(21);

    return ManualSetpoint(
        timeBootMs: timeBootMs,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        thrust: thrust,
        modeSwitch: modeSwitch,
        manualOverrideSwitch: manualOverrideSwitch);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, roll, Endian.little);
    data_.setFloat32(8, pitch, Endian.little);
    data_.setFloat32(12, yaw, Endian.little);
    data_.setFloat32(16, thrust, Endian.little);
    data_.setUint8(20, modeSwitch);
    data_.setUint8(21, manualOverrideSwitch);
    return data_;
  }
}

/// Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller or other system).
///
/// SET_ATTITUDE_TARGET
class SetAttitudeTarget implements MavlinkMessage {
  static const int _mavlinkMessageId = 82;

  static const int _mavlinkCrcExtra = 49;

  static const int mavlinkEncodedLength = 51;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0) from MAV_FRAME_LOCAL_NED to MAV_FRAME_BODY_FRD
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// Body roll rate
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// body_roll_rate
  final float bodyRollRate;

  /// Body pitch rate
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// body_pitch_rate
  final float bodyPitchRate;

  /// Body yaw rate
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// body_yaw_rate
  final float bodyYawRate;

  /// Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
  ///
  /// MAVLink type: float
  ///
  /// thrust
  final float thrust;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Bitmap to indicate which dimensions should be ignored by the vehicle.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AttitudeTargetTypemask]
  ///
  /// type_mask
  final AttitudeTargetTypemask typeMask;

  /// 3D thrust setpoint in the body NED frame, normalized to -1 .. 1
  ///
  /// MAVLink type: float[3]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// thrust_body
  final List<float> thrustBody;

  SetAttitudeTarget({
    required this.timeBootMs,
    required this.q,
    required this.bodyRollRate,
    required this.bodyPitchRate,
    required this.bodyYawRate,
    required this.thrust,
    required this.targetSystem,
    required this.targetComponent,
    required this.typeMask,
    required this.thrustBody,
  });

  SetAttitudeTarget copyWith({
    uint32_t? timeBootMs,
    List<float>? q,
    float? bodyRollRate,
    float? bodyPitchRate,
    float? bodyYawRate,
    float? thrust,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    AttitudeTargetTypemask? typeMask,
    List<float>? thrustBody,
  }) {
    return SetAttitudeTarget(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      q: q ?? this.q,
      bodyRollRate: bodyRollRate ?? this.bodyRollRate,
      bodyPitchRate: bodyPitchRate ?? this.bodyPitchRate,
      bodyYawRate: bodyYawRate ?? this.bodyYawRate,
      thrust: thrust ?? this.thrust,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      typeMask: typeMask ?? this.typeMask,
      thrustBody: thrustBody ?? this.thrustBody,
    );
  }

  factory SetAttitudeTarget.parse(ByteData data_) {
    if (data_.lengthInBytes < SetAttitudeTarget.mavlinkEncodedLength) {
      var len = SetAttitudeTarget.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 4, 4);
    var bodyRollRate = data_.getFloat32(20, Endian.little);
    var bodyPitchRate = data_.getFloat32(24, Endian.little);
    var bodyYawRate = data_.getFloat32(28, Endian.little);
    var thrust = data_.getFloat32(32, Endian.little);
    var targetSystem = data_.getUint8(36);
    var targetComponent = data_.getUint8(37);
    var typeMask = data_.getUint8(38);
    var thrustBody = MavlinkMessage.asFloat32List(data_, 39, 3);

    return SetAttitudeTarget(
        timeBootMs: timeBootMs,
        q: q,
        bodyRollRate: bodyRollRate,
        bodyPitchRate: bodyPitchRate,
        bodyYawRate: bodyYawRate,
        thrust: thrust,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        typeMask: typeMask,
        thrustBody: thrustBody);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    MavlinkMessage.setFloat32List(data_, 4, q);
    data_.setFloat32(20, bodyRollRate, Endian.little);
    data_.setFloat32(24, bodyPitchRate, Endian.little);
    data_.setFloat32(28, bodyYawRate, Endian.little);
    data_.setFloat32(32, thrust, Endian.little);
    data_.setUint8(36, targetSystem);
    data_.setUint8(37, targetComponent);
    data_.setUint8(38, typeMask);
    MavlinkMessage.setFloat32List(data_, 39, thrustBody);
    return data_;
  }
}

/// Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way.
///
/// ATTITUDE_TARGET
class AttitudeTarget implements MavlinkMessage {
  static const int _mavlinkMessageId = 83;

  static const int _mavlinkCrcExtra = 22;

  static const int mavlinkEncodedLength = 37;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// Body roll rate
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// body_roll_rate
  final float bodyRollRate;

  /// Body pitch rate
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// body_pitch_rate
  final float bodyPitchRate;

  /// Body yaw rate
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// body_yaw_rate
  final float bodyYawRate;

  /// Collective thrust, normalized to 0 .. 1 (-1 .. 1 for vehicles capable of reverse trust)
  ///
  /// MAVLink type: float
  ///
  /// thrust
  final float thrust;

  /// Bitmap to indicate which dimensions should be ignored by the vehicle.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AttitudeTargetTypemask]
  ///
  /// type_mask
  final AttitudeTargetTypemask typeMask;

  AttitudeTarget({
    required this.timeBootMs,
    required this.q,
    required this.bodyRollRate,
    required this.bodyPitchRate,
    required this.bodyYawRate,
    required this.thrust,
    required this.typeMask,
  });

  AttitudeTarget copyWith({
    uint32_t? timeBootMs,
    List<float>? q,
    float? bodyRollRate,
    float? bodyPitchRate,
    float? bodyYawRate,
    float? thrust,
    AttitudeTargetTypemask? typeMask,
  }) {
    return AttitudeTarget(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      q: q ?? this.q,
      bodyRollRate: bodyRollRate ?? this.bodyRollRate,
      bodyPitchRate: bodyPitchRate ?? this.bodyPitchRate,
      bodyYawRate: bodyYawRate ?? this.bodyYawRate,
      thrust: thrust ?? this.thrust,
      typeMask: typeMask ?? this.typeMask,
    );
  }

  factory AttitudeTarget.parse(ByteData data_) {
    if (data_.lengthInBytes < AttitudeTarget.mavlinkEncodedLength) {
      var len = AttitudeTarget.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 4, 4);
    var bodyRollRate = data_.getFloat32(20, Endian.little);
    var bodyPitchRate = data_.getFloat32(24, Endian.little);
    var bodyYawRate = data_.getFloat32(28, Endian.little);
    var thrust = data_.getFloat32(32, Endian.little);
    var typeMask = data_.getUint8(36);

    return AttitudeTarget(
        timeBootMs: timeBootMs,
        q: q,
        bodyRollRate: bodyRollRate,
        bodyPitchRate: bodyPitchRate,
        bodyYawRate: bodyYawRate,
        thrust: thrust,
        typeMask: typeMask);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    MavlinkMessage.setFloat32List(data_, 4, q);
    data_.setFloat32(20, bodyRollRate, Endian.little);
    data_.setFloat32(24, bodyPitchRate, Endian.little);
    data_.setFloat32(28, bodyYawRate, Endian.little);
    data_.setFloat32(32, thrust, Endian.little);
    data_.setUint8(36, typeMask);
    return data_;
  }
}

/// Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller to command the vehicle (manual controller or other system).
///
/// SET_POSITION_TARGET_LOCAL_NED
class SetPositionTargetLocalNed implements MavlinkMessage {
  static const int _mavlinkMessageId = 84;

  static const int _mavlinkCrcExtra = 143;

  static const int mavlinkEncodedLength = 53;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// X Position in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Y Position in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Z Position in NED frame (note, altitude is negative in NED)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// X velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// Y velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// Z velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afx
  final float afx;

  /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afy
  final float afy;

  /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afz
  final float afz;

  /// yaw setpoint
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// yaw rate setpoint
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yaw_rate
  final float yawRate;

  /// Bitmap to indicate which dimensions should be ignored by the vehicle.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [PositionTargetTypemask]
  ///
  /// type_mask
  final PositionTargetTypemask typeMask;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// coordinate_frame
  final MavFrame coordinateFrame;

  SetPositionTargetLocalNed({
    required this.timeBootMs,
    required this.x,
    required this.y,
    required this.z,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.afx,
    required this.afy,
    required this.afz,
    required this.yaw,
    required this.yawRate,
    required this.typeMask,
    required this.targetSystem,
    required this.targetComponent,
    required this.coordinateFrame,
  });

  SetPositionTargetLocalNed copyWith({
    uint32_t? timeBootMs,
    float? x,
    float? y,
    float? z,
    float? vx,
    float? vy,
    float? vz,
    float? afx,
    float? afy,
    float? afz,
    float? yaw,
    float? yawRate,
    PositionTargetTypemask? typeMask,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavFrame? coordinateFrame,
  }) {
    return SetPositionTargetLocalNed(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      afx: afx ?? this.afx,
      afy: afy ?? this.afy,
      afz: afz ?? this.afz,
      yaw: yaw ?? this.yaw,
      yawRate: yawRate ?? this.yawRate,
      typeMask: typeMask ?? this.typeMask,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      coordinateFrame: coordinateFrame ?? this.coordinateFrame,
    );
  }

  factory SetPositionTargetLocalNed.parse(ByteData data_) {
    if (data_.lengthInBytes < SetPositionTargetLocalNed.mavlinkEncodedLength) {
      var len =
          SetPositionTargetLocalNed.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var x = data_.getFloat32(4, Endian.little);
    var y = data_.getFloat32(8, Endian.little);
    var z = data_.getFloat32(12, Endian.little);
    var vx = data_.getFloat32(16, Endian.little);
    var vy = data_.getFloat32(20, Endian.little);
    var vz = data_.getFloat32(24, Endian.little);
    var afx = data_.getFloat32(28, Endian.little);
    var afy = data_.getFloat32(32, Endian.little);
    var afz = data_.getFloat32(36, Endian.little);
    var yaw = data_.getFloat32(40, Endian.little);
    var yawRate = data_.getFloat32(44, Endian.little);
    var typeMask = data_.getUint16(48, Endian.little);
    var targetSystem = data_.getUint8(50);
    var targetComponent = data_.getUint8(51);
    var coordinateFrame = data_.getUint8(52);

    return SetPositionTargetLocalNed(
        timeBootMs: timeBootMs,
        x: x,
        y: y,
        z: z,
        vx: vx,
        vy: vy,
        vz: vz,
        afx: afx,
        afy: afy,
        afz: afz,
        yaw: yaw,
        yawRate: yawRate,
        typeMask: typeMask,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        coordinateFrame: coordinateFrame);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, x, Endian.little);
    data_.setFloat32(8, y, Endian.little);
    data_.setFloat32(12, z, Endian.little);
    data_.setFloat32(16, vx, Endian.little);
    data_.setFloat32(20, vy, Endian.little);
    data_.setFloat32(24, vz, Endian.little);
    data_.setFloat32(28, afx, Endian.little);
    data_.setFloat32(32, afy, Endian.little);
    data_.setFloat32(36, afz, Endian.little);
    data_.setFloat32(40, yaw, Endian.little);
    data_.setFloat32(44, yawRate, Endian.little);
    data_.setUint16(48, typeMask, Endian.little);
    data_.setUint8(50, targetSystem);
    data_.setUint8(51, targetComponent);
    data_.setUint8(52, coordinateFrame);
    return data_;
  }
}

/// Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled this way.
///
/// POSITION_TARGET_LOCAL_NED
class PositionTargetLocalNed implements MavlinkMessage {
  static const int _mavlinkMessageId = 85;

  static const int _mavlinkCrcExtra = 140;

  static const int mavlinkEncodedLength = 51;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// X Position in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Y Position in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Z Position in NED frame (note, altitude is negative in NED)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// X velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// Y velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// Z velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afx
  final float afx;

  /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afy
  final float afy;

  /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afz
  final float afz;

  /// yaw setpoint
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// yaw rate setpoint
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yaw_rate
  final float yawRate;

  /// Bitmap to indicate which dimensions should be ignored by the vehicle.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [PositionTargetTypemask]
  ///
  /// type_mask
  final PositionTargetTypemask typeMask;

  /// Valid options are: MAV_FRAME_LOCAL_NED = 1, MAV_FRAME_LOCAL_OFFSET_NED = 7, MAV_FRAME_BODY_NED = 8, MAV_FRAME_BODY_OFFSET_NED = 9
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// coordinate_frame
  final MavFrame coordinateFrame;

  PositionTargetLocalNed({
    required this.timeBootMs,
    required this.x,
    required this.y,
    required this.z,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.afx,
    required this.afy,
    required this.afz,
    required this.yaw,
    required this.yawRate,
    required this.typeMask,
    required this.coordinateFrame,
  });

  PositionTargetLocalNed copyWith({
    uint32_t? timeBootMs,
    float? x,
    float? y,
    float? z,
    float? vx,
    float? vy,
    float? vz,
    float? afx,
    float? afy,
    float? afz,
    float? yaw,
    float? yawRate,
    PositionTargetTypemask? typeMask,
    MavFrame? coordinateFrame,
  }) {
    return PositionTargetLocalNed(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      afx: afx ?? this.afx,
      afy: afy ?? this.afy,
      afz: afz ?? this.afz,
      yaw: yaw ?? this.yaw,
      yawRate: yawRate ?? this.yawRate,
      typeMask: typeMask ?? this.typeMask,
      coordinateFrame: coordinateFrame ?? this.coordinateFrame,
    );
  }

  factory PositionTargetLocalNed.parse(ByteData data_) {
    if (data_.lengthInBytes < PositionTargetLocalNed.mavlinkEncodedLength) {
      var len =
          PositionTargetLocalNed.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var x = data_.getFloat32(4, Endian.little);
    var y = data_.getFloat32(8, Endian.little);
    var z = data_.getFloat32(12, Endian.little);
    var vx = data_.getFloat32(16, Endian.little);
    var vy = data_.getFloat32(20, Endian.little);
    var vz = data_.getFloat32(24, Endian.little);
    var afx = data_.getFloat32(28, Endian.little);
    var afy = data_.getFloat32(32, Endian.little);
    var afz = data_.getFloat32(36, Endian.little);
    var yaw = data_.getFloat32(40, Endian.little);
    var yawRate = data_.getFloat32(44, Endian.little);
    var typeMask = data_.getUint16(48, Endian.little);
    var coordinateFrame = data_.getUint8(50);

    return PositionTargetLocalNed(
        timeBootMs: timeBootMs,
        x: x,
        y: y,
        z: z,
        vx: vx,
        vy: vy,
        vz: vz,
        afx: afx,
        afy: afy,
        afz: afz,
        yaw: yaw,
        yawRate: yawRate,
        typeMask: typeMask,
        coordinateFrame: coordinateFrame);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, x, Endian.little);
    data_.setFloat32(8, y, Endian.little);
    data_.setFloat32(12, z, Endian.little);
    data_.setFloat32(16, vx, Endian.little);
    data_.setFloat32(20, vy, Endian.little);
    data_.setFloat32(24, vz, Endian.little);
    data_.setFloat32(28, afx, Endian.little);
    data_.setFloat32(32, afy, Endian.little);
    data_.setFloat32(36, afz, Endian.little);
    data_.setFloat32(40, yaw, Endian.little);
    data_.setFloat32(44, yawRate, Endian.little);
    data_.setUint16(48, typeMask, Endian.little);
    data_.setUint8(50, coordinateFrame);
    return data_;
  }
}

/// Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84). Used by an external controller to command the vehicle (manual controller or other system).
///
/// SET_POSITION_TARGET_GLOBAL_INT
class SetPositionTargetGlobalInt implements MavlinkMessage {
  static const int _mavlinkMessageId = 86;

  static const int _mavlinkCrcExtra = 5;

  static const int mavlinkEncodedLength = 53;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Latitude in WGS84 frame
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat_int
  final int32_t latInt;

  /// Longitude in WGS84 frame
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon_int
  final int32_t lonInt;

  /// Altitude (MSL, Relative to home, or AGL - depending on frame)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt
  final float alt;

  /// X velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// Y velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// Z velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afx
  final float afx;

  /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afy
  final float afy;

  /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afz
  final float afz;

  /// yaw setpoint
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// yaw rate setpoint
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yaw_rate
  final float yawRate;

  /// Bitmap to indicate which dimensions should be ignored by the vehicle.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [PositionTargetTypemask]
  ///
  /// type_mask
  final PositionTargetTypemask typeMask;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Valid options are: MAV_FRAME_GLOBAL = 0, MAV_FRAME_GLOBAL_RELATIVE_ALT = 3, MAV_FRAME_GLOBAL_TERRAIN_ALT = 10 (MAV_FRAME_GLOBAL_INT, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT are allowed synonyms, but have been deprecated)
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// coordinate_frame
  final MavFrame coordinateFrame;

  SetPositionTargetGlobalInt({
    required this.timeBootMs,
    required this.latInt,
    required this.lonInt,
    required this.alt,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.afx,
    required this.afy,
    required this.afz,
    required this.yaw,
    required this.yawRate,
    required this.typeMask,
    required this.targetSystem,
    required this.targetComponent,
    required this.coordinateFrame,
  });

  SetPositionTargetGlobalInt copyWith({
    uint32_t? timeBootMs,
    int32_t? latInt,
    int32_t? lonInt,
    float? alt,
    float? vx,
    float? vy,
    float? vz,
    float? afx,
    float? afy,
    float? afz,
    float? yaw,
    float? yawRate,
    PositionTargetTypemask? typeMask,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavFrame? coordinateFrame,
  }) {
    return SetPositionTargetGlobalInt(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      latInt: latInt ?? this.latInt,
      lonInt: lonInt ?? this.lonInt,
      alt: alt ?? this.alt,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      afx: afx ?? this.afx,
      afy: afy ?? this.afy,
      afz: afz ?? this.afz,
      yaw: yaw ?? this.yaw,
      yawRate: yawRate ?? this.yawRate,
      typeMask: typeMask ?? this.typeMask,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      coordinateFrame: coordinateFrame ?? this.coordinateFrame,
    );
  }

  factory SetPositionTargetGlobalInt.parse(ByteData data_) {
    if (data_.lengthInBytes < SetPositionTargetGlobalInt.mavlinkEncodedLength) {
      var len =
          SetPositionTargetGlobalInt.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var latInt = data_.getInt32(4, Endian.little);
    var lonInt = data_.getInt32(8, Endian.little);
    var alt = data_.getFloat32(12, Endian.little);
    var vx = data_.getFloat32(16, Endian.little);
    var vy = data_.getFloat32(20, Endian.little);
    var vz = data_.getFloat32(24, Endian.little);
    var afx = data_.getFloat32(28, Endian.little);
    var afy = data_.getFloat32(32, Endian.little);
    var afz = data_.getFloat32(36, Endian.little);
    var yaw = data_.getFloat32(40, Endian.little);
    var yawRate = data_.getFloat32(44, Endian.little);
    var typeMask = data_.getUint16(48, Endian.little);
    var targetSystem = data_.getUint8(50);
    var targetComponent = data_.getUint8(51);
    var coordinateFrame = data_.getUint8(52);

    return SetPositionTargetGlobalInt(
        timeBootMs: timeBootMs,
        latInt: latInt,
        lonInt: lonInt,
        alt: alt,
        vx: vx,
        vy: vy,
        vz: vz,
        afx: afx,
        afy: afy,
        afz: afz,
        yaw: yaw,
        yawRate: yawRate,
        typeMask: typeMask,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        coordinateFrame: coordinateFrame);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt32(4, latInt, Endian.little);
    data_.setInt32(8, lonInt, Endian.little);
    data_.setFloat32(12, alt, Endian.little);
    data_.setFloat32(16, vx, Endian.little);
    data_.setFloat32(20, vy, Endian.little);
    data_.setFloat32(24, vz, Endian.little);
    data_.setFloat32(28, afx, Endian.little);
    data_.setFloat32(32, afy, Endian.little);
    data_.setFloat32(36, afz, Endian.little);
    data_.setFloat32(40, yaw, Endian.little);
    data_.setFloat32(44, yawRate, Endian.little);
    data_.setUint16(48, typeMask, Endian.little);
    data_.setUint8(50, targetSystem);
    data_.setUint8(51, targetComponent);
    data_.setUint8(52, coordinateFrame);
    return data_;
  }
}

/// Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot. This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled this way.
///
/// POSITION_TARGET_GLOBAL_INT
class PositionTargetGlobalInt implements MavlinkMessage {
  static const int _mavlinkMessageId = 87;

  static const int _mavlinkCrcExtra = 150;

  static const int mavlinkEncodedLength = 51;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot). The rationale for the timestamp in the setpoint is to allow the system to compensate for the transport delay of the setpoint. This allows the system to compensate processing latency.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Latitude in WGS84 frame
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat_int
  final int32_t latInt;

  /// Longitude in WGS84 frame
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon_int
  final int32_t lonInt;

  /// Altitude (MSL, AGL or relative to home altitude, depending on frame)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt
  final float alt;

  /// X velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// Y velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// Z velocity in NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  /// X acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afx
  final float afx;

  /// Y acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afy
  final float afy;

  /// Z acceleration or force (if bit 10 of type_mask is set) in NED frame in meter / s^2 or N
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// afz
  final float afz;

  /// yaw setpoint
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// yaw rate setpoint
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yaw_rate
  final float yawRate;

  /// Bitmap to indicate which dimensions should be ignored by the vehicle.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [PositionTargetTypemask]
  ///
  /// type_mask
  final PositionTargetTypemask typeMask;

  /// Valid options are: MAV_FRAME_GLOBAL = 0, MAV_FRAME_GLOBAL_RELATIVE_ALT = 3, MAV_FRAME_GLOBAL_TERRAIN_ALT = 10 (MAV_FRAME_GLOBAL_INT, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT are allowed synonyms, but have been deprecated)
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// coordinate_frame
  final MavFrame coordinateFrame;

  PositionTargetGlobalInt({
    required this.timeBootMs,
    required this.latInt,
    required this.lonInt,
    required this.alt,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.afx,
    required this.afy,
    required this.afz,
    required this.yaw,
    required this.yawRate,
    required this.typeMask,
    required this.coordinateFrame,
  });

  PositionTargetGlobalInt copyWith({
    uint32_t? timeBootMs,
    int32_t? latInt,
    int32_t? lonInt,
    float? alt,
    float? vx,
    float? vy,
    float? vz,
    float? afx,
    float? afy,
    float? afz,
    float? yaw,
    float? yawRate,
    PositionTargetTypemask? typeMask,
    MavFrame? coordinateFrame,
  }) {
    return PositionTargetGlobalInt(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      latInt: latInt ?? this.latInt,
      lonInt: lonInt ?? this.lonInt,
      alt: alt ?? this.alt,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      afx: afx ?? this.afx,
      afy: afy ?? this.afy,
      afz: afz ?? this.afz,
      yaw: yaw ?? this.yaw,
      yawRate: yawRate ?? this.yawRate,
      typeMask: typeMask ?? this.typeMask,
      coordinateFrame: coordinateFrame ?? this.coordinateFrame,
    );
  }

  factory PositionTargetGlobalInt.parse(ByteData data_) {
    if (data_.lengthInBytes < PositionTargetGlobalInt.mavlinkEncodedLength) {
      var len =
          PositionTargetGlobalInt.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var latInt = data_.getInt32(4, Endian.little);
    var lonInt = data_.getInt32(8, Endian.little);
    var alt = data_.getFloat32(12, Endian.little);
    var vx = data_.getFloat32(16, Endian.little);
    var vy = data_.getFloat32(20, Endian.little);
    var vz = data_.getFloat32(24, Endian.little);
    var afx = data_.getFloat32(28, Endian.little);
    var afy = data_.getFloat32(32, Endian.little);
    var afz = data_.getFloat32(36, Endian.little);
    var yaw = data_.getFloat32(40, Endian.little);
    var yawRate = data_.getFloat32(44, Endian.little);
    var typeMask = data_.getUint16(48, Endian.little);
    var coordinateFrame = data_.getUint8(50);

    return PositionTargetGlobalInt(
        timeBootMs: timeBootMs,
        latInt: latInt,
        lonInt: lonInt,
        alt: alt,
        vx: vx,
        vy: vy,
        vz: vz,
        afx: afx,
        afy: afy,
        afz: afz,
        yaw: yaw,
        yawRate: yawRate,
        typeMask: typeMask,
        coordinateFrame: coordinateFrame);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt32(4, latInt, Endian.little);
    data_.setInt32(8, lonInt, Endian.little);
    data_.setFloat32(12, alt, Endian.little);
    data_.setFloat32(16, vx, Endian.little);
    data_.setFloat32(20, vy, Endian.little);
    data_.setFloat32(24, vz, Endian.little);
    data_.setFloat32(28, afx, Endian.little);
    data_.setFloat32(32, afy, Endian.little);
    data_.setFloat32(36, afz, Endian.little);
    data_.setFloat32(40, yaw, Endian.little);
    data_.setFloat32(44, yawRate, Endian.little);
    data_.setUint16(48, typeMask, Endian.little);
    data_.setUint8(50, coordinateFrame);
    return data_;
  }
}

/// The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down convention)
///
/// LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET
class LocalPositionNedSystemGlobalOffset implements MavlinkMessage {
  static const int _mavlinkMessageId = 89;

  static const int _mavlinkCrcExtra = 231;

  static const int mavlinkEncodedLength = 28;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// X Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Y Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Z Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// Roll
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  LocalPositionNedSystemGlobalOffset({
    required this.timeBootMs,
    required this.x,
    required this.y,
    required this.z,
    required this.roll,
    required this.pitch,
    required this.yaw,
  });

  LocalPositionNedSystemGlobalOffset copyWith({
    uint32_t? timeBootMs,
    float? x,
    float? y,
    float? z,
    float? roll,
    float? pitch,
    float? yaw,
  }) {
    return LocalPositionNedSystemGlobalOffset(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
    );
  }

  factory LocalPositionNedSystemGlobalOffset.parse(ByteData data_) {
    if (data_.lengthInBytes <
        LocalPositionNedSystemGlobalOffset.mavlinkEncodedLength) {
      var len = LocalPositionNedSystemGlobalOffset.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var x = data_.getFloat32(4, Endian.little);
    var y = data_.getFloat32(8, Endian.little);
    var z = data_.getFloat32(12, Endian.little);
    var roll = data_.getFloat32(16, Endian.little);
    var pitch = data_.getFloat32(20, Endian.little);
    var yaw = data_.getFloat32(24, Endian.little);

    return LocalPositionNedSystemGlobalOffset(
        timeBootMs: timeBootMs,
        x: x,
        y: y,
        z: z,
        roll: roll,
        pitch: pitch,
        yaw: yaw);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, x, Endian.little);
    data_.setFloat32(8, y, Endian.little);
    data_.setFloat32(12, z, Endian.little);
    data_.setFloat32(16, roll, Endian.little);
    data_.setFloat32(20, pitch, Endian.little);
    data_.setFloat32(24, yaw, Endian.little);
    return data_;
  }
}

/// Sent from simulation to autopilot. This packet is useful for high throughput applications such as hardware in the loop simulations.
///
/// HIL_STATE
class HilState implements MavlinkMessage {
  static const int _mavlinkMessageId = 90;

  static const int _mavlinkCrcExtra = 183;

  static const int mavlinkEncodedLength = 56;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Roll angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Body frame roll / phi angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// rollspeed
  final float rollspeed;

  /// Body frame pitch / theta angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitchspeed
  final float pitchspeed;

  /// Body frame yaw / psi angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yawspeed
  final float yawspeed;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt
  final int32_t alt;

  /// Ground X Speed (Latitude)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vx
  final int16_t vx;

  /// Ground Y Speed (Longitude)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vy
  final int16_t vy;

  /// Ground Z Speed (Altitude)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vz
  final int16_t vz;

  /// X acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// xacc
  final int16_t xacc;

  /// Y acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// yacc
  final int16_t yacc;

  /// Z acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// zacc
  final int16_t zacc;

  HilState({
    required this.timeUsec,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.rollspeed,
    required this.pitchspeed,
    required this.yawspeed,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.xacc,
    required this.yacc,
    required this.zacc,
  });

  HilState copyWith({
    uint64_t? timeUsec,
    float? roll,
    float? pitch,
    float? yaw,
    float? rollspeed,
    float? pitchspeed,
    float? yawspeed,
    int32_t? lat,
    int32_t? lon,
    int32_t? alt,
    int16_t? vx,
    int16_t? vy,
    int16_t? vz,
    int16_t? xacc,
    int16_t? yacc,
    int16_t? zacc,
  }) {
    return HilState(
      timeUsec: timeUsec ?? this.timeUsec,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      rollspeed: rollspeed ?? this.rollspeed,
      pitchspeed: pitchspeed ?? this.pitchspeed,
      yawspeed: yawspeed ?? this.yawspeed,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
    );
  }

  factory HilState.parse(ByteData data_) {
    if (data_.lengthInBytes < HilState.mavlinkEncodedLength) {
      var len = HilState.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var roll = data_.getFloat32(8, Endian.little);
    var pitch = data_.getFloat32(12, Endian.little);
    var yaw = data_.getFloat32(16, Endian.little);
    var rollspeed = data_.getFloat32(20, Endian.little);
    var pitchspeed = data_.getFloat32(24, Endian.little);
    var yawspeed = data_.getFloat32(28, Endian.little);
    var lat = data_.getInt32(32, Endian.little);
    var lon = data_.getInt32(36, Endian.little);
    var alt = data_.getInt32(40, Endian.little);
    var vx = data_.getInt16(44, Endian.little);
    var vy = data_.getInt16(46, Endian.little);
    var vz = data_.getInt16(48, Endian.little);
    var xacc = data_.getInt16(50, Endian.little);
    var yacc = data_.getInt16(52, Endian.little);
    var zacc = data_.getInt16(54, Endian.little);

    return HilState(
        timeUsec: timeUsec,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        rollspeed: rollspeed,
        pitchspeed: pitchspeed,
        yawspeed: yawspeed,
        lat: lat,
        lon: lon,
        alt: alt,
        vx: vx,
        vy: vy,
        vz: vz,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, roll, Endian.little);
    data_.setFloat32(12, pitch, Endian.little);
    data_.setFloat32(16, yaw, Endian.little);
    data_.setFloat32(20, rollspeed, Endian.little);
    data_.setFloat32(24, pitchspeed, Endian.little);
    data_.setFloat32(28, yawspeed, Endian.little);
    data_.setInt32(32, lat, Endian.little);
    data_.setInt32(36, lon, Endian.little);
    data_.setInt32(40, alt, Endian.little);
    data_.setInt16(44, vx, Endian.little);
    data_.setInt16(46, vy, Endian.little);
    data_.setInt16(48, vz, Endian.little);
    data_.setInt16(50, xacc, Endian.little);
    data_.setInt16(52, yacc, Endian.little);
    data_.setInt16(54, zacc, Endian.little);
    return data_;
  }
}

/// Sent from autopilot to simulation. Hardware in the loop control outputs
///
/// HIL_CONTROLS
class HilControls implements MavlinkMessage {
  static const int _mavlinkMessageId = 91;

  static const int _mavlinkCrcExtra = 63;

  static const int mavlinkEncodedLength = 42;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Control output -1 .. 1
  ///
  /// MAVLink type: float
  ///
  /// roll_ailerons
  final float rollAilerons;

  /// Control output -1 .. 1
  ///
  /// MAVLink type: float
  ///
  /// pitch_elevator
  final float pitchElevator;

  /// Control output -1 .. 1
  ///
  /// MAVLink type: float
  ///
  /// yaw_rudder
  final float yawRudder;

  /// Throttle 0 .. 1
  ///
  /// MAVLink type: float
  ///
  /// throttle
  final float throttle;

  /// Aux 1, -1 .. 1
  ///
  /// MAVLink type: float
  ///
  /// aux1
  final float aux1;

  /// Aux 2, -1 .. 1
  ///
  /// MAVLink type: float
  ///
  /// aux2
  final float aux2;

  /// Aux 3, -1 .. 1
  ///
  /// MAVLink type: float
  ///
  /// aux3
  final float aux3;

  /// Aux 4, -1 .. 1
  ///
  /// MAVLink type: float
  ///
  /// aux4
  final float aux4;

  /// System mode.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMode]
  ///
  /// mode
  final MavMode mode;

  /// Navigation mode (MAV_NAV_MODE)
  ///
  /// MAVLink type: uint8_t
  ///
  /// nav_mode
  final uint8_t navMode;

  HilControls({
    required this.timeUsec,
    required this.rollAilerons,
    required this.pitchElevator,
    required this.yawRudder,
    required this.throttle,
    required this.aux1,
    required this.aux2,
    required this.aux3,
    required this.aux4,
    required this.mode,
    required this.navMode,
  });

  HilControls copyWith({
    uint64_t? timeUsec,
    float? rollAilerons,
    float? pitchElevator,
    float? yawRudder,
    float? throttle,
    float? aux1,
    float? aux2,
    float? aux3,
    float? aux4,
    MavMode? mode,
    uint8_t? navMode,
  }) {
    return HilControls(
      timeUsec: timeUsec ?? this.timeUsec,
      rollAilerons: rollAilerons ?? this.rollAilerons,
      pitchElevator: pitchElevator ?? this.pitchElevator,
      yawRudder: yawRudder ?? this.yawRudder,
      throttle: throttle ?? this.throttle,
      aux1: aux1 ?? this.aux1,
      aux2: aux2 ?? this.aux2,
      aux3: aux3 ?? this.aux3,
      aux4: aux4 ?? this.aux4,
      mode: mode ?? this.mode,
      navMode: navMode ?? this.navMode,
    );
  }

  factory HilControls.parse(ByteData data_) {
    if (data_.lengthInBytes < HilControls.mavlinkEncodedLength) {
      var len = HilControls.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var rollAilerons = data_.getFloat32(8, Endian.little);
    var pitchElevator = data_.getFloat32(12, Endian.little);
    var yawRudder = data_.getFloat32(16, Endian.little);
    var throttle = data_.getFloat32(20, Endian.little);
    var aux1 = data_.getFloat32(24, Endian.little);
    var aux2 = data_.getFloat32(28, Endian.little);
    var aux3 = data_.getFloat32(32, Endian.little);
    var aux4 = data_.getFloat32(36, Endian.little);
    var mode = data_.getUint8(40);
    var navMode = data_.getUint8(41);

    return HilControls(
        timeUsec: timeUsec,
        rollAilerons: rollAilerons,
        pitchElevator: pitchElevator,
        yawRudder: yawRudder,
        throttle: throttle,
        aux1: aux1,
        aux2: aux2,
        aux3: aux3,
        aux4: aux4,
        mode: mode,
        navMode: navMode);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, rollAilerons, Endian.little);
    data_.setFloat32(12, pitchElevator, Endian.little);
    data_.setFloat32(16, yawRudder, Endian.little);
    data_.setFloat32(20, throttle, Endian.little);
    data_.setFloat32(24, aux1, Endian.little);
    data_.setFloat32(28, aux2, Endian.little);
    data_.setFloat32(32, aux3, Endian.little);
    data_.setFloat32(36, aux4, Endian.little);
    data_.setUint8(40, mode);
    data_.setUint8(41, navMode);
    return data_;
  }
}

/// Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification.
///
/// HIL_RC_INPUTS_RAW
class HilRcInputsRaw implements MavlinkMessage {
  static const int _mavlinkMessageId = 92;

  static const int _mavlinkCrcExtra = 54;

  static const int mavlinkEncodedLength = 33;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// RC channel 1 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan1_raw
  final uint16_t chan1Raw;

  /// RC channel 2 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan2_raw
  final uint16_t chan2Raw;

  /// RC channel 3 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan3_raw
  final uint16_t chan3Raw;

  /// RC channel 4 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan4_raw
  final uint16_t chan4Raw;

  /// RC channel 5 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan5_raw
  final uint16_t chan5Raw;

  /// RC channel 6 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan6_raw
  final uint16_t chan6Raw;

  /// RC channel 7 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan7_raw
  final uint16_t chan7Raw;

  /// RC channel 8 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan8_raw
  final uint16_t chan8Raw;

  /// RC channel 9 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan9_raw
  final uint16_t chan9Raw;

  /// RC channel 10 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan10_raw
  final uint16_t chan10Raw;

  /// RC channel 11 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan11_raw
  final uint16_t chan11Raw;

  /// RC channel 12 value
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: us
  ///
  /// chan12_raw
  final uint16_t chan12Raw;

  /// Receive signal strength indicator in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rssi
  final uint8_t rssi;

  HilRcInputsRaw({
    required this.timeUsec,
    required this.chan1Raw,
    required this.chan2Raw,
    required this.chan3Raw,
    required this.chan4Raw,
    required this.chan5Raw,
    required this.chan6Raw,
    required this.chan7Raw,
    required this.chan8Raw,
    required this.chan9Raw,
    required this.chan10Raw,
    required this.chan11Raw,
    required this.chan12Raw,
    required this.rssi,
  });

  HilRcInputsRaw copyWith({
    uint64_t? timeUsec,
    uint16_t? chan1Raw,
    uint16_t? chan2Raw,
    uint16_t? chan3Raw,
    uint16_t? chan4Raw,
    uint16_t? chan5Raw,
    uint16_t? chan6Raw,
    uint16_t? chan7Raw,
    uint16_t? chan8Raw,
    uint16_t? chan9Raw,
    uint16_t? chan10Raw,
    uint16_t? chan11Raw,
    uint16_t? chan12Raw,
    uint8_t? rssi,
  }) {
    return HilRcInputsRaw(
      timeUsec: timeUsec ?? this.timeUsec,
      chan1Raw: chan1Raw ?? this.chan1Raw,
      chan2Raw: chan2Raw ?? this.chan2Raw,
      chan3Raw: chan3Raw ?? this.chan3Raw,
      chan4Raw: chan4Raw ?? this.chan4Raw,
      chan5Raw: chan5Raw ?? this.chan5Raw,
      chan6Raw: chan6Raw ?? this.chan6Raw,
      chan7Raw: chan7Raw ?? this.chan7Raw,
      chan8Raw: chan8Raw ?? this.chan8Raw,
      chan9Raw: chan9Raw ?? this.chan9Raw,
      chan10Raw: chan10Raw ?? this.chan10Raw,
      chan11Raw: chan11Raw ?? this.chan11Raw,
      chan12Raw: chan12Raw ?? this.chan12Raw,
      rssi: rssi ?? this.rssi,
    );
  }

  factory HilRcInputsRaw.parse(ByteData data_) {
    if (data_.lengthInBytes < HilRcInputsRaw.mavlinkEncodedLength) {
      var len = HilRcInputsRaw.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var chan1Raw = data_.getUint16(8, Endian.little);
    var chan2Raw = data_.getUint16(10, Endian.little);
    var chan3Raw = data_.getUint16(12, Endian.little);
    var chan4Raw = data_.getUint16(14, Endian.little);
    var chan5Raw = data_.getUint16(16, Endian.little);
    var chan6Raw = data_.getUint16(18, Endian.little);
    var chan7Raw = data_.getUint16(20, Endian.little);
    var chan8Raw = data_.getUint16(22, Endian.little);
    var chan9Raw = data_.getUint16(24, Endian.little);
    var chan10Raw = data_.getUint16(26, Endian.little);
    var chan11Raw = data_.getUint16(28, Endian.little);
    var chan12Raw = data_.getUint16(30, Endian.little);
    var rssi = data_.getUint8(32);

    return HilRcInputsRaw(
        timeUsec: timeUsec,
        chan1Raw: chan1Raw,
        chan2Raw: chan2Raw,
        chan3Raw: chan3Raw,
        chan4Raw: chan4Raw,
        chan5Raw: chan5Raw,
        chan6Raw: chan6Raw,
        chan7Raw: chan7Raw,
        chan8Raw: chan8Raw,
        chan9Raw: chan9Raw,
        chan10Raw: chan10Raw,
        chan11Raw: chan11Raw,
        chan12Raw: chan12Raw,
        rssi: rssi);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint16(8, chan1Raw, Endian.little);
    data_.setUint16(10, chan2Raw, Endian.little);
    data_.setUint16(12, chan3Raw, Endian.little);
    data_.setUint16(14, chan4Raw, Endian.little);
    data_.setUint16(16, chan5Raw, Endian.little);
    data_.setUint16(18, chan6Raw, Endian.little);
    data_.setUint16(20, chan7Raw, Endian.little);
    data_.setUint16(22, chan8Raw, Endian.little);
    data_.setUint16(24, chan9Raw, Endian.little);
    data_.setUint16(26, chan10Raw, Endian.little);
    data_.setUint16(28, chan11Raw, Endian.little);
    data_.setUint16(30, chan12Raw, Endian.little);
    data_.setUint8(32, rssi);
    return data_;
  }
}

/// Sent from autopilot to simulation. Hardware in the loop control outputs (replacement for HIL_CONTROLS)
///
/// HIL_ACTUATOR_CONTROLS
class HilActuatorControls implements MavlinkMessage {
  static const int _mavlinkMessageId = 93;

  static const int _mavlinkCrcExtra = 47;

  static const int mavlinkEncodedLength = 81;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Flags as bitfield, 1: indicate simulation using lockstep.
  ///
  /// MAVLink type: uint64_t
  ///
  /// flags
  final uint64_t flags;

  /// Control outputs -1 .. 1. Channel assignment depends on the simulated hardware.
  ///
  /// MAVLink type: float[16]
  ///
  /// controls
  final List<float> controls;

  /// System mode. Includes arming state.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavModeFlag]
  ///
  /// mode
  final MavModeFlag mode;

  HilActuatorControls({
    required this.timeUsec,
    required this.flags,
    required this.controls,
    required this.mode,
  });

  HilActuatorControls copyWith({
    uint64_t? timeUsec,
    uint64_t? flags,
    List<float>? controls,
    MavModeFlag? mode,
  }) {
    return HilActuatorControls(
      timeUsec: timeUsec ?? this.timeUsec,
      flags: flags ?? this.flags,
      controls: controls ?? this.controls,
      mode: mode ?? this.mode,
    );
  }

  factory HilActuatorControls.parse(ByteData data_) {
    if (data_.lengthInBytes < HilActuatorControls.mavlinkEncodedLength) {
      var len = HilActuatorControls.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var flags = data_.getUint64(8, Endian.little);
    var controls = MavlinkMessage.asFloat32List(data_, 16, 16);
    var mode = data_.getUint8(80);

    return HilActuatorControls(
        timeUsec: timeUsec, flags: flags, controls: controls, mode: mode);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint64(8, flags, Endian.little);
    MavlinkMessage.setFloat32List(data_, 16, controls);
    data_.setUint8(80, mode);
    return data_;
  }
}

/// Optical flow from a flow sensor (e.g. optical mouse sensor)
///
/// OPTICAL_FLOW
class OpticalFlow implements MavlinkMessage {
  static const int _mavlinkMessageId = 100;

  static const int _mavlinkCrcExtra = 175;

  static const int mavlinkEncodedLength = 34;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Flow in x-sensor direction, angular-speed compensated
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// flow_comp_m_x
  final float flowCompMX;

  /// Flow in y-sensor direction, angular-speed compensated
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// flow_comp_m_y
  final float flowCompMY;

  /// Ground distance. Positive value: distance known. Negative value: Unknown distance
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// ground_distance
  final float groundDistance;

  /// Flow in x-sensor direction
  ///
  /// MAVLink type: int16_t
  ///
  /// units: dpix
  ///
  /// flow_x
  final int16_t flowX;

  /// Flow in y-sensor direction
  ///
  /// MAVLink type: int16_t
  ///
  /// units: dpix
  ///
  /// flow_y
  final int16_t flowY;

  /// Sensor ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// sensor_id
  final uint8_t sensorId;

  /// Optical flow quality / confidence. 0: bad, 255: maximum quality
  ///
  /// MAVLink type: uint8_t
  ///
  /// quality
  final uint8_t quality;

  /// Flow rate about X axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// flow_rate_x
  final float flowRateX;

  /// Flow rate about Y axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// flow_rate_y
  final float flowRateY;

  OpticalFlow({
    required this.timeUsec,
    required this.flowCompMX,
    required this.flowCompMY,
    required this.groundDistance,
    required this.flowX,
    required this.flowY,
    required this.sensorId,
    required this.quality,
    required this.flowRateX,
    required this.flowRateY,
  });

  OpticalFlow copyWith({
    uint64_t? timeUsec,
    float? flowCompMX,
    float? flowCompMY,
    float? groundDistance,
    int16_t? flowX,
    int16_t? flowY,
    uint8_t? sensorId,
    uint8_t? quality,
    float? flowRateX,
    float? flowRateY,
  }) {
    return OpticalFlow(
      timeUsec: timeUsec ?? this.timeUsec,
      flowCompMX: flowCompMX ?? this.flowCompMX,
      flowCompMY: flowCompMY ?? this.flowCompMY,
      groundDistance: groundDistance ?? this.groundDistance,
      flowX: flowX ?? this.flowX,
      flowY: flowY ?? this.flowY,
      sensorId: sensorId ?? this.sensorId,
      quality: quality ?? this.quality,
      flowRateX: flowRateX ?? this.flowRateX,
      flowRateY: flowRateY ?? this.flowRateY,
    );
  }

  factory OpticalFlow.parse(ByteData data_) {
    if (data_.lengthInBytes < OpticalFlow.mavlinkEncodedLength) {
      var len = OpticalFlow.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var flowCompMX = data_.getFloat32(8, Endian.little);
    var flowCompMY = data_.getFloat32(12, Endian.little);
    var groundDistance = data_.getFloat32(16, Endian.little);
    var flowX = data_.getInt16(20, Endian.little);
    var flowY = data_.getInt16(22, Endian.little);
    var sensorId = data_.getUint8(24);
    var quality = data_.getUint8(25);
    var flowRateX = data_.getFloat32(26, Endian.little);
    var flowRateY = data_.getFloat32(30, Endian.little);

    return OpticalFlow(
        timeUsec: timeUsec,
        flowCompMX: flowCompMX,
        flowCompMY: flowCompMY,
        groundDistance: groundDistance,
        flowX: flowX,
        flowY: flowY,
        sensorId: sensorId,
        quality: quality,
        flowRateX: flowRateX,
        flowRateY: flowRateY);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, flowCompMX, Endian.little);
    data_.setFloat32(12, flowCompMY, Endian.little);
    data_.setFloat32(16, groundDistance, Endian.little);
    data_.setInt16(20, flowX, Endian.little);
    data_.setInt16(22, flowY, Endian.little);
    data_.setUint8(24, sensorId);
    data_.setUint8(25, quality);
    data_.setFloat32(26, flowRateX, Endian.little);
    data_.setFloat32(30, flowRateY, Endian.little);
    return data_;
  }
}

/// Global position/attitude estimate from a vision source.
///
/// GLOBAL_VISION_POSITION_ESTIMATE
class GlobalVisionPositionEstimate implements MavlinkMessage {
  static const int _mavlinkMessageId = 101;

  static const int _mavlinkCrcExtra = 102;

  static const int mavlinkEncodedLength = 117;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX time or since system boot)
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// usec
  final uint64_t usec;

  /// Global X position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Global Y position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Global Z position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// Roll angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Row-major representation of pose 6x6 cross-covariance matrix upper right triangle (states: x_global, y_global, z_global, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[21]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// covariance
  final List<float> covariance;

  /// Estimate reset counter. This should be incremented when the estimate resets in any of the dimensions (position, velocity, attitude, angular speed). This is designed to be used when e.g an external SLAM system detects a loop-closure and the estimate jumps.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// reset_counter
  final uint8_t resetCounter;

  GlobalVisionPositionEstimate({
    required this.usec,
    required this.x,
    required this.y,
    required this.z,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.covariance,
    required this.resetCounter,
  });

  GlobalVisionPositionEstimate copyWith({
    uint64_t? usec,
    float? x,
    float? y,
    float? z,
    float? roll,
    float? pitch,
    float? yaw,
    List<float>? covariance,
    uint8_t? resetCounter,
  }) {
    return GlobalVisionPositionEstimate(
      usec: usec ?? this.usec,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      covariance: covariance ?? this.covariance,
      resetCounter: resetCounter ?? this.resetCounter,
    );
  }

  factory GlobalVisionPositionEstimate.parse(ByteData data_) {
    if (data_.lengthInBytes <
        GlobalVisionPositionEstimate.mavlinkEncodedLength) {
      var len = GlobalVisionPositionEstimate.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var usec = data_.getUint64(0, Endian.little);
    var x = data_.getFloat32(8, Endian.little);
    var y = data_.getFloat32(12, Endian.little);
    var z = data_.getFloat32(16, Endian.little);
    var roll = data_.getFloat32(20, Endian.little);
    var pitch = data_.getFloat32(24, Endian.little);
    var yaw = data_.getFloat32(28, Endian.little);
    var covariance = MavlinkMessage.asFloat32List(data_, 32, 21);
    var resetCounter = data_.getUint8(116);

    return GlobalVisionPositionEstimate(
        usec: usec,
        x: x,
        y: y,
        z: z,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        covariance: covariance,
        resetCounter: resetCounter);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, usec, Endian.little);
    data_.setFloat32(8, x, Endian.little);
    data_.setFloat32(12, y, Endian.little);
    data_.setFloat32(16, z, Endian.little);
    data_.setFloat32(20, roll, Endian.little);
    data_.setFloat32(24, pitch, Endian.little);
    data_.setFloat32(28, yaw, Endian.little);
    MavlinkMessage.setFloat32List(data_, 32, covariance);
    data_.setUint8(116, resetCounter);
    return data_;
  }
}

/// Local position/attitude estimate from a vision source.
///
/// VISION_POSITION_ESTIMATE
class VisionPositionEstimate implements MavlinkMessage {
  static const int _mavlinkMessageId = 102;

  static const int _mavlinkCrcExtra = 158;

  static const int mavlinkEncodedLength = 117;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX time or time since system boot)
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// usec
  final uint64_t usec;

  /// Local X position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Local Y position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Local Z position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// Roll angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Row-major representation of pose 6x6 cross-covariance matrix upper right triangle (states: x, y, z, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[21]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// covariance
  final List<float> covariance;

  /// Estimate reset counter. This should be incremented when the estimate resets in any of the dimensions (position, velocity, attitude, angular speed). This is designed to be used when e.g an external SLAM system detects a loop-closure and the estimate jumps.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// reset_counter
  final uint8_t resetCounter;

  VisionPositionEstimate({
    required this.usec,
    required this.x,
    required this.y,
    required this.z,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.covariance,
    required this.resetCounter,
  });

  VisionPositionEstimate copyWith({
    uint64_t? usec,
    float? x,
    float? y,
    float? z,
    float? roll,
    float? pitch,
    float? yaw,
    List<float>? covariance,
    uint8_t? resetCounter,
  }) {
    return VisionPositionEstimate(
      usec: usec ?? this.usec,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      covariance: covariance ?? this.covariance,
      resetCounter: resetCounter ?? this.resetCounter,
    );
  }

  factory VisionPositionEstimate.parse(ByteData data_) {
    if (data_.lengthInBytes < VisionPositionEstimate.mavlinkEncodedLength) {
      var len =
          VisionPositionEstimate.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var usec = data_.getUint64(0, Endian.little);
    var x = data_.getFloat32(8, Endian.little);
    var y = data_.getFloat32(12, Endian.little);
    var z = data_.getFloat32(16, Endian.little);
    var roll = data_.getFloat32(20, Endian.little);
    var pitch = data_.getFloat32(24, Endian.little);
    var yaw = data_.getFloat32(28, Endian.little);
    var covariance = MavlinkMessage.asFloat32List(data_, 32, 21);
    var resetCounter = data_.getUint8(116);

    return VisionPositionEstimate(
        usec: usec,
        x: x,
        y: y,
        z: z,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        covariance: covariance,
        resetCounter: resetCounter);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, usec, Endian.little);
    data_.setFloat32(8, x, Endian.little);
    data_.setFloat32(12, y, Endian.little);
    data_.setFloat32(16, z, Endian.little);
    data_.setFloat32(20, roll, Endian.little);
    data_.setFloat32(24, pitch, Endian.little);
    data_.setFloat32(28, yaw, Endian.little);
    MavlinkMessage.setFloat32List(data_, 32, covariance);
    data_.setUint8(116, resetCounter);
    return data_;
  }
}

/// Speed estimate from a vision source.
///
/// VISION_SPEED_ESTIMATE
class VisionSpeedEstimate implements MavlinkMessage {
  static const int _mavlinkMessageId = 103;

  static const int _mavlinkCrcExtra = 208;

  static const int mavlinkEncodedLength = 57;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX time or time since system boot)
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// usec
  final uint64_t usec;

  /// Global X speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// x
  final float x;

  /// Global Y speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// y
  final float y;

  /// Global Z speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// z
  final float z;

  /// Row-major representation of 3x3 linear velocity covariance matrix (states: vx, vy, vz; 1st three entries - 1st row, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[9]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// covariance
  final List<float> covariance;

  /// Estimate reset counter. This should be incremented when the estimate resets in any of the dimensions (position, velocity, attitude, angular speed). This is designed to be used when e.g an external SLAM system detects a loop-closure and the estimate jumps.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// reset_counter
  final uint8_t resetCounter;

  VisionSpeedEstimate({
    required this.usec,
    required this.x,
    required this.y,
    required this.z,
    required this.covariance,
    required this.resetCounter,
  });

  VisionSpeedEstimate copyWith({
    uint64_t? usec,
    float? x,
    float? y,
    float? z,
    List<float>? covariance,
    uint8_t? resetCounter,
  }) {
    return VisionSpeedEstimate(
      usec: usec ?? this.usec,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      covariance: covariance ?? this.covariance,
      resetCounter: resetCounter ?? this.resetCounter,
    );
  }

  factory VisionSpeedEstimate.parse(ByteData data_) {
    if (data_.lengthInBytes < VisionSpeedEstimate.mavlinkEncodedLength) {
      var len = VisionSpeedEstimate.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var usec = data_.getUint64(0, Endian.little);
    var x = data_.getFloat32(8, Endian.little);
    var y = data_.getFloat32(12, Endian.little);
    var z = data_.getFloat32(16, Endian.little);
    var covariance = MavlinkMessage.asFloat32List(data_, 20, 9);
    var resetCounter = data_.getUint8(56);

    return VisionSpeedEstimate(
        usec: usec,
        x: x,
        y: y,
        z: z,
        covariance: covariance,
        resetCounter: resetCounter);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, usec, Endian.little);
    data_.setFloat32(8, x, Endian.little);
    data_.setFloat32(12, y, Endian.little);
    data_.setFloat32(16, z, Endian.little);
    MavlinkMessage.setFloat32List(data_, 20, covariance);
    data_.setUint8(56, resetCounter);
    return data_;
  }
}

/// Global position estimate from a Vicon motion system source.
///
/// VICON_POSITION_ESTIMATE
class ViconPositionEstimate implements MavlinkMessage {
  static const int _mavlinkMessageId = 104;

  static const int _mavlinkCrcExtra = 56;

  static const int mavlinkEncodedLength = 116;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX time or time since system boot)
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// usec
  final uint64_t usec;

  /// Global X position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Global Y position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Global Z position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// Roll angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Row-major representation of 6x6 pose cross-covariance matrix upper right triangle (states: x, y, z, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[21]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// covariance
  final List<float> covariance;

  ViconPositionEstimate({
    required this.usec,
    required this.x,
    required this.y,
    required this.z,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.covariance,
  });

  ViconPositionEstimate copyWith({
    uint64_t? usec,
    float? x,
    float? y,
    float? z,
    float? roll,
    float? pitch,
    float? yaw,
    List<float>? covariance,
  }) {
    return ViconPositionEstimate(
      usec: usec ?? this.usec,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      covariance: covariance ?? this.covariance,
    );
  }

  factory ViconPositionEstimate.parse(ByteData data_) {
    if (data_.lengthInBytes < ViconPositionEstimate.mavlinkEncodedLength) {
      var len =
          ViconPositionEstimate.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var usec = data_.getUint64(0, Endian.little);
    var x = data_.getFloat32(8, Endian.little);
    var y = data_.getFloat32(12, Endian.little);
    var z = data_.getFloat32(16, Endian.little);
    var roll = data_.getFloat32(20, Endian.little);
    var pitch = data_.getFloat32(24, Endian.little);
    var yaw = data_.getFloat32(28, Endian.little);
    var covariance = MavlinkMessage.asFloat32List(data_, 32, 21);

    return ViconPositionEstimate(
        usec: usec,
        x: x,
        y: y,
        z: z,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        covariance: covariance);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, usec, Endian.little);
    data_.setFloat32(8, x, Endian.little);
    data_.setFloat32(12, y, Endian.little);
    data_.setFloat32(16, z, Endian.little);
    data_.setFloat32(20, roll, Endian.little);
    data_.setFloat32(24, pitch, Endian.little);
    data_.setFloat32(28, yaw, Endian.little);
    MavlinkMessage.setFloat32List(data_, 32, covariance);
    return data_;
  }
}

/// The IMU readings in SI units in NED body frame
///
/// HIGHRES_IMU
class HighresImu implements MavlinkMessage {
  static const int _mavlinkMessageId = 105;

  static const int _mavlinkCrcExtra = 93;

  static const int mavlinkEncodedLength = 63;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// X acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// xacc
  final float xacc;

  /// Y acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// yacc
  final float yacc;

  /// Z acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// zacc
  final float zacc;

  /// Angular speed around X axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// xgyro
  final float xgyro;

  /// Angular speed around Y axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// ygyro
  final float ygyro;

  /// Angular speed around Z axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// zgyro
  final float zgyro;

  /// X Magnetic field
  ///
  /// MAVLink type: float
  ///
  /// units: gauss
  ///
  /// xmag
  final float xmag;

  /// Y Magnetic field
  ///
  /// MAVLink type: float
  ///
  /// units: gauss
  ///
  /// ymag
  final float ymag;

  /// Z Magnetic field
  ///
  /// MAVLink type: float
  ///
  /// units: gauss
  ///
  /// zmag
  final float zmag;

  /// Absolute pressure
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// abs_pressure
  final float absPressure;

  /// Differential pressure
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// diff_pressure
  final float diffPressure;

  /// Altitude calculated from pressure
  ///
  /// MAVLink type: float
  ///
  /// pressure_alt
  final float pressureAlt;

  /// Temperature
  ///
  /// MAVLink type: float
  ///
  /// units: degC
  ///
  /// temperature
  final float temperature;

  /// Bitmap for fields that have updated since last message
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [HighresImuUpdatedFlags]
  ///
  /// fields_updated
  final HighresImuUpdatedFlags fieldsUpdated;

  /// Id. Ids are numbered from 0 and map to IMUs numbered from 1 (e.g. IMU1 will have a message with id=0)
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// id
  final uint8_t id;

  HighresImu({
    required this.timeUsec,
    required this.xacc,
    required this.yacc,
    required this.zacc,
    required this.xgyro,
    required this.ygyro,
    required this.zgyro,
    required this.xmag,
    required this.ymag,
    required this.zmag,
    required this.absPressure,
    required this.diffPressure,
    required this.pressureAlt,
    required this.temperature,
    required this.fieldsUpdated,
    required this.id,
  });

  HighresImu copyWith({
    uint64_t? timeUsec,
    float? xacc,
    float? yacc,
    float? zacc,
    float? xgyro,
    float? ygyro,
    float? zgyro,
    float? xmag,
    float? ymag,
    float? zmag,
    float? absPressure,
    float? diffPressure,
    float? pressureAlt,
    float? temperature,
    HighresImuUpdatedFlags? fieldsUpdated,
    uint8_t? id,
  }) {
    return HighresImu(
      timeUsec: timeUsec ?? this.timeUsec,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
      xgyro: xgyro ?? this.xgyro,
      ygyro: ygyro ?? this.ygyro,
      zgyro: zgyro ?? this.zgyro,
      xmag: xmag ?? this.xmag,
      ymag: ymag ?? this.ymag,
      zmag: zmag ?? this.zmag,
      absPressure: absPressure ?? this.absPressure,
      diffPressure: diffPressure ?? this.diffPressure,
      pressureAlt: pressureAlt ?? this.pressureAlt,
      temperature: temperature ?? this.temperature,
      fieldsUpdated: fieldsUpdated ?? this.fieldsUpdated,
      id: id ?? this.id,
    );
  }

  factory HighresImu.parse(ByteData data_) {
    if (data_.lengthInBytes < HighresImu.mavlinkEncodedLength) {
      var len = HighresImu.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var xacc = data_.getFloat32(8, Endian.little);
    var yacc = data_.getFloat32(12, Endian.little);
    var zacc = data_.getFloat32(16, Endian.little);
    var xgyro = data_.getFloat32(20, Endian.little);
    var ygyro = data_.getFloat32(24, Endian.little);
    var zgyro = data_.getFloat32(28, Endian.little);
    var xmag = data_.getFloat32(32, Endian.little);
    var ymag = data_.getFloat32(36, Endian.little);
    var zmag = data_.getFloat32(40, Endian.little);
    var absPressure = data_.getFloat32(44, Endian.little);
    var diffPressure = data_.getFloat32(48, Endian.little);
    var pressureAlt = data_.getFloat32(52, Endian.little);
    var temperature = data_.getFloat32(56, Endian.little);
    var fieldsUpdated = data_.getUint16(60, Endian.little);
    var id = data_.getUint8(62);

    return HighresImu(
        timeUsec: timeUsec,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc,
        xgyro: xgyro,
        ygyro: ygyro,
        zgyro: zgyro,
        xmag: xmag,
        ymag: ymag,
        zmag: zmag,
        absPressure: absPressure,
        diffPressure: diffPressure,
        pressureAlt: pressureAlt,
        temperature: temperature,
        fieldsUpdated: fieldsUpdated,
        id: id);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, xacc, Endian.little);
    data_.setFloat32(12, yacc, Endian.little);
    data_.setFloat32(16, zacc, Endian.little);
    data_.setFloat32(20, xgyro, Endian.little);
    data_.setFloat32(24, ygyro, Endian.little);
    data_.setFloat32(28, zgyro, Endian.little);
    data_.setFloat32(32, xmag, Endian.little);
    data_.setFloat32(36, ymag, Endian.little);
    data_.setFloat32(40, zmag, Endian.little);
    data_.setFloat32(44, absPressure, Endian.little);
    data_.setFloat32(48, diffPressure, Endian.little);
    data_.setFloat32(52, pressureAlt, Endian.little);
    data_.setFloat32(56, temperature, Endian.little);
    data_.setUint16(60, fieldsUpdated, Endian.little);
    data_.setUint8(62, id);
    return data_;
  }
}

/// Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor)
///
/// OPTICAL_FLOW_RAD
class OpticalFlowRad implements MavlinkMessage {
  static const int _mavlinkMessageId = 106;

  static const int _mavlinkCrcExtra = 138;

  static const int mavlinkEncodedLength = 44;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: us
  ///
  /// integration_time_us
  final uint32_t integrationTimeUs;

  /// Flow around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_x
  final float integratedX;

  /// Flow around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_y
  final float integratedY;

  /// RH rotation around X axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_xgyro
  final float integratedXgyro;

  /// RH rotation around Y axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_ygyro
  final float integratedYgyro;

  /// RH rotation around Z axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_zgyro
  final float integratedZgyro;

  /// Time since the distance was sampled.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: us
  ///
  /// time_delta_distance_us
  final uint32_t timeDeltaDistanceUs;

  /// Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// distance
  final float distance;

  /// Temperature
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// temperature
  final int16_t temperature;

  /// Sensor ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// sensor_id
  final uint8_t sensorId;

  /// Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
  ///
  /// MAVLink type: uint8_t
  ///
  /// quality
  final uint8_t quality;

  OpticalFlowRad({
    required this.timeUsec,
    required this.integrationTimeUs,
    required this.integratedX,
    required this.integratedY,
    required this.integratedXgyro,
    required this.integratedYgyro,
    required this.integratedZgyro,
    required this.timeDeltaDistanceUs,
    required this.distance,
    required this.temperature,
    required this.sensorId,
    required this.quality,
  });

  OpticalFlowRad copyWith({
    uint64_t? timeUsec,
    uint32_t? integrationTimeUs,
    float? integratedX,
    float? integratedY,
    float? integratedXgyro,
    float? integratedYgyro,
    float? integratedZgyro,
    uint32_t? timeDeltaDistanceUs,
    float? distance,
    int16_t? temperature,
    uint8_t? sensorId,
    uint8_t? quality,
  }) {
    return OpticalFlowRad(
      timeUsec: timeUsec ?? this.timeUsec,
      integrationTimeUs: integrationTimeUs ?? this.integrationTimeUs,
      integratedX: integratedX ?? this.integratedX,
      integratedY: integratedY ?? this.integratedY,
      integratedXgyro: integratedXgyro ?? this.integratedXgyro,
      integratedYgyro: integratedYgyro ?? this.integratedYgyro,
      integratedZgyro: integratedZgyro ?? this.integratedZgyro,
      timeDeltaDistanceUs: timeDeltaDistanceUs ?? this.timeDeltaDistanceUs,
      distance: distance ?? this.distance,
      temperature: temperature ?? this.temperature,
      sensorId: sensorId ?? this.sensorId,
      quality: quality ?? this.quality,
    );
  }

  factory OpticalFlowRad.parse(ByteData data_) {
    if (data_.lengthInBytes < OpticalFlowRad.mavlinkEncodedLength) {
      var len = OpticalFlowRad.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var integrationTimeUs = data_.getUint32(8, Endian.little);
    var integratedX = data_.getFloat32(12, Endian.little);
    var integratedY = data_.getFloat32(16, Endian.little);
    var integratedXgyro = data_.getFloat32(20, Endian.little);
    var integratedYgyro = data_.getFloat32(24, Endian.little);
    var integratedZgyro = data_.getFloat32(28, Endian.little);
    var timeDeltaDistanceUs = data_.getUint32(32, Endian.little);
    var distance = data_.getFloat32(36, Endian.little);
    var temperature = data_.getInt16(40, Endian.little);
    var sensorId = data_.getUint8(42);
    var quality = data_.getUint8(43);

    return OpticalFlowRad(
        timeUsec: timeUsec,
        integrationTimeUs: integrationTimeUs,
        integratedX: integratedX,
        integratedY: integratedY,
        integratedXgyro: integratedXgyro,
        integratedYgyro: integratedYgyro,
        integratedZgyro: integratedZgyro,
        timeDeltaDistanceUs: timeDeltaDistanceUs,
        distance: distance,
        temperature: temperature,
        sensorId: sensorId,
        quality: quality);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint32(8, integrationTimeUs, Endian.little);
    data_.setFloat32(12, integratedX, Endian.little);
    data_.setFloat32(16, integratedY, Endian.little);
    data_.setFloat32(20, integratedXgyro, Endian.little);
    data_.setFloat32(24, integratedYgyro, Endian.little);
    data_.setFloat32(28, integratedZgyro, Endian.little);
    data_.setUint32(32, timeDeltaDistanceUs, Endian.little);
    data_.setFloat32(36, distance, Endian.little);
    data_.setInt16(40, temperature, Endian.little);
    data_.setUint8(42, sensorId);
    data_.setUint8(43, quality);
    return data_;
  }
}

/// The IMU readings in SI units in NED body frame
///
/// HIL_SENSOR
class HilSensor implements MavlinkMessage {
  static const int _mavlinkMessageId = 107;

  static const int _mavlinkCrcExtra = 108;

  static const int mavlinkEncodedLength = 65;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// X acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// xacc
  final float xacc;

  /// Y acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// yacc
  final float yacc;

  /// Z acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// zacc
  final float zacc;

  /// Angular speed around X axis in body frame
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// xgyro
  final float xgyro;

  /// Angular speed around Y axis in body frame
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// ygyro
  final float ygyro;

  /// Angular speed around Z axis in body frame
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// zgyro
  final float zgyro;

  /// X Magnetic field
  ///
  /// MAVLink type: float
  ///
  /// units: gauss
  ///
  /// xmag
  final float xmag;

  /// Y Magnetic field
  ///
  /// MAVLink type: float
  ///
  /// units: gauss
  ///
  /// ymag
  final float ymag;

  /// Z Magnetic field
  ///
  /// MAVLink type: float
  ///
  /// units: gauss
  ///
  /// zmag
  final float zmag;

  /// Absolute pressure
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// abs_pressure
  final float absPressure;

  /// Differential pressure (airspeed)
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// diff_pressure
  final float diffPressure;

  /// Altitude calculated from pressure
  ///
  /// MAVLink type: float
  ///
  /// pressure_alt
  final float pressureAlt;

  /// Temperature
  ///
  /// MAVLink type: float
  ///
  /// units: degC
  ///
  /// temperature
  final float temperature;

  /// Bitmap for fields that have updated since last message
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [HilSensorUpdatedFlags]
  ///
  /// fields_updated
  final HilSensorUpdatedFlags fieldsUpdated;

  /// Sensor ID (zero indexed). Used for multiple sensor inputs
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// id
  final uint8_t id;

  HilSensor({
    required this.timeUsec,
    required this.xacc,
    required this.yacc,
    required this.zacc,
    required this.xgyro,
    required this.ygyro,
    required this.zgyro,
    required this.xmag,
    required this.ymag,
    required this.zmag,
    required this.absPressure,
    required this.diffPressure,
    required this.pressureAlt,
    required this.temperature,
    required this.fieldsUpdated,
    required this.id,
  });

  HilSensor copyWith({
    uint64_t? timeUsec,
    float? xacc,
    float? yacc,
    float? zacc,
    float? xgyro,
    float? ygyro,
    float? zgyro,
    float? xmag,
    float? ymag,
    float? zmag,
    float? absPressure,
    float? diffPressure,
    float? pressureAlt,
    float? temperature,
    HilSensorUpdatedFlags? fieldsUpdated,
    uint8_t? id,
  }) {
    return HilSensor(
      timeUsec: timeUsec ?? this.timeUsec,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
      xgyro: xgyro ?? this.xgyro,
      ygyro: ygyro ?? this.ygyro,
      zgyro: zgyro ?? this.zgyro,
      xmag: xmag ?? this.xmag,
      ymag: ymag ?? this.ymag,
      zmag: zmag ?? this.zmag,
      absPressure: absPressure ?? this.absPressure,
      diffPressure: diffPressure ?? this.diffPressure,
      pressureAlt: pressureAlt ?? this.pressureAlt,
      temperature: temperature ?? this.temperature,
      fieldsUpdated: fieldsUpdated ?? this.fieldsUpdated,
      id: id ?? this.id,
    );
  }

  factory HilSensor.parse(ByteData data_) {
    if (data_.lengthInBytes < HilSensor.mavlinkEncodedLength) {
      var len = HilSensor.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var xacc = data_.getFloat32(8, Endian.little);
    var yacc = data_.getFloat32(12, Endian.little);
    var zacc = data_.getFloat32(16, Endian.little);
    var xgyro = data_.getFloat32(20, Endian.little);
    var ygyro = data_.getFloat32(24, Endian.little);
    var zgyro = data_.getFloat32(28, Endian.little);
    var xmag = data_.getFloat32(32, Endian.little);
    var ymag = data_.getFloat32(36, Endian.little);
    var zmag = data_.getFloat32(40, Endian.little);
    var absPressure = data_.getFloat32(44, Endian.little);
    var diffPressure = data_.getFloat32(48, Endian.little);
    var pressureAlt = data_.getFloat32(52, Endian.little);
    var temperature = data_.getFloat32(56, Endian.little);
    var fieldsUpdated = data_.getUint32(60, Endian.little);
    var id = data_.getUint8(64);

    return HilSensor(
        timeUsec: timeUsec,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc,
        xgyro: xgyro,
        ygyro: ygyro,
        zgyro: zgyro,
        xmag: xmag,
        ymag: ymag,
        zmag: zmag,
        absPressure: absPressure,
        diffPressure: diffPressure,
        pressureAlt: pressureAlt,
        temperature: temperature,
        fieldsUpdated: fieldsUpdated,
        id: id);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, xacc, Endian.little);
    data_.setFloat32(12, yacc, Endian.little);
    data_.setFloat32(16, zacc, Endian.little);
    data_.setFloat32(20, xgyro, Endian.little);
    data_.setFloat32(24, ygyro, Endian.little);
    data_.setFloat32(28, zgyro, Endian.little);
    data_.setFloat32(32, xmag, Endian.little);
    data_.setFloat32(36, ymag, Endian.little);
    data_.setFloat32(40, zmag, Endian.little);
    data_.setFloat32(44, absPressure, Endian.little);
    data_.setFloat32(48, diffPressure, Endian.little);
    data_.setFloat32(52, pressureAlt, Endian.little);
    data_.setFloat32(56, temperature, Endian.little);
    data_.setUint32(60, fieldsUpdated, Endian.little);
    data_.setUint8(64, id);
    return data_;
  }
}

/// Status of simulation environment, if used
///
/// SIM_STATE
class SimState implements MavlinkMessage {
  static const int _mavlinkMessageId = 108;

  static const int _mavlinkCrcExtra = 32;

  static const int mavlinkEncodedLength = 92;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// True attitude quaternion component 1, w (1 in null-rotation)
  ///
  /// MAVLink type: float
  ///
  /// q1
  final float q1;

  /// True attitude quaternion component 2, x (0 in null-rotation)
  ///
  /// MAVLink type: float
  ///
  /// q2
  final float q2;

  /// True attitude quaternion component 3, y (0 in null-rotation)
  ///
  /// MAVLink type: float
  ///
  /// q3
  final float q3;

  /// True attitude quaternion component 4, z (0 in null-rotation)
  ///
  /// MAVLink type: float
  ///
  /// q4
  final float q4;

  /// Attitude roll expressed as Euler angles, not recommended except for human-readable outputs
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Attitude pitch expressed as Euler angles, not recommended except for human-readable outputs
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Attitude yaw expressed as Euler angles, not recommended except for human-readable outputs
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// X acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// xacc
  final float xacc;

  /// Y acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// yacc
  final float yacc;

  /// Z acceleration
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// zacc
  final float zacc;

  /// Angular speed around X axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// xgyro
  final float xgyro;

  /// Angular speed around Y axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// ygyro
  final float ygyro;

  /// Angular speed around Z axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// zgyro
  final float zgyro;

  /// Latitude (lower precision). Both this and the lat_int field should be set.
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// lat
  final float lat;

  /// Longitude (lower precision). Both this and the lon_int field should be set.
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// lon
  final float lon;

  /// Altitude
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt
  final float alt;

  /// Horizontal position standard deviation
  ///
  /// MAVLink type: float
  ///
  /// std_dev_horz
  final float stdDevHorz;

  /// Vertical position standard deviation
  ///
  /// MAVLink type: float
  ///
  /// std_dev_vert
  final float stdDevVert;

  /// True velocity in north direction in earth-fixed NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vn
  final float vn;

  /// True velocity in east direction in earth-fixed NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// ve
  final float ve;

  /// True velocity in down direction in earth-fixed NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vd
  final float vd;

  /// Latitude (higher precision). If 0, recipients should use the lat field value (otherwise this field is preferred).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// lat_int
  final int32_t latInt;

  /// Longitude (higher precision). If 0, recipients should use the lon field value (otherwise this field is preferred).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// lon_int
  final int32_t lonInt;

  SimState({
    required this.q1,
    required this.q2,
    required this.q3,
    required this.q4,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.xacc,
    required this.yacc,
    required this.zacc,
    required this.xgyro,
    required this.ygyro,
    required this.zgyro,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.stdDevHorz,
    required this.stdDevVert,
    required this.vn,
    required this.ve,
    required this.vd,
    required this.latInt,
    required this.lonInt,
  });

  SimState copyWith({
    float? q1,
    float? q2,
    float? q3,
    float? q4,
    float? roll,
    float? pitch,
    float? yaw,
    float? xacc,
    float? yacc,
    float? zacc,
    float? xgyro,
    float? ygyro,
    float? zgyro,
    float? lat,
    float? lon,
    float? alt,
    float? stdDevHorz,
    float? stdDevVert,
    float? vn,
    float? ve,
    float? vd,
    int32_t? latInt,
    int32_t? lonInt,
  }) {
    return SimState(
      q1: q1 ?? this.q1,
      q2: q2 ?? this.q2,
      q3: q3 ?? this.q3,
      q4: q4 ?? this.q4,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
      xgyro: xgyro ?? this.xgyro,
      ygyro: ygyro ?? this.ygyro,
      zgyro: zgyro ?? this.zgyro,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      stdDevHorz: stdDevHorz ?? this.stdDevHorz,
      stdDevVert: stdDevVert ?? this.stdDevVert,
      vn: vn ?? this.vn,
      ve: ve ?? this.ve,
      vd: vd ?? this.vd,
      latInt: latInt ?? this.latInt,
      lonInt: lonInt ?? this.lonInt,
    );
  }

  factory SimState.parse(ByteData data_) {
    if (data_.lengthInBytes < SimState.mavlinkEncodedLength) {
      var len = SimState.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var q1 = data_.getFloat32(0, Endian.little);
    var q2 = data_.getFloat32(4, Endian.little);
    var q3 = data_.getFloat32(8, Endian.little);
    var q4 = data_.getFloat32(12, Endian.little);
    var roll = data_.getFloat32(16, Endian.little);
    var pitch = data_.getFloat32(20, Endian.little);
    var yaw = data_.getFloat32(24, Endian.little);
    var xacc = data_.getFloat32(28, Endian.little);
    var yacc = data_.getFloat32(32, Endian.little);
    var zacc = data_.getFloat32(36, Endian.little);
    var xgyro = data_.getFloat32(40, Endian.little);
    var ygyro = data_.getFloat32(44, Endian.little);
    var zgyro = data_.getFloat32(48, Endian.little);
    var lat = data_.getFloat32(52, Endian.little);
    var lon = data_.getFloat32(56, Endian.little);
    var alt = data_.getFloat32(60, Endian.little);
    var stdDevHorz = data_.getFloat32(64, Endian.little);
    var stdDevVert = data_.getFloat32(68, Endian.little);
    var vn = data_.getFloat32(72, Endian.little);
    var ve = data_.getFloat32(76, Endian.little);
    var vd = data_.getFloat32(80, Endian.little);
    var latInt = data_.getInt32(84, Endian.little);
    var lonInt = data_.getInt32(88, Endian.little);

    return SimState(
        q1: q1,
        q2: q2,
        q3: q3,
        q4: q4,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc,
        xgyro: xgyro,
        ygyro: ygyro,
        zgyro: zgyro,
        lat: lat,
        lon: lon,
        alt: alt,
        stdDevHorz: stdDevHorz,
        stdDevVert: stdDevVert,
        vn: vn,
        ve: ve,
        vd: vd,
        latInt: latInt,
        lonInt: lonInt);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, q1, Endian.little);
    data_.setFloat32(4, q2, Endian.little);
    data_.setFloat32(8, q3, Endian.little);
    data_.setFloat32(12, q4, Endian.little);
    data_.setFloat32(16, roll, Endian.little);
    data_.setFloat32(20, pitch, Endian.little);
    data_.setFloat32(24, yaw, Endian.little);
    data_.setFloat32(28, xacc, Endian.little);
    data_.setFloat32(32, yacc, Endian.little);
    data_.setFloat32(36, zacc, Endian.little);
    data_.setFloat32(40, xgyro, Endian.little);
    data_.setFloat32(44, ygyro, Endian.little);
    data_.setFloat32(48, zgyro, Endian.little);
    data_.setFloat32(52, lat, Endian.little);
    data_.setFloat32(56, lon, Endian.little);
    data_.setFloat32(60, alt, Endian.little);
    data_.setFloat32(64, stdDevHorz, Endian.little);
    data_.setFloat32(68, stdDevVert, Endian.little);
    data_.setFloat32(72, vn, Endian.little);
    data_.setFloat32(76, ve, Endian.little);
    data_.setFloat32(80, vd, Endian.little);
    data_.setInt32(84, latInt, Endian.little);
    data_.setInt32(88, lonInt, Endian.little);
    return data_;
  }
}

/// Status generated by radio and injected into MAVLink stream.
///
/// RADIO_STATUS
class RadioStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 109;

  static const int _mavlinkCrcExtra = 185;

  static const int mavlinkEncodedLength = 9;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Count of radio packet receive errors (since boot).
  ///
  /// MAVLink type: uint16_t
  ///
  /// rxerrors
  final uint16_t rxerrors;

  /// Count of error corrected radio packets (since boot).
  ///
  /// MAVLink type: uint16_t
  ///
  /// fixed
  final uint16_t fixed;

  /// Local (message sender) received signal strength indication in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rssi
  final uint8_t rssi;

  /// Remote (message receiver) signal strength indication in device-dependent units/scale. Values: [0-254], UINT8_MAX: invalid/unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// remrssi
  final uint8_t remrssi;

  /// Remaining free transmitter buffer space.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// txbuf
  final uint8_t txbuf;

  /// Local background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], UINT8_MAX: invalid/unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// noise
  final uint8_t noise;

  /// Remote background noise level. These are device dependent RSSI values (scale as approx 2x dB on SiK radios). Values: [0-254], UINT8_MAX: invalid/unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// remnoise
  final uint8_t remnoise;

  RadioStatus({
    required this.rxerrors,
    required this.fixed,
    required this.rssi,
    required this.remrssi,
    required this.txbuf,
    required this.noise,
    required this.remnoise,
  });

  RadioStatus copyWith({
    uint16_t? rxerrors,
    uint16_t? fixed,
    uint8_t? rssi,
    uint8_t? remrssi,
    uint8_t? txbuf,
    uint8_t? noise,
    uint8_t? remnoise,
  }) {
    return RadioStatus(
      rxerrors: rxerrors ?? this.rxerrors,
      fixed: fixed ?? this.fixed,
      rssi: rssi ?? this.rssi,
      remrssi: remrssi ?? this.remrssi,
      txbuf: txbuf ?? this.txbuf,
      noise: noise ?? this.noise,
      remnoise: remnoise ?? this.remnoise,
    );
  }

  factory RadioStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < RadioStatus.mavlinkEncodedLength) {
      var len = RadioStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var rxerrors = data_.getUint16(0, Endian.little);
    var fixed = data_.getUint16(2, Endian.little);
    var rssi = data_.getUint8(4);
    var remrssi = data_.getUint8(5);
    var txbuf = data_.getUint8(6);
    var noise = data_.getUint8(7);
    var remnoise = data_.getUint8(8);

    return RadioStatus(
        rxerrors: rxerrors,
        fixed: fixed,
        rssi: rssi,
        remrssi: remrssi,
        txbuf: txbuf,
        noise: noise,
        remnoise: remnoise);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, rxerrors, Endian.little);
    data_.setUint16(2, fixed, Endian.little);
    data_.setUint8(4, rssi);
    data_.setUint8(5, remrssi);
    data_.setUint8(6, txbuf);
    data_.setUint8(7, noise);
    data_.setUint8(8, remnoise);
    return data_;
  }
}

/// File transfer protocol message: https://mavlink.io/en/services/ftp.html.
///
/// FILE_TRANSFER_PROTOCOL
class FileTransferProtocol implements MavlinkMessage {
  static const int _mavlinkMessageId = 110;

  static const int _mavlinkCrcExtra = 84;

  static const int mavlinkEncodedLength = 254;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Network ID (0 for broadcast)
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_network
  final uint8_t targetNetwork;

  /// System ID (0 for broadcast)
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast)
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Variable length payload. The length is defined by the remaining message length when subtracting the header and other fields. The content/format of this block is defined in https://mavlink.io/en/services/ftp.html.
  ///
  /// MAVLink type: uint8_t[251]
  ///
  /// payload
  final List<int8_t> payload;

  FileTransferProtocol({
    required this.targetNetwork,
    required this.targetSystem,
    required this.targetComponent,
    required this.payload,
  });

  FileTransferProtocol copyWith({
    uint8_t? targetNetwork,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? payload,
  }) {
    return FileTransferProtocol(
      targetNetwork: targetNetwork ?? this.targetNetwork,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      payload: payload ?? this.payload,
    );
  }

  factory FileTransferProtocol.parse(ByteData data_) {
    if (data_.lengthInBytes < FileTransferProtocol.mavlinkEncodedLength) {
      var len = FileTransferProtocol.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetNetwork = data_.getUint8(0);
    var targetSystem = data_.getUint8(1);
    var targetComponent = data_.getUint8(2);
    var payload = MavlinkMessage.asUint8List(data_, 3, 251);

    return FileTransferProtocol(
        targetNetwork: targetNetwork,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        payload: payload);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetNetwork);
    data_.setUint8(1, targetSystem);
    data_.setUint8(2, targetComponent);
    MavlinkMessage.setUint8List(data_, 3, payload);
    return data_;
  }
}

///
/// Time synchronization message.
/// The message is used for both timesync requests and responses.
/// The request is sent with `ts1=syncing component timestamp` and `tc1=0`, and may be broadcast or targeted to a specific system/component.
/// The response is sent with `ts1=syncing component timestamp` (mirror back unchanged), and `tc1=responding component timestamp`, with the `target_system` and `target_component` set to ids of the original request.
/// Systems can determine if they are receiving a request or response based on the value of `tc`.
/// If the response has `target_system==target_component==0` the remote system has not been updated to use the component IDs and cannot reliably timesync; the requestor may report an error.
/// Timestamps are UNIX Epoch time or time since system boot in nanoseconds (the timestamp format can be inferred by checking for the magnitude of the number; generally it doesn't matter as only the offset is used).
/// The message sequence is repeated numerous times with results being filtered/averaged to estimate the offset.
///
///
/// TIMESYNC
class Timesync implements MavlinkMessage {
  static const int _mavlinkMessageId = 111;

  static const int _mavlinkCrcExtra = 34;

  static const int mavlinkEncodedLength = 18;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Time sync timestamp 1. Syncing: 0. Responding: Timestamp of responding component.
  ///
  /// MAVLink type: int64_t
  ///
  /// units: ns
  ///
  /// tc1
  final int64_t tc1;

  /// Time sync timestamp 2. Timestamp of syncing component (mirrored in response).
  ///
  /// MAVLink type: int64_t
  ///
  /// units: ns
  ///
  /// ts1
  final int64_t ts1;

  /// Target system id. Request: 0 (broadcast) or id of specific system. Response must contain system id of the requesting component.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Target component id. Request: 0 (broadcast) or id of specific component. Response must contain component id of the requesting component.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// target_component
  final uint8_t targetComponent;

  Timesync({
    required this.tc1,
    required this.ts1,
    required this.targetSystem,
    required this.targetComponent,
  });

  Timesync copyWith({
    int64_t? tc1,
    int64_t? ts1,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return Timesync(
      tc1: tc1 ?? this.tc1,
      ts1: ts1 ?? this.ts1,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory Timesync.parse(ByteData data_) {
    if (data_.lengthInBytes < Timesync.mavlinkEncodedLength) {
      var len = Timesync.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var tc1 = data_.getInt64(0, Endian.little);
    var ts1 = data_.getInt64(8, Endian.little);
    var targetSystem = data_.getUint8(16);
    var targetComponent = data_.getUint8(17);

    return Timesync(
        tc1: tc1,
        ts1: ts1,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt64(0, tc1, Endian.little);
    data_.setInt64(8, ts1, Endian.little);
    data_.setUint8(16, targetSystem);
    data_.setUint8(17, targetComponent);
    return data_;
  }
}

/// Camera-IMU triggering and synchronisation message.
///
/// CAMERA_TRIGGER
class CameraTrigger implements MavlinkMessage {
  static const int _mavlinkMessageId = 112;

  static const int _mavlinkCrcExtra = 174;

  static const int mavlinkEncodedLength = 12;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp for image frame (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Image frame sequence
  ///
  /// MAVLink type: uint32_t
  ///
  /// seq
  final uint32_t seq;

  CameraTrigger({
    required this.timeUsec,
    required this.seq,
  });

  CameraTrigger copyWith({
    uint64_t? timeUsec,
    uint32_t? seq,
  }) {
    return CameraTrigger(
      timeUsec: timeUsec ?? this.timeUsec,
      seq: seq ?? this.seq,
    );
  }

  factory CameraTrigger.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraTrigger.mavlinkEncodedLength) {
      var len = CameraTrigger.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var seq = data_.getUint32(8, Endian.little);

    return CameraTrigger(timeUsec: timeUsec, seq: seq);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint32(8, seq, Endian.little);
    return data_;
  }
}

/// The global position, as returned by the Global Positioning System (GPS). This is
/// NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION_INT for the global position estimate.
///
/// HIL_GPS
class HilGps implements MavlinkMessage {
  static const int _mavlinkMessageId = 113;

  static const int _mavlinkCrcExtra = 124;

  static const int mavlinkEncodedLength = 39;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude (MSL). Positive for up.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt
  final int32_t alt;

  /// GPS HDOP horizontal dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// eph
  final uint16_t eph;

  /// GPS VDOP vertical dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// epv
  final uint16_t epv;

  /// GPS ground speed. If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// vel
  final uint16_t vel;

  /// GPS velocity in north direction in earth-fixed NED frame
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vn
  final int16_t vn;

  /// GPS velocity in east direction in earth-fixed NED frame
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// ve
  final int16_t ve;

  /// GPS velocity in down direction in earth-fixed NED frame
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vd
  final int16_t vd;

  /// Course over ground (NOT heading, but direction of movement), 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// cog
  final uint16_t cog;

  /// 0-1: no fix, 2: 2D fix, 3: 3D fix. Some applications will not use the value of this field unless it is at least two, so always correctly fill in the fix.
  ///
  /// MAVLink type: uint8_t
  ///
  /// fix_type
  final uint8_t fixType;

  /// Number of satellites visible. If unknown, set to UINT8_MAX
  ///
  /// MAVLink type: uint8_t
  ///
  /// satellites_visible
  final uint8_t satellitesVisible;

  /// GPS ID (zero indexed). Used for multiple GPS inputs
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// id
  final uint8_t id;

  /// Yaw of vehicle relative to Earth's North, zero means not available, use 36000 for north
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// yaw
  final uint16_t yaw;

  HilGps({
    required this.timeUsec,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.eph,
    required this.epv,
    required this.vel,
    required this.vn,
    required this.ve,
    required this.vd,
    required this.cog,
    required this.fixType,
    required this.satellitesVisible,
    required this.id,
    required this.yaw,
  });

  HilGps copyWith({
    uint64_t? timeUsec,
    int32_t? lat,
    int32_t? lon,
    int32_t? alt,
    uint16_t? eph,
    uint16_t? epv,
    uint16_t? vel,
    int16_t? vn,
    int16_t? ve,
    int16_t? vd,
    uint16_t? cog,
    uint8_t? fixType,
    uint8_t? satellitesVisible,
    uint8_t? id,
    uint16_t? yaw,
  }) {
    return HilGps(
      timeUsec: timeUsec ?? this.timeUsec,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      eph: eph ?? this.eph,
      epv: epv ?? this.epv,
      vel: vel ?? this.vel,
      vn: vn ?? this.vn,
      ve: ve ?? this.ve,
      vd: vd ?? this.vd,
      cog: cog ?? this.cog,
      fixType: fixType ?? this.fixType,
      satellitesVisible: satellitesVisible ?? this.satellitesVisible,
      id: id ?? this.id,
      yaw: yaw ?? this.yaw,
    );
  }

  factory HilGps.parse(ByteData data_) {
    if (data_.lengthInBytes < HilGps.mavlinkEncodedLength) {
      var len = HilGps.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var lat = data_.getInt32(8, Endian.little);
    var lon = data_.getInt32(12, Endian.little);
    var alt = data_.getInt32(16, Endian.little);
    var eph = data_.getUint16(20, Endian.little);
    var epv = data_.getUint16(22, Endian.little);
    var vel = data_.getUint16(24, Endian.little);
    var vn = data_.getInt16(26, Endian.little);
    var ve = data_.getInt16(28, Endian.little);
    var vd = data_.getInt16(30, Endian.little);
    var cog = data_.getUint16(32, Endian.little);
    var fixType = data_.getUint8(34);
    var satellitesVisible = data_.getUint8(35);
    var id = data_.getUint8(36);
    var yaw = data_.getUint16(37, Endian.little);

    return HilGps(
        timeUsec: timeUsec,
        lat: lat,
        lon: lon,
        alt: alt,
        eph: eph,
        epv: epv,
        vel: vel,
        vn: vn,
        ve: ve,
        vd: vd,
        cog: cog,
        fixType: fixType,
        satellitesVisible: satellitesVisible,
        id: id,
        yaw: yaw);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setInt32(8, lat, Endian.little);
    data_.setInt32(12, lon, Endian.little);
    data_.setInt32(16, alt, Endian.little);
    data_.setUint16(20, eph, Endian.little);
    data_.setUint16(22, epv, Endian.little);
    data_.setUint16(24, vel, Endian.little);
    data_.setInt16(26, vn, Endian.little);
    data_.setInt16(28, ve, Endian.little);
    data_.setInt16(30, vd, Endian.little);
    data_.setUint16(32, cog, Endian.little);
    data_.setUint8(34, fixType);
    data_.setUint8(35, satellitesVisible);
    data_.setUint8(36, id);
    data_.setUint16(37, yaw, Endian.little);
    return data_;
  }
}

/// Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor)
///
/// HIL_OPTICAL_FLOW
class HilOpticalFlow implements MavlinkMessage {
  static const int _mavlinkMessageId = 114;

  static const int _mavlinkCrcExtra = 237;

  static const int mavlinkEncodedLength = 44;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Integration time. Divide integrated_x and integrated_y by the integration time to obtain average flow. The integration time also indicates the.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: us
  ///
  /// integration_time_us
  final uint32_t integrationTimeUs;

  /// Flow in radians around X axis (Sensor RH rotation about the X axis induces a positive flow. Sensor linear motion along the positive Y axis induces a negative flow.)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_x
  final float integratedX;

  /// Flow in radians around Y axis (Sensor RH rotation about the Y axis induces a positive flow. Sensor linear motion along the positive X axis induces a positive flow.)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_y
  final float integratedY;

  /// RH rotation around X axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_xgyro
  final float integratedXgyro;

  /// RH rotation around Y axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_ygyro
  final float integratedYgyro;

  /// RH rotation around Z axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// integrated_zgyro
  final float integratedZgyro;

  /// Time since the distance was sampled.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: us
  ///
  /// time_delta_distance_us
  final uint32_t timeDeltaDistanceUs;

  /// Distance to the center of the flow field. Positive value (including zero): distance known. Negative value: Unknown distance.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// distance
  final float distance;

  /// Temperature
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// temperature
  final int16_t temperature;

  /// Sensor ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// sensor_id
  final uint8_t sensorId;

  /// Optical flow quality / confidence. 0: no valid flow, 255: maximum quality
  ///
  /// MAVLink type: uint8_t
  ///
  /// quality
  final uint8_t quality;

  HilOpticalFlow({
    required this.timeUsec,
    required this.integrationTimeUs,
    required this.integratedX,
    required this.integratedY,
    required this.integratedXgyro,
    required this.integratedYgyro,
    required this.integratedZgyro,
    required this.timeDeltaDistanceUs,
    required this.distance,
    required this.temperature,
    required this.sensorId,
    required this.quality,
  });

  HilOpticalFlow copyWith({
    uint64_t? timeUsec,
    uint32_t? integrationTimeUs,
    float? integratedX,
    float? integratedY,
    float? integratedXgyro,
    float? integratedYgyro,
    float? integratedZgyro,
    uint32_t? timeDeltaDistanceUs,
    float? distance,
    int16_t? temperature,
    uint8_t? sensorId,
    uint8_t? quality,
  }) {
    return HilOpticalFlow(
      timeUsec: timeUsec ?? this.timeUsec,
      integrationTimeUs: integrationTimeUs ?? this.integrationTimeUs,
      integratedX: integratedX ?? this.integratedX,
      integratedY: integratedY ?? this.integratedY,
      integratedXgyro: integratedXgyro ?? this.integratedXgyro,
      integratedYgyro: integratedYgyro ?? this.integratedYgyro,
      integratedZgyro: integratedZgyro ?? this.integratedZgyro,
      timeDeltaDistanceUs: timeDeltaDistanceUs ?? this.timeDeltaDistanceUs,
      distance: distance ?? this.distance,
      temperature: temperature ?? this.temperature,
      sensorId: sensorId ?? this.sensorId,
      quality: quality ?? this.quality,
    );
  }

  factory HilOpticalFlow.parse(ByteData data_) {
    if (data_.lengthInBytes < HilOpticalFlow.mavlinkEncodedLength) {
      var len = HilOpticalFlow.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var integrationTimeUs = data_.getUint32(8, Endian.little);
    var integratedX = data_.getFloat32(12, Endian.little);
    var integratedY = data_.getFloat32(16, Endian.little);
    var integratedXgyro = data_.getFloat32(20, Endian.little);
    var integratedYgyro = data_.getFloat32(24, Endian.little);
    var integratedZgyro = data_.getFloat32(28, Endian.little);
    var timeDeltaDistanceUs = data_.getUint32(32, Endian.little);
    var distance = data_.getFloat32(36, Endian.little);
    var temperature = data_.getInt16(40, Endian.little);
    var sensorId = data_.getUint8(42);
    var quality = data_.getUint8(43);

    return HilOpticalFlow(
        timeUsec: timeUsec,
        integrationTimeUs: integrationTimeUs,
        integratedX: integratedX,
        integratedY: integratedY,
        integratedXgyro: integratedXgyro,
        integratedYgyro: integratedYgyro,
        integratedZgyro: integratedZgyro,
        timeDeltaDistanceUs: timeDeltaDistanceUs,
        distance: distance,
        temperature: temperature,
        sensorId: sensorId,
        quality: quality);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint32(8, integrationTimeUs, Endian.little);
    data_.setFloat32(12, integratedX, Endian.little);
    data_.setFloat32(16, integratedY, Endian.little);
    data_.setFloat32(20, integratedXgyro, Endian.little);
    data_.setFloat32(24, integratedYgyro, Endian.little);
    data_.setFloat32(28, integratedZgyro, Endian.little);
    data_.setUint32(32, timeDeltaDistanceUs, Endian.little);
    data_.setFloat32(36, distance, Endian.little);
    data_.setInt16(40, temperature, Endian.little);
    data_.setUint8(42, sensorId);
    data_.setUint8(43, quality);
    return data_;
  }
}

/// Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful for high throughput applications such as hardware in the loop simulations.
///
/// HIL_STATE_QUATERNION
class HilStateQuaternion implements MavlinkMessage {
  static const int _mavlinkMessageId = 115;

  static const int _mavlinkCrcExtra = 4;

  static const int mavlinkEncodedLength = 64;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Vehicle attitude expressed as normalized quaternion in w, x, y, z order (with 1 0 0 0 being the null-rotation)
  ///
  /// MAVLink type: float[4]
  ///
  /// attitude_quaternion
  final List<float> attitudeQuaternion;

  /// Body frame roll / phi angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// rollspeed
  final float rollspeed;

  /// Body frame pitch / theta angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitchspeed
  final float pitchspeed;

  /// Body frame yaw / psi angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yawspeed
  final float yawspeed;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt
  final int32_t alt;

  /// Ground X Speed (Latitude)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vx
  final int16_t vx;

  /// Ground Y Speed (Longitude)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vy
  final int16_t vy;

  /// Ground Z Speed (Altitude)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vz
  final int16_t vz;

  /// Indicated airspeed
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// ind_airspeed
  final uint16_t indAirspeed;

  /// True airspeed
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// true_airspeed
  final uint16_t trueAirspeed;

  /// X acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// xacc
  final int16_t xacc;

  /// Y acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// yacc
  final int16_t yacc;

  /// Z acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// zacc
  final int16_t zacc;

  HilStateQuaternion({
    required this.timeUsec,
    required this.attitudeQuaternion,
    required this.rollspeed,
    required this.pitchspeed,
    required this.yawspeed,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.indAirspeed,
    required this.trueAirspeed,
    required this.xacc,
    required this.yacc,
    required this.zacc,
  });

  HilStateQuaternion copyWith({
    uint64_t? timeUsec,
    List<float>? attitudeQuaternion,
    float? rollspeed,
    float? pitchspeed,
    float? yawspeed,
    int32_t? lat,
    int32_t? lon,
    int32_t? alt,
    int16_t? vx,
    int16_t? vy,
    int16_t? vz,
    uint16_t? indAirspeed,
    uint16_t? trueAirspeed,
    int16_t? xacc,
    int16_t? yacc,
    int16_t? zacc,
  }) {
    return HilStateQuaternion(
      timeUsec: timeUsec ?? this.timeUsec,
      attitudeQuaternion: attitudeQuaternion ?? this.attitudeQuaternion,
      rollspeed: rollspeed ?? this.rollspeed,
      pitchspeed: pitchspeed ?? this.pitchspeed,
      yawspeed: yawspeed ?? this.yawspeed,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      indAirspeed: indAirspeed ?? this.indAirspeed,
      trueAirspeed: trueAirspeed ?? this.trueAirspeed,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
    );
  }

  factory HilStateQuaternion.parse(ByteData data_) {
    if (data_.lengthInBytes < HilStateQuaternion.mavlinkEncodedLength) {
      var len = HilStateQuaternion.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var attitudeQuaternion = MavlinkMessage.asFloat32List(data_, 8, 4);
    var rollspeed = data_.getFloat32(24, Endian.little);
    var pitchspeed = data_.getFloat32(28, Endian.little);
    var yawspeed = data_.getFloat32(32, Endian.little);
    var lat = data_.getInt32(36, Endian.little);
    var lon = data_.getInt32(40, Endian.little);
    var alt = data_.getInt32(44, Endian.little);
    var vx = data_.getInt16(48, Endian.little);
    var vy = data_.getInt16(50, Endian.little);
    var vz = data_.getInt16(52, Endian.little);
    var indAirspeed = data_.getUint16(54, Endian.little);
    var trueAirspeed = data_.getUint16(56, Endian.little);
    var xacc = data_.getInt16(58, Endian.little);
    var yacc = data_.getInt16(60, Endian.little);
    var zacc = data_.getInt16(62, Endian.little);

    return HilStateQuaternion(
        timeUsec: timeUsec,
        attitudeQuaternion: attitudeQuaternion,
        rollspeed: rollspeed,
        pitchspeed: pitchspeed,
        yawspeed: yawspeed,
        lat: lat,
        lon: lon,
        alt: alt,
        vx: vx,
        vy: vy,
        vz: vz,
        indAirspeed: indAirspeed,
        trueAirspeed: trueAirspeed,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setFloat32List(data_, 8, attitudeQuaternion);
    data_.setFloat32(24, rollspeed, Endian.little);
    data_.setFloat32(28, pitchspeed, Endian.little);
    data_.setFloat32(32, yawspeed, Endian.little);
    data_.setInt32(36, lat, Endian.little);
    data_.setInt32(40, lon, Endian.little);
    data_.setInt32(44, alt, Endian.little);
    data_.setInt16(48, vx, Endian.little);
    data_.setInt16(50, vy, Endian.little);
    data_.setInt16(52, vz, Endian.little);
    data_.setUint16(54, indAirspeed, Endian.little);
    data_.setUint16(56, trueAirspeed, Endian.little);
    data_.setInt16(58, xacc, Endian.little);
    data_.setInt16(60, yacc, Endian.little);
    data_.setInt16(62, zacc, Endian.little);
    return data_;
  }
}

/// The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to the described units
///
/// SCALED_IMU2
class ScaledImu2 implements MavlinkMessage {
  static const int _mavlinkMessageId = 116;

  static const int _mavlinkCrcExtra = 76;

  static const int mavlinkEncodedLength = 24;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// X acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// xacc
  final int16_t xacc;

  /// Y acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// yacc
  final int16_t yacc;

  /// Z acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// zacc
  final int16_t zacc;

  /// Angular speed around X axis
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mrad/s
  ///
  /// xgyro
  final int16_t xgyro;

  /// Angular speed around Y axis
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mrad/s
  ///
  /// ygyro
  final int16_t ygyro;

  /// Angular speed around Z axis
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mrad/s
  ///
  /// zgyro
  final int16_t zgyro;

  /// X Magnetic field
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mgauss
  ///
  /// xmag
  final int16_t xmag;

  /// Y Magnetic field
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mgauss
  ///
  /// ymag
  final int16_t ymag;

  /// Z Magnetic field
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mgauss
  ///
  /// zmag
  final int16_t zmag;

  /// Temperature, 0: IMU does not provide temperature values. If the IMU is at 0C it must send 1 (0.01C).
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// temperature
  final int16_t temperature;

  ScaledImu2({
    required this.timeBootMs,
    required this.xacc,
    required this.yacc,
    required this.zacc,
    required this.xgyro,
    required this.ygyro,
    required this.zgyro,
    required this.xmag,
    required this.ymag,
    required this.zmag,
    required this.temperature,
  });

  ScaledImu2 copyWith({
    uint32_t? timeBootMs,
    int16_t? xacc,
    int16_t? yacc,
    int16_t? zacc,
    int16_t? xgyro,
    int16_t? ygyro,
    int16_t? zgyro,
    int16_t? xmag,
    int16_t? ymag,
    int16_t? zmag,
    int16_t? temperature,
  }) {
    return ScaledImu2(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
      xgyro: xgyro ?? this.xgyro,
      ygyro: ygyro ?? this.ygyro,
      zgyro: zgyro ?? this.zgyro,
      xmag: xmag ?? this.xmag,
      ymag: ymag ?? this.ymag,
      zmag: zmag ?? this.zmag,
      temperature: temperature ?? this.temperature,
    );
  }

  factory ScaledImu2.parse(ByteData data_) {
    if (data_.lengthInBytes < ScaledImu2.mavlinkEncodedLength) {
      var len = ScaledImu2.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var xacc = data_.getInt16(4, Endian.little);
    var yacc = data_.getInt16(6, Endian.little);
    var zacc = data_.getInt16(8, Endian.little);
    var xgyro = data_.getInt16(10, Endian.little);
    var ygyro = data_.getInt16(12, Endian.little);
    var zgyro = data_.getInt16(14, Endian.little);
    var xmag = data_.getInt16(16, Endian.little);
    var ymag = data_.getInt16(18, Endian.little);
    var zmag = data_.getInt16(20, Endian.little);
    var temperature = data_.getInt16(22, Endian.little);

    return ScaledImu2(
        timeBootMs: timeBootMs,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc,
        xgyro: xgyro,
        ygyro: ygyro,
        zgyro: zgyro,
        xmag: xmag,
        ymag: ymag,
        zmag: zmag,
        temperature: temperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt16(4, xacc, Endian.little);
    data_.setInt16(6, yacc, Endian.little);
    data_.setInt16(8, zacc, Endian.little);
    data_.setInt16(10, xgyro, Endian.little);
    data_.setInt16(12, ygyro, Endian.little);
    data_.setInt16(14, zgyro, Endian.little);
    data_.setInt16(16, xmag, Endian.little);
    data_.setInt16(18, ymag, Endian.little);
    data_.setInt16(20, zmag, Endian.little);
    data_.setInt16(22, temperature, Endian.little);
    return data_;
  }
}

/// Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END is called. If there are no log files available this request shall be answered with one LOG_ENTRY message with id = 0 and num_logs = 0.
///
/// LOG_REQUEST_LIST
class LogRequestList implements MavlinkMessage {
  static const int _mavlinkMessageId = 117;

  static const int _mavlinkCrcExtra = 128;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// First log id (0 for first available)
  ///
  /// MAVLink type: uint16_t
  ///
  /// start
  final uint16_t start;

  /// Last log id (0xffff for last available)
  ///
  /// MAVLink type: uint16_t
  ///
  /// end
  final uint16_t end;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  LogRequestList({
    required this.start,
    required this.end,
    required this.targetSystem,
    required this.targetComponent,
  });

  LogRequestList copyWith({
    uint16_t? start,
    uint16_t? end,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return LogRequestList(
      start: start ?? this.start,
      end: end ?? this.end,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory LogRequestList.parse(ByteData data_) {
    if (data_.lengthInBytes < LogRequestList.mavlinkEncodedLength) {
      var len = LogRequestList.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var start = data_.getUint16(0, Endian.little);
    var end = data_.getUint16(2, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);

    return LogRequestList(
        start: start,
        end: end,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, start, Endian.little);
    data_.setUint16(2, end, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    return data_;
  }
}

/// Reply to LOG_REQUEST_LIST
///
/// LOG_ENTRY
class LogEntry implements MavlinkMessage {
  static const int _mavlinkMessageId = 118;

  static const int _mavlinkCrcExtra = 56;

  static const int mavlinkEncodedLength = 14;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// UTC timestamp of log since 1970, or 0 if not available
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: s
  ///
  /// time_utc
  final uint32_t timeUtc;

  /// Size of the log (may be approximate)
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bytes
  ///
  /// size
  final uint32_t size;

  /// Log id
  ///
  /// MAVLink type: uint16_t
  ///
  /// id
  final uint16_t id;

  /// Total number of logs
  ///
  /// MAVLink type: uint16_t
  ///
  /// num_logs
  final uint16_t numLogs;

  /// High log number
  ///
  /// MAVLink type: uint16_t
  ///
  /// last_log_num
  final uint16_t lastLogNum;

  LogEntry({
    required this.timeUtc,
    required this.size,
    required this.id,
    required this.numLogs,
    required this.lastLogNum,
  });

  LogEntry copyWith({
    uint32_t? timeUtc,
    uint32_t? size,
    uint16_t? id,
    uint16_t? numLogs,
    uint16_t? lastLogNum,
  }) {
    return LogEntry(
      timeUtc: timeUtc ?? this.timeUtc,
      size: size ?? this.size,
      id: id ?? this.id,
      numLogs: numLogs ?? this.numLogs,
      lastLogNum: lastLogNum ?? this.lastLogNum,
    );
  }

  factory LogEntry.parse(ByteData data_) {
    if (data_.lengthInBytes < LogEntry.mavlinkEncodedLength) {
      var len = LogEntry.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUtc = data_.getUint32(0, Endian.little);
    var size = data_.getUint32(4, Endian.little);
    var id = data_.getUint16(8, Endian.little);
    var numLogs = data_.getUint16(10, Endian.little);
    var lastLogNum = data_.getUint16(12, Endian.little);

    return LogEntry(
        timeUtc: timeUtc,
        size: size,
        id: id,
        numLogs: numLogs,
        lastLogNum: lastLogNum);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeUtc, Endian.little);
    data_.setUint32(4, size, Endian.little);
    data_.setUint16(8, id, Endian.little);
    data_.setUint16(10, numLogs, Endian.little);
    data_.setUint16(12, lastLogNum, Endian.little);
    return data_;
  }
}

/// Request a chunk of a log
///
/// LOG_REQUEST_DATA
class LogRequestData implements MavlinkMessage {
  static const int _mavlinkMessageId = 119;

  static const int _mavlinkCrcExtra = 116;

  static const int mavlinkEncodedLength = 12;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Offset into the log
  ///
  /// MAVLink type: uint32_t
  ///
  /// ofs
  final uint32_t ofs;

  /// Number of bytes
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bytes
  ///
  /// count
  final uint32_t count;

  /// Log id (from LOG_ENTRY reply)
  ///
  /// MAVLink type: uint16_t
  ///
  /// id
  final uint16_t id;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  LogRequestData({
    required this.ofs,
    required this.count,
    required this.id,
    required this.targetSystem,
    required this.targetComponent,
  });

  LogRequestData copyWith({
    uint32_t? ofs,
    uint32_t? count,
    uint16_t? id,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return LogRequestData(
      ofs: ofs ?? this.ofs,
      count: count ?? this.count,
      id: id ?? this.id,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory LogRequestData.parse(ByteData data_) {
    if (data_.lengthInBytes < LogRequestData.mavlinkEncodedLength) {
      var len = LogRequestData.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var ofs = data_.getUint32(0, Endian.little);
    var count = data_.getUint32(4, Endian.little);
    var id = data_.getUint16(8, Endian.little);
    var targetSystem = data_.getUint8(10);
    var targetComponent = data_.getUint8(11);

    return LogRequestData(
        ofs: ofs,
        count: count,
        id: id,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, ofs, Endian.little);
    data_.setUint32(4, count, Endian.little);
    data_.setUint16(8, id, Endian.little);
    data_.setUint8(10, targetSystem);
    data_.setUint8(11, targetComponent);
    return data_;
  }
}

/// Reply to LOG_REQUEST_DATA
///
/// LOG_DATA
class LogData implements MavlinkMessage {
  static const int _mavlinkMessageId = 120;

  static const int _mavlinkCrcExtra = 134;

  static const int mavlinkEncodedLength = 97;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Offset into the log
  ///
  /// MAVLink type: uint32_t
  ///
  /// ofs
  final uint32_t ofs;

  /// Log id (from LOG_ENTRY reply)
  ///
  /// MAVLink type: uint16_t
  ///
  /// id
  final uint16_t id;

  /// Number of bytes (zero for end of log)
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// count
  final uint8_t count;

  /// log data
  ///
  /// MAVLink type: uint8_t[90]
  ///
  /// data
  final List<int8_t> data;

  LogData({
    required this.ofs,
    required this.id,
    required this.count,
    required this.data,
  });

  LogData copyWith({
    uint32_t? ofs,
    uint16_t? id,
    uint8_t? count,
    List<int8_t>? data,
  }) {
    return LogData(
      ofs: ofs ?? this.ofs,
      id: id ?? this.id,
      count: count ?? this.count,
      data: data ?? this.data,
    );
  }

  factory LogData.parse(ByteData data_) {
    if (data_.lengthInBytes < LogData.mavlinkEncodedLength) {
      var len = LogData.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var ofs = data_.getUint32(0, Endian.little);
    var id = data_.getUint16(4, Endian.little);
    var count = data_.getUint8(6);
    var data = MavlinkMessage.asUint8List(data_, 7, 90);

    return LogData(ofs: ofs, id: id, count: count, data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, ofs, Endian.little);
    data_.setUint16(4, id, Endian.little);
    data_.setUint8(6, count);
    MavlinkMessage.setUint8List(data_, 7, data);
    return data_;
  }
}

/// Erase all logs
///
/// LOG_ERASE
class LogErase implements MavlinkMessage {
  static const int _mavlinkMessageId = 121;

  static const int _mavlinkCrcExtra = 237;

  static const int mavlinkEncodedLength = 2;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  LogErase({
    required this.targetSystem,
    required this.targetComponent,
  });

  LogErase copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return LogErase(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory LogErase.parse(ByteData data_) {
    if (data_.lengthInBytes < LogErase.mavlinkEncodedLength) {
      var len = LogErase.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);

    return LogErase(
        targetSystem: targetSystem, targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    return data_;
  }
}

/// Stop log transfer and resume normal logging
///
/// LOG_REQUEST_END
class LogRequestEnd implements MavlinkMessage {
  static const int _mavlinkMessageId = 122;

  static const int _mavlinkCrcExtra = 203;

  static const int mavlinkEncodedLength = 2;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  LogRequestEnd({
    required this.targetSystem,
    required this.targetComponent,
  });

  LogRequestEnd copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return LogRequestEnd(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory LogRequestEnd.parse(ByteData data_) {
    if (data_.lengthInBytes < LogRequestEnd.mavlinkEncodedLength) {
      var len = LogRequestEnd.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);

    return LogRequestEnd(
        targetSystem: targetSystem, targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    return data_;
  }
}

/// Data for injecting into the onboard GPS (used for DGPS)
///
/// GPS_INJECT_DATA
class GpsInjectData implements MavlinkMessage {
  static const int _mavlinkMessageId = 123;

  static const int _mavlinkCrcExtra = 250;

  static const int mavlinkEncodedLength = 113;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Data length
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// len
  final uint8_t len;

  /// Raw data (110 is enough for 12 satellites of RTCMv2)
  ///
  /// MAVLink type: uint8_t[110]
  ///
  /// data
  final List<int8_t> data;

  GpsInjectData({
    required this.targetSystem,
    required this.targetComponent,
    required this.len,
    required this.data,
  });

  GpsInjectData copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? len,
    List<int8_t>? data,
  }) {
    return GpsInjectData(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      len: len ?? this.len,
      data: data ?? this.data,
    );
  }

  factory GpsInjectData.parse(ByteData data_) {
    if (data_.lengthInBytes < GpsInjectData.mavlinkEncodedLength) {
      var len = GpsInjectData.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var len = data_.getUint8(2);
    var data = MavlinkMessage.asUint8List(data_, 3, 110);

    return GpsInjectData(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        len: len,
        data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, len);
    MavlinkMessage.setUint8List(data_, 3, data);
    return data_;
  }
}

/// Second GPS data.
///
/// GPS2_RAW
class Gps2Raw implements MavlinkMessage {
  static const int _mavlinkMessageId = 124;

  static const int _mavlinkCrcExtra = 87;

  static const int mavlinkEncodedLength = 57;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude (MSL). Positive for up.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt
  final int32_t alt;

  /// Age of DGPS info
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// dgps_age
  final uint32_t dgpsAge;

  /// GPS HDOP horizontal dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// eph
  final uint16_t eph;

  /// GPS VDOP vertical dilution of position (unitless * 100). If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// epv
  final uint16_t epv;

  /// GPS ground speed. If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// vel
  final uint16_t vel;

  /// Course over ground (NOT heading, but direction of movement): 0.0..359.99 degrees. If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// cog
  final uint16_t cog;

  /// GPS fix type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GpsFixType]
  ///
  /// fix_type
  final GpsFixType fixType;

  /// Number of satellites visible. If unknown, set to UINT8_MAX
  ///
  /// MAVLink type: uint8_t
  ///
  /// satellites_visible
  final uint8_t satellitesVisible;

  /// Number of DGPS satellites
  ///
  /// MAVLink type: uint8_t
  ///
  /// dgps_numch
  final uint8_t dgpsNumch;

  /// Yaw in earth frame from north. Use 0 if this GPS does not provide yaw. Use UINT16_MAX if this GPS is configured to provide yaw and is currently unable to provide it. Use 36000 for north.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// yaw
  final uint16_t yaw;

  /// Altitude (above WGS84, EGM96 ellipsoid). Positive for up.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// alt_ellipsoid
  final int32_t altEllipsoid;

  /// Position uncertainty.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: mm
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// h_acc
  final uint32_t hAcc;

  /// Altitude uncertainty.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: mm
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// v_acc
  final uint32_t vAcc;

  /// Speed uncertainty.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: mm
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// vel_acc
  final uint32_t velAcc;

  /// Heading / track uncertainty
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: degE5
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// hdg_acc
  final uint32_t hdgAcc;

  Gps2Raw({
    required this.timeUsec,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.dgpsAge,
    required this.eph,
    required this.epv,
    required this.vel,
    required this.cog,
    required this.fixType,
    required this.satellitesVisible,
    required this.dgpsNumch,
    required this.yaw,
    required this.altEllipsoid,
    required this.hAcc,
    required this.vAcc,
    required this.velAcc,
    required this.hdgAcc,
  });

  Gps2Raw copyWith({
    uint64_t? timeUsec,
    int32_t? lat,
    int32_t? lon,
    int32_t? alt,
    uint32_t? dgpsAge,
    uint16_t? eph,
    uint16_t? epv,
    uint16_t? vel,
    uint16_t? cog,
    GpsFixType? fixType,
    uint8_t? satellitesVisible,
    uint8_t? dgpsNumch,
    uint16_t? yaw,
    int32_t? altEllipsoid,
    uint32_t? hAcc,
    uint32_t? vAcc,
    uint32_t? velAcc,
    uint32_t? hdgAcc,
  }) {
    return Gps2Raw(
      timeUsec: timeUsec ?? this.timeUsec,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      dgpsAge: dgpsAge ?? this.dgpsAge,
      eph: eph ?? this.eph,
      epv: epv ?? this.epv,
      vel: vel ?? this.vel,
      cog: cog ?? this.cog,
      fixType: fixType ?? this.fixType,
      satellitesVisible: satellitesVisible ?? this.satellitesVisible,
      dgpsNumch: dgpsNumch ?? this.dgpsNumch,
      yaw: yaw ?? this.yaw,
      altEllipsoid: altEllipsoid ?? this.altEllipsoid,
      hAcc: hAcc ?? this.hAcc,
      vAcc: vAcc ?? this.vAcc,
      velAcc: velAcc ?? this.velAcc,
      hdgAcc: hdgAcc ?? this.hdgAcc,
    );
  }

  factory Gps2Raw.parse(ByteData data_) {
    if (data_.lengthInBytes < Gps2Raw.mavlinkEncodedLength) {
      var len = Gps2Raw.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var lat = data_.getInt32(8, Endian.little);
    var lon = data_.getInt32(12, Endian.little);
    var alt = data_.getInt32(16, Endian.little);
    var dgpsAge = data_.getUint32(20, Endian.little);
    var eph = data_.getUint16(24, Endian.little);
    var epv = data_.getUint16(26, Endian.little);
    var vel = data_.getUint16(28, Endian.little);
    var cog = data_.getUint16(30, Endian.little);
    var fixType = data_.getUint8(32);
    var satellitesVisible = data_.getUint8(33);
    var dgpsNumch = data_.getUint8(34);
    var yaw = data_.getUint16(35, Endian.little);
    var altEllipsoid = data_.getInt32(37, Endian.little);
    var hAcc = data_.getUint32(41, Endian.little);
    var vAcc = data_.getUint32(45, Endian.little);
    var velAcc = data_.getUint32(49, Endian.little);
    var hdgAcc = data_.getUint32(53, Endian.little);

    return Gps2Raw(
        timeUsec: timeUsec,
        lat: lat,
        lon: lon,
        alt: alt,
        dgpsAge: dgpsAge,
        eph: eph,
        epv: epv,
        vel: vel,
        cog: cog,
        fixType: fixType,
        satellitesVisible: satellitesVisible,
        dgpsNumch: dgpsNumch,
        yaw: yaw,
        altEllipsoid: altEllipsoid,
        hAcc: hAcc,
        vAcc: vAcc,
        velAcc: velAcc,
        hdgAcc: hdgAcc);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setInt32(8, lat, Endian.little);
    data_.setInt32(12, lon, Endian.little);
    data_.setInt32(16, alt, Endian.little);
    data_.setUint32(20, dgpsAge, Endian.little);
    data_.setUint16(24, eph, Endian.little);
    data_.setUint16(26, epv, Endian.little);
    data_.setUint16(28, vel, Endian.little);
    data_.setUint16(30, cog, Endian.little);
    data_.setUint8(32, fixType);
    data_.setUint8(33, satellitesVisible);
    data_.setUint8(34, dgpsNumch);
    data_.setUint16(35, yaw, Endian.little);
    data_.setInt32(37, altEllipsoid, Endian.little);
    data_.setUint32(41, hAcc, Endian.little);
    data_.setUint32(45, vAcc, Endian.little);
    data_.setUint32(49, velAcc, Endian.little);
    data_.setUint32(53, hdgAcc, Endian.little);
    return data_;
  }
}

/// Power supply status
///
/// POWER_STATUS
class PowerStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 125;

  static const int _mavlinkCrcExtra = 203;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// 5V rail voltage.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mV
  ///
  /// Vcc
  final uint16_t vcc;

  /// Servo rail voltage.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mV
  ///
  /// Vservo
  final uint16_t vservo;

  /// Bitmap of power supply status flags.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavPowerStatus]
  ///
  /// flags
  final MavPowerStatus flags;

  PowerStatus({
    required this.vcc,
    required this.vservo,
    required this.flags,
  });

  PowerStatus copyWith({
    uint16_t? vcc,
    uint16_t? vservo,
    MavPowerStatus? flags,
  }) {
    return PowerStatus(
      vcc: vcc ?? this.vcc,
      vservo: vservo ?? this.vservo,
      flags: flags ?? this.flags,
    );
  }

  factory PowerStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < PowerStatus.mavlinkEncodedLength) {
      var len = PowerStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var vcc = data_.getUint16(0, Endian.little);
    var vservo = data_.getUint16(2, Endian.little);
    var flags = data_.getUint16(4, Endian.little);

    return PowerStatus(vcc: vcc, vservo: vservo, flags: flags);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, vcc, Endian.little);
    data_.setUint16(2, vservo, Endian.little);
    data_.setUint16(4, flags, Endian.little);
    return data_;
  }
}

/// Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages or change the devices settings. A message with zero bytes can be used to change just the baudrate.
///
/// SERIAL_CONTROL
class SerialControl implements MavlinkMessage {
  static const int _mavlinkMessageId = 126;

  static const int _mavlinkCrcExtra = 220;

  static const int mavlinkEncodedLength = 81;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Baudrate of transfer. Zero means no change.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bits/s
  ///
  /// baudrate
  final uint32_t baudrate;

  /// Timeout for reply data
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: ms
  ///
  /// timeout
  final uint16_t timeout;

  /// Serial control device type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [SerialControlDev]
  ///
  /// device
  final SerialControlDev device;

  /// Bitmap of serial control flags.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [SerialControlFlag]
  ///
  /// flags
  final SerialControlFlag flags;

  /// how many bytes in this transfer
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// count
  final uint8_t count;

  /// serial data
  ///
  /// MAVLink type: uint8_t[70]
  ///
  /// data
  final List<int8_t> data;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// target_component
  final uint8_t targetComponent;

  SerialControl({
    required this.baudrate,
    required this.timeout,
    required this.device,
    required this.flags,
    required this.count,
    required this.data,
    required this.targetSystem,
    required this.targetComponent,
  });

  SerialControl copyWith({
    uint32_t? baudrate,
    uint16_t? timeout,
    SerialControlDev? device,
    SerialControlFlag? flags,
    uint8_t? count,
    List<int8_t>? data,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return SerialControl(
      baudrate: baudrate ?? this.baudrate,
      timeout: timeout ?? this.timeout,
      device: device ?? this.device,
      flags: flags ?? this.flags,
      count: count ?? this.count,
      data: data ?? this.data,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory SerialControl.parse(ByteData data_) {
    if (data_.lengthInBytes < SerialControl.mavlinkEncodedLength) {
      var len = SerialControl.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var baudrate = data_.getUint32(0, Endian.little);
    var timeout = data_.getUint16(4, Endian.little);
    var device = data_.getUint8(6);
    var flags = data_.getUint8(7);
    var count = data_.getUint8(8);
    var data = MavlinkMessage.asUint8List(data_, 9, 70);
    var targetSystem = data_.getUint8(79);
    var targetComponent = data_.getUint8(80);

    return SerialControl(
        baudrate: baudrate,
        timeout: timeout,
        device: device,
        flags: flags,
        count: count,
        data: data,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, baudrate, Endian.little);
    data_.setUint16(4, timeout, Endian.little);
    data_.setUint8(6, device);
    data_.setUint8(7, flags);
    data_.setUint8(8, count);
    MavlinkMessage.setUint8List(data_, 9, data);
    data_.setUint8(79, targetSystem);
    data_.setUint8(80, targetComponent);
    return data_;
  }
}

/// RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
///
/// GPS_RTK
class GpsRtk implements MavlinkMessage {
  static const int _mavlinkMessageId = 127;

  static const int _mavlinkCrcExtra = 25;

  static const int mavlinkEncodedLength = 35;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Time since boot of last baseline message received.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_last_baseline_ms
  final uint32_t timeLastBaselineMs;

  /// GPS Time of Week of last baseline
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// tow
  final uint32_t tow;

  /// Current baseline in ECEF x or NED north component.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// baseline_a_mm
  final int32_t baselineAMm;

  /// Current baseline in ECEF y or NED east component.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// baseline_b_mm
  final int32_t baselineBMm;

  /// Current baseline in ECEF z or NED down component.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// baseline_c_mm
  final int32_t baselineCMm;

  /// Current estimate of baseline accuracy.
  ///
  /// MAVLink type: uint32_t
  ///
  /// accuracy
  final uint32_t accuracy;

  /// Current number of integer ambiguity hypotheses.
  ///
  /// MAVLink type: int32_t
  ///
  /// iar_num_hypotheses
  final int32_t iarNumHypotheses;

  /// GPS Week Number of last baseline
  ///
  /// MAVLink type: uint16_t
  ///
  /// wn
  final uint16_t wn;

  /// Identification of connected RTK receiver.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rtk_receiver_id
  final uint8_t rtkReceiverId;

  /// GPS-specific health report for RTK data.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rtk_health
  final uint8_t rtkHealth;

  /// Rate of baseline messages being received by GPS
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: Hz
  ///
  /// rtk_rate
  final uint8_t rtkRate;

  /// Current number of sats used for RTK calculation.
  ///
  /// MAVLink type: uint8_t
  ///
  /// nsats
  final uint8_t nsats;

  /// Coordinate system of baseline
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [RtkBaselineCoordinateSystem]
  ///
  /// baseline_coords_type
  final RtkBaselineCoordinateSystem baselineCoordsType;

  GpsRtk({
    required this.timeLastBaselineMs,
    required this.tow,
    required this.baselineAMm,
    required this.baselineBMm,
    required this.baselineCMm,
    required this.accuracy,
    required this.iarNumHypotheses,
    required this.wn,
    required this.rtkReceiverId,
    required this.rtkHealth,
    required this.rtkRate,
    required this.nsats,
    required this.baselineCoordsType,
  });

  GpsRtk copyWith({
    uint32_t? timeLastBaselineMs,
    uint32_t? tow,
    int32_t? baselineAMm,
    int32_t? baselineBMm,
    int32_t? baselineCMm,
    uint32_t? accuracy,
    int32_t? iarNumHypotheses,
    uint16_t? wn,
    uint8_t? rtkReceiverId,
    uint8_t? rtkHealth,
    uint8_t? rtkRate,
    uint8_t? nsats,
    RtkBaselineCoordinateSystem? baselineCoordsType,
  }) {
    return GpsRtk(
      timeLastBaselineMs: timeLastBaselineMs ?? this.timeLastBaselineMs,
      tow: tow ?? this.tow,
      baselineAMm: baselineAMm ?? this.baselineAMm,
      baselineBMm: baselineBMm ?? this.baselineBMm,
      baselineCMm: baselineCMm ?? this.baselineCMm,
      accuracy: accuracy ?? this.accuracy,
      iarNumHypotheses: iarNumHypotheses ?? this.iarNumHypotheses,
      wn: wn ?? this.wn,
      rtkReceiverId: rtkReceiverId ?? this.rtkReceiverId,
      rtkHealth: rtkHealth ?? this.rtkHealth,
      rtkRate: rtkRate ?? this.rtkRate,
      nsats: nsats ?? this.nsats,
      baselineCoordsType: baselineCoordsType ?? this.baselineCoordsType,
    );
  }

  factory GpsRtk.parse(ByteData data_) {
    if (data_.lengthInBytes < GpsRtk.mavlinkEncodedLength) {
      var len = GpsRtk.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeLastBaselineMs = data_.getUint32(0, Endian.little);
    var tow = data_.getUint32(4, Endian.little);
    var baselineAMm = data_.getInt32(8, Endian.little);
    var baselineBMm = data_.getInt32(12, Endian.little);
    var baselineCMm = data_.getInt32(16, Endian.little);
    var accuracy = data_.getUint32(20, Endian.little);
    var iarNumHypotheses = data_.getInt32(24, Endian.little);
    var wn = data_.getUint16(28, Endian.little);
    var rtkReceiverId = data_.getUint8(30);
    var rtkHealth = data_.getUint8(31);
    var rtkRate = data_.getUint8(32);
    var nsats = data_.getUint8(33);
    var baselineCoordsType = data_.getUint8(34);

    return GpsRtk(
        timeLastBaselineMs: timeLastBaselineMs,
        tow: tow,
        baselineAMm: baselineAMm,
        baselineBMm: baselineBMm,
        baselineCMm: baselineCMm,
        accuracy: accuracy,
        iarNumHypotheses: iarNumHypotheses,
        wn: wn,
        rtkReceiverId: rtkReceiverId,
        rtkHealth: rtkHealth,
        rtkRate: rtkRate,
        nsats: nsats,
        baselineCoordsType: baselineCoordsType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeLastBaselineMs, Endian.little);
    data_.setUint32(4, tow, Endian.little);
    data_.setInt32(8, baselineAMm, Endian.little);
    data_.setInt32(12, baselineBMm, Endian.little);
    data_.setInt32(16, baselineCMm, Endian.little);
    data_.setUint32(20, accuracy, Endian.little);
    data_.setInt32(24, iarNumHypotheses, Endian.little);
    data_.setUint16(28, wn, Endian.little);
    data_.setUint8(30, rtkReceiverId);
    data_.setUint8(31, rtkHealth);
    data_.setUint8(32, rtkRate);
    data_.setUint8(33, nsats);
    data_.setUint8(34, baselineCoordsType);
    return data_;
  }
}

/// RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting
///
/// GPS2_RTK
class Gps2Rtk implements MavlinkMessage {
  static const int _mavlinkMessageId = 128;

  static const int _mavlinkCrcExtra = 226;

  static const int mavlinkEncodedLength = 35;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Time since boot of last baseline message received.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_last_baseline_ms
  final uint32_t timeLastBaselineMs;

  /// GPS Time of Week of last baseline
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// tow
  final uint32_t tow;

  /// Current baseline in ECEF x or NED north component.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// baseline_a_mm
  final int32_t baselineAMm;

  /// Current baseline in ECEF y or NED east component.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// baseline_b_mm
  final int32_t baselineBMm;

  /// Current baseline in ECEF z or NED down component.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// baseline_c_mm
  final int32_t baselineCMm;

  /// Current estimate of baseline accuracy.
  ///
  /// MAVLink type: uint32_t
  ///
  /// accuracy
  final uint32_t accuracy;

  /// Current number of integer ambiguity hypotheses.
  ///
  /// MAVLink type: int32_t
  ///
  /// iar_num_hypotheses
  final int32_t iarNumHypotheses;

  /// GPS Week Number of last baseline
  ///
  /// MAVLink type: uint16_t
  ///
  /// wn
  final uint16_t wn;

  /// Identification of connected RTK receiver.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rtk_receiver_id
  final uint8_t rtkReceiverId;

  /// GPS-specific health report for RTK data.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rtk_health
  final uint8_t rtkHealth;

  /// Rate of baseline messages being received by GPS
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: Hz
  ///
  /// rtk_rate
  final uint8_t rtkRate;

  /// Current number of sats used for RTK calculation.
  ///
  /// MAVLink type: uint8_t
  ///
  /// nsats
  final uint8_t nsats;

  /// Coordinate system of baseline
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [RtkBaselineCoordinateSystem]
  ///
  /// baseline_coords_type
  final RtkBaselineCoordinateSystem baselineCoordsType;

  Gps2Rtk({
    required this.timeLastBaselineMs,
    required this.tow,
    required this.baselineAMm,
    required this.baselineBMm,
    required this.baselineCMm,
    required this.accuracy,
    required this.iarNumHypotheses,
    required this.wn,
    required this.rtkReceiverId,
    required this.rtkHealth,
    required this.rtkRate,
    required this.nsats,
    required this.baselineCoordsType,
  });

  Gps2Rtk copyWith({
    uint32_t? timeLastBaselineMs,
    uint32_t? tow,
    int32_t? baselineAMm,
    int32_t? baselineBMm,
    int32_t? baselineCMm,
    uint32_t? accuracy,
    int32_t? iarNumHypotheses,
    uint16_t? wn,
    uint8_t? rtkReceiverId,
    uint8_t? rtkHealth,
    uint8_t? rtkRate,
    uint8_t? nsats,
    RtkBaselineCoordinateSystem? baselineCoordsType,
  }) {
    return Gps2Rtk(
      timeLastBaselineMs: timeLastBaselineMs ?? this.timeLastBaselineMs,
      tow: tow ?? this.tow,
      baselineAMm: baselineAMm ?? this.baselineAMm,
      baselineBMm: baselineBMm ?? this.baselineBMm,
      baselineCMm: baselineCMm ?? this.baselineCMm,
      accuracy: accuracy ?? this.accuracy,
      iarNumHypotheses: iarNumHypotheses ?? this.iarNumHypotheses,
      wn: wn ?? this.wn,
      rtkReceiverId: rtkReceiverId ?? this.rtkReceiverId,
      rtkHealth: rtkHealth ?? this.rtkHealth,
      rtkRate: rtkRate ?? this.rtkRate,
      nsats: nsats ?? this.nsats,
      baselineCoordsType: baselineCoordsType ?? this.baselineCoordsType,
    );
  }

  factory Gps2Rtk.parse(ByteData data_) {
    if (data_.lengthInBytes < Gps2Rtk.mavlinkEncodedLength) {
      var len = Gps2Rtk.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeLastBaselineMs = data_.getUint32(0, Endian.little);
    var tow = data_.getUint32(4, Endian.little);
    var baselineAMm = data_.getInt32(8, Endian.little);
    var baselineBMm = data_.getInt32(12, Endian.little);
    var baselineCMm = data_.getInt32(16, Endian.little);
    var accuracy = data_.getUint32(20, Endian.little);
    var iarNumHypotheses = data_.getInt32(24, Endian.little);
    var wn = data_.getUint16(28, Endian.little);
    var rtkReceiverId = data_.getUint8(30);
    var rtkHealth = data_.getUint8(31);
    var rtkRate = data_.getUint8(32);
    var nsats = data_.getUint8(33);
    var baselineCoordsType = data_.getUint8(34);

    return Gps2Rtk(
        timeLastBaselineMs: timeLastBaselineMs,
        tow: tow,
        baselineAMm: baselineAMm,
        baselineBMm: baselineBMm,
        baselineCMm: baselineCMm,
        accuracy: accuracy,
        iarNumHypotheses: iarNumHypotheses,
        wn: wn,
        rtkReceiverId: rtkReceiverId,
        rtkHealth: rtkHealth,
        rtkRate: rtkRate,
        nsats: nsats,
        baselineCoordsType: baselineCoordsType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeLastBaselineMs, Endian.little);
    data_.setUint32(4, tow, Endian.little);
    data_.setInt32(8, baselineAMm, Endian.little);
    data_.setInt32(12, baselineBMm, Endian.little);
    data_.setInt32(16, baselineCMm, Endian.little);
    data_.setUint32(20, accuracy, Endian.little);
    data_.setInt32(24, iarNumHypotheses, Endian.little);
    data_.setUint16(28, wn, Endian.little);
    data_.setUint8(30, rtkReceiverId);
    data_.setUint8(31, rtkHealth);
    data_.setUint8(32, rtkRate);
    data_.setUint8(33, nsats);
    data_.setUint8(34, baselineCoordsType);
    return data_;
  }
}

/// The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described units
///
/// SCALED_IMU3
class ScaledImu3 implements MavlinkMessage {
  static const int _mavlinkMessageId = 129;

  static const int _mavlinkCrcExtra = 46;

  static const int mavlinkEncodedLength = 24;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// X acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// xacc
  final int16_t xacc;

  /// Y acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// yacc
  final int16_t yacc;

  /// Z acceleration
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mG
  ///
  /// zacc
  final int16_t zacc;

  /// Angular speed around X axis
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mrad/s
  ///
  /// xgyro
  final int16_t xgyro;

  /// Angular speed around Y axis
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mrad/s
  ///
  /// ygyro
  final int16_t ygyro;

  /// Angular speed around Z axis
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mrad/s
  ///
  /// zgyro
  final int16_t zgyro;

  /// X Magnetic field
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mgauss
  ///
  /// xmag
  final int16_t xmag;

  /// Y Magnetic field
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mgauss
  ///
  /// ymag
  final int16_t ymag;

  /// Z Magnetic field
  ///
  /// MAVLink type: int16_t
  ///
  /// units: mgauss
  ///
  /// zmag
  final int16_t zmag;

  /// Temperature, 0: IMU does not provide temperature values. If the IMU is at 0C it must send 1 (0.01C).
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// temperature
  final int16_t temperature;

  ScaledImu3({
    required this.timeBootMs,
    required this.xacc,
    required this.yacc,
    required this.zacc,
    required this.xgyro,
    required this.ygyro,
    required this.zgyro,
    required this.xmag,
    required this.ymag,
    required this.zmag,
    required this.temperature,
  });

  ScaledImu3 copyWith({
    uint32_t? timeBootMs,
    int16_t? xacc,
    int16_t? yacc,
    int16_t? zacc,
    int16_t? xgyro,
    int16_t? ygyro,
    int16_t? zgyro,
    int16_t? xmag,
    int16_t? ymag,
    int16_t? zmag,
    int16_t? temperature,
  }) {
    return ScaledImu3(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
      xgyro: xgyro ?? this.xgyro,
      ygyro: ygyro ?? this.ygyro,
      zgyro: zgyro ?? this.zgyro,
      xmag: xmag ?? this.xmag,
      ymag: ymag ?? this.ymag,
      zmag: zmag ?? this.zmag,
      temperature: temperature ?? this.temperature,
    );
  }

  factory ScaledImu3.parse(ByteData data_) {
    if (data_.lengthInBytes < ScaledImu3.mavlinkEncodedLength) {
      var len = ScaledImu3.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var xacc = data_.getInt16(4, Endian.little);
    var yacc = data_.getInt16(6, Endian.little);
    var zacc = data_.getInt16(8, Endian.little);
    var xgyro = data_.getInt16(10, Endian.little);
    var ygyro = data_.getInt16(12, Endian.little);
    var zgyro = data_.getInt16(14, Endian.little);
    var xmag = data_.getInt16(16, Endian.little);
    var ymag = data_.getInt16(18, Endian.little);
    var zmag = data_.getInt16(20, Endian.little);
    var temperature = data_.getInt16(22, Endian.little);

    return ScaledImu3(
        timeBootMs: timeBootMs,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc,
        xgyro: xgyro,
        ygyro: ygyro,
        zgyro: zgyro,
        xmag: xmag,
        ymag: ymag,
        zmag: zmag,
        temperature: temperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt16(4, xacc, Endian.little);
    data_.setInt16(6, yacc, Endian.little);
    data_.setInt16(8, zacc, Endian.little);
    data_.setInt16(10, xgyro, Endian.little);
    data_.setInt16(12, ygyro, Endian.little);
    data_.setInt16(14, zgyro, Endian.little);
    data_.setInt16(16, xmag, Endian.little);
    data_.setInt16(18, ymag, Endian.little);
    data_.setInt16(20, zmag, Endian.little);
    data_.setInt16(22, temperature, Endian.little);
    return data_;
  }
}

/// Handshake message to initiate, control and stop image streaming when using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html.
///
/// DATA_TRANSMISSION_HANDSHAKE
class DataTransmissionHandshake implements MavlinkMessage {
  static const int _mavlinkMessageId = 130;

  static const int _mavlinkCrcExtra = 29;

  static const int mavlinkEncodedLength = 13;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// total data size (set on ACK only).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bytes
  ///
  /// size
  final uint32_t size;

  /// Width of a matrix or image.
  ///
  /// MAVLink type: uint16_t
  ///
  /// width
  final uint16_t width;

  /// Height of a matrix or image.
  ///
  /// MAVLink type: uint16_t
  ///
  /// height
  final uint16_t height;

  /// Number of packets being sent (set on ACK only).
  ///
  /// MAVLink type: uint16_t
  ///
  /// packets
  final uint16_t packets;

  /// Type of requested/acknowledged data.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavlinkDataStreamType]
  ///
  /// type
  final MavlinkDataStreamType type;

  /// Payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only).
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// payload
  final uint8_t payload;

  /// JPEG quality. Values: [1-100].
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// jpg_quality
  final uint8_t jpgQuality;

  DataTransmissionHandshake({
    required this.size,
    required this.width,
    required this.height,
    required this.packets,
    required this.type,
    required this.payload,
    required this.jpgQuality,
  });

  DataTransmissionHandshake copyWith({
    uint32_t? size,
    uint16_t? width,
    uint16_t? height,
    uint16_t? packets,
    MavlinkDataStreamType? type,
    uint8_t? payload,
    uint8_t? jpgQuality,
  }) {
    return DataTransmissionHandshake(
      size: size ?? this.size,
      width: width ?? this.width,
      height: height ?? this.height,
      packets: packets ?? this.packets,
      type: type ?? this.type,
      payload: payload ?? this.payload,
      jpgQuality: jpgQuality ?? this.jpgQuality,
    );
  }

  factory DataTransmissionHandshake.parse(ByteData data_) {
    if (data_.lengthInBytes < DataTransmissionHandshake.mavlinkEncodedLength) {
      var len =
          DataTransmissionHandshake.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var size = data_.getUint32(0, Endian.little);
    var width = data_.getUint16(4, Endian.little);
    var height = data_.getUint16(6, Endian.little);
    var packets = data_.getUint16(8, Endian.little);
    var type = data_.getUint8(10);
    var payload = data_.getUint8(11);
    var jpgQuality = data_.getUint8(12);

    return DataTransmissionHandshake(
        size: size,
        width: width,
        height: height,
        packets: packets,
        type: type,
        payload: payload,
        jpgQuality: jpgQuality);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, size, Endian.little);
    data_.setUint16(4, width, Endian.little);
    data_.setUint16(6, height, Endian.little);
    data_.setUint16(8, packets, Endian.little);
    data_.setUint8(10, type);
    data_.setUint8(11, payload);
    data_.setUint8(12, jpgQuality);
    return data_;
  }
}

/// Data packet for images sent using the Image Transmission Protocol: https://mavlink.io/en/services/image_transmission.html.
///
/// ENCAPSULATED_DATA
class EncapsulatedData implements MavlinkMessage {
  static const int _mavlinkMessageId = 131;

  static const int _mavlinkCrcExtra = 223;

  static const int mavlinkEncodedLength = 255;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// sequence number (starting with 0 on every transmission)
  ///
  /// MAVLink type: uint16_t
  ///
  /// seqnr
  final uint16_t seqnr;

  /// image data bytes
  ///
  /// MAVLink type: uint8_t[253]
  ///
  /// data
  final List<int8_t> data;

  EncapsulatedData({
    required this.seqnr,
    required this.data,
  });

  EncapsulatedData copyWith({
    uint16_t? seqnr,
    List<int8_t>? data,
  }) {
    return EncapsulatedData(
      seqnr: seqnr ?? this.seqnr,
      data: data ?? this.data,
    );
  }

  factory EncapsulatedData.parse(ByteData data_) {
    if (data_.lengthInBytes < EncapsulatedData.mavlinkEncodedLength) {
      var len = EncapsulatedData.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var seqnr = data_.getUint16(0, Endian.little);
    var data = MavlinkMessage.asUint8List(data_, 2, 253);

    return EncapsulatedData(seqnr: seqnr, data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, seqnr, Endian.little);
    MavlinkMessage.setUint8List(data_, 2, data);
    return data_;
  }
}

/// Distance sensor information for an onboard rangefinder.
///
/// DISTANCE_SENSOR
class DistanceSensor implements MavlinkMessage {
  static const int _mavlinkMessageId = 132;

  static const int _mavlinkCrcExtra = 85;

  static const int mavlinkEncodedLength = 39;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Minimum distance the sensor can measure
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm
  ///
  /// min_distance
  final uint16_t minDistance;

  /// Maximum distance the sensor can measure
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm
  ///
  /// max_distance
  final uint16_t maxDistance;

  /// Current distance reading
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm
  ///
  /// current_distance
  final uint16_t currentDistance;

  /// Type of distance sensor.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavDistanceSensor]
  ///
  /// type
  final MavDistanceSensor type;

  /// Onboard ID of the sensor
  ///
  /// MAVLink type: uint8_t
  ///
  /// id
  final uint8_t id;

  /// Direction the sensor faces. downward-facing: ROTATION_PITCH_270, upward-facing: ROTATION_PITCH_90, backward-facing: ROTATION_PITCH_180, forward-facing: ROTATION_NONE, left-facing: ROTATION_YAW_90, right-facing: ROTATION_YAW_270
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavSensorOrientation]
  ///
  /// orientation
  final MavSensorOrientation orientation;

  /// Measurement variance. Max standard deviation is 6cm. UINT8_MAX if unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: cm^2
  ///
  /// covariance
  final uint8_t covariance;

  /// Horizontal Field of View (angle) where the distance measurement is valid and the field of view is known. Otherwise this is set to 0.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// horizontal_fov
  final float horizontalFov;

  /// Vertical Field of View (angle) where the distance measurement is valid and the field of view is known. Otherwise this is set to 0.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// vertical_fov
  final float verticalFov;

  /// Quaternion of the sensor orientation in vehicle body frame (w, x, y, z order, zero-rotation is 1, 0, 0, 0). Zero-rotation is along the vehicle body x-axis. This field is required if the orientation is set to MAV_SENSOR_ROTATION_CUSTOM. Set it to 0 if invalid."
  ///
  /// MAVLink type: float[4]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// quaternion
  final List<float> quaternion;

  /// Signal quality of the sensor. Specific to each sensor type, representing the relation of the signal strength with the target reflectivity, distance, size or aspect, but normalised as a percentage. 0 = unknown/unset signal quality, 1 = invalid signal, 100 = perfect signal.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// signal_quality
  final uint8_t signalQuality;

  DistanceSensor({
    required this.timeBootMs,
    required this.minDistance,
    required this.maxDistance,
    required this.currentDistance,
    required this.type,
    required this.id,
    required this.orientation,
    required this.covariance,
    required this.horizontalFov,
    required this.verticalFov,
    required this.quaternion,
    required this.signalQuality,
  });

  DistanceSensor copyWith({
    uint32_t? timeBootMs,
    uint16_t? minDistance,
    uint16_t? maxDistance,
    uint16_t? currentDistance,
    MavDistanceSensor? type,
    uint8_t? id,
    MavSensorOrientation? orientation,
    uint8_t? covariance,
    float? horizontalFov,
    float? verticalFov,
    List<float>? quaternion,
    uint8_t? signalQuality,
  }) {
    return DistanceSensor(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      minDistance: minDistance ?? this.minDistance,
      maxDistance: maxDistance ?? this.maxDistance,
      currentDistance: currentDistance ?? this.currentDistance,
      type: type ?? this.type,
      id: id ?? this.id,
      orientation: orientation ?? this.orientation,
      covariance: covariance ?? this.covariance,
      horizontalFov: horizontalFov ?? this.horizontalFov,
      verticalFov: verticalFov ?? this.verticalFov,
      quaternion: quaternion ?? this.quaternion,
      signalQuality: signalQuality ?? this.signalQuality,
    );
  }

  factory DistanceSensor.parse(ByteData data_) {
    if (data_.lengthInBytes < DistanceSensor.mavlinkEncodedLength) {
      var len = DistanceSensor.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var minDistance = data_.getUint16(4, Endian.little);
    var maxDistance = data_.getUint16(6, Endian.little);
    var currentDistance = data_.getUint16(8, Endian.little);
    var type = data_.getUint8(10);
    var id = data_.getUint8(11);
    var orientation = data_.getUint8(12);
    var covariance = data_.getUint8(13);
    var horizontalFov = data_.getFloat32(14, Endian.little);
    var verticalFov = data_.getFloat32(18, Endian.little);
    var quaternion = MavlinkMessage.asFloat32List(data_, 22, 4);
    var signalQuality = data_.getUint8(38);

    return DistanceSensor(
        timeBootMs: timeBootMs,
        minDistance: minDistance,
        maxDistance: maxDistance,
        currentDistance: currentDistance,
        type: type,
        id: id,
        orientation: orientation,
        covariance: covariance,
        horizontalFov: horizontalFov,
        verticalFov: verticalFov,
        quaternion: quaternion,
        signalQuality: signalQuality);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint16(4, minDistance, Endian.little);
    data_.setUint16(6, maxDistance, Endian.little);
    data_.setUint16(8, currentDistance, Endian.little);
    data_.setUint8(10, type);
    data_.setUint8(11, id);
    data_.setUint8(12, orientation);
    data_.setUint8(13, covariance);
    data_.setFloat32(14, horizontalFov, Endian.little);
    data_.setFloat32(18, verticalFov, Endian.little);
    MavlinkMessage.setFloat32List(data_, 22, quaternion);
    data_.setUint8(38, signalQuality);
    return data_;
  }
}

/// Request for terrain data and terrain status. See terrain protocol docs: https://mavlink.io/en/services/terrain.html
///
/// TERRAIN_REQUEST
class TerrainRequest implements MavlinkMessage {
  static const int _mavlinkMessageId = 133;

  static const int _mavlinkCrcExtra = 6;

  static const int mavlinkEncodedLength = 18;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Bitmask of requested 4x4 grids (row major 8x7 array of grids, 56 bits)
  ///
  /// MAVLink type: uint64_t
  ///
  /// mask
  final uint64_t mask;

  /// Latitude of SW corner of first grid
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude of SW corner of first grid
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Grid spacing
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: m
  ///
  /// grid_spacing
  final uint16_t gridSpacing;

  TerrainRequest({
    required this.mask,
    required this.lat,
    required this.lon,
    required this.gridSpacing,
  });

  TerrainRequest copyWith({
    uint64_t? mask,
    int32_t? lat,
    int32_t? lon,
    uint16_t? gridSpacing,
  }) {
    return TerrainRequest(
      mask: mask ?? this.mask,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      gridSpacing: gridSpacing ?? this.gridSpacing,
    );
  }

  factory TerrainRequest.parse(ByteData data_) {
    if (data_.lengthInBytes < TerrainRequest.mavlinkEncodedLength) {
      var len = TerrainRequest.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var mask = data_.getUint64(0, Endian.little);
    var lat = data_.getInt32(8, Endian.little);
    var lon = data_.getInt32(12, Endian.little);
    var gridSpacing = data_.getUint16(16, Endian.little);

    return TerrainRequest(
        mask: mask, lat: lat, lon: lon, gridSpacing: gridSpacing);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, mask, Endian.little);
    data_.setInt32(8, lat, Endian.little);
    data_.setInt32(12, lon, Endian.little);
    data_.setUint16(16, gridSpacing, Endian.little);
    return data_;
  }
}

/// Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUEST. See terrain protocol docs: https://mavlink.io/en/services/terrain.html
///
/// TERRAIN_DATA
class TerrainData implements MavlinkMessage {
  static const int _mavlinkMessageId = 134;

  static const int _mavlinkCrcExtra = 229;

  static const int mavlinkEncodedLength = 43;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude of SW corner of first grid
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude of SW corner of first grid
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Grid spacing
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: m
  ///
  /// grid_spacing
  final uint16_t gridSpacing;

  /// Terrain data MSL
  ///
  /// MAVLink type: int16_t[16]
  ///
  /// units: m
  ///
  /// data
  final List<int16_t> data;

  /// bit within the terrain request mask
  ///
  /// MAVLink type: uint8_t
  ///
  /// gridbit
  final uint8_t gridbit;

  TerrainData({
    required this.lat,
    required this.lon,
    required this.gridSpacing,
    required this.data,
    required this.gridbit,
  });

  TerrainData copyWith({
    int32_t? lat,
    int32_t? lon,
    uint16_t? gridSpacing,
    List<int16_t>? data,
    uint8_t? gridbit,
  }) {
    return TerrainData(
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      gridSpacing: gridSpacing ?? this.gridSpacing,
      data: data ?? this.data,
      gridbit: gridbit ?? this.gridbit,
    );
  }

  factory TerrainData.parse(ByteData data_) {
    if (data_.lengthInBytes < TerrainData.mavlinkEncodedLength) {
      var len = TerrainData.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var lat = data_.getInt32(0, Endian.little);
    var lon = data_.getInt32(4, Endian.little);
    var gridSpacing = data_.getUint16(8, Endian.little);
    var data = MavlinkMessage.asInt16List(data_, 10, 16);
    var gridbit = data_.getUint8(42);

    return TerrainData(
        lat: lat,
        lon: lon,
        gridSpacing: gridSpacing,
        data: data,
        gridbit: gridbit);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, lat, Endian.little);
    data_.setInt32(4, lon, Endian.little);
    data_.setUint16(8, gridSpacing, Endian.little);
    MavlinkMessage.setInt16List(data_, 10, data);
    data_.setUint8(42, gridbit);
    return data_;
  }
}

/// Request that the vehicle report terrain height at the given location (expected response is a TERRAIN_REPORT). Used by GCS to check if vehicle has all terrain data needed for a mission.
///
/// TERRAIN_CHECK
class TerrainCheck implements MavlinkMessage {
  static const int _mavlinkMessageId = 135;

  static const int _mavlinkCrcExtra = 203;

  static const int mavlinkEncodedLength = 8;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  TerrainCheck({
    required this.lat,
    required this.lon,
  });

  TerrainCheck copyWith({
    int32_t? lat,
    int32_t? lon,
  }) {
    return TerrainCheck(
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
    );
  }

  factory TerrainCheck.parse(ByteData data_) {
    if (data_.lengthInBytes < TerrainCheck.mavlinkEncodedLength) {
      var len = TerrainCheck.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var lat = data_.getInt32(0, Endian.little);
    var lon = data_.getInt32(4, Endian.little);

    return TerrainCheck(lat: lat, lon: lon);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, lat, Endian.little);
    data_.setInt32(4, lon, Endian.little);
    return data_;
  }
}

/// Streamed from drone to report progress of terrain map download (initiated by TERRAIN_REQUEST), or sent as a response to a TERRAIN_CHECK request. See terrain protocol docs: https://mavlink.io/en/services/terrain.html
///
/// TERRAIN_REPORT
class TerrainReport implements MavlinkMessage {
  static const int _mavlinkMessageId = 136;

  static const int _mavlinkCrcExtra = 1;

  static const int mavlinkEncodedLength = 22;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Terrain height MSL
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// terrain_height
  final float terrainHeight;

  /// Current vehicle height above lat/lon terrain height
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// current_height
  final float currentHeight;

  /// grid spacing (zero if terrain at this location unavailable)
  ///
  /// MAVLink type: uint16_t
  ///
  /// spacing
  final uint16_t spacing;

  /// Number of 4x4 terrain blocks waiting to be received or read from disk
  ///
  /// MAVLink type: uint16_t
  ///
  /// pending
  final uint16_t pending;

  /// Number of 4x4 terrain blocks in memory
  ///
  /// MAVLink type: uint16_t
  ///
  /// loaded
  final uint16_t loaded;

  TerrainReport({
    required this.lat,
    required this.lon,
    required this.terrainHeight,
    required this.currentHeight,
    required this.spacing,
    required this.pending,
    required this.loaded,
  });

  TerrainReport copyWith({
    int32_t? lat,
    int32_t? lon,
    float? terrainHeight,
    float? currentHeight,
    uint16_t? spacing,
    uint16_t? pending,
    uint16_t? loaded,
  }) {
    return TerrainReport(
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      terrainHeight: terrainHeight ?? this.terrainHeight,
      currentHeight: currentHeight ?? this.currentHeight,
      spacing: spacing ?? this.spacing,
      pending: pending ?? this.pending,
      loaded: loaded ?? this.loaded,
    );
  }

  factory TerrainReport.parse(ByteData data_) {
    if (data_.lengthInBytes < TerrainReport.mavlinkEncodedLength) {
      var len = TerrainReport.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var lat = data_.getInt32(0, Endian.little);
    var lon = data_.getInt32(4, Endian.little);
    var terrainHeight = data_.getFloat32(8, Endian.little);
    var currentHeight = data_.getFloat32(12, Endian.little);
    var spacing = data_.getUint16(16, Endian.little);
    var pending = data_.getUint16(18, Endian.little);
    var loaded = data_.getUint16(20, Endian.little);

    return TerrainReport(
        lat: lat,
        lon: lon,
        terrainHeight: terrainHeight,
        currentHeight: currentHeight,
        spacing: spacing,
        pending: pending,
        loaded: loaded);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, lat, Endian.little);
    data_.setInt32(4, lon, Endian.little);
    data_.setFloat32(8, terrainHeight, Endian.little);
    data_.setFloat32(12, currentHeight, Endian.little);
    data_.setUint16(16, spacing, Endian.little);
    data_.setUint16(18, pending, Endian.little);
    data_.setUint16(20, loaded, Endian.little);
    return data_;
  }
}

/// Barometer readings for 2nd barometer
///
/// SCALED_PRESSURE2
class ScaledPressure2 implements MavlinkMessage {
  static const int _mavlinkMessageId = 137;

  static const int _mavlinkCrcExtra = 195;

  static const int mavlinkEncodedLength = 16;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Absolute pressure
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// press_abs
  final float pressAbs;

  /// Differential pressure
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// press_diff
  final float pressDiff;

  /// Absolute pressure temperature
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// temperature
  final int16_t temperature;

  /// Differential pressure temperature (0, if not available). Report values of 0 (or 1) as 1 cdegC.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// temperature_press_diff
  final int16_t temperaturePressDiff;

  ScaledPressure2({
    required this.timeBootMs,
    required this.pressAbs,
    required this.pressDiff,
    required this.temperature,
    required this.temperaturePressDiff,
  });

  ScaledPressure2 copyWith({
    uint32_t? timeBootMs,
    float? pressAbs,
    float? pressDiff,
    int16_t? temperature,
    int16_t? temperaturePressDiff,
  }) {
    return ScaledPressure2(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      pressAbs: pressAbs ?? this.pressAbs,
      pressDiff: pressDiff ?? this.pressDiff,
      temperature: temperature ?? this.temperature,
      temperaturePressDiff: temperaturePressDiff ?? this.temperaturePressDiff,
    );
  }

  factory ScaledPressure2.parse(ByteData data_) {
    if (data_.lengthInBytes < ScaledPressure2.mavlinkEncodedLength) {
      var len = ScaledPressure2.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var pressAbs = data_.getFloat32(4, Endian.little);
    var pressDiff = data_.getFloat32(8, Endian.little);
    var temperature = data_.getInt16(12, Endian.little);
    var temperaturePressDiff = data_.getInt16(14, Endian.little);

    return ScaledPressure2(
        timeBootMs: timeBootMs,
        pressAbs: pressAbs,
        pressDiff: pressDiff,
        temperature: temperature,
        temperaturePressDiff: temperaturePressDiff);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, pressAbs, Endian.little);
    data_.setFloat32(8, pressDiff, Endian.little);
    data_.setInt16(12, temperature, Endian.little);
    data_.setInt16(14, temperaturePressDiff, Endian.little);
    return data_;
  }
}

/// Motion capture attitude and position
///
/// ATT_POS_MOCAP
class AttPosMocap implements MavlinkMessage {
  static const int _mavlinkMessageId = 138;

  static const int _mavlinkCrcExtra = 109;

  static const int mavlinkEncodedLength = 120;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// X position (NED)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Y position (NED)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Z position (NED)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// Row-major representation of a pose 6x6 cross-covariance matrix upper right triangle (states: x, y, z, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[21]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// covariance
  final List<float> covariance;

  AttPosMocap({
    required this.timeUsec,
    required this.q,
    required this.x,
    required this.y,
    required this.z,
    required this.covariance,
  });

  AttPosMocap copyWith({
    uint64_t? timeUsec,
    List<float>? q,
    float? x,
    float? y,
    float? z,
    List<float>? covariance,
  }) {
    return AttPosMocap(
      timeUsec: timeUsec ?? this.timeUsec,
      q: q ?? this.q,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      covariance: covariance ?? this.covariance,
    );
  }

  factory AttPosMocap.parse(ByteData data_) {
    if (data_.lengthInBytes < AttPosMocap.mavlinkEncodedLength) {
      var len = AttPosMocap.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 8, 4);
    var x = data_.getFloat32(24, Endian.little);
    var y = data_.getFloat32(28, Endian.little);
    var z = data_.getFloat32(32, Endian.little);
    var covariance = MavlinkMessage.asFloat32List(data_, 36, 21);

    return AttPosMocap(
        timeUsec: timeUsec, q: q, x: x, y: y, z: z, covariance: covariance);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setFloat32List(data_, 8, q);
    data_.setFloat32(24, x, Endian.little);
    data_.setFloat32(28, y, Endian.little);
    data_.setFloat32(32, z, Endian.little);
    MavlinkMessage.setFloat32List(data_, 36, covariance);
    return data_;
  }
}

/// Set the vehicle attitude and body angular rates.
///
/// SET_ACTUATOR_CONTROL_TARGET
class SetActuatorControlTarget implements MavlinkMessage {
  static const int _mavlinkMessageId = 139;

  static const int _mavlinkCrcExtra = 168;

  static const int mavlinkEncodedLength = 43;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
  ///
  /// MAVLink type: float[8]
  ///
  /// controls
  final List<float> controls;

  /// Actuator group. The "_mlx" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.
  ///
  /// MAVLink type: uint8_t
  ///
  /// group_mlx
  final uint8_t groupMlx;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  SetActuatorControlTarget({
    required this.timeUsec,
    required this.controls,
    required this.groupMlx,
    required this.targetSystem,
    required this.targetComponent,
  });

  SetActuatorControlTarget copyWith({
    uint64_t? timeUsec,
    List<float>? controls,
    uint8_t? groupMlx,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return SetActuatorControlTarget(
      timeUsec: timeUsec ?? this.timeUsec,
      controls: controls ?? this.controls,
      groupMlx: groupMlx ?? this.groupMlx,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory SetActuatorControlTarget.parse(ByteData data_) {
    if (data_.lengthInBytes < SetActuatorControlTarget.mavlinkEncodedLength) {
      var len =
          SetActuatorControlTarget.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var controls = MavlinkMessage.asFloat32List(data_, 8, 8);
    var groupMlx = data_.getUint8(40);
    var targetSystem = data_.getUint8(41);
    var targetComponent = data_.getUint8(42);

    return SetActuatorControlTarget(
        timeUsec: timeUsec,
        controls: controls,
        groupMlx: groupMlx,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setFloat32List(data_, 8, controls);
    data_.setUint8(40, groupMlx);
    data_.setUint8(41, targetSystem);
    data_.setUint8(42, targetComponent);
    return data_;
  }
}

/// Set the vehicle attitude and body angular rates.
///
/// ACTUATOR_CONTROL_TARGET
class ActuatorControlTarget implements MavlinkMessage {
  static const int _mavlinkMessageId = 140;

  static const int _mavlinkCrcExtra = 181;

  static const int mavlinkEncodedLength = 41;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Actuator controls. Normed to -1..+1 where 0 is neutral position. Throttle for single rotation direction motors is 0..1, negative range for reverse direction. Standard mapping for attitude controls (group 0): (index 0-7): roll, pitch, yaw, throttle, flaps, spoilers, airbrakes, landing gear. Load a pass-through mixer to repurpose them as generic outputs.
  ///
  /// MAVLink type: float[8]
  ///
  /// controls
  final List<float> controls;

  /// Actuator group. The "_mlx" indicates this is a multi-instance message and a MAVLink parser should use this field to difference between instances.
  ///
  /// MAVLink type: uint8_t
  ///
  /// group_mlx
  final uint8_t groupMlx;

  ActuatorControlTarget({
    required this.timeUsec,
    required this.controls,
    required this.groupMlx,
  });

  ActuatorControlTarget copyWith({
    uint64_t? timeUsec,
    List<float>? controls,
    uint8_t? groupMlx,
  }) {
    return ActuatorControlTarget(
      timeUsec: timeUsec ?? this.timeUsec,
      controls: controls ?? this.controls,
      groupMlx: groupMlx ?? this.groupMlx,
    );
  }

  factory ActuatorControlTarget.parse(ByteData data_) {
    if (data_.lengthInBytes < ActuatorControlTarget.mavlinkEncodedLength) {
      var len =
          ActuatorControlTarget.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var controls = MavlinkMessage.asFloat32List(data_, 8, 8);
    var groupMlx = data_.getUint8(40);

    return ActuatorControlTarget(
        timeUsec: timeUsec, controls: controls, groupMlx: groupMlx);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setFloat32List(data_, 8, controls);
    data_.setUint8(40, groupMlx);
    return data_;
  }
}

/// The current system altitude.
///
/// ALTITUDE
class Altitude implements MavlinkMessage {
  static const int _mavlinkMessageId = 141;

  static const int _mavlinkCrcExtra = 47;

  static const int mavlinkEncodedLength = 32;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// This altitude measure is initialized on system boot and monotonic (it is never reset, but represents the local altitude change). The only guarantee on this field is that it will never be reset and is consistent within a flight. The recommended value for this field is the uncorrected barometric altitude at boot time. This altitude will also drift and vary between flights.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude_monotonic
  final float altitudeMonotonic;

  /// This altitude measure is strictly above mean sea level and might be non-monotonic (it might reset on events like GPS lock or when a new QNH value is set). It should be the altitude to which global altitude waypoints are compared to. Note that it is *not* the GPS altitude, however, most GPS modules already output MSL by default and not the WGS84 altitude.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude_amsl
  final float altitudeAmsl;

  /// This is the local altitude in the local coordinate frame. It is not the altitude above home, but in reference to the coordinate origin (0, 0, 0). It is up-positive.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude_local
  final float altitudeLocal;

  /// This is the altitude above the home position. It resets on each change of the current home position.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude_relative
  final float altitudeRelative;

  /// This is the altitude above terrain. It might be fed by a terrain database or an altimeter. Values smaller than -1000 should be interpreted as unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude_terrain
  final float altitudeTerrain;

  /// This is not the altitude, but the clear space below the system according to the fused clearance estimate. It generally should max out at the maximum range of e.g. the laser altimeter. It is generally a moving target. A negative value indicates no measurement available.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// bottom_clearance
  final float bottomClearance;

  Altitude({
    required this.timeUsec,
    required this.altitudeMonotonic,
    required this.altitudeAmsl,
    required this.altitudeLocal,
    required this.altitudeRelative,
    required this.altitudeTerrain,
    required this.bottomClearance,
  });

  Altitude copyWith({
    uint64_t? timeUsec,
    float? altitudeMonotonic,
    float? altitudeAmsl,
    float? altitudeLocal,
    float? altitudeRelative,
    float? altitudeTerrain,
    float? bottomClearance,
  }) {
    return Altitude(
      timeUsec: timeUsec ?? this.timeUsec,
      altitudeMonotonic: altitudeMonotonic ?? this.altitudeMonotonic,
      altitudeAmsl: altitudeAmsl ?? this.altitudeAmsl,
      altitudeLocal: altitudeLocal ?? this.altitudeLocal,
      altitudeRelative: altitudeRelative ?? this.altitudeRelative,
      altitudeTerrain: altitudeTerrain ?? this.altitudeTerrain,
      bottomClearance: bottomClearance ?? this.bottomClearance,
    );
  }

  factory Altitude.parse(ByteData data_) {
    if (data_.lengthInBytes < Altitude.mavlinkEncodedLength) {
      var len = Altitude.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var altitudeMonotonic = data_.getFloat32(8, Endian.little);
    var altitudeAmsl = data_.getFloat32(12, Endian.little);
    var altitudeLocal = data_.getFloat32(16, Endian.little);
    var altitudeRelative = data_.getFloat32(20, Endian.little);
    var altitudeTerrain = data_.getFloat32(24, Endian.little);
    var bottomClearance = data_.getFloat32(28, Endian.little);

    return Altitude(
        timeUsec: timeUsec,
        altitudeMonotonic: altitudeMonotonic,
        altitudeAmsl: altitudeAmsl,
        altitudeLocal: altitudeLocal,
        altitudeRelative: altitudeRelative,
        altitudeTerrain: altitudeTerrain,
        bottomClearance: bottomClearance);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, altitudeMonotonic, Endian.little);
    data_.setFloat32(12, altitudeAmsl, Endian.little);
    data_.setFloat32(16, altitudeLocal, Endian.little);
    data_.setFloat32(20, altitudeRelative, Endian.little);
    data_.setFloat32(24, altitudeTerrain, Endian.little);
    data_.setFloat32(28, bottomClearance, Endian.little);
    return data_;
  }
}

/// The autopilot is requesting a resource (file, binary, other type of data)
///
/// RESOURCE_REQUEST
class ResourceRequest implements MavlinkMessage {
  static const int _mavlinkMessageId = 142;

  static const int _mavlinkCrcExtra = 72;

  static const int mavlinkEncodedLength = 243;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Request ID. This ID should be re-used when sending back URI contents
  ///
  /// MAVLink type: uint8_t
  ///
  /// request_id
  final uint8_t requestId;

  /// The type of requested URI. 0 = a file via URL. 1 = a UAVCAN binary
  ///
  /// MAVLink type: uint8_t
  ///
  /// uri_type
  final uint8_t uriType;

  /// The requested unique resource identifier (URI). It is not necessarily a straight domain name (depends on the URI type enum)
  ///
  /// MAVLink type: uint8_t[120]
  ///
  /// uri
  final List<int8_t> uri;

  /// The way the autopilot wants to receive the URI. 0 = MAVLink FTP. 1 = binary stream.
  ///
  /// MAVLink type: uint8_t
  ///
  /// transfer_type
  final uint8_t transferType;

  /// The storage path the autopilot wants the URI to be stored in. Will only be valid if the transfer_type has a storage associated (e.g. MAVLink FTP).
  ///
  /// MAVLink type: uint8_t[120]
  ///
  /// storage
  final List<int8_t> storage;

  ResourceRequest({
    required this.requestId,
    required this.uriType,
    required this.uri,
    required this.transferType,
    required this.storage,
  });

  ResourceRequest copyWith({
    uint8_t? requestId,
    uint8_t? uriType,
    List<int8_t>? uri,
    uint8_t? transferType,
    List<int8_t>? storage,
  }) {
    return ResourceRequest(
      requestId: requestId ?? this.requestId,
      uriType: uriType ?? this.uriType,
      uri: uri ?? this.uri,
      transferType: transferType ?? this.transferType,
      storage: storage ?? this.storage,
    );
  }

  factory ResourceRequest.parse(ByteData data_) {
    if (data_.lengthInBytes < ResourceRequest.mavlinkEncodedLength) {
      var len = ResourceRequest.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var requestId = data_.getUint8(0);
    var uriType = data_.getUint8(1);
    var uri = MavlinkMessage.asUint8List(data_, 2, 120);
    var transferType = data_.getUint8(122);
    var storage = MavlinkMessage.asUint8List(data_, 123, 120);

    return ResourceRequest(
        requestId: requestId,
        uriType: uriType,
        uri: uri,
        transferType: transferType,
        storage: storage);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, requestId);
    data_.setUint8(1, uriType);
    MavlinkMessage.setUint8List(data_, 2, uri);
    data_.setUint8(122, transferType);
    MavlinkMessage.setUint8List(data_, 123, storage);
    return data_;
  }
}

/// Barometer readings for 3rd barometer
///
/// SCALED_PRESSURE3
class ScaledPressure3 implements MavlinkMessage {
  static const int _mavlinkMessageId = 143;

  static const int _mavlinkCrcExtra = 131;

  static const int mavlinkEncodedLength = 16;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Absolute pressure
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// press_abs
  final float pressAbs;

  /// Differential pressure
  ///
  /// MAVLink type: float
  ///
  /// units: hPa
  ///
  /// press_diff
  final float pressDiff;

  /// Absolute pressure temperature
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// temperature
  final int16_t temperature;

  /// Differential pressure temperature (0, if not available). Report values of 0 (or 1) as 1 cdegC.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// temperature_press_diff
  final int16_t temperaturePressDiff;

  ScaledPressure3({
    required this.timeBootMs,
    required this.pressAbs,
    required this.pressDiff,
    required this.temperature,
    required this.temperaturePressDiff,
  });

  ScaledPressure3 copyWith({
    uint32_t? timeBootMs,
    float? pressAbs,
    float? pressDiff,
    int16_t? temperature,
    int16_t? temperaturePressDiff,
  }) {
    return ScaledPressure3(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      pressAbs: pressAbs ?? this.pressAbs,
      pressDiff: pressDiff ?? this.pressDiff,
      temperature: temperature ?? this.temperature,
      temperaturePressDiff: temperaturePressDiff ?? this.temperaturePressDiff,
    );
  }

  factory ScaledPressure3.parse(ByteData data_) {
    if (data_.lengthInBytes < ScaledPressure3.mavlinkEncodedLength) {
      var len = ScaledPressure3.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var pressAbs = data_.getFloat32(4, Endian.little);
    var pressDiff = data_.getFloat32(8, Endian.little);
    var temperature = data_.getInt16(12, Endian.little);
    var temperaturePressDiff = data_.getInt16(14, Endian.little);

    return ScaledPressure3(
        timeBootMs: timeBootMs,
        pressAbs: pressAbs,
        pressDiff: pressDiff,
        temperature: temperature,
        temperaturePressDiff: temperaturePressDiff);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, pressAbs, Endian.little);
    data_.setFloat32(8, pressDiff, Endian.little);
    data_.setInt16(12, temperature, Endian.little);
    data_.setInt16(14, temperaturePressDiff, Endian.little);
    return data_;
  }
}

/// Current motion information from a designated system
///
/// FOLLOW_TARGET
class FollowTarget implements MavlinkMessage {
  static const int _mavlinkMessageId = 144;

  static const int _mavlinkCrcExtra = 127;

  static const int mavlinkEncodedLength = 93;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: ms
  ///
  /// timestamp
  final uint64_t timestamp;

  /// button states or switches of a tracker device
  ///
  /// MAVLink type: uint64_t
  ///
  /// custom_state
  final uint64_t customState;

  /// Latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude (MSL)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt
  final float alt;

  /// target velocity (0,0,0) for unknown
  ///
  /// MAVLink type: float[3]
  ///
  /// units: m/s
  ///
  /// vel
  final List<float> vel;

  /// linear target acceleration (0,0,0) for unknown
  ///
  /// MAVLink type: float[3]
  ///
  /// units: m/s/s
  ///
  /// acc
  final List<float> acc;

  /// (0 0 0 0 for unknown)
  ///
  /// MAVLink type: float[4]
  ///
  /// attitude_q
  final List<float> attitudeQ;

  /// (0 0 0 for unknown)
  ///
  /// MAVLink type: float[3]
  ///
  /// rates
  final List<float> rates;

  /// eph epv
  ///
  /// MAVLink type: float[3]
  ///
  /// position_cov
  final List<float> positionCov;

  /// bit positions for tracker reporting capabilities (POS = 0, VEL = 1, ACCEL = 2, ATT + RATES = 3)
  ///
  /// MAVLink type: uint8_t
  ///
  /// est_capabilities
  final uint8_t estCapabilities;

  FollowTarget({
    required this.timestamp,
    required this.customState,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.vel,
    required this.acc,
    required this.attitudeQ,
    required this.rates,
    required this.positionCov,
    required this.estCapabilities,
  });

  FollowTarget copyWith({
    uint64_t? timestamp,
    uint64_t? customState,
    int32_t? lat,
    int32_t? lon,
    float? alt,
    List<float>? vel,
    List<float>? acc,
    List<float>? attitudeQ,
    List<float>? rates,
    List<float>? positionCov,
    uint8_t? estCapabilities,
  }) {
    return FollowTarget(
      timestamp: timestamp ?? this.timestamp,
      customState: customState ?? this.customState,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      vel: vel ?? this.vel,
      acc: acc ?? this.acc,
      attitudeQ: attitudeQ ?? this.attitudeQ,
      rates: rates ?? this.rates,
      positionCov: positionCov ?? this.positionCov,
      estCapabilities: estCapabilities ?? this.estCapabilities,
    );
  }

  factory FollowTarget.parse(ByteData data_) {
    if (data_.lengthInBytes < FollowTarget.mavlinkEncodedLength) {
      var len = FollowTarget.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timestamp = data_.getUint64(0, Endian.little);
    var customState = data_.getUint64(8, Endian.little);
    var lat = data_.getInt32(16, Endian.little);
    var lon = data_.getInt32(20, Endian.little);
    var alt = data_.getFloat32(24, Endian.little);
    var vel = MavlinkMessage.asFloat32List(data_, 28, 3);
    var acc = MavlinkMessage.asFloat32List(data_, 40, 3);
    var attitudeQ = MavlinkMessage.asFloat32List(data_, 52, 4);
    var rates = MavlinkMessage.asFloat32List(data_, 68, 3);
    var positionCov = MavlinkMessage.asFloat32List(data_, 80, 3);
    var estCapabilities = data_.getUint8(92);

    return FollowTarget(
        timestamp: timestamp,
        customState: customState,
        lat: lat,
        lon: lon,
        alt: alt,
        vel: vel,
        acc: acc,
        attitudeQ: attitudeQ,
        rates: rates,
        positionCov: positionCov,
        estCapabilities: estCapabilities);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timestamp, Endian.little);
    data_.setUint64(8, customState, Endian.little);
    data_.setInt32(16, lat, Endian.little);
    data_.setInt32(20, lon, Endian.little);
    data_.setFloat32(24, alt, Endian.little);
    MavlinkMessage.setFloat32List(data_, 28, vel);
    MavlinkMessage.setFloat32List(data_, 40, acc);
    MavlinkMessage.setFloat32List(data_, 52, attitudeQ);
    MavlinkMessage.setFloat32List(data_, 68, rates);
    MavlinkMessage.setFloat32List(data_, 80, positionCov);
    data_.setUint8(92, estCapabilities);
    return data_;
  }
}

/// The smoothed, monotonic system state used to feed the control loops of the system.
///
/// CONTROL_SYSTEM_STATE
class ControlSystemState implements MavlinkMessage {
  static const int _mavlinkMessageId = 146;

  static const int _mavlinkCrcExtra = 103;

  static const int mavlinkEncodedLength = 100;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// X acceleration in body frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// x_acc
  final float xAcc;

  /// Y acceleration in body frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// y_acc
  final float yAcc;

  /// Z acceleration in body frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// z_acc
  final float zAcc;

  /// X velocity in body frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// x_vel
  final float xVel;

  /// Y velocity in body frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// y_vel
  final float yVel;

  /// Z velocity in body frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// z_vel
  final float zVel;

  /// X position in local frame
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x_pos
  final float xPos;

  /// Y position in local frame
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y_pos
  final float yPos;

  /// Z position in local frame
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z_pos
  final float zPos;

  /// Airspeed, set to -1 if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// airspeed
  final float airspeed;

  /// Variance of body velocity estimate
  ///
  /// MAVLink type: float[3]
  ///
  /// vel_variance
  final List<float> velVariance;

  /// Variance in local position
  ///
  /// MAVLink type: float[3]
  ///
  /// pos_variance
  final List<float> posVariance;

  /// The attitude, represented as Quaternion
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// Angular rate in roll axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// roll_rate
  final float rollRate;

  /// Angular rate in pitch axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitch_rate
  final float pitchRate;

  /// Angular rate in yaw axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yaw_rate
  final float yawRate;

  ControlSystemState({
    required this.timeUsec,
    required this.xAcc,
    required this.yAcc,
    required this.zAcc,
    required this.xVel,
    required this.yVel,
    required this.zVel,
    required this.xPos,
    required this.yPos,
    required this.zPos,
    required this.airspeed,
    required this.velVariance,
    required this.posVariance,
    required this.q,
    required this.rollRate,
    required this.pitchRate,
    required this.yawRate,
  });

  ControlSystemState copyWith({
    uint64_t? timeUsec,
    float? xAcc,
    float? yAcc,
    float? zAcc,
    float? xVel,
    float? yVel,
    float? zVel,
    float? xPos,
    float? yPos,
    float? zPos,
    float? airspeed,
    List<float>? velVariance,
    List<float>? posVariance,
    List<float>? q,
    float? rollRate,
    float? pitchRate,
    float? yawRate,
  }) {
    return ControlSystemState(
      timeUsec: timeUsec ?? this.timeUsec,
      xAcc: xAcc ?? this.xAcc,
      yAcc: yAcc ?? this.yAcc,
      zAcc: zAcc ?? this.zAcc,
      xVel: xVel ?? this.xVel,
      yVel: yVel ?? this.yVel,
      zVel: zVel ?? this.zVel,
      xPos: xPos ?? this.xPos,
      yPos: yPos ?? this.yPos,
      zPos: zPos ?? this.zPos,
      airspeed: airspeed ?? this.airspeed,
      velVariance: velVariance ?? this.velVariance,
      posVariance: posVariance ?? this.posVariance,
      q: q ?? this.q,
      rollRate: rollRate ?? this.rollRate,
      pitchRate: pitchRate ?? this.pitchRate,
      yawRate: yawRate ?? this.yawRate,
    );
  }

  factory ControlSystemState.parse(ByteData data_) {
    if (data_.lengthInBytes < ControlSystemState.mavlinkEncodedLength) {
      var len = ControlSystemState.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var xAcc = data_.getFloat32(8, Endian.little);
    var yAcc = data_.getFloat32(12, Endian.little);
    var zAcc = data_.getFloat32(16, Endian.little);
    var xVel = data_.getFloat32(20, Endian.little);
    var yVel = data_.getFloat32(24, Endian.little);
    var zVel = data_.getFloat32(28, Endian.little);
    var xPos = data_.getFloat32(32, Endian.little);
    var yPos = data_.getFloat32(36, Endian.little);
    var zPos = data_.getFloat32(40, Endian.little);
    var airspeed = data_.getFloat32(44, Endian.little);
    var velVariance = MavlinkMessage.asFloat32List(data_, 48, 3);
    var posVariance = MavlinkMessage.asFloat32List(data_, 60, 3);
    var q = MavlinkMessage.asFloat32List(data_, 72, 4);
    var rollRate = data_.getFloat32(88, Endian.little);
    var pitchRate = data_.getFloat32(92, Endian.little);
    var yawRate = data_.getFloat32(96, Endian.little);

    return ControlSystemState(
        timeUsec: timeUsec,
        xAcc: xAcc,
        yAcc: yAcc,
        zAcc: zAcc,
        xVel: xVel,
        yVel: yVel,
        zVel: zVel,
        xPos: xPos,
        yPos: yPos,
        zPos: zPos,
        airspeed: airspeed,
        velVariance: velVariance,
        posVariance: posVariance,
        q: q,
        rollRate: rollRate,
        pitchRate: pitchRate,
        yawRate: yawRate);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, xAcc, Endian.little);
    data_.setFloat32(12, yAcc, Endian.little);
    data_.setFloat32(16, zAcc, Endian.little);
    data_.setFloat32(20, xVel, Endian.little);
    data_.setFloat32(24, yVel, Endian.little);
    data_.setFloat32(28, zVel, Endian.little);
    data_.setFloat32(32, xPos, Endian.little);
    data_.setFloat32(36, yPos, Endian.little);
    data_.setFloat32(40, zPos, Endian.little);
    data_.setFloat32(44, airspeed, Endian.little);
    MavlinkMessage.setFloat32List(data_, 48, velVariance);
    MavlinkMessage.setFloat32List(data_, 60, posVariance);
    MavlinkMessage.setFloat32List(data_, 72, q);
    data_.setFloat32(88, rollRate, Endian.little);
    data_.setFloat32(92, pitchRate, Endian.little);
    data_.setFloat32(96, yawRate, Endian.little);
    return data_;
  }
}

/// Battery information. Updates GCS with flight controller battery status. Smart batteries also use this message, but may additionally send BATTERY_INFO.
///
/// BATTERY_STATUS
class BatteryStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 147;

  static const int _mavlinkCrcExtra = 154;

  static const int mavlinkEncodedLength = 54;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Consumed charge, -1: autopilot does not provide consumption estimate
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mAh
  ///
  /// current_consumed
  final int32_t currentConsumed;

  /// Consumed energy, -1: autopilot does not provide energy consumption estimate
  ///
  /// MAVLink type: int32_t
  ///
  /// units: hJ
  ///
  /// energy_consumed
  final int32_t energyConsumed;

  /// Temperature of the battery. INT16_MAX for unknown temperature.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// temperature
  final int16_t temperature;

  /// Battery voltage of cells 1 to 10 (see voltages_ext for cells 11-14). Cells in this field above the valid cell count for this battery should have the UINT16_MAX value. If individual cell voltages are unknown or not measured for this battery, then the overall battery voltage should be filled in cell 0, with all others set to UINT16_MAX. If the voltage of the battery is greater than (UINT16_MAX - 1), then cell 0 should be set to (UINT16_MAX - 1), and cell 1 to the remaining voltage. This can be extended to multiple cells if the total voltage is greater than 2 * (UINT16_MAX - 1).
  ///
  /// MAVLink type: uint16_t[10]
  ///
  /// units: mV
  ///
  /// voltages
  final List<int16_t> voltages;

  /// Battery current, -1: autopilot does not measure the current
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cA
  ///
  /// current_battery
  final int16_t currentBattery;

  /// Battery ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// id
  final uint8_t id;

  /// Function of the battery
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavBatteryFunction]
  ///
  /// battery_function
  final MavBatteryFunction batteryFunction;

  /// Type (chemistry) of the battery
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavBatteryType]
  ///
  /// type
  final MavBatteryType type;

  /// Remaining battery energy. Values: [0-100], -1: autopilot does not estimate the remaining battery.
  ///
  /// MAVLink type: int8_t
  ///
  /// units: %
  ///
  /// battery_remaining
  final int8_t batteryRemaining;

  /// Remaining battery time, 0: autopilot does not provide remaining battery time estimate
  ///
  /// MAVLink type: int32_t
  ///
  /// units: s
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// time_remaining
  final int32_t timeRemaining;

  /// State for extent of discharge, provided by autopilot for warning or external reactions
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavBatteryChargeState]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// charge_state
  final MavBatteryChargeState chargeState;

  /// Battery voltages for cells 11 to 14. Cells above the valid cell count for this battery should have a value of 0, where zero indicates not supported (note, this is different than for the voltages field and allows empty byte truncation). If the measured value is 0 then 1 should be sent instead.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: mV
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// voltages_ext
  final List<int16_t> voltagesExt;

  /// Battery mode. Default (0) is that battery mode reporting is not supported or battery is in normal-use mode.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavBatteryMode]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mode
  final MavBatteryMode mode;

  /// Fault/health indications. These should be set when charge_state is MAV_BATTERY_CHARGE_STATE_FAILED or MAV_BATTERY_CHARGE_STATE_UNHEALTHY (if not, fault reporting is not supported).
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavBatteryFault]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// fault_bitmask
  final MavBatteryFault faultBitmask;

  BatteryStatus({
    required this.currentConsumed,
    required this.energyConsumed,
    required this.temperature,
    required this.voltages,
    required this.currentBattery,
    required this.id,
    required this.batteryFunction,
    required this.type,
    required this.batteryRemaining,
    required this.timeRemaining,
    required this.chargeState,
    required this.voltagesExt,
    required this.mode,
    required this.faultBitmask,
  });

  BatteryStatus copyWith({
    int32_t? currentConsumed,
    int32_t? energyConsumed,
    int16_t? temperature,
    List<int16_t>? voltages,
    int16_t? currentBattery,
    uint8_t? id,
    MavBatteryFunction? batteryFunction,
    MavBatteryType? type,
    int8_t? batteryRemaining,
    int32_t? timeRemaining,
    MavBatteryChargeState? chargeState,
    List<int16_t>? voltagesExt,
    MavBatteryMode? mode,
    MavBatteryFault? faultBitmask,
  }) {
    return BatteryStatus(
      currentConsumed: currentConsumed ?? this.currentConsumed,
      energyConsumed: energyConsumed ?? this.energyConsumed,
      temperature: temperature ?? this.temperature,
      voltages: voltages ?? this.voltages,
      currentBattery: currentBattery ?? this.currentBattery,
      id: id ?? this.id,
      batteryFunction: batteryFunction ?? this.batteryFunction,
      type: type ?? this.type,
      batteryRemaining: batteryRemaining ?? this.batteryRemaining,
      timeRemaining: timeRemaining ?? this.timeRemaining,
      chargeState: chargeState ?? this.chargeState,
      voltagesExt: voltagesExt ?? this.voltagesExt,
      mode: mode ?? this.mode,
      faultBitmask: faultBitmask ?? this.faultBitmask,
    );
  }

  factory BatteryStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < BatteryStatus.mavlinkEncodedLength) {
      var len = BatteryStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var currentConsumed = data_.getInt32(0, Endian.little);
    var energyConsumed = data_.getInt32(4, Endian.little);
    var temperature = data_.getInt16(8, Endian.little);
    var voltages = MavlinkMessage.asUint16List(data_, 10, 10);
    var currentBattery = data_.getInt16(30, Endian.little);
    var id = data_.getUint8(32);
    var batteryFunction = data_.getUint8(33);
    var type = data_.getUint8(34);
    var batteryRemaining = data_.getInt8(35);
    var timeRemaining = data_.getInt32(36, Endian.little);
    var chargeState = data_.getUint8(40);
    var voltagesExt = MavlinkMessage.asUint16List(data_, 41, 4);
    var mode = data_.getUint8(49);
    var faultBitmask = data_.getUint32(50, Endian.little);

    return BatteryStatus(
        currentConsumed: currentConsumed,
        energyConsumed: energyConsumed,
        temperature: temperature,
        voltages: voltages,
        currentBattery: currentBattery,
        id: id,
        batteryFunction: batteryFunction,
        type: type,
        batteryRemaining: batteryRemaining,
        timeRemaining: timeRemaining,
        chargeState: chargeState,
        voltagesExt: voltagesExt,
        mode: mode,
        faultBitmask: faultBitmask);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, currentConsumed, Endian.little);
    data_.setInt32(4, energyConsumed, Endian.little);
    data_.setInt16(8, temperature, Endian.little);
    MavlinkMessage.setUint16List(data_, 10, voltages);
    data_.setInt16(30, currentBattery, Endian.little);
    data_.setUint8(32, id);
    data_.setUint8(33, batteryFunction);
    data_.setUint8(34, type);
    data_.setInt8(35, batteryRemaining);
    data_.setInt32(36, timeRemaining, Endian.little);
    data_.setUint8(40, chargeState);
    MavlinkMessage.setUint16List(data_, 41, voltagesExt);
    data_.setUint8(49, mode);
    data_.setUint32(50, faultBitmask, Endian.little);
    return data_;
  }
}

/// Version and capability of autopilot software. This should be emitted in response to a request with MAV_CMD_REQUEST_MESSAGE.
///
/// AUTOPILOT_VERSION
class AutopilotVersion implements MavlinkMessage {
  static const int _mavlinkMessageId = 148;

  static const int _mavlinkCrcExtra = 178;

  static const int mavlinkEncodedLength = 78;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Bitmap of capabilities
  ///
  /// MAVLink type: uint64_t
  ///
  /// enum: [MavProtocolCapability]
  ///
  /// capabilities
  final MavProtocolCapability capabilities;

  /// UID if provided by hardware (see uid2)
  ///
  /// MAVLink type: uint64_t
  ///
  /// uid
  final uint64_t uid;

  /// Firmware version number
  ///
  /// MAVLink type: uint32_t
  ///
  /// flight_sw_version
  final uint32_t flightSwVersion;

  /// Middleware version number
  ///
  /// MAVLink type: uint32_t
  ///
  /// middleware_sw_version
  final uint32_t middlewareSwVersion;

  /// Operating system version number
  ///
  /// MAVLink type: uint32_t
  ///
  /// os_sw_version
  final uint32_t osSwVersion;

  /// HW / board version (last 8 bits should be silicon ID, if any). The first 16 bits of this field specify https://github.com/PX4/PX4-Bootloader/blob/master/board_types.txt
  ///
  /// MAVLink type: uint32_t
  ///
  /// board_version
  final uint32_t boardVersion;

  /// ID of the board vendor
  ///
  /// MAVLink type: uint16_t
  ///
  /// vendor_id
  final uint16_t vendorId;

  /// ID of the product
  ///
  /// MAVLink type: uint16_t
  ///
  /// product_id
  final uint16_t productId;

  /// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
  ///
  /// MAVLink type: uint8_t[8]
  ///
  /// flight_custom_version
  final List<int8_t> flightCustomVersion;

  /// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
  ///
  /// MAVLink type: uint8_t[8]
  ///
  /// middleware_custom_version
  final List<int8_t> middlewareCustomVersion;

  /// Custom version field, commonly the first 8 bytes of the git hash. This is not an unique identifier, but should allow to identify the commit using the main version number even for very large code bases.
  ///
  /// MAVLink type: uint8_t[8]
  ///
  /// os_custom_version
  final List<int8_t> osCustomVersion;

  /// UID if provided by hardware (supersedes the uid field. If this is non-zero, use this field, otherwise use uid)
  ///
  /// MAVLink type: uint8_t[18]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// uid2
  final List<int8_t> uid2;

  AutopilotVersion({
    required this.capabilities,
    required this.uid,
    required this.flightSwVersion,
    required this.middlewareSwVersion,
    required this.osSwVersion,
    required this.boardVersion,
    required this.vendorId,
    required this.productId,
    required this.flightCustomVersion,
    required this.middlewareCustomVersion,
    required this.osCustomVersion,
    required this.uid2,
  });

  AutopilotVersion copyWith({
    MavProtocolCapability? capabilities,
    uint64_t? uid,
    uint32_t? flightSwVersion,
    uint32_t? middlewareSwVersion,
    uint32_t? osSwVersion,
    uint32_t? boardVersion,
    uint16_t? vendorId,
    uint16_t? productId,
    List<int8_t>? flightCustomVersion,
    List<int8_t>? middlewareCustomVersion,
    List<int8_t>? osCustomVersion,
    List<int8_t>? uid2,
  }) {
    return AutopilotVersion(
      capabilities: capabilities ?? this.capabilities,
      uid: uid ?? this.uid,
      flightSwVersion: flightSwVersion ?? this.flightSwVersion,
      middlewareSwVersion: middlewareSwVersion ?? this.middlewareSwVersion,
      osSwVersion: osSwVersion ?? this.osSwVersion,
      boardVersion: boardVersion ?? this.boardVersion,
      vendorId: vendorId ?? this.vendorId,
      productId: productId ?? this.productId,
      flightCustomVersion: flightCustomVersion ?? this.flightCustomVersion,
      middlewareCustomVersion:
          middlewareCustomVersion ?? this.middlewareCustomVersion,
      osCustomVersion: osCustomVersion ?? this.osCustomVersion,
      uid2: uid2 ?? this.uid2,
    );
  }

  factory AutopilotVersion.parse(ByteData data_) {
    if (data_.lengthInBytes < AutopilotVersion.mavlinkEncodedLength) {
      var len = AutopilotVersion.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var capabilities = data_.getUint64(0, Endian.little);
    var uid = data_.getUint64(8, Endian.little);
    var flightSwVersion = data_.getUint32(16, Endian.little);
    var middlewareSwVersion = data_.getUint32(20, Endian.little);
    var osSwVersion = data_.getUint32(24, Endian.little);
    var boardVersion = data_.getUint32(28, Endian.little);
    var vendorId = data_.getUint16(32, Endian.little);
    var productId = data_.getUint16(34, Endian.little);
    var flightCustomVersion = MavlinkMessage.asUint8List(data_, 36, 8);
    var middlewareCustomVersion = MavlinkMessage.asUint8List(data_, 44, 8);
    var osCustomVersion = MavlinkMessage.asUint8List(data_, 52, 8);
    var uid2 = MavlinkMessage.asUint8List(data_, 60, 18);

    return AutopilotVersion(
        capabilities: capabilities,
        uid: uid,
        flightSwVersion: flightSwVersion,
        middlewareSwVersion: middlewareSwVersion,
        osSwVersion: osSwVersion,
        boardVersion: boardVersion,
        vendorId: vendorId,
        productId: productId,
        flightCustomVersion: flightCustomVersion,
        middlewareCustomVersion: middlewareCustomVersion,
        osCustomVersion: osCustomVersion,
        uid2: uid2);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, capabilities, Endian.little);
    data_.setUint64(8, uid, Endian.little);
    data_.setUint32(16, flightSwVersion, Endian.little);
    data_.setUint32(20, middlewareSwVersion, Endian.little);
    data_.setUint32(24, osSwVersion, Endian.little);
    data_.setUint32(28, boardVersion, Endian.little);
    data_.setUint16(32, vendorId, Endian.little);
    data_.setUint16(34, productId, Endian.little);
    MavlinkMessage.setUint8List(data_, 36, flightCustomVersion);
    MavlinkMessage.setUint8List(data_, 44, middlewareCustomVersion);
    MavlinkMessage.setUint8List(data_, 52, osCustomVersion);
    MavlinkMessage.setUint8List(data_, 60, uid2);
    return data_;
  }
}

/// The location of a landing target. See: https://mavlink.io/en/services/landing_target.html
///
/// LANDING_TARGET
class LandingTarget implements MavlinkMessage {
  static const int _mavlinkMessageId = 149;

  static const int _mavlinkCrcExtra = 200;

  static const int mavlinkEncodedLength = 60;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// X-axis angular offset of the target from the center of the image
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// angle_x
  final float angleX;

  /// Y-axis angular offset of the target from the center of the image
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// angle_y
  final float angleY;

  /// Distance to the target from the vehicle
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// distance
  final float distance;

  /// Size of target along x-axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// size_x
  final float sizeX;

  /// Size of target along y-axis
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// size_y
  final float sizeY;

  /// The ID of the target if multiple targets are present
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_num
  final uint8_t targetNum;

  /// Coordinate frame used for following fields.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// frame
  final MavFrame frame;

  /// X Position of the landing target in MAV_FRAME
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// x
  final float x;

  /// Y Position of the landing target in MAV_FRAME
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// y
  final float y;

  /// Z Position of the landing target in MAV_FRAME
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// z
  final float z;

  /// Quaternion of landing target orientation (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
  ///
  /// MAVLink type: float[4]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// q
  final List<float> q;

  /// Type of landing target
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [LandingTargetType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// type
  final LandingTargetType type;

  /// Boolean indicating whether the position fields (x, y, z, q, type) contain valid target position information (valid: 1, invalid: 0). Default is 0 (invalid).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// position_valid
  final uint8_t positionValid;

  LandingTarget({
    required this.timeUsec,
    required this.angleX,
    required this.angleY,
    required this.distance,
    required this.sizeX,
    required this.sizeY,
    required this.targetNum,
    required this.frame,
    required this.x,
    required this.y,
    required this.z,
    required this.q,
    required this.type,
    required this.positionValid,
  });

  LandingTarget copyWith({
    uint64_t? timeUsec,
    float? angleX,
    float? angleY,
    float? distance,
    float? sizeX,
    float? sizeY,
    uint8_t? targetNum,
    MavFrame? frame,
    float? x,
    float? y,
    float? z,
    List<float>? q,
    LandingTargetType? type,
    uint8_t? positionValid,
  }) {
    return LandingTarget(
      timeUsec: timeUsec ?? this.timeUsec,
      angleX: angleX ?? this.angleX,
      angleY: angleY ?? this.angleY,
      distance: distance ?? this.distance,
      sizeX: sizeX ?? this.sizeX,
      sizeY: sizeY ?? this.sizeY,
      targetNum: targetNum ?? this.targetNum,
      frame: frame ?? this.frame,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      q: q ?? this.q,
      type: type ?? this.type,
      positionValid: positionValid ?? this.positionValid,
    );
  }

  factory LandingTarget.parse(ByteData data_) {
    if (data_.lengthInBytes < LandingTarget.mavlinkEncodedLength) {
      var len = LandingTarget.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var angleX = data_.getFloat32(8, Endian.little);
    var angleY = data_.getFloat32(12, Endian.little);
    var distance = data_.getFloat32(16, Endian.little);
    var sizeX = data_.getFloat32(20, Endian.little);
    var sizeY = data_.getFloat32(24, Endian.little);
    var targetNum = data_.getUint8(28);
    var frame = data_.getUint8(29);
    var x = data_.getFloat32(30, Endian.little);
    var y = data_.getFloat32(34, Endian.little);
    var z = data_.getFloat32(38, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 42, 4);
    var type = data_.getUint8(58);
    var positionValid = data_.getUint8(59);

    return LandingTarget(
        timeUsec: timeUsec,
        angleX: angleX,
        angleY: angleY,
        distance: distance,
        sizeX: sizeX,
        sizeY: sizeY,
        targetNum: targetNum,
        frame: frame,
        x: x,
        y: y,
        z: z,
        q: q,
        type: type,
        positionValid: positionValid);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, angleX, Endian.little);
    data_.setFloat32(12, angleY, Endian.little);
    data_.setFloat32(16, distance, Endian.little);
    data_.setFloat32(20, sizeX, Endian.little);
    data_.setFloat32(24, sizeY, Endian.little);
    data_.setUint8(28, targetNum);
    data_.setUint8(29, frame);
    data_.setFloat32(30, x, Endian.little);
    data_.setFloat32(34, y, Endian.little);
    data_.setFloat32(38, z, Endian.little);
    MavlinkMessage.setFloat32List(data_, 42, q);
    data_.setUint8(58, type);
    data_.setUint8(59, positionValid);
    return data_;
  }
}

/// Status of geo-fencing. Sent in extended status stream when fencing enabled.
///
/// FENCE_STATUS
class FenceStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 162;

  static const int _mavlinkCrcExtra = 189;

  static const int mavlinkEncodedLength = 9;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Time (since boot) of last breach.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// breach_time
  final uint32_t breachTime;

  /// Number of fence breaches.
  ///
  /// MAVLink type: uint16_t
  ///
  /// breach_count
  final uint16_t breachCount;

  /// Breach status (0 if currently inside fence, 1 if outside).
  ///
  /// MAVLink type: uint8_t
  ///
  /// breach_status
  final uint8_t breachStatus;

  /// Last breach type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [FenceBreach]
  ///
  /// breach_type
  final FenceBreach breachType;

  /// Active action to prevent fence breach
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [FenceMitigate]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// breach_mitigation
  final FenceMitigate breachMitigation;

  FenceStatus({
    required this.breachTime,
    required this.breachCount,
    required this.breachStatus,
    required this.breachType,
    required this.breachMitigation,
  });

  FenceStatus copyWith({
    uint32_t? breachTime,
    uint16_t? breachCount,
    uint8_t? breachStatus,
    FenceBreach? breachType,
    FenceMitigate? breachMitigation,
  }) {
    return FenceStatus(
      breachTime: breachTime ?? this.breachTime,
      breachCount: breachCount ?? this.breachCount,
      breachStatus: breachStatus ?? this.breachStatus,
      breachType: breachType ?? this.breachType,
      breachMitigation: breachMitigation ?? this.breachMitigation,
    );
  }

  factory FenceStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < FenceStatus.mavlinkEncodedLength) {
      var len = FenceStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var breachTime = data_.getUint32(0, Endian.little);
    var breachCount = data_.getUint16(4, Endian.little);
    var breachStatus = data_.getUint8(6);
    var breachType = data_.getUint8(7);
    var breachMitigation = data_.getUint8(8);

    return FenceStatus(
        breachTime: breachTime,
        breachCount: breachCount,
        breachStatus: breachStatus,
        breachType: breachType,
        breachMitigation: breachMitigation);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, breachTime, Endian.little);
    data_.setUint16(4, breachCount, Endian.little);
    data_.setUint8(6, breachStatus);
    data_.setUint8(7, breachType);
    data_.setUint8(8, breachMitigation);
    return data_;
  }
}

/// Reports results of completed compass calibration. Sent until MAG_CAL_ACK received.
///
/// MAG_CAL_REPORT
class MagCalReport implements MavlinkMessage {
  static const int _mavlinkMessageId = 192;

  static const int _mavlinkCrcExtra = 36;

  static const int mavlinkEncodedLength = 54;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// RMS milligauss residuals.
  ///
  /// MAVLink type: float
  ///
  /// units: mgauss
  ///
  /// fitness
  final float fitness;

  /// X offset.
  ///
  /// MAVLink type: float
  ///
  /// ofs_x
  final float ofsX;

  /// Y offset.
  ///
  /// MAVLink type: float
  ///
  /// ofs_y
  final float ofsY;

  /// Z offset.
  ///
  /// MAVLink type: float
  ///
  /// ofs_z
  final float ofsZ;

  /// X diagonal (matrix 11).
  ///
  /// MAVLink type: float
  ///
  /// diag_x
  final float diagX;

  /// Y diagonal (matrix 22).
  ///
  /// MAVLink type: float
  ///
  /// diag_y
  final float diagY;

  /// Z diagonal (matrix 33).
  ///
  /// MAVLink type: float
  ///
  /// diag_z
  final float diagZ;

  /// X off-diagonal (matrix 12 and 21).
  ///
  /// MAVLink type: float
  ///
  /// offdiag_x
  final float offdiagX;

  /// Y off-diagonal (matrix 13 and 31).
  ///
  /// MAVLink type: float
  ///
  /// offdiag_y
  final float offdiagY;

  /// Z off-diagonal (matrix 32 and 23).
  ///
  /// MAVLink type: float
  ///
  /// offdiag_z
  final float offdiagZ;

  /// Compass being calibrated.
  ///
  /// MAVLink type: uint8_t
  ///
  /// compass_id
  final uint8_t compassId;

  /// Bitmask of compasses being calibrated.
  ///
  /// MAVLink type: uint8_t
  ///
  /// cal_mask
  final uint8_t calMask;

  /// Calibration Status.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MagCalStatus]
  ///
  /// cal_status
  final MagCalStatus calStatus;

  /// 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters.
  ///
  /// MAVLink type: uint8_t
  ///
  /// autosaved
  final uint8_t autosaved;

  /// Confidence in orientation (higher is better).
  ///
  /// MAVLink type: float
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// orientation_confidence
  final float orientationConfidence;

  /// orientation before calibration.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavSensorOrientation]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// old_orientation
  final MavSensorOrientation oldOrientation;

  /// orientation after calibration.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavSensorOrientation]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// new_orientation
  final MavSensorOrientation newOrientation;

  /// field radius correction factor
  ///
  /// MAVLink type: float
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// scale_factor
  final float scaleFactor;

  MagCalReport({
    required this.fitness,
    required this.ofsX,
    required this.ofsY,
    required this.ofsZ,
    required this.diagX,
    required this.diagY,
    required this.diagZ,
    required this.offdiagX,
    required this.offdiagY,
    required this.offdiagZ,
    required this.compassId,
    required this.calMask,
    required this.calStatus,
    required this.autosaved,
    required this.orientationConfidence,
    required this.oldOrientation,
    required this.newOrientation,
    required this.scaleFactor,
  });

  MagCalReport copyWith({
    float? fitness,
    float? ofsX,
    float? ofsY,
    float? ofsZ,
    float? diagX,
    float? diagY,
    float? diagZ,
    float? offdiagX,
    float? offdiagY,
    float? offdiagZ,
    uint8_t? compassId,
    uint8_t? calMask,
    MagCalStatus? calStatus,
    uint8_t? autosaved,
    float? orientationConfidence,
    MavSensorOrientation? oldOrientation,
    MavSensorOrientation? newOrientation,
    float? scaleFactor,
  }) {
    return MagCalReport(
      fitness: fitness ?? this.fitness,
      ofsX: ofsX ?? this.ofsX,
      ofsY: ofsY ?? this.ofsY,
      ofsZ: ofsZ ?? this.ofsZ,
      diagX: diagX ?? this.diagX,
      diagY: diagY ?? this.diagY,
      diagZ: diagZ ?? this.diagZ,
      offdiagX: offdiagX ?? this.offdiagX,
      offdiagY: offdiagY ?? this.offdiagY,
      offdiagZ: offdiagZ ?? this.offdiagZ,
      compassId: compassId ?? this.compassId,
      calMask: calMask ?? this.calMask,
      calStatus: calStatus ?? this.calStatus,
      autosaved: autosaved ?? this.autosaved,
      orientationConfidence:
          orientationConfidence ?? this.orientationConfidence,
      oldOrientation: oldOrientation ?? this.oldOrientation,
      newOrientation: newOrientation ?? this.newOrientation,
      scaleFactor: scaleFactor ?? this.scaleFactor,
    );
  }

  factory MagCalReport.parse(ByteData data_) {
    if (data_.lengthInBytes < MagCalReport.mavlinkEncodedLength) {
      var len = MagCalReport.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var fitness = data_.getFloat32(0, Endian.little);
    var ofsX = data_.getFloat32(4, Endian.little);
    var ofsY = data_.getFloat32(8, Endian.little);
    var ofsZ = data_.getFloat32(12, Endian.little);
    var diagX = data_.getFloat32(16, Endian.little);
    var diagY = data_.getFloat32(20, Endian.little);
    var diagZ = data_.getFloat32(24, Endian.little);
    var offdiagX = data_.getFloat32(28, Endian.little);
    var offdiagY = data_.getFloat32(32, Endian.little);
    var offdiagZ = data_.getFloat32(36, Endian.little);
    var compassId = data_.getUint8(40);
    var calMask = data_.getUint8(41);
    var calStatus = data_.getUint8(42);
    var autosaved = data_.getUint8(43);
    var orientationConfidence = data_.getFloat32(44, Endian.little);
    var oldOrientation = data_.getUint8(48);
    var newOrientation = data_.getUint8(49);
    var scaleFactor = data_.getFloat32(50, Endian.little);

    return MagCalReport(
        fitness: fitness,
        ofsX: ofsX,
        ofsY: ofsY,
        ofsZ: ofsZ,
        diagX: diagX,
        diagY: diagY,
        diagZ: diagZ,
        offdiagX: offdiagX,
        offdiagY: offdiagY,
        offdiagZ: offdiagZ,
        compassId: compassId,
        calMask: calMask,
        calStatus: calStatus,
        autosaved: autosaved,
        orientationConfidence: orientationConfidence,
        oldOrientation: oldOrientation,
        newOrientation: newOrientation,
        scaleFactor: scaleFactor);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, fitness, Endian.little);
    data_.setFloat32(4, ofsX, Endian.little);
    data_.setFloat32(8, ofsY, Endian.little);
    data_.setFloat32(12, ofsZ, Endian.little);
    data_.setFloat32(16, diagX, Endian.little);
    data_.setFloat32(20, diagY, Endian.little);
    data_.setFloat32(24, diagZ, Endian.little);
    data_.setFloat32(28, offdiagX, Endian.little);
    data_.setFloat32(32, offdiagY, Endian.little);
    data_.setFloat32(36, offdiagZ, Endian.little);
    data_.setUint8(40, compassId);
    data_.setUint8(41, calMask);
    data_.setUint8(42, calStatus);
    data_.setUint8(43, autosaved);
    data_.setFloat32(44, orientationConfidence, Endian.little);
    data_.setUint8(48, oldOrientation);
    data_.setUint8(49, newOrientation);
    data_.setFloat32(50, scaleFactor, Endian.little);
    return data_;
  }
}

/// EFI status output
///
/// EFI_STATUS
class EfiStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 225;

  static const int _mavlinkCrcExtra = 208;

  static const int mavlinkEncodedLength = 73;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// ECU index
  ///
  /// MAVLink type: float
  ///
  /// ecu_index
  final float ecuIndex;

  /// RPM
  ///
  /// MAVLink type: float
  ///
  /// rpm
  final float rpm;

  /// Fuel consumed
  ///
  /// MAVLink type: float
  ///
  /// units: cm^3
  ///
  /// fuel_consumed
  final float fuelConsumed;

  /// Fuel flow rate
  ///
  /// MAVLink type: float
  ///
  /// units: cm^3/min
  ///
  /// fuel_flow
  final float fuelFlow;

  /// Engine load
  ///
  /// MAVLink type: float
  ///
  /// units: %
  ///
  /// engine_load
  final float engineLoad;

  /// Throttle position
  ///
  /// MAVLink type: float
  ///
  /// units: %
  ///
  /// throttle_position
  final float throttlePosition;

  /// Spark dwell time
  ///
  /// MAVLink type: float
  ///
  /// units: ms
  ///
  /// spark_dwell_time
  final float sparkDwellTime;

  /// Barometric pressure
  ///
  /// MAVLink type: float
  ///
  /// units: kPa
  ///
  /// barometric_pressure
  final float barometricPressure;

  /// Intake manifold pressure(
  ///
  /// MAVLink type: float
  ///
  /// units: kPa
  ///
  /// intake_manifold_pressure
  final float intakeManifoldPressure;

  /// Intake manifold temperature
  ///
  /// MAVLink type: float
  ///
  /// units: degC
  ///
  /// intake_manifold_temperature
  final float intakeManifoldTemperature;

  /// Cylinder head temperature
  ///
  /// MAVLink type: float
  ///
  /// units: degC
  ///
  /// cylinder_head_temperature
  final float cylinderHeadTemperature;

  /// Ignition timing (Crank angle degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// ignition_timing
  final float ignitionTiming;

  /// Injection time
  ///
  /// MAVLink type: float
  ///
  /// units: ms
  ///
  /// injection_time
  final float injectionTime;

  /// Exhaust gas temperature
  ///
  /// MAVLink type: float
  ///
  /// units: degC
  ///
  /// exhaust_gas_temperature
  final float exhaustGasTemperature;

  /// Output throttle
  ///
  /// MAVLink type: float
  ///
  /// units: %
  ///
  /// throttle_out
  final float throttleOut;

  /// Pressure/temperature compensation
  ///
  /// MAVLink type: float
  ///
  /// pt_compensation
  final float ptCompensation;

  /// EFI health status
  ///
  /// MAVLink type: uint8_t
  ///
  /// health
  final uint8_t health;

  /// Supply voltage to EFI sparking system.  Zero in this value means "unknown", so if the supply voltage really is zero volts use 0.0001 instead.
  ///
  /// MAVLink type: float
  ///
  /// units: V
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// ignition_voltage
  final float ignitionVoltage;

  /// Fuel pressure. Zero in this value means "unknown", so if the fuel pressure really is zero kPa use 0.0001 instead.
  ///
  /// MAVLink type: float
  ///
  /// units: kPa
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// fuel_pressure
  final float fuelPressure;

  EfiStatus({
    required this.ecuIndex,
    required this.rpm,
    required this.fuelConsumed,
    required this.fuelFlow,
    required this.engineLoad,
    required this.throttlePosition,
    required this.sparkDwellTime,
    required this.barometricPressure,
    required this.intakeManifoldPressure,
    required this.intakeManifoldTemperature,
    required this.cylinderHeadTemperature,
    required this.ignitionTiming,
    required this.injectionTime,
    required this.exhaustGasTemperature,
    required this.throttleOut,
    required this.ptCompensation,
    required this.health,
    required this.ignitionVoltage,
    required this.fuelPressure,
  });

  EfiStatus copyWith({
    float? ecuIndex,
    float? rpm,
    float? fuelConsumed,
    float? fuelFlow,
    float? engineLoad,
    float? throttlePosition,
    float? sparkDwellTime,
    float? barometricPressure,
    float? intakeManifoldPressure,
    float? intakeManifoldTemperature,
    float? cylinderHeadTemperature,
    float? ignitionTiming,
    float? injectionTime,
    float? exhaustGasTemperature,
    float? throttleOut,
    float? ptCompensation,
    uint8_t? health,
    float? ignitionVoltage,
    float? fuelPressure,
  }) {
    return EfiStatus(
      ecuIndex: ecuIndex ?? this.ecuIndex,
      rpm: rpm ?? this.rpm,
      fuelConsumed: fuelConsumed ?? this.fuelConsumed,
      fuelFlow: fuelFlow ?? this.fuelFlow,
      engineLoad: engineLoad ?? this.engineLoad,
      throttlePosition: throttlePosition ?? this.throttlePosition,
      sparkDwellTime: sparkDwellTime ?? this.sparkDwellTime,
      barometricPressure: barometricPressure ?? this.barometricPressure,
      intakeManifoldPressure:
          intakeManifoldPressure ?? this.intakeManifoldPressure,
      intakeManifoldTemperature:
          intakeManifoldTemperature ?? this.intakeManifoldTemperature,
      cylinderHeadTemperature:
          cylinderHeadTemperature ?? this.cylinderHeadTemperature,
      ignitionTiming: ignitionTiming ?? this.ignitionTiming,
      injectionTime: injectionTime ?? this.injectionTime,
      exhaustGasTemperature:
          exhaustGasTemperature ?? this.exhaustGasTemperature,
      throttleOut: throttleOut ?? this.throttleOut,
      ptCompensation: ptCompensation ?? this.ptCompensation,
      health: health ?? this.health,
      ignitionVoltage: ignitionVoltage ?? this.ignitionVoltage,
      fuelPressure: fuelPressure ?? this.fuelPressure,
    );
  }

  factory EfiStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < EfiStatus.mavlinkEncodedLength) {
      var len = EfiStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var ecuIndex = data_.getFloat32(0, Endian.little);
    var rpm = data_.getFloat32(4, Endian.little);
    var fuelConsumed = data_.getFloat32(8, Endian.little);
    var fuelFlow = data_.getFloat32(12, Endian.little);
    var engineLoad = data_.getFloat32(16, Endian.little);
    var throttlePosition = data_.getFloat32(20, Endian.little);
    var sparkDwellTime = data_.getFloat32(24, Endian.little);
    var barometricPressure = data_.getFloat32(28, Endian.little);
    var intakeManifoldPressure = data_.getFloat32(32, Endian.little);
    var intakeManifoldTemperature = data_.getFloat32(36, Endian.little);
    var cylinderHeadTemperature = data_.getFloat32(40, Endian.little);
    var ignitionTiming = data_.getFloat32(44, Endian.little);
    var injectionTime = data_.getFloat32(48, Endian.little);
    var exhaustGasTemperature = data_.getFloat32(52, Endian.little);
    var throttleOut = data_.getFloat32(56, Endian.little);
    var ptCompensation = data_.getFloat32(60, Endian.little);
    var health = data_.getUint8(64);
    var ignitionVoltage = data_.getFloat32(65, Endian.little);
    var fuelPressure = data_.getFloat32(69, Endian.little);

    return EfiStatus(
        ecuIndex: ecuIndex,
        rpm: rpm,
        fuelConsumed: fuelConsumed,
        fuelFlow: fuelFlow,
        engineLoad: engineLoad,
        throttlePosition: throttlePosition,
        sparkDwellTime: sparkDwellTime,
        barometricPressure: barometricPressure,
        intakeManifoldPressure: intakeManifoldPressure,
        intakeManifoldTemperature: intakeManifoldTemperature,
        cylinderHeadTemperature: cylinderHeadTemperature,
        ignitionTiming: ignitionTiming,
        injectionTime: injectionTime,
        exhaustGasTemperature: exhaustGasTemperature,
        throttleOut: throttleOut,
        ptCompensation: ptCompensation,
        health: health,
        ignitionVoltage: ignitionVoltage,
        fuelPressure: fuelPressure);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, ecuIndex, Endian.little);
    data_.setFloat32(4, rpm, Endian.little);
    data_.setFloat32(8, fuelConsumed, Endian.little);
    data_.setFloat32(12, fuelFlow, Endian.little);
    data_.setFloat32(16, engineLoad, Endian.little);
    data_.setFloat32(20, throttlePosition, Endian.little);
    data_.setFloat32(24, sparkDwellTime, Endian.little);
    data_.setFloat32(28, barometricPressure, Endian.little);
    data_.setFloat32(32, intakeManifoldPressure, Endian.little);
    data_.setFloat32(36, intakeManifoldTemperature, Endian.little);
    data_.setFloat32(40, cylinderHeadTemperature, Endian.little);
    data_.setFloat32(44, ignitionTiming, Endian.little);
    data_.setFloat32(48, injectionTime, Endian.little);
    data_.setFloat32(52, exhaustGasTemperature, Endian.little);
    data_.setFloat32(56, throttleOut, Endian.little);
    data_.setFloat32(60, ptCompensation, Endian.little);
    data_.setUint8(64, health);
    data_.setFloat32(65, ignitionVoltage, Endian.little);
    data_.setFloat32(69, fuelPressure, Endian.little);
    return data_;
  }
}

/// Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS enum definition for further information. The innovation test ratios show the magnitude of the sensor innovation divided by the innovation check threshold. Under normal operation the innovation test ratios should be below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should be optional and controllable by the user.
///
/// ESTIMATOR_STATUS
class EstimatorStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 230;

  static const int _mavlinkCrcExtra = 163;

  static const int mavlinkEncodedLength = 42;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Velocity innovation test ratio
  ///
  /// MAVLink type: float
  ///
  /// vel_ratio
  final float velRatio;

  /// Horizontal position innovation test ratio
  ///
  /// MAVLink type: float
  ///
  /// pos_horiz_ratio
  final float posHorizRatio;

  /// Vertical position innovation test ratio
  ///
  /// MAVLink type: float
  ///
  /// pos_vert_ratio
  final float posVertRatio;

  /// Magnetometer innovation test ratio
  ///
  /// MAVLink type: float
  ///
  /// mag_ratio
  final float magRatio;

  /// Height above terrain innovation test ratio
  ///
  /// MAVLink type: float
  ///
  /// hagl_ratio
  final float haglRatio;

  /// True airspeed innovation test ratio
  ///
  /// MAVLink type: float
  ///
  /// tas_ratio
  final float tasRatio;

  /// Horizontal position 1-STD accuracy relative to the EKF local origin
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// pos_horiz_accuracy
  final float posHorizAccuracy;

  /// Vertical position 1-STD accuracy relative to the EKF local origin
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// pos_vert_accuracy
  final float posVertAccuracy;

  /// Bitmap indicating which EKF outputs are valid.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [EstimatorStatusFlags]
  ///
  /// flags
  final EstimatorStatusFlags flags;

  EstimatorStatus({
    required this.timeUsec,
    required this.velRatio,
    required this.posHorizRatio,
    required this.posVertRatio,
    required this.magRatio,
    required this.haglRatio,
    required this.tasRatio,
    required this.posHorizAccuracy,
    required this.posVertAccuracy,
    required this.flags,
  });

  EstimatorStatus copyWith({
    uint64_t? timeUsec,
    float? velRatio,
    float? posHorizRatio,
    float? posVertRatio,
    float? magRatio,
    float? haglRatio,
    float? tasRatio,
    float? posHorizAccuracy,
    float? posVertAccuracy,
    EstimatorStatusFlags? flags,
  }) {
    return EstimatorStatus(
      timeUsec: timeUsec ?? this.timeUsec,
      velRatio: velRatio ?? this.velRatio,
      posHorizRatio: posHorizRatio ?? this.posHorizRatio,
      posVertRatio: posVertRatio ?? this.posVertRatio,
      magRatio: magRatio ?? this.magRatio,
      haglRatio: haglRatio ?? this.haglRatio,
      tasRatio: tasRatio ?? this.tasRatio,
      posHorizAccuracy: posHorizAccuracy ?? this.posHorizAccuracy,
      posVertAccuracy: posVertAccuracy ?? this.posVertAccuracy,
      flags: flags ?? this.flags,
    );
  }

  factory EstimatorStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < EstimatorStatus.mavlinkEncodedLength) {
      var len = EstimatorStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var velRatio = data_.getFloat32(8, Endian.little);
    var posHorizRatio = data_.getFloat32(12, Endian.little);
    var posVertRatio = data_.getFloat32(16, Endian.little);
    var magRatio = data_.getFloat32(20, Endian.little);
    var haglRatio = data_.getFloat32(24, Endian.little);
    var tasRatio = data_.getFloat32(28, Endian.little);
    var posHorizAccuracy = data_.getFloat32(32, Endian.little);
    var posVertAccuracy = data_.getFloat32(36, Endian.little);
    var flags = data_.getUint16(40, Endian.little);

    return EstimatorStatus(
        timeUsec: timeUsec,
        velRatio: velRatio,
        posHorizRatio: posHorizRatio,
        posVertRatio: posVertRatio,
        magRatio: magRatio,
        haglRatio: haglRatio,
        tasRatio: tasRatio,
        posHorizAccuracy: posHorizAccuracy,
        posVertAccuracy: posVertAccuracy,
        flags: flags);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, velRatio, Endian.little);
    data_.setFloat32(12, posHorizRatio, Endian.little);
    data_.setFloat32(16, posVertRatio, Endian.little);
    data_.setFloat32(20, magRatio, Endian.little);
    data_.setFloat32(24, haglRatio, Endian.little);
    data_.setFloat32(28, tasRatio, Endian.little);
    data_.setFloat32(32, posHorizAccuracy, Endian.little);
    data_.setFloat32(36, posVertAccuracy, Endian.little);
    data_.setUint16(40, flags, Endian.little);
    return data_;
  }
}

/// Wind estimate from vehicle. Note that despite the name, this message does not actually contain any covariances but instead variability and accuracy fields in terms of standard deviation (1-STD).
///
/// WIND_COV
class WindCov implements MavlinkMessage {
  static const int _mavlinkMessageId = 231;

  static const int _mavlinkCrcExtra = 105;

  static const int mavlinkEncodedLength = 40;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Wind in North (NED) direction (NAN if unknown)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// wind_x
  final float windX;

  /// Wind in East (NED) direction (NAN if unknown)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// wind_y
  final float windY;

  /// Wind in down (NED) direction (NAN if unknown)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// wind_z
  final float windZ;

  /// Variability of wind in XY, 1-STD estimated from a 1 Hz lowpassed wind estimate (NAN if unknown)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// var_horiz
  final float varHoriz;

  /// Variability of wind in Z, 1-STD estimated from a 1 Hz lowpassed wind estimate (NAN if unknown)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// var_vert
  final float varVert;

  /// Altitude (MSL) that this measurement was taken at (NAN if unknown)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// wind_alt
  final float windAlt;

  /// Horizontal speed 1-STD accuracy (0 if unknown)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// horiz_accuracy
  final float horizAccuracy;

  /// Vertical speed 1-STD accuracy (0 if unknown)
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vert_accuracy
  final float vertAccuracy;

  WindCov({
    required this.timeUsec,
    required this.windX,
    required this.windY,
    required this.windZ,
    required this.varHoriz,
    required this.varVert,
    required this.windAlt,
    required this.horizAccuracy,
    required this.vertAccuracy,
  });

  WindCov copyWith({
    uint64_t? timeUsec,
    float? windX,
    float? windY,
    float? windZ,
    float? varHoriz,
    float? varVert,
    float? windAlt,
    float? horizAccuracy,
    float? vertAccuracy,
  }) {
    return WindCov(
      timeUsec: timeUsec ?? this.timeUsec,
      windX: windX ?? this.windX,
      windY: windY ?? this.windY,
      windZ: windZ ?? this.windZ,
      varHoriz: varHoriz ?? this.varHoriz,
      varVert: varVert ?? this.varVert,
      windAlt: windAlt ?? this.windAlt,
      horizAccuracy: horizAccuracy ?? this.horizAccuracy,
      vertAccuracy: vertAccuracy ?? this.vertAccuracy,
    );
  }

  factory WindCov.parse(ByteData data_) {
    if (data_.lengthInBytes < WindCov.mavlinkEncodedLength) {
      var len = WindCov.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var windX = data_.getFloat32(8, Endian.little);
    var windY = data_.getFloat32(12, Endian.little);
    var windZ = data_.getFloat32(16, Endian.little);
    var varHoriz = data_.getFloat32(20, Endian.little);
    var varVert = data_.getFloat32(24, Endian.little);
    var windAlt = data_.getFloat32(28, Endian.little);
    var horizAccuracy = data_.getFloat32(32, Endian.little);
    var vertAccuracy = data_.getFloat32(36, Endian.little);

    return WindCov(
        timeUsec: timeUsec,
        windX: windX,
        windY: windY,
        windZ: windZ,
        varHoriz: varHoriz,
        varVert: varVert,
        windAlt: windAlt,
        horizAccuracy: horizAccuracy,
        vertAccuracy: vertAccuracy);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, windX, Endian.little);
    data_.setFloat32(12, windY, Endian.little);
    data_.setFloat32(16, windZ, Endian.little);
    data_.setFloat32(20, varHoriz, Endian.little);
    data_.setFloat32(24, varVert, Endian.little);
    data_.setFloat32(28, windAlt, Endian.little);
    data_.setFloat32(32, horizAccuracy, Endian.little);
    data_.setFloat32(36, vertAccuracy, Endian.little);
    return data_;
  }
}

/// GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position estimate of the system.
///
/// GPS_INPUT
class GpsInput implements MavlinkMessage {
  static const int _mavlinkMessageId = 232;

  static const int _mavlinkCrcExtra = 151;

  static const int mavlinkEncodedLength = 65;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// GPS time (from start of GPS week)
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_week_ms
  final uint32_t timeWeekMs;

  /// Latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude (MSL). Positive for up.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt
  final float alt;

  /// GPS HDOP horizontal dilution of position (unitless). If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: float
  ///
  /// hdop
  final float hdop;

  /// GPS VDOP vertical dilution of position (unitless). If unknown, set to: UINT16_MAX
  ///
  /// MAVLink type: float
  ///
  /// vdop
  final float vdop;

  /// GPS velocity in north direction in earth-fixed NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vn
  final float vn;

  /// GPS velocity in east direction in earth-fixed NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// ve
  final float ve;

  /// GPS velocity in down direction in earth-fixed NED frame
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vd
  final float vd;

  /// GPS speed accuracy
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// speed_accuracy
  final float speedAccuracy;

  /// GPS horizontal accuracy
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// horiz_accuracy
  final float horizAccuracy;

  /// GPS vertical accuracy
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// vert_accuracy
  final float vertAccuracy;

  /// Bitmap indicating which GPS input flags fields to ignore.  All other fields must be provided.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [GpsInputIgnoreFlags]
  ///
  /// ignore_flags
  final GpsInputIgnoreFlags ignoreFlags;

  /// GPS week number
  ///
  /// MAVLink type: uint16_t
  ///
  /// time_week
  final uint16_t timeWeek;

  /// ID of the GPS for multiple GPS inputs
  ///
  /// MAVLink type: uint8_t
  ///
  /// gps_id
  final uint8_t gpsId;

  /// 0-1: no fix, 2: 2D fix, 3: 3D fix. 4: 3D with DGPS. 5: 3D with RTK
  ///
  /// MAVLink type: uint8_t
  ///
  /// fix_type
  final uint8_t fixType;

  /// Number of satellites visible.
  ///
  /// MAVLink type: uint8_t
  ///
  /// satellites_visible
  final uint8_t satellitesVisible;

  /// Yaw of vehicle relative to Earth's North, zero means not available, use 36000 for north
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// yaw
  final uint16_t yaw;

  GpsInput({
    required this.timeUsec,
    required this.timeWeekMs,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.hdop,
    required this.vdop,
    required this.vn,
    required this.ve,
    required this.vd,
    required this.speedAccuracy,
    required this.horizAccuracy,
    required this.vertAccuracy,
    required this.ignoreFlags,
    required this.timeWeek,
    required this.gpsId,
    required this.fixType,
    required this.satellitesVisible,
    required this.yaw,
  });

  GpsInput copyWith({
    uint64_t? timeUsec,
    uint32_t? timeWeekMs,
    int32_t? lat,
    int32_t? lon,
    float? alt,
    float? hdop,
    float? vdop,
    float? vn,
    float? ve,
    float? vd,
    float? speedAccuracy,
    float? horizAccuracy,
    float? vertAccuracy,
    GpsInputIgnoreFlags? ignoreFlags,
    uint16_t? timeWeek,
    uint8_t? gpsId,
    uint8_t? fixType,
    uint8_t? satellitesVisible,
    uint16_t? yaw,
  }) {
    return GpsInput(
      timeUsec: timeUsec ?? this.timeUsec,
      timeWeekMs: timeWeekMs ?? this.timeWeekMs,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      hdop: hdop ?? this.hdop,
      vdop: vdop ?? this.vdop,
      vn: vn ?? this.vn,
      ve: ve ?? this.ve,
      vd: vd ?? this.vd,
      speedAccuracy: speedAccuracy ?? this.speedAccuracy,
      horizAccuracy: horizAccuracy ?? this.horizAccuracy,
      vertAccuracy: vertAccuracy ?? this.vertAccuracy,
      ignoreFlags: ignoreFlags ?? this.ignoreFlags,
      timeWeek: timeWeek ?? this.timeWeek,
      gpsId: gpsId ?? this.gpsId,
      fixType: fixType ?? this.fixType,
      satellitesVisible: satellitesVisible ?? this.satellitesVisible,
      yaw: yaw ?? this.yaw,
    );
  }

  factory GpsInput.parse(ByteData data_) {
    if (data_.lengthInBytes < GpsInput.mavlinkEncodedLength) {
      var len = GpsInput.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var timeWeekMs = data_.getUint32(8, Endian.little);
    var lat = data_.getInt32(12, Endian.little);
    var lon = data_.getInt32(16, Endian.little);
    var alt = data_.getFloat32(20, Endian.little);
    var hdop = data_.getFloat32(24, Endian.little);
    var vdop = data_.getFloat32(28, Endian.little);
    var vn = data_.getFloat32(32, Endian.little);
    var ve = data_.getFloat32(36, Endian.little);
    var vd = data_.getFloat32(40, Endian.little);
    var speedAccuracy = data_.getFloat32(44, Endian.little);
    var horizAccuracy = data_.getFloat32(48, Endian.little);
    var vertAccuracy = data_.getFloat32(52, Endian.little);
    var ignoreFlags = data_.getUint16(56, Endian.little);
    var timeWeek = data_.getUint16(58, Endian.little);
    var gpsId = data_.getUint8(60);
    var fixType = data_.getUint8(61);
    var satellitesVisible = data_.getUint8(62);
    var yaw = data_.getUint16(63, Endian.little);

    return GpsInput(
        timeUsec: timeUsec,
        timeWeekMs: timeWeekMs,
        lat: lat,
        lon: lon,
        alt: alt,
        hdop: hdop,
        vdop: vdop,
        vn: vn,
        ve: ve,
        vd: vd,
        speedAccuracy: speedAccuracy,
        horizAccuracy: horizAccuracy,
        vertAccuracy: vertAccuracy,
        ignoreFlags: ignoreFlags,
        timeWeek: timeWeek,
        gpsId: gpsId,
        fixType: fixType,
        satellitesVisible: satellitesVisible,
        yaw: yaw);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint32(8, timeWeekMs, Endian.little);
    data_.setInt32(12, lat, Endian.little);
    data_.setInt32(16, lon, Endian.little);
    data_.setFloat32(20, alt, Endian.little);
    data_.setFloat32(24, hdop, Endian.little);
    data_.setFloat32(28, vdop, Endian.little);
    data_.setFloat32(32, vn, Endian.little);
    data_.setFloat32(36, ve, Endian.little);
    data_.setFloat32(40, vd, Endian.little);
    data_.setFloat32(44, speedAccuracy, Endian.little);
    data_.setFloat32(48, horizAccuracy, Endian.little);
    data_.setFloat32(52, vertAccuracy, Endian.little);
    data_.setUint16(56, ignoreFlags, Endian.little);
    data_.setUint16(58, timeWeek, Endian.little);
    data_.setUint8(60, gpsId);
    data_.setUint8(61, fixType);
    data_.setUint8(62, satellitesVisible);
    data_.setUint16(63, yaw, Endian.little);
    return data_;
  }
}

/// RTCM message for injecting into the onboard GPS (used for DGPS)
///
/// GPS_RTCM_DATA
class GpsRtcmData implements MavlinkMessage {
  static const int _mavlinkMessageId = 233;

  static const int _mavlinkCrcExtra = 35;

  static const int mavlinkEncodedLength = 182;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// LSB: 1 means message is fragmented, next 2 bits are the fragment ID, the remaining 5 bits are used for the sequence ID. Messages are only to be flushed to the GPS when the entire message has been reconstructed on the autopilot. The fragment ID specifies which order the fragments should be assembled into a buffer, while the sequence ID is used to detect a mismatch between different buffers. The buffer is considered fully reconstructed when either all 4 fragments are present, or all the fragments before the first fragment with a non full payload is received. This management is used to ensure that normal GPS operation doesn't corrupt RTCM data, and to recover from a unreliable transport delivery order.
  ///
  /// MAVLink type: uint8_t
  ///
  /// flags
  final uint8_t flags;

  /// data length
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// len
  final uint8_t len;

  /// RTCM message (may be fragmented)
  ///
  /// MAVLink type: uint8_t[180]
  ///
  /// data
  final List<int8_t> data;

  GpsRtcmData({
    required this.flags,
    required this.len,
    required this.data,
  });

  GpsRtcmData copyWith({
    uint8_t? flags,
    uint8_t? len,
    List<int8_t>? data,
  }) {
    return GpsRtcmData(
      flags: flags ?? this.flags,
      len: len ?? this.len,
      data: data ?? this.data,
    );
  }

  factory GpsRtcmData.parse(ByteData data_) {
    if (data_.lengthInBytes < GpsRtcmData.mavlinkEncodedLength) {
      var len = GpsRtcmData.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var flags = data_.getUint8(0);
    var len = data_.getUint8(1);
    var data = MavlinkMessage.asUint8List(data_, 2, 180);

    return GpsRtcmData(flags: flags, len: len, data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, flags);
    data_.setUint8(1, len);
    MavlinkMessage.setUint8List(data_, 2, data);
    return data_;
  }
}

/// Message appropriate for high latency connections like Iridium
///
/// HIGH_LATENCY
class HighLatency implements MavlinkMessage {
  static const int _mavlinkMessageId = 234;

  static const int _mavlinkCrcExtra = 150;

  static const int mavlinkEncodedLength = 40;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// A bitfield for use for autopilot-specific flags.
  ///
  /// MAVLink type: uint32_t
  ///
  /// custom_mode
  final uint32_t customMode;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// latitude
  final int32_t latitude;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// longitude
  final int32_t longitude;

  /// roll
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdeg
  ///
  /// roll
  final int16_t roll;

  /// pitch
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdeg
  ///
  /// pitch
  final int16_t pitch;

  /// heading
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// heading
  final uint16_t heading;

  /// heading setpoint
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdeg
  ///
  /// heading_sp
  final int16_t headingSp;

  /// Altitude above mean sea level
  ///
  /// MAVLink type: int16_t
  ///
  /// units: m
  ///
  /// altitude_amsl
  final int16_t altitudeAmsl;

  /// Altitude setpoint relative to the home position
  ///
  /// MAVLink type: int16_t
  ///
  /// units: m
  ///
  /// altitude_sp
  final int16_t altitudeSp;

  /// distance to target
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: m
  ///
  /// wp_distance
  final uint16_t wpDistance;

  /// Bitmap of enabled system modes.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavModeFlag]
  ///
  /// base_mode
  final MavModeFlag baseMode;

  /// The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavLandedState]
  ///
  /// landed_state
  final MavLandedState landedState;

  /// throttle (percentage)
  ///
  /// MAVLink type: int8_t
  ///
  /// units: %
  ///
  /// throttle
  final int8_t throttle;

  /// airspeed
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: m/s
  ///
  /// airspeed
  final uint8_t airspeed;

  /// airspeed setpoint
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: m/s
  ///
  /// airspeed_sp
  final uint8_t airspeedSp;

  /// groundspeed
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: m/s
  ///
  /// groundspeed
  final uint8_t groundspeed;

  /// climb rate
  ///
  /// MAVLink type: int8_t
  ///
  /// units: m/s
  ///
  /// climb_rate
  final int8_t climbRate;

  /// Number of satellites visible. If unknown, set to UINT8_MAX
  ///
  /// MAVLink type: uint8_t
  ///
  /// gps_nsat
  final uint8_t gpsNsat;

  /// GPS Fix type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GpsFixType]
  ///
  /// gps_fix_type
  final GpsFixType gpsFixType;

  /// Remaining battery (percentage)
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// battery_remaining
  final uint8_t batteryRemaining;

  /// Autopilot temperature (degrees C)
  ///
  /// MAVLink type: int8_t
  ///
  /// units: degC
  ///
  /// temperature
  final int8_t temperature;

  /// Air temperature (degrees C) from airspeed sensor
  ///
  /// MAVLink type: int8_t
  ///
  /// units: degC
  ///
  /// temperature_air
  final int8_t temperatureAir;

  /// failsafe (each bit represents a failsafe where 0=ok, 1=failsafe active (bit0:RC, bit1:batt, bit2:GPS, bit3:GCS, bit4:fence)
  ///
  /// MAVLink type: uint8_t
  ///
  /// failsafe
  final uint8_t failsafe;

  /// current waypoint number
  ///
  /// MAVLink type: uint8_t
  ///
  /// wp_num
  final uint8_t wpNum;

  HighLatency({
    required this.customMode,
    required this.latitude,
    required this.longitude,
    required this.roll,
    required this.pitch,
    required this.heading,
    required this.headingSp,
    required this.altitudeAmsl,
    required this.altitudeSp,
    required this.wpDistance,
    required this.baseMode,
    required this.landedState,
    required this.throttle,
    required this.airspeed,
    required this.airspeedSp,
    required this.groundspeed,
    required this.climbRate,
    required this.gpsNsat,
    required this.gpsFixType,
    required this.batteryRemaining,
    required this.temperature,
    required this.temperatureAir,
    required this.failsafe,
    required this.wpNum,
  });

  HighLatency copyWith({
    uint32_t? customMode,
    int32_t? latitude,
    int32_t? longitude,
    int16_t? roll,
    int16_t? pitch,
    uint16_t? heading,
    int16_t? headingSp,
    int16_t? altitudeAmsl,
    int16_t? altitudeSp,
    uint16_t? wpDistance,
    MavModeFlag? baseMode,
    MavLandedState? landedState,
    int8_t? throttle,
    uint8_t? airspeed,
    uint8_t? airspeedSp,
    uint8_t? groundspeed,
    int8_t? climbRate,
    uint8_t? gpsNsat,
    GpsFixType? gpsFixType,
    uint8_t? batteryRemaining,
    int8_t? temperature,
    int8_t? temperatureAir,
    uint8_t? failsafe,
    uint8_t? wpNum,
  }) {
    return HighLatency(
      customMode: customMode ?? this.customMode,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      heading: heading ?? this.heading,
      headingSp: headingSp ?? this.headingSp,
      altitudeAmsl: altitudeAmsl ?? this.altitudeAmsl,
      altitudeSp: altitudeSp ?? this.altitudeSp,
      wpDistance: wpDistance ?? this.wpDistance,
      baseMode: baseMode ?? this.baseMode,
      landedState: landedState ?? this.landedState,
      throttle: throttle ?? this.throttle,
      airspeed: airspeed ?? this.airspeed,
      airspeedSp: airspeedSp ?? this.airspeedSp,
      groundspeed: groundspeed ?? this.groundspeed,
      climbRate: climbRate ?? this.climbRate,
      gpsNsat: gpsNsat ?? this.gpsNsat,
      gpsFixType: gpsFixType ?? this.gpsFixType,
      batteryRemaining: batteryRemaining ?? this.batteryRemaining,
      temperature: temperature ?? this.temperature,
      temperatureAir: temperatureAir ?? this.temperatureAir,
      failsafe: failsafe ?? this.failsafe,
      wpNum: wpNum ?? this.wpNum,
    );
  }

  factory HighLatency.parse(ByteData data_) {
    if (data_.lengthInBytes < HighLatency.mavlinkEncodedLength) {
      var len = HighLatency.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var customMode = data_.getUint32(0, Endian.little);
    var latitude = data_.getInt32(4, Endian.little);
    var longitude = data_.getInt32(8, Endian.little);
    var roll = data_.getInt16(12, Endian.little);
    var pitch = data_.getInt16(14, Endian.little);
    var heading = data_.getUint16(16, Endian.little);
    var headingSp = data_.getInt16(18, Endian.little);
    var altitudeAmsl = data_.getInt16(20, Endian.little);
    var altitudeSp = data_.getInt16(22, Endian.little);
    var wpDistance = data_.getUint16(24, Endian.little);
    var baseMode = data_.getUint8(26);
    var landedState = data_.getUint8(27);
    var throttle = data_.getInt8(28);
    var airspeed = data_.getUint8(29);
    var airspeedSp = data_.getUint8(30);
    var groundspeed = data_.getUint8(31);
    var climbRate = data_.getInt8(32);
    var gpsNsat = data_.getUint8(33);
    var gpsFixType = data_.getUint8(34);
    var batteryRemaining = data_.getUint8(35);
    var temperature = data_.getInt8(36);
    var temperatureAir = data_.getInt8(37);
    var failsafe = data_.getUint8(38);
    var wpNum = data_.getUint8(39);

    return HighLatency(
        customMode: customMode,
        latitude: latitude,
        longitude: longitude,
        roll: roll,
        pitch: pitch,
        heading: heading,
        headingSp: headingSp,
        altitudeAmsl: altitudeAmsl,
        altitudeSp: altitudeSp,
        wpDistance: wpDistance,
        baseMode: baseMode,
        landedState: landedState,
        throttle: throttle,
        airspeed: airspeed,
        airspeedSp: airspeedSp,
        groundspeed: groundspeed,
        climbRate: climbRate,
        gpsNsat: gpsNsat,
        gpsFixType: gpsFixType,
        batteryRemaining: batteryRemaining,
        temperature: temperature,
        temperatureAir: temperatureAir,
        failsafe: failsafe,
        wpNum: wpNum);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, customMode, Endian.little);
    data_.setInt32(4, latitude, Endian.little);
    data_.setInt32(8, longitude, Endian.little);
    data_.setInt16(12, roll, Endian.little);
    data_.setInt16(14, pitch, Endian.little);
    data_.setUint16(16, heading, Endian.little);
    data_.setInt16(18, headingSp, Endian.little);
    data_.setInt16(20, altitudeAmsl, Endian.little);
    data_.setInt16(22, altitudeSp, Endian.little);
    data_.setUint16(24, wpDistance, Endian.little);
    data_.setUint8(26, baseMode);
    data_.setUint8(27, landedState);
    data_.setInt8(28, throttle);
    data_.setUint8(29, airspeed);
    data_.setUint8(30, airspeedSp);
    data_.setUint8(31, groundspeed);
    data_.setInt8(32, climbRate);
    data_.setUint8(33, gpsNsat);
    data_.setUint8(34, gpsFixType);
    data_.setUint8(35, batteryRemaining);
    data_.setInt8(36, temperature);
    data_.setInt8(37, temperatureAir);
    data_.setUint8(38, failsafe);
    data_.setUint8(39, wpNum);
    return data_;
  }
}

/// Message appropriate for high latency connections like Iridium (version 2)
///
/// HIGH_LATENCY2
class HighLatency2 implements MavlinkMessage {
  static const int _mavlinkMessageId = 235;

  static const int _mavlinkCrcExtra = 179;

  static const int mavlinkEncodedLength = 42;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (milliseconds since boot or Unix epoch)
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// timestamp
  final uint32_t timestamp;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// latitude
  final int32_t latitude;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// longitude
  final int32_t longitude;

  /// A bitfield for use for autopilot-specific flags (2 byte version).
  ///
  /// MAVLink type: uint16_t
  ///
  /// custom_mode
  final uint16_t customMode;

  /// Altitude above mean sea level
  ///
  /// MAVLink type: int16_t
  ///
  /// units: m
  ///
  /// altitude
  final int16_t altitude;

  /// Altitude setpoint
  ///
  /// MAVLink type: int16_t
  ///
  /// units: m
  ///
  /// target_altitude
  final int16_t targetAltitude;

  /// Distance to target waypoint or position
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: dam
  ///
  /// target_distance
  final uint16_t targetDistance;

  /// Current waypoint number
  ///
  /// MAVLink type: uint16_t
  ///
  /// wp_num
  final uint16_t wpNum;

  /// Bitmap of failure flags.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [HlFailureFlag]
  ///
  /// failure_flags
  final HlFailureFlag failureFlags;

  /// Type of the MAV (quadrotor, helicopter, etc.)
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavType]
  ///
  /// type
  final MavType type;

  /// Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavAutopilot]
  ///
  /// autopilot
  final MavAutopilot autopilot;

  /// Heading
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: deg/2
  ///
  /// heading
  final uint8_t heading;

  /// Heading setpoint
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: deg/2
  ///
  /// target_heading
  final uint8_t targetHeading;

  /// Throttle
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// throttle
  final uint8_t throttle;

  /// Airspeed
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: m/s*5
  ///
  /// airspeed
  final uint8_t airspeed;

  /// Airspeed setpoint
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: m/s*5
  ///
  /// airspeed_sp
  final uint8_t airspeedSp;

  /// Groundspeed
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: m/s*5
  ///
  /// groundspeed
  final uint8_t groundspeed;

  /// Windspeed
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: m/s*5
  ///
  /// windspeed
  final uint8_t windspeed;

  /// Wind heading
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: deg/2
  ///
  /// wind_heading
  final uint8_t windHeading;

  /// Maximum error horizontal position since last message
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: dm
  ///
  /// eph
  final uint8_t eph;

  /// Maximum error vertical position since last message
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: dm
  ///
  /// epv
  final uint8_t epv;

  /// Air temperature from airspeed sensor
  ///
  /// MAVLink type: int8_t
  ///
  /// units: degC
  ///
  /// temperature_air
  final int8_t temperatureAir;

  /// Maximum climb rate magnitude since last message
  ///
  /// MAVLink type: int8_t
  ///
  /// units: dm/s
  ///
  /// climb_rate
  final int8_t climbRate;

  /// Battery level (-1 if field not provided).
  ///
  /// MAVLink type: int8_t
  ///
  /// units: %
  ///
  /// battery
  final int8_t battery;

  /// Field for custom payload.
  ///
  /// MAVLink type: int8_t
  ///
  /// custom0
  final int8_t custom0;

  /// Field for custom payload.
  ///
  /// MAVLink type: int8_t
  ///
  /// custom1
  final int8_t custom1;

  /// Field for custom payload.
  ///
  /// MAVLink type: int8_t
  ///
  /// custom2
  final int8_t custom2;

  HighLatency2({
    required this.timestamp,
    required this.latitude,
    required this.longitude,
    required this.customMode,
    required this.altitude,
    required this.targetAltitude,
    required this.targetDistance,
    required this.wpNum,
    required this.failureFlags,
    required this.type,
    required this.autopilot,
    required this.heading,
    required this.targetHeading,
    required this.throttle,
    required this.airspeed,
    required this.airspeedSp,
    required this.groundspeed,
    required this.windspeed,
    required this.windHeading,
    required this.eph,
    required this.epv,
    required this.temperatureAir,
    required this.climbRate,
    required this.battery,
    required this.custom0,
    required this.custom1,
    required this.custom2,
  });

  HighLatency2 copyWith({
    uint32_t? timestamp,
    int32_t? latitude,
    int32_t? longitude,
    uint16_t? customMode,
    int16_t? altitude,
    int16_t? targetAltitude,
    uint16_t? targetDistance,
    uint16_t? wpNum,
    HlFailureFlag? failureFlags,
    MavType? type,
    MavAutopilot? autopilot,
    uint8_t? heading,
    uint8_t? targetHeading,
    uint8_t? throttle,
    uint8_t? airspeed,
    uint8_t? airspeedSp,
    uint8_t? groundspeed,
    uint8_t? windspeed,
    uint8_t? windHeading,
    uint8_t? eph,
    uint8_t? epv,
    int8_t? temperatureAir,
    int8_t? climbRate,
    int8_t? battery,
    int8_t? custom0,
    int8_t? custom1,
    int8_t? custom2,
  }) {
    return HighLatency2(
      timestamp: timestamp ?? this.timestamp,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      customMode: customMode ?? this.customMode,
      altitude: altitude ?? this.altitude,
      targetAltitude: targetAltitude ?? this.targetAltitude,
      targetDistance: targetDistance ?? this.targetDistance,
      wpNum: wpNum ?? this.wpNum,
      failureFlags: failureFlags ?? this.failureFlags,
      type: type ?? this.type,
      autopilot: autopilot ?? this.autopilot,
      heading: heading ?? this.heading,
      targetHeading: targetHeading ?? this.targetHeading,
      throttle: throttle ?? this.throttle,
      airspeed: airspeed ?? this.airspeed,
      airspeedSp: airspeedSp ?? this.airspeedSp,
      groundspeed: groundspeed ?? this.groundspeed,
      windspeed: windspeed ?? this.windspeed,
      windHeading: windHeading ?? this.windHeading,
      eph: eph ?? this.eph,
      epv: epv ?? this.epv,
      temperatureAir: temperatureAir ?? this.temperatureAir,
      climbRate: climbRate ?? this.climbRate,
      battery: battery ?? this.battery,
      custom0: custom0 ?? this.custom0,
      custom1: custom1 ?? this.custom1,
      custom2: custom2 ?? this.custom2,
    );
  }

  factory HighLatency2.parse(ByteData data_) {
    if (data_.lengthInBytes < HighLatency2.mavlinkEncodedLength) {
      var len = HighLatency2.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timestamp = data_.getUint32(0, Endian.little);
    var latitude = data_.getInt32(4, Endian.little);
    var longitude = data_.getInt32(8, Endian.little);
    var customMode = data_.getUint16(12, Endian.little);
    var altitude = data_.getInt16(14, Endian.little);
    var targetAltitude = data_.getInt16(16, Endian.little);
    var targetDistance = data_.getUint16(18, Endian.little);
    var wpNum = data_.getUint16(20, Endian.little);
    var failureFlags = data_.getUint16(22, Endian.little);
    var type = data_.getUint8(24);
    var autopilot = data_.getUint8(25);
    var heading = data_.getUint8(26);
    var targetHeading = data_.getUint8(27);
    var throttle = data_.getUint8(28);
    var airspeed = data_.getUint8(29);
    var airspeedSp = data_.getUint8(30);
    var groundspeed = data_.getUint8(31);
    var windspeed = data_.getUint8(32);
    var windHeading = data_.getUint8(33);
    var eph = data_.getUint8(34);
    var epv = data_.getUint8(35);
    var temperatureAir = data_.getInt8(36);
    var climbRate = data_.getInt8(37);
    var battery = data_.getInt8(38);
    var custom0 = data_.getInt8(39);
    var custom1 = data_.getInt8(40);
    var custom2 = data_.getInt8(41);

    return HighLatency2(
        timestamp: timestamp,
        latitude: latitude,
        longitude: longitude,
        customMode: customMode,
        altitude: altitude,
        targetAltitude: targetAltitude,
        targetDistance: targetDistance,
        wpNum: wpNum,
        failureFlags: failureFlags,
        type: type,
        autopilot: autopilot,
        heading: heading,
        targetHeading: targetHeading,
        throttle: throttle,
        airspeed: airspeed,
        airspeedSp: airspeedSp,
        groundspeed: groundspeed,
        windspeed: windspeed,
        windHeading: windHeading,
        eph: eph,
        epv: epv,
        temperatureAir: temperatureAir,
        climbRate: climbRate,
        battery: battery,
        custom0: custom0,
        custom1: custom1,
        custom2: custom2);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timestamp, Endian.little);
    data_.setInt32(4, latitude, Endian.little);
    data_.setInt32(8, longitude, Endian.little);
    data_.setUint16(12, customMode, Endian.little);
    data_.setInt16(14, altitude, Endian.little);
    data_.setInt16(16, targetAltitude, Endian.little);
    data_.setUint16(18, targetDistance, Endian.little);
    data_.setUint16(20, wpNum, Endian.little);
    data_.setUint16(22, failureFlags, Endian.little);
    data_.setUint8(24, type);
    data_.setUint8(25, autopilot);
    data_.setUint8(26, heading);
    data_.setUint8(27, targetHeading);
    data_.setUint8(28, throttle);
    data_.setUint8(29, airspeed);
    data_.setUint8(30, airspeedSp);
    data_.setUint8(31, groundspeed);
    data_.setUint8(32, windspeed);
    data_.setUint8(33, windHeading);
    data_.setUint8(34, eph);
    data_.setUint8(35, epv);
    data_.setInt8(36, temperatureAir);
    data_.setInt8(37, climbRate);
    data_.setInt8(38, battery);
    data_.setInt8(39, custom0);
    data_.setInt8(40, custom1);
    data_.setInt8(41, custom2);
    return data_;
  }
}

/// Vibration levels and accelerometer clipping
///
/// VIBRATION
class Vibration implements MavlinkMessage {
  static const int _mavlinkMessageId = 241;

  static const int _mavlinkCrcExtra = 90;

  static const int mavlinkEncodedLength = 32;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Vibration levels on X-axis
  ///
  /// MAVLink type: float
  ///
  /// vibration_x
  final float vibrationX;

  /// Vibration levels on Y-axis
  ///
  /// MAVLink type: float
  ///
  /// vibration_y
  final float vibrationY;

  /// Vibration levels on Z-axis
  ///
  /// MAVLink type: float
  ///
  /// vibration_z
  final float vibrationZ;

  /// first accelerometer clipping count
  ///
  /// MAVLink type: uint32_t
  ///
  /// clipping_0
  final uint32_t clipping0;

  /// second accelerometer clipping count
  ///
  /// MAVLink type: uint32_t
  ///
  /// clipping_1
  final uint32_t clipping1;

  /// third accelerometer clipping count
  ///
  /// MAVLink type: uint32_t
  ///
  /// clipping_2
  final uint32_t clipping2;

  Vibration({
    required this.timeUsec,
    required this.vibrationX,
    required this.vibrationY,
    required this.vibrationZ,
    required this.clipping0,
    required this.clipping1,
    required this.clipping2,
  });

  Vibration copyWith({
    uint64_t? timeUsec,
    float? vibrationX,
    float? vibrationY,
    float? vibrationZ,
    uint32_t? clipping0,
    uint32_t? clipping1,
    uint32_t? clipping2,
  }) {
    return Vibration(
      timeUsec: timeUsec ?? this.timeUsec,
      vibrationX: vibrationX ?? this.vibrationX,
      vibrationY: vibrationY ?? this.vibrationY,
      vibrationZ: vibrationZ ?? this.vibrationZ,
      clipping0: clipping0 ?? this.clipping0,
      clipping1: clipping1 ?? this.clipping1,
      clipping2: clipping2 ?? this.clipping2,
    );
  }

  factory Vibration.parse(ByteData data_) {
    if (data_.lengthInBytes < Vibration.mavlinkEncodedLength) {
      var len = Vibration.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var vibrationX = data_.getFloat32(8, Endian.little);
    var vibrationY = data_.getFloat32(12, Endian.little);
    var vibrationZ = data_.getFloat32(16, Endian.little);
    var clipping0 = data_.getUint32(20, Endian.little);
    var clipping1 = data_.getUint32(24, Endian.little);
    var clipping2 = data_.getUint32(28, Endian.little);

    return Vibration(
        timeUsec: timeUsec,
        vibrationX: vibrationX,
        vibrationY: vibrationY,
        vibrationZ: vibrationZ,
        clipping0: clipping0,
        clipping1: clipping1,
        clipping2: clipping2);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, vibrationX, Endian.little);
    data_.setFloat32(12, vibrationY, Endian.little);
    data_.setFloat32(16, vibrationZ, Endian.little);
    data_.setUint32(20, clipping0, Endian.little);
    data_.setUint32(24, clipping1, Endian.little);
    data_.setUint32(28, clipping2, Endian.little);
    return data_;
  }
}

///
/// Contains the home position.
/// The home position is the default position that the system will return to and land on.
/// The position must be set automatically by the system during the takeoff, and may also be explicitly set using MAV_CMD_DO_SET_HOME.
/// The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface.
/// Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach.
/// The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
/// Note: this message can be requested by sending the MAV_CMD_REQUEST_MESSAGE with param1=242 (or the deprecated MAV_CMD_GET_HOME_POSITION command).
///
///
/// HOME_POSITION
class HomePosition implements MavlinkMessage {
  static const int _mavlinkMessageId = 242;

  static const int _mavlinkCrcExtra = 104;

  static const int mavlinkEncodedLength = 60;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// latitude
  final int32_t latitude;

  /// Longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// longitude
  final int32_t longitude;

  /// Altitude (MSL). Positive for up.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// altitude
  final int32_t altitude;

  /// Local X position of this position in the local coordinate frame (NED)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Local Y position of this position in the local coordinate frame (NED)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Local Z position of this position in the local coordinate frame (NED: positive "down")
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  ///
  /// Quaternion indicating world-to-surface-normal and heading transformation of the takeoff position.
  /// Used to indicate the heading and slope of the ground.
  /// All fields should be set to NaN if an accurate quaternion for both heading and surface slope cannot be supplied.
  ///
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// approach_x
  final float approachX;

  /// Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// approach_y
  final float approachY;

  /// Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// approach_z
  final float approachZ;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// time_usec
  final uint64_t timeUsec;

  HomePosition({
    required this.latitude,
    required this.longitude,
    required this.altitude,
    required this.x,
    required this.y,
    required this.z,
    required this.q,
    required this.approachX,
    required this.approachY,
    required this.approachZ,
    required this.timeUsec,
  });

  HomePosition copyWith({
    int32_t? latitude,
    int32_t? longitude,
    int32_t? altitude,
    float? x,
    float? y,
    float? z,
    List<float>? q,
    float? approachX,
    float? approachY,
    float? approachZ,
    uint64_t? timeUsec,
  }) {
    return HomePosition(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      altitude: altitude ?? this.altitude,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      q: q ?? this.q,
      approachX: approachX ?? this.approachX,
      approachY: approachY ?? this.approachY,
      approachZ: approachZ ?? this.approachZ,
      timeUsec: timeUsec ?? this.timeUsec,
    );
  }

  factory HomePosition.parse(ByteData data_) {
    if (data_.lengthInBytes < HomePosition.mavlinkEncodedLength) {
      var len = HomePosition.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var latitude = data_.getInt32(0, Endian.little);
    var longitude = data_.getInt32(4, Endian.little);
    var altitude = data_.getInt32(8, Endian.little);
    var x = data_.getFloat32(12, Endian.little);
    var y = data_.getFloat32(16, Endian.little);
    var z = data_.getFloat32(20, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 24, 4);
    var approachX = data_.getFloat32(40, Endian.little);
    var approachY = data_.getFloat32(44, Endian.little);
    var approachZ = data_.getFloat32(48, Endian.little);
    var timeUsec = data_.getUint64(52, Endian.little);

    return HomePosition(
        latitude: latitude,
        longitude: longitude,
        altitude: altitude,
        x: x,
        y: y,
        z: z,
        q: q,
        approachX: approachX,
        approachY: approachY,
        approachZ: approachZ,
        timeUsec: timeUsec);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, latitude, Endian.little);
    data_.setInt32(4, longitude, Endian.little);
    data_.setInt32(8, altitude, Endian.little);
    data_.setFloat32(12, x, Endian.little);
    data_.setFloat32(16, y, Endian.little);
    data_.setFloat32(20, z, Endian.little);
    MavlinkMessage.setFloat32List(data_, 24, q);
    data_.setFloat32(40, approachX, Endian.little);
    data_.setFloat32(44, approachY, Endian.little);
    data_.setFloat32(48, approachZ, Endian.little);
    data_.setUint64(52, timeUsec, Endian.little);
    return data_;
  }
}

///
/// Sets the home position.
/// The home position is the default position that the system will return to and land on.
/// The position is set automatically by the system during the takeoff (and may also be set using this message).
/// The global and local positions encode the position in the respective coordinate frames, while the q parameter encodes the orientation of the surface.
/// Under normal conditions it describes the heading and terrain slope, which can be used by the aircraft to adjust the approach.
/// The approach 3D vector describes the point to which the system should fly in normal flight mode and then perform a landing sequence along the vector.
/// Note: the current home position may be emitted in a HOME_POSITION message on request (using MAV_CMD_REQUEST_MESSAGE with param1=242).
///
///
/// SET_HOME_POSITION
class SetHomePosition implements MavlinkMessage {
  static const int _mavlinkMessageId = 243;

  static const int _mavlinkCrcExtra = 85;

  static const int mavlinkEncodedLength = 61;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// latitude
  final int32_t latitude;

  /// Longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// longitude
  final int32_t longitude;

  /// Altitude (MSL). Positive for up.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// altitude
  final int32_t altitude;

  /// Local X position of this position in the local coordinate frame (NED)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Local Y position of this position in the local coordinate frame (NED)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Local Z position of this position in the local coordinate frame (NED: positive "down")
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// World to surface normal and heading transformation of the takeoff position. Used to indicate the heading and slope of the ground
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// Local X position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// approach_x
  final float approachX;

  /// Local Y position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// approach_y
  final float approachY;

  /// Local Z position of the end of the approach vector. Multicopters should set this position based on their takeoff path. Grass-landing fixed wing aircraft should set it the same way as multicopters. Runway-landing fixed wing aircraft should set it to the opposite direction of the takeoff, assuming the takeoff happened from the threshold / touchdown zone.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// approach_z
  final float approachZ;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// time_usec
  final uint64_t timeUsec;

  SetHomePosition({
    required this.latitude,
    required this.longitude,
    required this.altitude,
    required this.x,
    required this.y,
    required this.z,
    required this.q,
    required this.approachX,
    required this.approachY,
    required this.approachZ,
    required this.targetSystem,
    required this.timeUsec,
  });

  SetHomePosition copyWith({
    int32_t? latitude,
    int32_t? longitude,
    int32_t? altitude,
    float? x,
    float? y,
    float? z,
    List<float>? q,
    float? approachX,
    float? approachY,
    float? approachZ,
    uint8_t? targetSystem,
    uint64_t? timeUsec,
  }) {
    return SetHomePosition(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      altitude: altitude ?? this.altitude,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      q: q ?? this.q,
      approachX: approachX ?? this.approachX,
      approachY: approachY ?? this.approachY,
      approachZ: approachZ ?? this.approachZ,
      targetSystem: targetSystem ?? this.targetSystem,
      timeUsec: timeUsec ?? this.timeUsec,
    );
  }

  factory SetHomePosition.parse(ByteData data_) {
    if (data_.lengthInBytes < SetHomePosition.mavlinkEncodedLength) {
      var len = SetHomePosition.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var latitude = data_.getInt32(0, Endian.little);
    var longitude = data_.getInt32(4, Endian.little);
    var altitude = data_.getInt32(8, Endian.little);
    var x = data_.getFloat32(12, Endian.little);
    var y = data_.getFloat32(16, Endian.little);
    var z = data_.getFloat32(20, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 24, 4);
    var approachX = data_.getFloat32(40, Endian.little);
    var approachY = data_.getFloat32(44, Endian.little);
    var approachZ = data_.getFloat32(48, Endian.little);
    var targetSystem = data_.getUint8(52);
    var timeUsec = data_.getUint64(53, Endian.little);

    return SetHomePosition(
        latitude: latitude,
        longitude: longitude,
        altitude: altitude,
        x: x,
        y: y,
        z: z,
        q: q,
        approachX: approachX,
        approachY: approachY,
        approachZ: approachZ,
        targetSystem: targetSystem,
        timeUsec: timeUsec);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, latitude, Endian.little);
    data_.setInt32(4, longitude, Endian.little);
    data_.setInt32(8, altitude, Endian.little);
    data_.setFloat32(12, x, Endian.little);
    data_.setFloat32(16, y, Endian.little);
    data_.setFloat32(20, z, Endian.little);
    MavlinkMessage.setFloat32List(data_, 24, q);
    data_.setFloat32(40, approachX, Endian.little);
    data_.setFloat32(44, approachY, Endian.little);
    data_.setFloat32(48, approachZ, Endian.little);
    data_.setUint8(52, targetSystem);
    data_.setUint64(53, timeUsec, Endian.little);
    return data_;
  }
}

///
/// The interval between messages for a particular MAVLink message ID.
/// This message is sent in response to the MAV_CMD_REQUEST_MESSAGE command with param1=244 (this message) and param2=message_id (the id of the message for which the interval is required).
/// It may also be sent in response to MAV_CMD_GET_MESSAGE_INTERVAL.
/// This interface replaces DATA_STREAM.
///
/// MESSAGE_INTERVAL
class MessageInterval implements MavlinkMessage {
  static const int _mavlinkMessageId = 244;

  static const int _mavlinkCrcExtra = 95;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// The interval between two messages. A value of -1 indicates this stream is disabled, 0 indicates it is not available, > 0 indicates the interval at which it is sent.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: us
  ///
  /// interval_us
  final int32_t intervalUs;

  /// The ID of the requested MAVLink message. v1.0 is limited to 254 messages.
  ///
  /// MAVLink type: uint16_t
  ///
  /// message_id
  final uint16_t messageId;

  MessageInterval({
    required this.intervalUs,
    required this.messageId,
  });

  MessageInterval copyWith({
    int32_t? intervalUs,
    uint16_t? messageId,
  }) {
    return MessageInterval(
      intervalUs: intervalUs ?? this.intervalUs,
      messageId: messageId ?? this.messageId,
    );
  }

  factory MessageInterval.parse(ByteData data_) {
    if (data_.lengthInBytes < MessageInterval.mavlinkEncodedLength) {
      var len = MessageInterval.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var intervalUs = data_.getInt32(0, Endian.little);
    var messageId = data_.getUint16(4, Endian.little);

    return MessageInterval(intervalUs: intervalUs, messageId: messageId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, intervalUs, Endian.little);
    data_.setUint16(4, messageId, Endian.little);
    return data_;
  }
}

/// Provides state for additional features
///
/// EXTENDED_SYS_STATE
class ExtendedSysState implements MavlinkMessage {
  static const int _mavlinkMessageId = 245;

  static const int _mavlinkCrcExtra = 130;

  static const int mavlinkEncodedLength = 2;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// The VTOL state if applicable. Is set to MAV_VTOL_STATE_UNDEFINED if UAV is not in VTOL configuration.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavVtolState]
  ///
  /// vtol_state
  final MavVtolState vtolState;

  /// The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavLandedState]
  ///
  /// landed_state
  final MavLandedState landedState;

  ExtendedSysState({
    required this.vtolState,
    required this.landedState,
  });

  ExtendedSysState copyWith({
    MavVtolState? vtolState,
    MavLandedState? landedState,
  }) {
    return ExtendedSysState(
      vtolState: vtolState ?? this.vtolState,
      landedState: landedState ?? this.landedState,
    );
  }

  factory ExtendedSysState.parse(ByteData data_) {
    if (data_.lengthInBytes < ExtendedSysState.mavlinkEncodedLength) {
      var len = ExtendedSysState.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var vtolState = data_.getUint8(0);
    var landedState = data_.getUint8(1);

    return ExtendedSysState(vtolState: vtolState, landedState: landedState);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, vtolState);
    data_.setUint8(1, landedState);
    return data_;
  }
}

/// The location and information of an ADSB vehicle
///
/// ADSB_VEHICLE
class AdsbVehicle implements MavlinkMessage {
  static const int _mavlinkMessageId = 246;

  static const int _mavlinkCrcExtra = 184;

  static const int mavlinkEncodedLength = 38;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// ICAO address
  ///
  /// MAVLink type: uint32_t
  ///
  /// ICAO_address
  final uint32_t icaoAddress;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude(ASL)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// altitude
  final int32_t altitude;

  /// Course over ground
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// heading
  final uint16_t heading;

  /// The horizontal velocity
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// hor_velocity
  final uint16_t horVelocity;

  /// The vertical velocity. Positive is up
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// ver_velocity
  final int16_t verVelocity;

  /// Bitmap to indicate various statuses including valid data fields
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [AdsbFlags]
  ///
  /// flags
  final AdsbFlags flags;

  /// Squawk code. Note that the code is in decimal: e.g. 7700 (general emergency) is encoded as binary 0b0001_1110_0001_0100, not(!) as 0b0000_111_111_000_000
  ///
  /// MAVLink type: uint16_t
  ///
  /// squawk
  final uint16_t squawk;

  /// ADSB altitude type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AdsbAltitudeType]
  ///
  /// altitude_type
  final AdsbAltitudeType altitudeType;

  /// The callsign, 8+null
  ///
  /// MAVLink type: char[9]
  ///
  /// callsign
  final List<char> callsign;

  /// ADSB emitter type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AdsbEmitterType]
  ///
  /// emitter_type
  final AdsbEmitterType emitterType;

  /// Time since last communication in seconds
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: s
  ///
  /// tslc
  final uint8_t tslc;

  AdsbVehicle({
    required this.icaoAddress,
    required this.lat,
    required this.lon,
    required this.altitude,
    required this.heading,
    required this.horVelocity,
    required this.verVelocity,
    required this.flags,
    required this.squawk,
    required this.altitudeType,
    required this.callsign,
    required this.emitterType,
    required this.tslc,
  });

  AdsbVehicle copyWith({
    uint32_t? icaoAddress,
    int32_t? lat,
    int32_t? lon,
    int32_t? altitude,
    uint16_t? heading,
    uint16_t? horVelocity,
    int16_t? verVelocity,
    AdsbFlags? flags,
    uint16_t? squawk,
    AdsbAltitudeType? altitudeType,
    List<char>? callsign,
    AdsbEmitterType? emitterType,
    uint8_t? tslc,
  }) {
    return AdsbVehicle(
      icaoAddress: icaoAddress ?? this.icaoAddress,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      altitude: altitude ?? this.altitude,
      heading: heading ?? this.heading,
      horVelocity: horVelocity ?? this.horVelocity,
      verVelocity: verVelocity ?? this.verVelocity,
      flags: flags ?? this.flags,
      squawk: squawk ?? this.squawk,
      altitudeType: altitudeType ?? this.altitudeType,
      callsign: callsign ?? this.callsign,
      emitterType: emitterType ?? this.emitterType,
      tslc: tslc ?? this.tslc,
    );
  }

  factory AdsbVehicle.parse(ByteData data_) {
    if (data_.lengthInBytes < AdsbVehicle.mavlinkEncodedLength) {
      var len = AdsbVehicle.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var icaoAddress = data_.getUint32(0, Endian.little);
    var lat = data_.getInt32(4, Endian.little);
    var lon = data_.getInt32(8, Endian.little);
    var altitude = data_.getInt32(12, Endian.little);
    var heading = data_.getUint16(16, Endian.little);
    var horVelocity = data_.getUint16(18, Endian.little);
    var verVelocity = data_.getInt16(20, Endian.little);
    var flags = data_.getUint16(22, Endian.little);
    var squawk = data_.getUint16(24, Endian.little);
    var altitudeType = data_.getUint8(26);
    var callsign = MavlinkMessage.asInt8List(data_, 27, 9);
    var emitterType = data_.getUint8(36);
    var tslc = data_.getUint8(37);

    return AdsbVehicle(
        icaoAddress: icaoAddress,
        lat: lat,
        lon: lon,
        altitude: altitude,
        heading: heading,
        horVelocity: horVelocity,
        verVelocity: verVelocity,
        flags: flags,
        squawk: squawk,
        altitudeType: altitudeType,
        callsign: callsign,
        emitterType: emitterType,
        tslc: tslc);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, icaoAddress, Endian.little);
    data_.setInt32(4, lat, Endian.little);
    data_.setInt32(8, lon, Endian.little);
    data_.setInt32(12, altitude, Endian.little);
    data_.setUint16(16, heading, Endian.little);
    data_.setUint16(18, horVelocity, Endian.little);
    data_.setInt16(20, verVelocity, Endian.little);
    data_.setUint16(22, flags, Endian.little);
    data_.setUint16(24, squawk, Endian.little);
    data_.setUint8(26, altitudeType);
    MavlinkMessage.setInt8List(data_, 27, callsign);
    data_.setUint8(36, emitterType);
    data_.setUint8(37, tslc);
    return data_;
  }
}

/// Information about a potential collision
///
/// COLLISION
class Collision implements MavlinkMessage {
  static const int _mavlinkMessageId = 247;

  static const int _mavlinkCrcExtra = 81;

  static const int mavlinkEncodedLength = 19;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Unique identifier, domain based on src field
  ///
  /// MAVLink type: uint32_t
  ///
  /// id
  final uint32_t id;

  /// Estimated time until collision occurs
  ///
  /// MAVLink type: float
  ///
  /// units: s
  ///
  /// time_to_minimum_delta
  final float timeToMinimumDelta;

  /// Closest vertical distance between vehicle and object
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude_minimum_delta
  final float altitudeMinimumDelta;

  /// Closest horizontal distance between vehicle and object
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// horizontal_minimum_delta
  final float horizontalMinimumDelta;

  /// Collision data source
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavCollisionSrc]
  ///
  /// src
  final MavCollisionSrc src;

  /// Action that is being taken to avoid this collision
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavCollisionAction]
  ///
  /// action
  final MavCollisionAction action;

  /// How concerned the aircraft is about this collision
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavCollisionThreatLevel]
  ///
  /// threat_level
  final MavCollisionThreatLevel threatLevel;

  Collision({
    required this.id,
    required this.timeToMinimumDelta,
    required this.altitudeMinimumDelta,
    required this.horizontalMinimumDelta,
    required this.src,
    required this.action,
    required this.threatLevel,
  });

  Collision copyWith({
    uint32_t? id,
    float? timeToMinimumDelta,
    float? altitudeMinimumDelta,
    float? horizontalMinimumDelta,
    MavCollisionSrc? src,
    MavCollisionAction? action,
    MavCollisionThreatLevel? threatLevel,
  }) {
    return Collision(
      id: id ?? this.id,
      timeToMinimumDelta: timeToMinimumDelta ?? this.timeToMinimumDelta,
      altitudeMinimumDelta: altitudeMinimumDelta ?? this.altitudeMinimumDelta,
      horizontalMinimumDelta:
          horizontalMinimumDelta ?? this.horizontalMinimumDelta,
      src: src ?? this.src,
      action: action ?? this.action,
      threatLevel: threatLevel ?? this.threatLevel,
    );
  }

  factory Collision.parse(ByteData data_) {
    if (data_.lengthInBytes < Collision.mavlinkEncodedLength) {
      var len = Collision.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var id = data_.getUint32(0, Endian.little);
    var timeToMinimumDelta = data_.getFloat32(4, Endian.little);
    var altitudeMinimumDelta = data_.getFloat32(8, Endian.little);
    var horizontalMinimumDelta = data_.getFloat32(12, Endian.little);
    var src = data_.getUint8(16);
    var action = data_.getUint8(17);
    var threatLevel = data_.getUint8(18);

    return Collision(
        id: id,
        timeToMinimumDelta: timeToMinimumDelta,
        altitudeMinimumDelta: altitudeMinimumDelta,
        horizontalMinimumDelta: horizontalMinimumDelta,
        src: src,
        action: action,
        threatLevel: threatLevel);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, id, Endian.little);
    data_.setFloat32(4, timeToMinimumDelta, Endian.little);
    data_.setFloat32(8, altitudeMinimumDelta, Endian.little);
    data_.setFloat32(12, horizontalMinimumDelta, Endian.little);
    data_.setUint8(16, src);
    data_.setUint8(17, action);
    data_.setUint8(18, threatLevel);
    return data_;
  }
}

/// Message implementing parts of the V2 payload specs in V1 frames for transitional support.
///
/// V2_EXTENSION
class V2Extension implements MavlinkMessage {
  static const int _mavlinkMessageId = 248;

  static const int _mavlinkCrcExtra = 8;

  static const int mavlinkEncodedLength = 254;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// A code that identifies the software component that understands this message (analogous to USB device classes or mime type strings). If this code is less than 32768, it is considered a 'registered' protocol extension and the corresponding entry should be added to https://github.com/mavlink/mavlink/definition_files/extension_message_ids.xml. Software creators can register blocks of message IDs as needed (useful for GCS specific metadata, etc...). Message_types greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
  ///
  /// MAVLink type: uint16_t
  ///
  /// message_type
  final uint16_t messageType;

  /// Network ID (0 for broadcast)
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_network
  final uint8_t targetNetwork;

  /// System ID (0 for broadcast)
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast)
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Variable length payload. The length must be encoded in the payload as part of the message_type protocol, e.g. by including the length as payload data, or by terminating the payload data with a non-zero marker. This is required in order to reconstruct zero-terminated payloads that are (or otherwise would be) trimmed by MAVLink 2 empty-byte truncation. The entire content of the payload block is opaque unless you understand the encoding message_type. The particular encoding used can be extension specific and might not always be documented as part of the MAVLink specification.
  ///
  /// MAVLink type: uint8_t[249]
  ///
  /// payload
  final List<int8_t> payload;

  V2Extension({
    required this.messageType,
    required this.targetNetwork,
    required this.targetSystem,
    required this.targetComponent,
    required this.payload,
  });

  V2Extension copyWith({
    uint16_t? messageType,
    uint8_t? targetNetwork,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? payload,
  }) {
    return V2Extension(
      messageType: messageType ?? this.messageType,
      targetNetwork: targetNetwork ?? this.targetNetwork,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      payload: payload ?? this.payload,
    );
  }

  factory V2Extension.parse(ByteData data_) {
    if (data_.lengthInBytes < V2Extension.mavlinkEncodedLength) {
      var len = V2Extension.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var messageType = data_.getUint16(0, Endian.little);
    var targetNetwork = data_.getUint8(2);
    var targetSystem = data_.getUint8(3);
    var targetComponent = data_.getUint8(4);
    var payload = MavlinkMessage.asUint8List(data_, 5, 249);

    return V2Extension(
        messageType: messageType,
        targetNetwork: targetNetwork,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        payload: payload);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, messageType, Endian.little);
    data_.setUint8(2, targetNetwork);
    data_.setUint8(3, targetSystem);
    data_.setUint8(4, targetComponent);
    MavlinkMessage.setUint8List(data_, 5, payload);
    return data_;
  }
}

/// Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
///
/// MEMORY_VECT
class MemoryVect implements MavlinkMessage {
  static const int _mavlinkMessageId = 249;

  static const int _mavlinkCrcExtra = 204;

  static const int mavlinkEncodedLength = 36;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Starting address of the debug variables
  ///
  /// MAVLink type: uint16_t
  ///
  /// address
  final uint16_t address;

  /// Version code of the type variable. 0=unknown, type ignored and assumed int16_t. 1=as below
  ///
  /// MAVLink type: uint8_t
  ///
  /// ver
  final uint8_t ver;

  /// Type code of the memory variables. for ver = 1: 0=16 x int16_t, 1=16 x uint16_t, 2=16 x Q15, 3=16 x 1Q14
  ///
  /// MAVLink type: uint8_t
  ///
  /// type
  final uint8_t type;

  /// Memory contents at specified address
  ///
  /// MAVLink type: int8_t[32]
  ///
  /// value
  final List<int8_t> value;

  MemoryVect({
    required this.address,
    required this.ver,
    required this.type,
    required this.value,
  });

  MemoryVect copyWith({
    uint16_t? address,
    uint8_t? ver,
    uint8_t? type,
    List<int8_t>? value,
  }) {
    return MemoryVect(
      address: address ?? this.address,
      ver: ver ?? this.ver,
      type: type ?? this.type,
      value: value ?? this.value,
    );
  }

  factory MemoryVect.parse(ByteData data_) {
    if (data_.lengthInBytes < MemoryVect.mavlinkEncodedLength) {
      var len = MemoryVect.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var address = data_.getUint16(0, Endian.little);
    var ver = data_.getUint8(2);
    var type = data_.getUint8(3);
    var value = MavlinkMessage.asInt8List(data_, 4, 32);

    return MemoryVect(address: address, ver: ver, type: type, value: value);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, address, Endian.little);
    data_.setUint8(2, ver);
    data_.setUint8(3, type);
    MavlinkMessage.setInt8List(data_, 4, value);
    return data_;
  }
}

/// To debug something using a named 3D vector.
///
/// DEBUG_VECT
class DebugVect implements MavlinkMessage {
  static const int _mavlinkMessageId = 250;

  static const int _mavlinkCrcExtra = 49;

  static const int mavlinkEncodedLength = 30;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// x
  ///
  /// MAVLink type: float
  ///
  /// x
  final float x;

  /// y
  ///
  /// MAVLink type: float
  ///
  /// y
  final float y;

  /// z
  ///
  /// MAVLink type: float
  ///
  /// z
  final float z;

  /// Name
  ///
  /// MAVLink type: char[10]
  ///
  /// name
  final List<char> name;

  DebugVect({
    required this.timeUsec,
    required this.x,
    required this.y,
    required this.z,
    required this.name,
  });

  DebugVect copyWith({
    uint64_t? timeUsec,
    float? x,
    float? y,
    float? z,
    List<char>? name,
  }) {
    return DebugVect(
      timeUsec: timeUsec ?? this.timeUsec,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      name: name ?? this.name,
    );
  }

  factory DebugVect.parse(ByteData data_) {
    if (data_.lengthInBytes < DebugVect.mavlinkEncodedLength) {
      var len = DebugVect.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var x = data_.getFloat32(8, Endian.little);
    var y = data_.getFloat32(12, Endian.little);
    var z = data_.getFloat32(16, Endian.little);
    var name = MavlinkMessage.asInt8List(data_, 20, 10);

    return DebugVect(timeUsec: timeUsec, x: x, y: y, z: z, name: name);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, x, Endian.little);
    data_.setFloat32(12, y, Endian.little);
    data_.setFloat32(16, z, Endian.little);
    MavlinkMessage.setInt8List(data_, 20, name);
    return data_;
  }
}

/// Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
///
/// NAMED_VALUE_FLOAT
class NamedValueFloat implements MavlinkMessage {
  static const int _mavlinkMessageId = 251;

  static const int _mavlinkCrcExtra = 170;

  static const int mavlinkEncodedLength = 18;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Floating point value
  ///
  /// MAVLink type: float
  ///
  /// value
  final float value;

  /// Name of the debug variable
  ///
  /// MAVLink type: char[10]
  ///
  /// name
  final List<char> name;

  NamedValueFloat({
    required this.timeBootMs,
    required this.value,
    required this.name,
  });

  NamedValueFloat copyWith({
    uint32_t? timeBootMs,
    float? value,
    List<char>? name,
  }) {
    return NamedValueFloat(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      value: value ?? this.value,
      name: name ?? this.name,
    );
  }

  factory NamedValueFloat.parse(ByteData data_) {
    if (data_.lengthInBytes < NamedValueFloat.mavlinkEncodedLength) {
      var len = NamedValueFloat.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var value = data_.getFloat32(4, Endian.little);
    var name = MavlinkMessage.asInt8List(data_, 8, 10);

    return NamedValueFloat(timeBootMs: timeBootMs, value: value, name: name);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, value, Endian.little);
    MavlinkMessage.setInt8List(data_, 8, name);
    return data_;
  }
}

/// Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite efficient way for testing new messages and getting experimental debug output.
///
/// NAMED_VALUE_INT
class NamedValueInt implements MavlinkMessage {
  static const int _mavlinkMessageId = 252;

  static const int _mavlinkCrcExtra = 44;

  static const int mavlinkEncodedLength = 18;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Signed integer value
  ///
  /// MAVLink type: int32_t
  ///
  /// value
  final int32_t value;

  /// Name of the debug variable
  ///
  /// MAVLink type: char[10]
  ///
  /// name
  final List<char> name;

  NamedValueInt({
    required this.timeBootMs,
    required this.value,
    required this.name,
  });

  NamedValueInt copyWith({
    uint32_t? timeBootMs,
    int32_t? value,
    List<char>? name,
  }) {
    return NamedValueInt(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      value: value ?? this.value,
      name: name ?? this.name,
    );
  }

  factory NamedValueInt.parse(ByteData data_) {
    if (data_.lengthInBytes < NamedValueInt.mavlinkEncodedLength) {
      var len = NamedValueInt.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var value = data_.getInt32(4, Endian.little);
    var name = MavlinkMessage.asInt8List(data_, 8, 10);

    return NamedValueInt(timeBootMs: timeBootMs, value: value, name: name);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt32(4, value, Endian.little);
    MavlinkMessage.setInt8List(data_, 8, name);
    return data_;
  }
}

/// Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING: They consume quite some bandwidth, so use only for important status and error messages. If implemented wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz).
///
/// STATUSTEXT
class Statustext implements MavlinkMessage {
  static const int _mavlinkMessageId = 253;

  static const int _mavlinkCrcExtra = 83;

  static const int mavlinkEncodedLength = 54;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Severity of status. Relies on the definitions within RFC-5424.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavSeverity]
  ///
  /// severity
  final MavSeverity severity;

  /// Status text message, without null termination character
  ///
  /// MAVLink type: char[50]
  ///
  /// text
  final List<char> text;

  /// Unique (opaque) identifier for this statustext message.  May be used to reassemble a logical long-statustext message from a sequence of chunks.  A value of zero indicates this is the only chunk in the sequence and the message can be emitted immediately.
  ///
  /// MAVLink type: uint16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// id
  final uint16_t id;

  /// This chunk's sequence number; indexing is from zero.  Any null character in the text field is taken to mean this was the last chunk.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// chunk_seq
  final uint8_t chunkSeq;

  Statustext({
    required this.severity,
    required this.text,
    required this.id,
    required this.chunkSeq,
  });

  Statustext copyWith({
    MavSeverity? severity,
    List<char>? text,
    uint16_t? id,
    uint8_t? chunkSeq,
  }) {
    return Statustext(
      severity: severity ?? this.severity,
      text: text ?? this.text,
      id: id ?? this.id,
      chunkSeq: chunkSeq ?? this.chunkSeq,
    );
  }

  factory Statustext.parse(ByteData data_) {
    if (data_.lengthInBytes < Statustext.mavlinkEncodedLength) {
      var len = Statustext.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var severity = data_.getUint8(0);
    var text = MavlinkMessage.asInt8List(data_, 1, 50);
    var id = data_.getUint16(51, Endian.little);
    var chunkSeq = data_.getUint8(53);

    return Statustext(
        severity: severity, text: text, id: id, chunkSeq: chunkSeq);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, severity);
    MavlinkMessage.setInt8List(data_, 1, text);
    data_.setUint16(51, id, Endian.little);
    data_.setUint8(53, chunkSeq);
    return data_;
  }
}

/// Send a debug value. The index is used to discriminate between values. These values show up in the plot of QGroundControl as DEBUG N.
///
/// DEBUG
class Debug implements MavlinkMessage {
  static const int _mavlinkMessageId = 254;

  static const int _mavlinkCrcExtra = 46;

  static const int mavlinkEncodedLength = 9;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// DEBUG value
  ///
  /// MAVLink type: float
  ///
  /// value
  final float value;

  /// index of debug variable
  ///
  /// MAVLink type: uint8_t
  ///
  /// ind
  final uint8_t ind;

  Debug({
    required this.timeBootMs,
    required this.value,
    required this.ind,
  });

  Debug copyWith({
    uint32_t? timeBootMs,
    float? value,
    uint8_t? ind,
  }) {
    return Debug(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      value: value ?? this.value,
      ind: ind ?? this.ind,
    );
  }

  factory Debug.parse(ByteData data_) {
    if (data_.lengthInBytes < Debug.mavlinkEncodedLength) {
      var len = Debug.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var value = data_.getFloat32(4, Endian.little);
    var ind = data_.getUint8(8);

    return Debug(timeBootMs: timeBootMs, value: value, ind: ind);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, value, Endian.little);
    data_.setUint8(8, ind);
    return data_;
  }
}

/// Setup a MAVLink2 signing key. If called with secret_key of all zero and zero initial_timestamp will disable signing
///
/// SETUP_SIGNING
class SetupSigning implements MavlinkMessage {
  static const int _mavlinkMessageId = 256;

  static const int _mavlinkCrcExtra = 71;

  static const int mavlinkEncodedLength = 42;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// initial timestamp
  ///
  /// MAVLink type: uint64_t
  ///
  /// initial_timestamp
  final uint64_t initialTimestamp;

  /// system id of the target
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// component ID of the target
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// signing key
  ///
  /// MAVLink type: uint8_t[32]
  ///
  /// secret_key
  final List<int8_t> secretKey;

  SetupSigning({
    required this.initialTimestamp,
    required this.targetSystem,
    required this.targetComponent,
    required this.secretKey,
  });

  SetupSigning copyWith({
    uint64_t? initialTimestamp,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? secretKey,
  }) {
    return SetupSigning(
      initialTimestamp: initialTimestamp ?? this.initialTimestamp,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      secretKey: secretKey ?? this.secretKey,
    );
  }

  factory SetupSigning.parse(ByteData data_) {
    if (data_.lengthInBytes < SetupSigning.mavlinkEncodedLength) {
      var len = SetupSigning.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var initialTimestamp = data_.getUint64(0, Endian.little);
    var targetSystem = data_.getUint8(8);
    var targetComponent = data_.getUint8(9);
    var secretKey = MavlinkMessage.asUint8List(data_, 10, 32);

    return SetupSigning(
        initialTimestamp: initialTimestamp,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        secretKey: secretKey);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, initialTimestamp, Endian.little);
    data_.setUint8(8, targetSystem);
    data_.setUint8(9, targetComponent);
    MavlinkMessage.setUint8List(data_, 10, secretKey);
    return data_;
  }
}

/// Report button state change.
///
/// BUTTON_CHANGE
class ButtonChange implements MavlinkMessage {
  static const int _mavlinkMessageId = 257;

  static const int _mavlinkCrcExtra = 131;

  static const int mavlinkEncodedLength = 9;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Time of last change of button state.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// last_change_ms
  final uint32_t lastChangeMs;

  /// Bitmap for state of buttons.
  ///
  /// MAVLink type: uint8_t
  ///
  /// state
  final uint8_t state;

  ButtonChange({
    required this.timeBootMs,
    required this.lastChangeMs,
    required this.state,
  });

  ButtonChange copyWith({
    uint32_t? timeBootMs,
    uint32_t? lastChangeMs,
    uint8_t? state,
  }) {
    return ButtonChange(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      lastChangeMs: lastChangeMs ?? this.lastChangeMs,
      state: state ?? this.state,
    );
  }

  factory ButtonChange.parse(ByteData data_) {
    if (data_.lengthInBytes < ButtonChange.mavlinkEncodedLength) {
      var len = ButtonChange.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var lastChangeMs = data_.getUint32(4, Endian.little);
    var state = data_.getUint8(8);

    return ButtonChange(
        timeBootMs: timeBootMs, lastChangeMs: lastChangeMs, state: state);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint32(4, lastChangeMs, Endian.little);
    data_.setUint8(8, state);
    return data_;
  }
}

/// Control vehicle tone generation (buzzer).
///
/// PLAY_TUNE
class PlayTune implements MavlinkMessage {
  static const int _mavlinkMessageId = 258;

  static const int _mavlinkCrcExtra = 187;

  static const int mavlinkEncodedLength = 232;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// tune in board specific format
  ///
  /// MAVLink type: char[30]
  ///
  /// tune
  final List<char> tune;

  /// tune extension (appended to tune)
  ///
  /// MAVLink type: char[200]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// tune2
  final List<char> tune2;

  PlayTune({
    required this.targetSystem,
    required this.targetComponent,
    required this.tune,
    required this.tune2,
  });

  PlayTune copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<char>? tune,
    List<char>? tune2,
  }) {
    return PlayTune(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      tune: tune ?? this.tune,
      tune2: tune2 ?? this.tune2,
    );
  }

  factory PlayTune.parse(ByteData data_) {
    if (data_.lengthInBytes < PlayTune.mavlinkEncodedLength) {
      var len = PlayTune.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var tune = MavlinkMessage.asInt8List(data_, 2, 30);
    var tune2 = MavlinkMessage.asInt8List(data_, 32, 200);

    return PlayTune(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        tune: tune,
        tune2: tune2);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    MavlinkMessage.setInt8List(data_, 2, tune);
    MavlinkMessage.setInt8List(data_, 32, tune2);
    return data_;
  }
}

/// Information about a camera. Can be requested with a MAV_CMD_REQUEST_MESSAGE command.
///
/// CAMERA_INFORMATION
class CameraInformation implements MavlinkMessage {
  static const int _mavlinkMessageId = 259;

  static const int _mavlinkCrcExtra = 92;

  static const int mavlinkEncodedLength = 237;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Version of the camera firmware, encoded as: (Dev & 0xff) << 24 | (Patch & 0xff) << 16 | (Minor & 0xff) << 8 | (Major & 0xff). Use 0 if not known.
  ///
  /// MAVLink type: uint32_t
  ///
  /// firmware_version
  final uint32_t firmwareVersion;

  /// Focal length. Use NaN if not known.
  ///
  /// MAVLink type: float
  ///
  /// units: mm
  ///
  /// focal_length
  final float focalLength;

  /// Image sensor size horizontal. Use NaN if not known.
  ///
  /// MAVLink type: float
  ///
  /// units: mm
  ///
  /// sensor_size_h
  final float sensorSizeH;

  /// Image sensor size vertical. Use NaN if not known.
  ///
  /// MAVLink type: float
  ///
  /// units: mm
  ///
  /// sensor_size_v
  final float sensorSizeV;

  /// Bitmap of camera capability flags.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [CameraCapFlags]
  ///
  /// flags
  final CameraCapFlags flags;

  /// Horizontal image resolution. Use 0 if not known.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: pix
  ///
  /// resolution_h
  final uint16_t resolutionH;

  /// Vertical image resolution. Use 0 if not known.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: pix
  ///
  /// resolution_v
  final uint16_t resolutionV;

  /// Camera definition version (iteration).  Use 0 if not known.
  ///
  /// MAVLink type: uint16_t
  ///
  /// cam_definition_version
  final uint16_t camDefinitionVersion;

  /// Name of the camera vendor
  ///
  /// MAVLink type: uint8_t[32]
  ///
  /// vendor_name
  final List<int8_t> vendorName;

  /// Name of the camera model
  ///
  /// MAVLink type: uint8_t[32]
  ///
  /// model_name
  final List<int8_t> modelName;

  /// Reserved for a lens ID.  Use 0 if not known.
  ///
  /// MAVLink type: uint8_t
  ///
  /// lens_id
  final uint8_t lensId;

  /// Camera definition URI (if any, otherwise only basic functions will be available). HTTP- (http://) and MAVLink FTP- (mavlinkftp://) formatted URIs are allowed (and both must be supported by any GCS that implements the Camera Protocol). The definition file may be xz compressed, which will be indicated by the file extension .xml.xz (a GCS that implements the protocol must support decompressing the file). The string needs to be zero terminated.  Use a zero-length string if not known.
  ///
  /// MAVLink type: char[140]
  ///
  /// cam_definition_uri
  final List<char> camDefinitionUri;

  /// Gimbal id of a gimbal associated with this camera. This is the component id of the gimbal device, or 1-6 for non mavlink gimbals. Use 0 if no gimbal is associated with the camera.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// gimbal_device_id
  final uint8_t gimbalDeviceId;

  /// Camera id of a non-MAVLink camera attached to an autopilot (1-6).  0 if the component is a MAVLink camera (with its own component id).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// camera_device_id
  final uint8_t cameraDeviceId;

  CameraInformation({
    required this.timeBootMs,
    required this.firmwareVersion,
    required this.focalLength,
    required this.sensorSizeH,
    required this.sensorSizeV,
    required this.flags,
    required this.resolutionH,
    required this.resolutionV,
    required this.camDefinitionVersion,
    required this.vendorName,
    required this.modelName,
    required this.lensId,
    required this.camDefinitionUri,
    required this.gimbalDeviceId,
    required this.cameraDeviceId,
  });

  CameraInformation copyWith({
    uint32_t? timeBootMs,
    uint32_t? firmwareVersion,
    float? focalLength,
    float? sensorSizeH,
    float? sensorSizeV,
    CameraCapFlags? flags,
    uint16_t? resolutionH,
    uint16_t? resolutionV,
    uint16_t? camDefinitionVersion,
    List<int8_t>? vendorName,
    List<int8_t>? modelName,
    uint8_t? lensId,
    List<char>? camDefinitionUri,
    uint8_t? gimbalDeviceId,
    uint8_t? cameraDeviceId,
  }) {
    return CameraInformation(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      firmwareVersion: firmwareVersion ?? this.firmwareVersion,
      focalLength: focalLength ?? this.focalLength,
      sensorSizeH: sensorSizeH ?? this.sensorSizeH,
      sensorSizeV: sensorSizeV ?? this.sensorSizeV,
      flags: flags ?? this.flags,
      resolutionH: resolutionH ?? this.resolutionH,
      resolutionV: resolutionV ?? this.resolutionV,
      camDefinitionVersion: camDefinitionVersion ?? this.camDefinitionVersion,
      vendorName: vendorName ?? this.vendorName,
      modelName: modelName ?? this.modelName,
      lensId: lensId ?? this.lensId,
      camDefinitionUri: camDefinitionUri ?? this.camDefinitionUri,
      gimbalDeviceId: gimbalDeviceId ?? this.gimbalDeviceId,
      cameraDeviceId: cameraDeviceId ?? this.cameraDeviceId,
    );
  }

  factory CameraInformation.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraInformation.mavlinkEncodedLength) {
      var len = CameraInformation.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var firmwareVersion = data_.getUint32(4, Endian.little);
    var focalLength = data_.getFloat32(8, Endian.little);
    var sensorSizeH = data_.getFloat32(12, Endian.little);
    var sensorSizeV = data_.getFloat32(16, Endian.little);
    var flags = data_.getUint32(20, Endian.little);
    var resolutionH = data_.getUint16(24, Endian.little);
    var resolutionV = data_.getUint16(26, Endian.little);
    var camDefinitionVersion = data_.getUint16(28, Endian.little);
    var vendorName = MavlinkMessage.asUint8List(data_, 30, 32);
    var modelName = MavlinkMessage.asUint8List(data_, 62, 32);
    var lensId = data_.getUint8(94);
    var camDefinitionUri = MavlinkMessage.asInt8List(data_, 95, 140);
    var gimbalDeviceId = data_.getUint8(235);
    var cameraDeviceId = data_.getUint8(236);

    return CameraInformation(
        timeBootMs: timeBootMs,
        firmwareVersion: firmwareVersion,
        focalLength: focalLength,
        sensorSizeH: sensorSizeH,
        sensorSizeV: sensorSizeV,
        flags: flags,
        resolutionH: resolutionH,
        resolutionV: resolutionV,
        camDefinitionVersion: camDefinitionVersion,
        vendorName: vendorName,
        modelName: modelName,
        lensId: lensId,
        camDefinitionUri: camDefinitionUri,
        gimbalDeviceId: gimbalDeviceId,
        cameraDeviceId: cameraDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint32(4, firmwareVersion, Endian.little);
    data_.setFloat32(8, focalLength, Endian.little);
    data_.setFloat32(12, sensorSizeH, Endian.little);
    data_.setFloat32(16, sensorSizeV, Endian.little);
    data_.setUint32(20, flags, Endian.little);
    data_.setUint16(24, resolutionH, Endian.little);
    data_.setUint16(26, resolutionV, Endian.little);
    data_.setUint16(28, camDefinitionVersion, Endian.little);
    MavlinkMessage.setUint8List(data_, 30, vendorName);
    MavlinkMessage.setUint8List(data_, 62, modelName);
    data_.setUint8(94, lensId);
    MavlinkMessage.setInt8List(data_, 95, camDefinitionUri);
    data_.setUint8(235, gimbalDeviceId);
    data_.setUint8(236, cameraDeviceId);
    return data_;
  }
}

/// Settings of a camera. Can be requested with a MAV_CMD_REQUEST_MESSAGE command.
///
/// CAMERA_SETTINGS
class CameraSettings implements MavlinkMessage {
  static const int _mavlinkMessageId = 260;

  static const int _mavlinkCrcExtra = 146;

  static const int mavlinkEncodedLength = 14;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Camera mode
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CameraMode]
  ///
  /// mode_id
  final CameraMode modeId;

  /// Current zoom level as a percentage of the full range (0.0 to 100.0, NaN if not known)
  ///
  /// MAVLink type: float
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// zoomLevel
  final float zoomlevel;

  /// Current focus level as a percentage of the full range (0.0 to 100.0, NaN if not known)
  ///
  /// MAVLink type: float
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// focusLevel
  final float focuslevel;

  /// Camera id of a non-MAVLink camera attached to an autopilot (1-6).  0 if the component is a MAVLink camera (with its own component id).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// camera_device_id
  final uint8_t cameraDeviceId;

  CameraSettings({
    required this.timeBootMs,
    required this.modeId,
    required this.zoomlevel,
    required this.focuslevel,
    required this.cameraDeviceId,
  });

  CameraSettings copyWith({
    uint32_t? timeBootMs,
    CameraMode? modeId,
    float? zoomlevel,
    float? focuslevel,
    uint8_t? cameraDeviceId,
  }) {
    return CameraSettings(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      modeId: modeId ?? this.modeId,
      zoomlevel: zoomlevel ?? this.zoomlevel,
      focuslevel: focuslevel ?? this.focuslevel,
      cameraDeviceId: cameraDeviceId ?? this.cameraDeviceId,
    );
  }

  factory CameraSettings.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraSettings.mavlinkEncodedLength) {
      var len = CameraSettings.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var modeId = data_.getUint8(4);
    var zoomlevel = data_.getFloat32(5, Endian.little);
    var focuslevel = data_.getFloat32(9, Endian.little);
    var cameraDeviceId = data_.getUint8(13);

    return CameraSettings(
        timeBootMs: timeBootMs,
        modeId: modeId,
        zoomlevel: zoomlevel,
        focuslevel: focuslevel,
        cameraDeviceId: cameraDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint8(4, modeId);
    data_.setFloat32(5, zoomlevel, Endian.little);
    data_.setFloat32(9, focuslevel, Endian.little);
    data_.setUint8(13, cameraDeviceId);
    return data_;
  }
}

/// Information about a storage medium. This message is sent in response to a request with MAV_CMD_REQUEST_MESSAGE and whenever the status of the storage changes (STORAGE_STATUS). Use MAV_CMD_REQUEST_MESSAGE.param2 to indicate the index/id of requested storage: 0 for all, 1 for first, 2 for second, etc.
///
/// STORAGE_INFORMATION
class StorageInformation implements MavlinkMessage {
  static const int _mavlinkMessageId = 261;

  static const int _mavlinkCrcExtra = 179;

  static const int mavlinkEncodedLength = 61;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Total capacity. If storage is not ready (STORAGE_STATUS_READY) value will be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: MiB
  ///
  /// total_capacity
  final float totalCapacity;

  /// Used capacity. If storage is not ready (STORAGE_STATUS_READY) value will be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: MiB
  ///
  /// used_capacity
  final float usedCapacity;

  /// Available storage capacity. If storage is not ready (STORAGE_STATUS_READY) value will be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: MiB
  ///
  /// available_capacity
  final float availableCapacity;

  /// Read speed.
  ///
  /// MAVLink type: float
  ///
  /// units: MiB/s
  ///
  /// read_speed
  final float readSpeed;

  /// Write speed.
  ///
  /// MAVLink type: float
  ///
  /// units: MiB/s
  ///
  /// write_speed
  final float writeSpeed;

  /// Storage ID (1 for first, 2 for second, etc.)
  ///
  /// MAVLink type: uint8_t
  ///
  /// storage_id
  final uint8_t storageId;

  /// Number of storage devices
  ///
  /// MAVLink type: uint8_t
  ///
  /// storage_count
  final uint8_t storageCount;

  /// Status of storage
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [StorageStatus]
  ///
  /// status
  final StorageStatus status;

  /// Type of storage
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [StorageType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// type
  final StorageType type;

  /// Textual storage name to be used in UI (microSD 1, Internal Memory, etc.) This is a NULL terminated string. If it is exactly 32 characters long, add a terminating NULL. If this string is empty, the generic type is shown to the user.
  ///
  /// MAVLink type: char[32]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// name
  final List<char> name;

  /// Flags indicating whether this instance is preferred storage for photos, videos, etc.
  /// Note: Implementations should initially set the flags on the system-default storage id used for saving media (if possible/supported).
  /// This setting can then be overridden using MAV_CMD_SET_STORAGE_USAGE.
  /// If the media usage flags are not set, a GCS may assume storage ID 1 is the default storage for all media types.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [StorageUsageFlag]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// storage_usage
  final StorageUsageFlag storageUsage;

  StorageInformation({
    required this.timeBootMs,
    required this.totalCapacity,
    required this.usedCapacity,
    required this.availableCapacity,
    required this.readSpeed,
    required this.writeSpeed,
    required this.storageId,
    required this.storageCount,
    required this.status,
    required this.type,
    required this.name,
    required this.storageUsage,
  });

  StorageInformation copyWith({
    uint32_t? timeBootMs,
    float? totalCapacity,
    float? usedCapacity,
    float? availableCapacity,
    float? readSpeed,
    float? writeSpeed,
    uint8_t? storageId,
    uint8_t? storageCount,
    StorageStatus? status,
    StorageType? type,
    List<char>? name,
    StorageUsageFlag? storageUsage,
  }) {
    return StorageInformation(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      totalCapacity: totalCapacity ?? this.totalCapacity,
      usedCapacity: usedCapacity ?? this.usedCapacity,
      availableCapacity: availableCapacity ?? this.availableCapacity,
      readSpeed: readSpeed ?? this.readSpeed,
      writeSpeed: writeSpeed ?? this.writeSpeed,
      storageId: storageId ?? this.storageId,
      storageCount: storageCount ?? this.storageCount,
      status: status ?? this.status,
      type: type ?? this.type,
      name: name ?? this.name,
      storageUsage: storageUsage ?? this.storageUsage,
    );
  }

  factory StorageInformation.parse(ByteData data_) {
    if (data_.lengthInBytes < StorageInformation.mavlinkEncodedLength) {
      var len = StorageInformation.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var totalCapacity = data_.getFloat32(4, Endian.little);
    var usedCapacity = data_.getFloat32(8, Endian.little);
    var availableCapacity = data_.getFloat32(12, Endian.little);
    var readSpeed = data_.getFloat32(16, Endian.little);
    var writeSpeed = data_.getFloat32(20, Endian.little);
    var storageId = data_.getUint8(24);
    var storageCount = data_.getUint8(25);
    var status = data_.getUint8(26);
    var type = data_.getUint8(27);
    var name = MavlinkMessage.asInt8List(data_, 28, 32);
    var storageUsage = data_.getUint8(60);

    return StorageInformation(
        timeBootMs: timeBootMs,
        totalCapacity: totalCapacity,
        usedCapacity: usedCapacity,
        availableCapacity: availableCapacity,
        readSpeed: readSpeed,
        writeSpeed: writeSpeed,
        storageId: storageId,
        storageCount: storageCount,
        status: status,
        type: type,
        name: name,
        storageUsage: storageUsage);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, totalCapacity, Endian.little);
    data_.setFloat32(8, usedCapacity, Endian.little);
    data_.setFloat32(12, availableCapacity, Endian.little);
    data_.setFloat32(16, readSpeed, Endian.little);
    data_.setFloat32(20, writeSpeed, Endian.little);
    data_.setUint8(24, storageId);
    data_.setUint8(25, storageCount);
    data_.setUint8(26, status);
    data_.setUint8(27, type);
    MavlinkMessage.setInt8List(data_, 28, name);
    data_.setUint8(60, storageUsage);
    return data_;
  }
}

/// Information about the status of a capture. Can be requested with a MAV_CMD_REQUEST_MESSAGE command.
///
/// CAMERA_CAPTURE_STATUS
class CameraCaptureStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 262;

  static const int _mavlinkCrcExtra = 12;

  static const int mavlinkEncodedLength = 23;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Image capture interval
  ///
  /// MAVLink type: float
  ///
  /// units: s
  ///
  /// image_interval
  final float imageInterval;

  /// Elapsed time since recording started (0: Not supported/available). A GCS should compute recording time and use non-zero values of this field to correct any discrepancy.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// recording_time_ms
  final uint32_t recordingTimeMs;

  /// Available storage capacity.
  ///
  /// MAVLink type: float
  ///
  /// units: MiB
  ///
  /// available_capacity
  final float availableCapacity;

  /// Current status of image capturing (0: idle, 1: capture in progress, 2: interval set but idle, 3: interval set and capture in progress)
  ///
  /// MAVLink type: uint8_t
  ///
  /// image_status
  final uint8_t imageStatus;

  /// Current status of video capturing (0: idle, 1: capture in progress)
  ///
  /// MAVLink type: uint8_t
  ///
  /// video_status
  final uint8_t videoStatus;

  /// Total number of images captured ('forever', or until reset using MAV_CMD_STORAGE_FORMAT).
  ///
  /// MAVLink type: int32_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// image_count
  final int32_t imageCount;

  /// Camera id of a non-MAVLink camera attached to an autopilot (1-6).  0 if the component is a MAVLink camera (with its own component id).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// camera_device_id
  final uint8_t cameraDeviceId;

  CameraCaptureStatus({
    required this.timeBootMs,
    required this.imageInterval,
    required this.recordingTimeMs,
    required this.availableCapacity,
    required this.imageStatus,
    required this.videoStatus,
    required this.imageCount,
    required this.cameraDeviceId,
  });

  CameraCaptureStatus copyWith({
    uint32_t? timeBootMs,
    float? imageInterval,
    uint32_t? recordingTimeMs,
    float? availableCapacity,
    uint8_t? imageStatus,
    uint8_t? videoStatus,
    int32_t? imageCount,
    uint8_t? cameraDeviceId,
  }) {
    return CameraCaptureStatus(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      imageInterval: imageInterval ?? this.imageInterval,
      recordingTimeMs: recordingTimeMs ?? this.recordingTimeMs,
      availableCapacity: availableCapacity ?? this.availableCapacity,
      imageStatus: imageStatus ?? this.imageStatus,
      videoStatus: videoStatus ?? this.videoStatus,
      imageCount: imageCount ?? this.imageCount,
      cameraDeviceId: cameraDeviceId ?? this.cameraDeviceId,
    );
  }

  factory CameraCaptureStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraCaptureStatus.mavlinkEncodedLength) {
      var len = CameraCaptureStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var imageInterval = data_.getFloat32(4, Endian.little);
    var recordingTimeMs = data_.getUint32(8, Endian.little);
    var availableCapacity = data_.getFloat32(12, Endian.little);
    var imageStatus = data_.getUint8(16);
    var videoStatus = data_.getUint8(17);
    var imageCount = data_.getInt32(18, Endian.little);
    var cameraDeviceId = data_.getUint8(22);

    return CameraCaptureStatus(
        timeBootMs: timeBootMs,
        imageInterval: imageInterval,
        recordingTimeMs: recordingTimeMs,
        availableCapacity: availableCapacity,
        imageStatus: imageStatus,
        videoStatus: videoStatus,
        imageCount: imageCount,
        cameraDeviceId: cameraDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, imageInterval, Endian.little);
    data_.setUint32(8, recordingTimeMs, Endian.little);
    data_.setFloat32(12, availableCapacity, Endian.little);
    data_.setUint8(16, imageStatus);
    data_.setUint8(17, videoStatus);
    data_.setInt32(18, imageCount, Endian.little);
    data_.setUint8(22, cameraDeviceId);
    return data_;
  }
}

/// Information about a captured image. This is emitted every time a message is captured.
/// MAV_CMD_REQUEST_MESSAGE can be used to (re)request this message for a specific sequence number or range of sequence numbers:
/// MAV_CMD_REQUEST_MESSAGE.param2 indicates the sequence number the first image to send, or set to -1 to send the message for all sequence numbers.
/// MAV_CMD_REQUEST_MESSAGE.param3 is used to specify a range of messages to send:
/// set to 0 (default) to send just the the message for the sequence number in param 2,
/// set to -1 to send the message for the sequence number in param 2 and all the following sequence numbers,
/// set to the sequence number of the final message in the range.
///
/// CAMERA_IMAGE_CAPTURED
class CameraImageCaptured implements MavlinkMessage {
  static const int _mavlinkMessageId = 263;

  static const int _mavlinkCrcExtra = 133;

  static const int mavlinkEncodedLength = 255;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since UNIX epoch) in UTC. 0 for unknown.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_utc
  final uint64_t timeUtc;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Latitude where image was taken
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude where capture was taken
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude (MSL) where image was taken
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt
  final int32_t alt;

  /// Altitude above ground
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// relative_alt
  final int32_t relativeAlt;

  /// Quaternion of camera orientation (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// Zero based index of this image (i.e. a new image will have index CAMERA_CAPTURE_STATUS.image count -1)
  ///
  /// MAVLink type: int32_t
  ///
  /// image_index
  final int32_t imageIndex;

  /// Deprecated/unused. Component IDs are used to differentiate multiple cameras.
  ///
  /// MAVLink type: uint8_t
  ///
  /// camera_id
  final uint8_t cameraId;

  /// Boolean indicating success (1) or failure (0) while capturing this image.
  ///
  /// MAVLink type: int8_t
  ///
  /// capture_result
  final int8_t captureResult;

  /// URL of image taken. Either local storage or http://foo.jpg if camera provides an HTTP interface.
  ///
  /// MAVLink type: char[205]
  ///
  /// file_url
  final List<char> fileUrl;

  CameraImageCaptured({
    required this.timeUtc,
    required this.timeBootMs,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.relativeAlt,
    required this.q,
    required this.imageIndex,
    required this.cameraId,
    required this.captureResult,
    required this.fileUrl,
  });

  CameraImageCaptured copyWith({
    uint64_t? timeUtc,
    uint32_t? timeBootMs,
    int32_t? lat,
    int32_t? lon,
    int32_t? alt,
    int32_t? relativeAlt,
    List<float>? q,
    int32_t? imageIndex,
    uint8_t? cameraId,
    int8_t? captureResult,
    List<char>? fileUrl,
  }) {
    return CameraImageCaptured(
      timeUtc: timeUtc ?? this.timeUtc,
      timeBootMs: timeBootMs ?? this.timeBootMs,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      relativeAlt: relativeAlt ?? this.relativeAlt,
      q: q ?? this.q,
      imageIndex: imageIndex ?? this.imageIndex,
      cameraId: cameraId ?? this.cameraId,
      captureResult: captureResult ?? this.captureResult,
      fileUrl: fileUrl ?? this.fileUrl,
    );
  }

  factory CameraImageCaptured.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraImageCaptured.mavlinkEncodedLength) {
      var len = CameraImageCaptured.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUtc = data_.getUint64(0, Endian.little);
    var timeBootMs = data_.getUint32(8, Endian.little);
    var lat = data_.getInt32(12, Endian.little);
    var lon = data_.getInt32(16, Endian.little);
    var alt = data_.getInt32(20, Endian.little);
    var relativeAlt = data_.getInt32(24, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 28, 4);
    var imageIndex = data_.getInt32(44, Endian.little);
    var cameraId = data_.getUint8(48);
    var captureResult = data_.getInt8(49);
    var fileUrl = MavlinkMessage.asInt8List(data_, 50, 205);

    return CameraImageCaptured(
        timeUtc: timeUtc,
        timeBootMs: timeBootMs,
        lat: lat,
        lon: lon,
        alt: alt,
        relativeAlt: relativeAlt,
        q: q,
        imageIndex: imageIndex,
        cameraId: cameraId,
        captureResult: captureResult,
        fileUrl: fileUrl);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUtc, Endian.little);
    data_.setUint32(8, timeBootMs, Endian.little);
    data_.setInt32(12, lat, Endian.little);
    data_.setInt32(16, lon, Endian.little);
    data_.setInt32(20, alt, Endian.little);
    data_.setInt32(24, relativeAlt, Endian.little);
    MavlinkMessage.setFloat32List(data_, 28, q);
    data_.setInt32(44, imageIndex, Endian.little);
    data_.setUint8(48, cameraId);
    data_.setInt8(49, captureResult);
    MavlinkMessage.setInt8List(data_, 50, fileUrl);
    return data_;
  }
}

/// Flight information.
/// This includes time since boot for arm, takeoff, and land, and a flight number.
/// Takeoff and landing values reset to zero on arm.
/// This can be requested using MAV_CMD_REQUEST_MESSAGE.
/// Note, some fields are misnamed - timestamps are from boot (not UTC) and the flight_uuid is a sequence number.
///
///
/// FLIGHT_INFORMATION
class FlightInformation implements MavlinkMessage {
  static const int _mavlinkMessageId = 264;

  static const int _mavlinkCrcExtra = 49;

  static const int mavlinkEncodedLength = 32;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp at arming (since system boot). Set to 0 on boot. Set value on arming. Note, field is misnamed UTC.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// arming_time_utc
  final uint64_t armingTimeUtc;

  /// Timestamp at takeoff (since system boot). Set to 0 at boot and on arming. Note, field is misnamed UTC.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// takeoff_time_utc
  final uint64_t takeoffTimeUtc;

  /// Flight number. Note, field is misnamed UUID.
  ///
  /// MAVLink type: uint64_t
  ///
  /// flight_uuid
  final uint64_t flightUuid;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Timestamp at landing (in ms since system boot). Set to 0 at boot and on arming.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// landing_time
  final uint32_t landingTime;

  FlightInformation({
    required this.armingTimeUtc,
    required this.takeoffTimeUtc,
    required this.flightUuid,
    required this.timeBootMs,
    required this.landingTime,
  });

  FlightInformation copyWith({
    uint64_t? armingTimeUtc,
    uint64_t? takeoffTimeUtc,
    uint64_t? flightUuid,
    uint32_t? timeBootMs,
    uint32_t? landingTime,
  }) {
    return FlightInformation(
      armingTimeUtc: armingTimeUtc ?? this.armingTimeUtc,
      takeoffTimeUtc: takeoffTimeUtc ?? this.takeoffTimeUtc,
      flightUuid: flightUuid ?? this.flightUuid,
      timeBootMs: timeBootMs ?? this.timeBootMs,
      landingTime: landingTime ?? this.landingTime,
    );
  }

  factory FlightInformation.parse(ByteData data_) {
    if (data_.lengthInBytes < FlightInformation.mavlinkEncodedLength) {
      var len = FlightInformation.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var armingTimeUtc = data_.getUint64(0, Endian.little);
    var takeoffTimeUtc = data_.getUint64(8, Endian.little);
    var flightUuid = data_.getUint64(16, Endian.little);
    var timeBootMs = data_.getUint32(24, Endian.little);
    var landingTime = data_.getUint32(28, Endian.little);

    return FlightInformation(
        armingTimeUtc: armingTimeUtc,
        takeoffTimeUtc: takeoffTimeUtc,
        flightUuid: flightUuid,
        timeBootMs: timeBootMs,
        landingTime: landingTime);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, armingTimeUtc, Endian.little);
    data_.setUint64(8, takeoffTimeUtc, Endian.little);
    data_.setUint64(16, flightUuid, Endian.little);
    data_.setUint32(24, timeBootMs, Endian.little);
    data_.setUint32(28, landingTime, Endian.little);
    return data_;
  }
}

/// Orientation of a mount
///
/// MOUNT_ORIENTATION
class MountOrientation implements MavlinkMessage {
  static const int _mavlinkMessageId = 265;

  static const int _mavlinkCrcExtra = 26;

  static const int mavlinkEncodedLength = 20;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Roll in global frame (set to NaN for invalid).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// roll
  final float roll;

  /// Pitch in global frame (set to NaN for invalid).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// pitch
  final float pitch;

  /// Yaw relative to vehicle (set to NaN for invalid).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// yaw
  final float yaw;

  /// Yaw in absolute frame relative to Earth's North, north is 0 (set to NaN for invalid).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// yaw_absolute
  final float yawAbsolute;

  MountOrientation({
    required this.timeBootMs,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.yawAbsolute,
  });

  MountOrientation copyWith({
    uint32_t? timeBootMs,
    float? roll,
    float? pitch,
    float? yaw,
    float? yawAbsolute,
  }) {
    return MountOrientation(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      yawAbsolute: yawAbsolute ?? this.yawAbsolute,
    );
  }

  factory MountOrientation.parse(ByteData data_) {
    if (data_.lengthInBytes < MountOrientation.mavlinkEncodedLength) {
      var len = MountOrientation.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var roll = data_.getFloat32(4, Endian.little);
    var pitch = data_.getFloat32(8, Endian.little);
    var yaw = data_.getFloat32(12, Endian.little);
    var yawAbsolute = data_.getFloat32(16, Endian.little);

    return MountOrientation(
        timeBootMs: timeBootMs,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        yawAbsolute: yawAbsolute);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, roll, Endian.little);
    data_.setFloat32(8, pitch, Endian.little);
    data_.setFloat32(12, yaw, Endian.little);
    data_.setFloat32(16, yawAbsolute, Endian.little);
    return data_;
  }
}

/// A message containing logged data (see also MAV_CMD_LOGGING_START)
///
/// LOGGING_DATA
class LoggingData implements MavlinkMessage {
  static const int _mavlinkMessageId = 266;

  static const int _mavlinkCrcExtra = 193;

  static const int mavlinkEncodedLength = 255;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// sequence number (can wrap)
  ///
  /// MAVLink type: uint16_t
  ///
  /// sequence
  final uint16_t sequence;

  /// system ID of the target
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// component ID of the target
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// data length
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// length
  final uint8_t length;

  /// offset into data where first message starts. This can be used for recovery, when a previous message got lost (set to UINT8_MAX if no start exists).
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// first_message_offset
  final uint8_t firstMessageOffset;

  /// logged data
  ///
  /// MAVLink type: uint8_t[249]
  ///
  /// data
  final List<int8_t> data;

  LoggingData({
    required this.sequence,
    required this.targetSystem,
    required this.targetComponent,
    required this.length,
    required this.firstMessageOffset,
    required this.data,
  });

  LoggingData copyWith({
    uint16_t? sequence,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? length,
    uint8_t? firstMessageOffset,
    List<int8_t>? data,
  }) {
    return LoggingData(
      sequence: sequence ?? this.sequence,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      length: length ?? this.length,
      firstMessageOffset: firstMessageOffset ?? this.firstMessageOffset,
      data: data ?? this.data,
    );
  }

  factory LoggingData.parse(ByteData data_) {
    if (data_.lengthInBytes < LoggingData.mavlinkEncodedLength) {
      var len = LoggingData.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var sequence = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);
    var length = data_.getUint8(4);
    var firstMessageOffset = data_.getUint8(5);
    var data = MavlinkMessage.asUint8List(data_, 6, 249);

    return LoggingData(
        sequence: sequence,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        length: length,
        firstMessageOffset: firstMessageOffset,
        data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, sequence, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    data_.setUint8(4, length);
    data_.setUint8(5, firstMessageOffset);
    MavlinkMessage.setUint8List(data_, 6, data);
    return data_;
  }
}

/// A message containing logged data which requires a LOGGING_ACK to be sent back
///
/// LOGGING_DATA_ACKED
class LoggingDataAcked implements MavlinkMessage {
  static const int _mavlinkMessageId = 267;

  static const int _mavlinkCrcExtra = 35;

  static const int mavlinkEncodedLength = 255;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// sequence number (can wrap)
  ///
  /// MAVLink type: uint16_t
  ///
  /// sequence
  final uint16_t sequence;

  /// system ID of the target
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// component ID of the target
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// data length
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// length
  final uint8_t length;

  /// offset into data where first message starts. This can be used for recovery, when a previous message got lost (set to UINT8_MAX if no start exists).
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// first_message_offset
  final uint8_t firstMessageOffset;

  /// logged data
  ///
  /// MAVLink type: uint8_t[249]
  ///
  /// data
  final List<int8_t> data;

  LoggingDataAcked({
    required this.sequence,
    required this.targetSystem,
    required this.targetComponent,
    required this.length,
    required this.firstMessageOffset,
    required this.data,
  });

  LoggingDataAcked copyWith({
    uint16_t? sequence,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? length,
    uint8_t? firstMessageOffset,
    List<int8_t>? data,
  }) {
    return LoggingDataAcked(
      sequence: sequence ?? this.sequence,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      length: length ?? this.length,
      firstMessageOffset: firstMessageOffset ?? this.firstMessageOffset,
      data: data ?? this.data,
    );
  }

  factory LoggingDataAcked.parse(ByteData data_) {
    if (data_.lengthInBytes < LoggingDataAcked.mavlinkEncodedLength) {
      var len = LoggingDataAcked.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var sequence = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);
    var length = data_.getUint8(4);
    var firstMessageOffset = data_.getUint8(5);
    var data = MavlinkMessage.asUint8List(data_, 6, 249);

    return LoggingDataAcked(
        sequence: sequence,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        length: length,
        firstMessageOffset: firstMessageOffset,
        data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, sequence, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    data_.setUint8(4, length);
    data_.setUint8(5, firstMessageOffset);
    MavlinkMessage.setUint8List(data_, 6, data);
    return data_;
  }
}

/// An ack for a LOGGING_DATA_ACKED message
///
/// LOGGING_ACK
class LoggingAck implements MavlinkMessage {
  static const int _mavlinkMessageId = 268;

  static const int _mavlinkCrcExtra = 14;

  static const int mavlinkEncodedLength = 4;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// sequence number (must match the one in LOGGING_DATA_ACKED)
  ///
  /// MAVLink type: uint16_t
  ///
  /// sequence
  final uint16_t sequence;

  /// system ID of the target
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// component ID of the target
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  LoggingAck({
    required this.sequence,
    required this.targetSystem,
    required this.targetComponent,
  });

  LoggingAck copyWith({
    uint16_t? sequence,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return LoggingAck(
      sequence: sequence ?? this.sequence,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory LoggingAck.parse(ByteData data_) {
    if (data_.lengthInBytes < LoggingAck.mavlinkEncodedLength) {
      var len = LoggingAck.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var sequence = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);

    return LoggingAck(
        sequence: sequence,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, sequence, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    return data_;
  }
}

/// Information about video stream. It may be requested using MAV_CMD_REQUEST_MESSAGE, where param2 indicates the video stream id: 0 for all streams, 1 for first, 2 for second, etc.
///
/// VIDEO_STREAM_INFORMATION
class VideoStreamInformation implements MavlinkMessage {
  static const int _mavlinkMessageId = 269;

  static const int _mavlinkCrcExtra = 109;

  static const int mavlinkEncodedLength = 215;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Frame rate.
  ///
  /// MAVLink type: float
  ///
  /// units: Hz
  ///
  /// framerate
  final float framerate;

  /// Bit rate.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bits/s
  ///
  /// bitrate
  final uint32_t bitrate;

  /// Bitmap of stream status flags.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [VideoStreamStatusFlags]
  ///
  /// flags
  final VideoStreamStatusFlags flags;

  /// Horizontal resolution.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: pix
  ///
  /// resolution_h
  final uint16_t resolutionH;

  /// Vertical resolution.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: pix
  ///
  /// resolution_v
  final uint16_t resolutionV;

  /// Video image rotation clockwise.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: deg
  ///
  /// rotation
  final uint16_t rotation;

  /// Horizontal Field of view.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: deg
  ///
  /// hfov
  final uint16_t hfov;

  /// Video Stream ID (1 for first, 2 for second, etc.)
  ///
  /// MAVLink type: uint8_t
  ///
  /// stream_id
  final uint8_t streamId;

  /// Number of streams available.
  ///
  /// MAVLink type: uint8_t
  ///
  /// count
  final uint8_t count;

  /// Type of stream.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [VideoStreamType]
  ///
  /// type
  final VideoStreamType type;

  /// Stream name.
  ///
  /// MAVLink type: char[32]
  ///
  /// name
  final List<char> name;

  /// Video stream URI (TCP or RTSP URI ground station should connect to) or port number (UDP port ground station should listen to).
  ///
  /// MAVLink type: char[160]
  ///
  /// uri
  final List<char> uri;

  /// Encoding of stream.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [VideoStreamEncoding]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// encoding
  final VideoStreamEncoding encoding;

  /// Camera id of a non-MAVLink camera attached to an autopilot (1-6).  0 if the component is a MAVLink camera (with its own component id).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// camera_device_id
  final uint8_t cameraDeviceId;

  VideoStreamInformation({
    required this.framerate,
    required this.bitrate,
    required this.flags,
    required this.resolutionH,
    required this.resolutionV,
    required this.rotation,
    required this.hfov,
    required this.streamId,
    required this.count,
    required this.type,
    required this.name,
    required this.uri,
    required this.encoding,
    required this.cameraDeviceId,
  });

  VideoStreamInformation copyWith({
    float? framerate,
    uint32_t? bitrate,
    VideoStreamStatusFlags? flags,
    uint16_t? resolutionH,
    uint16_t? resolutionV,
    uint16_t? rotation,
    uint16_t? hfov,
    uint8_t? streamId,
    uint8_t? count,
    VideoStreamType? type,
    List<char>? name,
    List<char>? uri,
    VideoStreamEncoding? encoding,
    uint8_t? cameraDeviceId,
  }) {
    return VideoStreamInformation(
      framerate: framerate ?? this.framerate,
      bitrate: bitrate ?? this.bitrate,
      flags: flags ?? this.flags,
      resolutionH: resolutionH ?? this.resolutionH,
      resolutionV: resolutionV ?? this.resolutionV,
      rotation: rotation ?? this.rotation,
      hfov: hfov ?? this.hfov,
      streamId: streamId ?? this.streamId,
      count: count ?? this.count,
      type: type ?? this.type,
      name: name ?? this.name,
      uri: uri ?? this.uri,
      encoding: encoding ?? this.encoding,
      cameraDeviceId: cameraDeviceId ?? this.cameraDeviceId,
    );
  }

  factory VideoStreamInformation.parse(ByteData data_) {
    if (data_.lengthInBytes < VideoStreamInformation.mavlinkEncodedLength) {
      var len =
          VideoStreamInformation.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var framerate = data_.getFloat32(0, Endian.little);
    var bitrate = data_.getUint32(4, Endian.little);
    var flags = data_.getUint16(8, Endian.little);
    var resolutionH = data_.getUint16(10, Endian.little);
    var resolutionV = data_.getUint16(12, Endian.little);
    var rotation = data_.getUint16(14, Endian.little);
    var hfov = data_.getUint16(16, Endian.little);
    var streamId = data_.getUint8(18);
    var count = data_.getUint8(19);
    var type = data_.getUint8(20);
    var name = MavlinkMessage.asInt8List(data_, 21, 32);
    var uri = MavlinkMessage.asInt8List(data_, 53, 160);
    var encoding = data_.getUint8(213);
    var cameraDeviceId = data_.getUint8(214);

    return VideoStreamInformation(
        framerate: framerate,
        bitrate: bitrate,
        flags: flags,
        resolutionH: resolutionH,
        resolutionV: resolutionV,
        rotation: rotation,
        hfov: hfov,
        streamId: streamId,
        count: count,
        type: type,
        name: name,
        uri: uri,
        encoding: encoding,
        cameraDeviceId: cameraDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, framerate, Endian.little);
    data_.setUint32(4, bitrate, Endian.little);
    data_.setUint16(8, flags, Endian.little);
    data_.setUint16(10, resolutionH, Endian.little);
    data_.setUint16(12, resolutionV, Endian.little);
    data_.setUint16(14, rotation, Endian.little);
    data_.setUint16(16, hfov, Endian.little);
    data_.setUint8(18, streamId);
    data_.setUint8(19, count);
    data_.setUint8(20, type);
    MavlinkMessage.setInt8List(data_, 21, name);
    MavlinkMessage.setInt8List(data_, 53, uri);
    data_.setUint8(213, encoding);
    data_.setUint8(214, cameraDeviceId);
    return data_;
  }
}

/// Information about the status of a video stream. It may be requested using MAV_CMD_REQUEST_MESSAGE.
///
/// VIDEO_STREAM_STATUS
class VideoStreamStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 270;

  static const int _mavlinkCrcExtra = 59;

  static const int mavlinkEncodedLength = 20;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Frame rate
  ///
  /// MAVLink type: float
  ///
  /// units: Hz
  ///
  /// framerate
  final float framerate;

  /// Bit rate
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bits/s
  ///
  /// bitrate
  final uint32_t bitrate;

  /// Bitmap of stream status flags
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [VideoStreamStatusFlags]
  ///
  /// flags
  final VideoStreamStatusFlags flags;

  /// Horizontal resolution
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: pix
  ///
  /// resolution_h
  final uint16_t resolutionH;

  /// Vertical resolution
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: pix
  ///
  /// resolution_v
  final uint16_t resolutionV;

  /// Video image rotation clockwise
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: deg
  ///
  /// rotation
  final uint16_t rotation;

  /// Horizontal Field of view
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: deg
  ///
  /// hfov
  final uint16_t hfov;

  /// Video Stream ID (1 for first, 2 for second, etc.)
  ///
  /// MAVLink type: uint8_t
  ///
  /// stream_id
  final uint8_t streamId;

  /// Camera id of a non-MAVLink camera attached to an autopilot (1-6).  0 if the component is a MAVLink camera (with its own component id).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// camera_device_id
  final uint8_t cameraDeviceId;

  VideoStreamStatus({
    required this.framerate,
    required this.bitrate,
    required this.flags,
    required this.resolutionH,
    required this.resolutionV,
    required this.rotation,
    required this.hfov,
    required this.streamId,
    required this.cameraDeviceId,
  });

  VideoStreamStatus copyWith({
    float? framerate,
    uint32_t? bitrate,
    VideoStreamStatusFlags? flags,
    uint16_t? resolutionH,
    uint16_t? resolutionV,
    uint16_t? rotation,
    uint16_t? hfov,
    uint8_t? streamId,
    uint8_t? cameraDeviceId,
  }) {
    return VideoStreamStatus(
      framerate: framerate ?? this.framerate,
      bitrate: bitrate ?? this.bitrate,
      flags: flags ?? this.flags,
      resolutionH: resolutionH ?? this.resolutionH,
      resolutionV: resolutionV ?? this.resolutionV,
      rotation: rotation ?? this.rotation,
      hfov: hfov ?? this.hfov,
      streamId: streamId ?? this.streamId,
      cameraDeviceId: cameraDeviceId ?? this.cameraDeviceId,
    );
  }

  factory VideoStreamStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < VideoStreamStatus.mavlinkEncodedLength) {
      var len = VideoStreamStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var framerate = data_.getFloat32(0, Endian.little);
    var bitrate = data_.getUint32(4, Endian.little);
    var flags = data_.getUint16(8, Endian.little);
    var resolutionH = data_.getUint16(10, Endian.little);
    var resolutionV = data_.getUint16(12, Endian.little);
    var rotation = data_.getUint16(14, Endian.little);
    var hfov = data_.getUint16(16, Endian.little);
    var streamId = data_.getUint8(18);
    var cameraDeviceId = data_.getUint8(19);

    return VideoStreamStatus(
        framerate: framerate,
        bitrate: bitrate,
        flags: flags,
        resolutionH: resolutionH,
        resolutionV: resolutionV,
        rotation: rotation,
        hfov: hfov,
        streamId: streamId,
        cameraDeviceId: cameraDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, framerate, Endian.little);
    data_.setUint32(4, bitrate, Endian.little);
    data_.setUint16(8, flags, Endian.little);
    data_.setUint16(10, resolutionH, Endian.little);
    data_.setUint16(12, resolutionV, Endian.little);
    data_.setUint16(14, rotation, Endian.little);
    data_.setUint16(16, hfov, Endian.little);
    data_.setUint8(18, streamId);
    data_.setUint8(19, cameraDeviceId);
    return data_;
  }
}

/// Information about the field of view of a camera. Can be requested with a MAV_CMD_REQUEST_MESSAGE command.
///
/// CAMERA_FOV_STATUS
class CameraFovStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 271;

  static const int _mavlinkCrcExtra = 22;

  static const int mavlinkEncodedLength = 53;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Latitude of camera (INT32_MAX if unknown).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat_camera
  final int32_t latCamera;

  /// Longitude of camera (INT32_MAX if unknown).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon_camera
  final int32_t lonCamera;

  /// Altitude (MSL) of camera (INT32_MAX if unknown).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt_camera
  final int32_t altCamera;

  /// Latitude of center of image (INT32_MAX if unknown, INT32_MIN if at infinity, not intersecting with horizon).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat_image
  final int32_t latImage;

  /// Longitude of center of image (INT32_MAX if unknown, INT32_MIN if at infinity, not intersecting with horizon).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon_image
  final int32_t lonImage;

  /// Altitude (MSL) of center of image (INT32_MAX if unknown, INT32_MIN if at infinity, not intersecting with horizon).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt_image
  final int32_t altImage;

  /// Quaternion of camera orientation (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// Horizontal field of view (NaN if unknown).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// hfov
  final float hfov;

  /// Vertical field of view (NaN if unknown).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// vfov
  final float vfov;

  /// Camera id of a non-MAVLink camera attached to an autopilot (1-6).  0 if the component is a MAVLink camera (with its own component id).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// camera_device_id
  final uint8_t cameraDeviceId;

  CameraFovStatus({
    required this.timeBootMs,
    required this.latCamera,
    required this.lonCamera,
    required this.altCamera,
    required this.latImage,
    required this.lonImage,
    required this.altImage,
    required this.q,
    required this.hfov,
    required this.vfov,
    required this.cameraDeviceId,
  });

  CameraFovStatus copyWith({
    uint32_t? timeBootMs,
    int32_t? latCamera,
    int32_t? lonCamera,
    int32_t? altCamera,
    int32_t? latImage,
    int32_t? lonImage,
    int32_t? altImage,
    List<float>? q,
    float? hfov,
    float? vfov,
    uint8_t? cameraDeviceId,
  }) {
    return CameraFovStatus(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      latCamera: latCamera ?? this.latCamera,
      lonCamera: lonCamera ?? this.lonCamera,
      altCamera: altCamera ?? this.altCamera,
      latImage: latImage ?? this.latImage,
      lonImage: lonImage ?? this.lonImage,
      altImage: altImage ?? this.altImage,
      q: q ?? this.q,
      hfov: hfov ?? this.hfov,
      vfov: vfov ?? this.vfov,
      cameraDeviceId: cameraDeviceId ?? this.cameraDeviceId,
    );
  }

  factory CameraFovStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraFovStatus.mavlinkEncodedLength) {
      var len = CameraFovStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var latCamera = data_.getInt32(4, Endian.little);
    var lonCamera = data_.getInt32(8, Endian.little);
    var altCamera = data_.getInt32(12, Endian.little);
    var latImage = data_.getInt32(16, Endian.little);
    var lonImage = data_.getInt32(20, Endian.little);
    var altImage = data_.getInt32(24, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 28, 4);
    var hfov = data_.getFloat32(44, Endian.little);
    var vfov = data_.getFloat32(48, Endian.little);
    var cameraDeviceId = data_.getUint8(52);

    return CameraFovStatus(
        timeBootMs: timeBootMs,
        latCamera: latCamera,
        lonCamera: lonCamera,
        altCamera: altCamera,
        latImage: latImage,
        lonImage: lonImage,
        altImage: altImage,
        q: q,
        hfov: hfov,
        vfov: vfov,
        cameraDeviceId: cameraDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt32(4, latCamera, Endian.little);
    data_.setInt32(8, lonCamera, Endian.little);
    data_.setInt32(12, altCamera, Endian.little);
    data_.setInt32(16, latImage, Endian.little);
    data_.setInt32(20, lonImage, Endian.little);
    data_.setInt32(24, altImage, Endian.little);
    MavlinkMessage.setFloat32List(data_, 28, q);
    data_.setFloat32(44, hfov, Endian.little);
    data_.setFloat32(48, vfov, Endian.little);
    data_.setUint8(52, cameraDeviceId);
    return data_;
  }
}

/// Camera tracking status, sent while in active tracking. Use MAV_CMD_SET_MESSAGE_INTERVAL to define message interval.
///
/// CAMERA_TRACKING_IMAGE_STATUS
class CameraTrackingImageStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 275;

  static const int _mavlinkCrcExtra = 126;

  static const int mavlinkEncodedLength = 32;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Current tracked point x value if CAMERA_TRACKING_MODE_POINT (normalized 0..1, 0 is left, 1 is right), NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// point_x
  final float pointX;

  /// Current tracked point y value if CAMERA_TRACKING_MODE_POINT (normalized 0..1, 0 is top, 1 is bottom), NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// point_y
  final float pointY;

  /// Current tracked radius if CAMERA_TRACKING_MODE_POINT (normalized 0..1, 0 is image left, 1 is image right), NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// radius
  final float radius;

  /// Current tracked rectangle top x value if CAMERA_TRACKING_MODE_RECTANGLE (normalized 0..1, 0 is left, 1 is right), NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// rec_top_x
  final float recTopX;

  /// Current tracked rectangle top y value if CAMERA_TRACKING_MODE_RECTANGLE (normalized 0..1, 0 is top, 1 is bottom), NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// rec_top_y
  final float recTopY;

  /// Current tracked rectangle bottom x value if CAMERA_TRACKING_MODE_RECTANGLE (normalized 0..1, 0 is left, 1 is right), NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// rec_bottom_x
  final float recBottomX;

  /// Current tracked rectangle bottom y value if CAMERA_TRACKING_MODE_RECTANGLE (normalized 0..1, 0 is top, 1 is bottom), NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// rec_bottom_y
  final float recBottomY;

  /// Current tracking status
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CameraTrackingStatusFlags]
  ///
  /// tracking_status
  final CameraTrackingStatusFlags trackingStatus;

  /// Current tracking mode
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CameraTrackingMode]
  ///
  /// tracking_mode
  final CameraTrackingMode trackingMode;

  /// Defines location of target data
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CameraTrackingTargetData]
  ///
  /// target_data
  final CameraTrackingTargetData targetData;

  /// Camera id of a non-MAVLink camera attached to an autopilot (1-6).  0 if the component is a MAVLink camera (with its own component id).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// camera_device_id
  final uint8_t cameraDeviceId;

  CameraTrackingImageStatus({
    required this.pointX,
    required this.pointY,
    required this.radius,
    required this.recTopX,
    required this.recTopY,
    required this.recBottomX,
    required this.recBottomY,
    required this.trackingStatus,
    required this.trackingMode,
    required this.targetData,
    required this.cameraDeviceId,
  });

  CameraTrackingImageStatus copyWith({
    float? pointX,
    float? pointY,
    float? radius,
    float? recTopX,
    float? recTopY,
    float? recBottomX,
    float? recBottomY,
    CameraTrackingStatusFlags? trackingStatus,
    CameraTrackingMode? trackingMode,
    CameraTrackingTargetData? targetData,
    uint8_t? cameraDeviceId,
  }) {
    return CameraTrackingImageStatus(
      pointX: pointX ?? this.pointX,
      pointY: pointY ?? this.pointY,
      radius: radius ?? this.radius,
      recTopX: recTopX ?? this.recTopX,
      recTopY: recTopY ?? this.recTopY,
      recBottomX: recBottomX ?? this.recBottomX,
      recBottomY: recBottomY ?? this.recBottomY,
      trackingStatus: trackingStatus ?? this.trackingStatus,
      trackingMode: trackingMode ?? this.trackingMode,
      targetData: targetData ?? this.targetData,
      cameraDeviceId: cameraDeviceId ?? this.cameraDeviceId,
    );
  }

  factory CameraTrackingImageStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraTrackingImageStatus.mavlinkEncodedLength) {
      var len =
          CameraTrackingImageStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var pointX = data_.getFloat32(0, Endian.little);
    var pointY = data_.getFloat32(4, Endian.little);
    var radius = data_.getFloat32(8, Endian.little);
    var recTopX = data_.getFloat32(12, Endian.little);
    var recTopY = data_.getFloat32(16, Endian.little);
    var recBottomX = data_.getFloat32(20, Endian.little);
    var recBottomY = data_.getFloat32(24, Endian.little);
    var trackingStatus = data_.getUint8(28);
    var trackingMode = data_.getUint8(29);
    var targetData = data_.getUint8(30);
    var cameraDeviceId = data_.getUint8(31);

    return CameraTrackingImageStatus(
        pointX: pointX,
        pointY: pointY,
        radius: radius,
        recTopX: recTopX,
        recTopY: recTopY,
        recBottomX: recBottomX,
        recBottomY: recBottomY,
        trackingStatus: trackingStatus,
        trackingMode: trackingMode,
        targetData: targetData,
        cameraDeviceId: cameraDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, pointX, Endian.little);
    data_.setFloat32(4, pointY, Endian.little);
    data_.setFloat32(8, radius, Endian.little);
    data_.setFloat32(12, recTopX, Endian.little);
    data_.setFloat32(16, recTopY, Endian.little);
    data_.setFloat32(20, recBottomX, Endian.little);
    data_.setFloat32(24, recBottomY, Endian.little);
    data_.setUint8(28, trackingStatus);
    data_.setUint8(29, trackingMode);
    data_.setUint8(30, targetData);
    data_.setUint8(31, cameraDeviceId);
    return data_;
  }
}

/// Camera tracking status, sent while in active tracking. Use MAV_CMD_SET_MESSAGE_INTERVAL to define message interval.
///
/// CAMERA_TRACKING_GEO_STATUS
class CameraTrackingGeoStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 276;

  static const int _mavlinkCrcExtra = 18;

  static const int mavlinkEncodedLength = 50;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude of tracked object
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude of tracked object
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude of tracked object(AMSL, WGS84)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt
  final float alt;

  /// Horizontal accuracy. NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// h_acc
  final float hAcc;

  /// Vertical accuracy. NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// v_acc
  final float vAcc;

  /// North velocity of tracked object. NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vel_n
  final float velN;

  /// East velocity of tracked object. NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vel_e
  final float velE;

  /// Down velocity of tracked object. NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vel_d
  final float velD;

  /// Velocity accuracy. NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vel_acc
  final float velAcc;

  /// Distance between camera and tracked object. NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// dist
  final float dist;

  /// Heading in radians, in NED. NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// hdg
  final float hdg;

  /// Accuracy of heading, in NED. NAN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// hdg_acc
  final float hdgAcc;

  /// Current tracking status
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CameraTrackingStatusFlags]
  ///
  /// tracking_status
  final CameraTrackingStatusFlags trackingStatus;

  /// Camera id of a non-MAVLink camera attached to an autopilot (1-6).  0 if the component is a MAVLink camera (with its own component id).
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// camera_device_id
  final uint8_t cameraDeviceId;

  CameraTrackingGeoStatus({
    required this.lat,
    required this.lon,
    required this.alt,
    required this.hAcc,
    required this.vAcc,
    required this.velN,
    required this.velE,
    required this.velD,
    required this.velAcc,
    required this.dist,
    required this.hdg,
    required this.hdgAcc,
    required this.trackingStatus,
    required this.cameraDeviceId,
  });

  CameraTrackingGeoStatus copyWith({
    int32_t? lat,
    int32_t? lon,
    float? alt,
    float? hAcc,
    float? vAcc,
    float? velN,
    float? velE,
    float? velD,
    float? velAcc,
    float? dist,
    float? hdg,
    float? hdgAcc,
    CameraTrackingStatusFlags? trackingStatus,
    uint8_t? cameraDeviceId,
  }) {
    return CameraTrackingGeoStatus(
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      hAcc: hAcc ?? this.hAcc,
      vAcc: vAcc ?? this.vAcc,
      velN: velN ?? this.velN,
      velE: velE ?? this.velE,
      velD: velD ?? this.velD,
      velAcc: velAcc ?? this.velAcc,
      dist: dist ?? this.dist,
      hdg: hdg ?? this.hdg,
      hdgAcc: hdgAcc ?? this.hdgAcc,
      trackingStatus: trackingStatus ?? this.trackingStatus,
      cameraDeviceId: cameraDeviceId ?? this.cameraDeviceId,
    );
  }

  factory CameraTrackingGeoStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraTrackingGeoStatus.mavlinkEncodedLength) {
      var len =
          CameraTrackingGeoStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var lat = data_.getInt32(0, Endian.little);
    var lon = data_.getInt32(4, Endian.little);
    var alt = data_.getFloat32(8, Endian.little);
    var hAcc = data_.getFloat32(12, Endian.little);
    var vAcc = data_.getFloat32(16, Endian.little);
    var velN = data_.getFloat32(20, Endian.little);
    var velE = data_.getFloat32(24, Endian.little);
    var velD = data_.getFloat32(28, Endian.little);
    var velAcc = data_.getFloat32(32, Endian.little);
    var dist = data_.getFloat32(36, Endian.little);
    var hdg = data_.getFloat32(40, Endian.little);
    var hdgAcc = data_.getFloat32(44, Endian.little);
    var trackingStatus = data_.getUint8(48);
    var cameraDeviceId = data_.getUint8(49);

    return CameraTrackingGeoStatus(
        lat: lat,
        lon: lon,
        alt: alt,
        hAcc: hAcc,
        vAcc: vAcc,
        velN: velN,
        velE: velE,
        velD: velD,
        velAcc: velAcc,
        dist: dist,
        hdg: hdg,
        hdgAcc: hdgAcc,
        trackingStatus: trackingStatus,
        cameraDeviceId: cameraDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, lat, Endian.little);
    data_.setInt32(4, lon, Endian.little);
    data_.setFloat32(8, alt, Endian.little);
    data_.setFloat32(12, hAcc, Endian.little);
    data_.setFloat32(16, vAcc, Endian.little);
    data_.setFloat32(20, velN, Endian.little);
    data_.setFloat32(24, velE, Endian.little);
    data_.setFloat32(28, velD, Endian.little);
    data_.setFloat32(32, velAcc, Endian.little);
    data_.setFloat32(36, dist, Endian.little);
    data_.setFloat32(40, hdg, Endian.little);
    data_.setFloat32(44, hdgAcc, Endian.little);
    data_.setUint8(48, trackingStatus);
    data_.setUint8(49, cameraDeviceId);
    return data_;
  }
}

/// Camera absolute thermal range. This can be streamed when the associated VIDEO_STREAM_STATUS `flag` field bit VIDEO_STREAM_STATUS_FLAGS_THERMAL_RANGE_ENABLED is set, but a GCS may choose to only request it for the current active stream. Use MAV_CMD_SET_MESSAGE_INTERVAL to define message interval (param3 indicates the stream id of the current camera, or 0 for all streams, param4 indicates the target camera_device_id for autopilot-attached cameras or 0 for MAVLink cameras).
///
/// CAMERA_THERMAL_RANGE
class CameraThermalRange implements MavlinkMessage {
  static const int _mavlinkMessageId = 277;

  static const int _mavlinkCrcExtra = 62;

  static const int mavlinkEncodedLength = 30;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Temperature max.
  ///
  /// MAVLink type: float
  ///
  /// units: degC
  ///
  /// max
  final float max;

  /// Temperature max point x value (normalized 0..1, 0 is left, 1 is right), NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// max_point_x
  final float maxPointX;

  /// Temperature max point y value (normalized 0..1, 0 is top, 1 is bottom), NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// max_point_y
  final float maxPointY;

  /// Temperature min.
  ///
  /// MAVLink type: float
  ///
  /// units: degC
  ///
  /// min
  final float min;

  /// Temperature min point x value (normalized 0..1, 0 is left, 1 is right), NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// min_point_x
  final float minPointX;

  /// Temperature min point y value (normalized 0..1, 0 is top, 1 is bottom), NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// min_point_y
  final float minPointY;

  /// Video Stream ID (1 for first, 2 for second, etc.)
  ///
  /// MAVLink type: uint8_t
  ///
  /// stream_id
  final uint8_t streamId;

  /// Camera id of a non-MAVLink camera attached to an autopilot (1-6).  0 if the component is a MAVLink camera (with its own component id).
  ///
  /// MAVLink type: uint8_t
  ///
  /// camera_device_id
  final uint8_t cameraDeviceId;

  CameraThermalRange({
    required this.timeBootMs,
    required this.max,
    required this.maxPointX,
    required this.maxPointY,
    required this.min,
    required this.minPointX,
    required this.minPointY,
    required this.streamId,
    required this.cameraDeviceId,
  });

  CameraThermalRange copyWith({
    uint32_t? timeBootMs,
    float? max,
    float? maxPointX,
    float? maxPointY,
    float? min,
    float? minPointX,
    float? minPointY,
    uint8_t? streamId,
    uint8_t? cameraDeviceId,
  }) {
    return CameraThermalRange(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      max: max ?? this.max,
      maxPointX: maxPointX ?? this.maxPointX,
      maxPointY: maxPointY ?? this.maxPointY,
      min: min ?? this.min,
      minPointX: minPointX ?? this.minPointX,
      minPointY: minPointY ?? this.minPointY,
      streamId: streamId ?? this.streamId,
      cameraDeviceId: cameraDeviceId ?? this.cameraDeviceId,
    );
  }

  factory CameraThermalRange.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraThermalRange.mavlinkEncodedLength) {
      var len = CameraThermalRange.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var max = data_.getFloat32(4, Endian.little);
    var maxPointX = data_.getFloat32(8, Endian.little);
    var maxPointY = data_.getFloat32(12, Endian.little);
    var min = data_.getFloat32(16, Endian.little);
    var minPointX = data_.getFloat32(20, Endian.little);
    var minPointY = data_.getFloat32(24, Endian.little);
    var streamId = data_.getUint8(28);
    var cameraDeviceId = data_.getUint8(29);

    return CameraThermalRange(
        timeBootMs: timeBootMs,
        max: max,
        maxPointX: maxPointX,
        maxPointY: maxPointY,
        min: min,
        minPointX: minPointX,
        minPointY: minPointY,
        streamId: streamId,
        cameraDeviceId: cameraDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, max, Endian.little);
    data_.setFloat32(8, maxPointX, Endian.little);
    data_.setFloat32(12, maxPointY, Endian.little);
    data_.setFloat32(16, min, Endian.little);
    data_.setFloat32(20, minPointX, Endian.little);
    data_.setFloat32(24, minPointY, Endian.little);
    data_.setUint8(28, streamId);
    data_.setUint8(29, cameraDeviceId);
    return data_;
  }
}

/// Information about a high level gimbal manager. This message should be requested by a ground station using MAV_CMD_REQUEST_MESSAGE.
///
/// GIMBAL_MANAGER_INFORMATION
class GimbalManagerInformation implements MavlinkMessage {
  static const int _mavlinkMessageId = 280;

  static const int _mavlinkCrcExtra = 70;

  static const int mavlinkEncodedLength = 33;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Bitmap of gimbal capability flags.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [GimbalManagerCapFlags]
  ///
  /// cap_flags
  final GimbalManagerCapFlags capFlags;

  /// Minimum hardware roll angle (positive: rolling to the right, negative: rolling to the left)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll_min
  final float rollMin;

  /// Maximum hardware roll angle (positive: rolling to the right, negative: rolling to the left)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll_max
  final float rollMax;

  /// Minimum pitch angle (positive: up, negative: down)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch_min
  final float pitchMin;

  /// Maximum pitch angle (positive: up, negative: down)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch_max
  final float pitchMax;

  /// Minimum yaw angle (positive: to the right, negative: to the left)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw_min
  final float yawMin;

  /// Maximum yaw angle (positive: to the right, negative: to the left)
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw_max
  final float yawMax;

  /// Gimbal device ID that this gimbal manager is responsible for. Component ID of gimbal device (or 1-6 for non-MAVLink gimbal).
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_device_id
  final uint8_t gimbalDeviceId;

  GimbalManagerInformation({
    required this.timeBootMs,
    required this.capFlags,
    required this.rollMin,
    required this.rollMax,
    required this.pitchMin,
    required this.pitchMax,
    required this.yawMin,
    required this.yawMax,
    required this.gimbalDeviceId,
  });

  GimbalManagerInformation copyWith({
    uint32_t? timeBootMs,
    GimbalManagerCapFlags? capFlags,
    float? rollMin,
    float? rollMax,
    float? pitchMin,
    float? pitchMax,
    float? yawMin,
    float? yawMax,
    uint8_t? gimbalDeviceId,
  }) {
    return GimbalManagerInformation(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      capFlags: capFlags ?? this.capFlags,
      rollMin: rollMin ?? this.rollMin,
      rollMax: rollMax ?? this.rollMax,
      pitchMin: pitchMin ?? this.pitchMin,
      pitchMax: pitchMax ?? this.pitchMax,
      yawMin: yawMin ?? this.yawMin,
      yawMax: yawMax ?? this.yawMax,
      gimbalDeviceId: gimbalDeviceId ?? this.gimbalDeviceId,
    );
  }

  factory GimbalManagerInformation.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalManagerInformation.mavlinkEncodedLength) {
      var len =
          GimbalManagerInformation.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var capFlags = data_.getUint32(4, Endian.little);
    var rollMin = data_.getFloat32(8, Endian.little);
    var rollMax = data_.getFloat32(12, Endian.little);
    var pitchMin = data_.getFloat32(16, Endian.little);
    var pitchMax = data_.getFloat32(20, Endian.little);
    var yawMin = data_.getFloat32(24, Endian.little);
    var yawMax = data_.getFloat32(28, Endian.little);
    var gimbalDeviceId = data_.getUint8(32);

    return GimbalManagerInformation(
        timeBootMs: timeBootMs,
        capFlags: capFlags,
        rollMin: rollMin,
        rollMax: rollMax,
        pitchMin: pitchMin,
        pitchMax: pitchMax,
        yawMin: yawMin,
        yawMax: yawMax,
        gimbalDeviceId: gimbalDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint32(4, capFlags, Endian.little);
    data_.setFloat32(8, rollMin, Endian.little);
    data_.setFloat32(12, rollMax, Endian.little);
    data_.setFloat32(16, pitchMin, Endian.little);
    data_.setFloat32(20, pitchMax, Endian.little);
    data_.setFloat32(24, yawMin, Endian.little);
    data_.setFloat32(28, yawMax, Endian.little);
    data_.setUint8(32, gimbalDeviceId);
    return data_;
  }
}

/// Current status about a high level gimbal manager. This message should be broadcast at a low regular rate (e.g. 5Hz).
///
/// GIMBAL_MANAGER_STATUS
class GimbalManagerStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 281;

  static const int _mavlinkCrcExtra = 48;

  static const int mavlinkEncodedLength = 13;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// High level gimbal manager flags currently applied.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [GimbalManagerFlags]
  ///
  /// flags
  final GimbalManagerFlags flags;

  /// Gimbal device ID that this gimbal manager is responsible for. Component ID of gimbal device (or 1-6 for non-MAVLink gimbal).
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_device_id
  final uint8_t gimbalDeviceId;

  /// System ID of MAVLink component with primary control, 0 for none.
  ///
  /// MAVLink type: uint8_t
  ///
  /// primary_control_sysid
  final uint8_t primaryControlSysid;

  /// Component ID of MAVLink component with primary control, 0 for none.
  ///
  /// MAVLink type: uint8_t
  ///
  /// primary_control_compid
  final uint8_t primaryControlCompid;

  /// System ID of MAVLink component with secondary control, 0 for none.
  ///
  /// MAVLink type: uint8_t
  ///
  /// secondary_control_sysid
  final uint8_t secondaryControlSysid;

  /// Component ID of MAVLink component with secondary control, 0 for none.
  ///
  /// MAVLink type: uint8_t
  ///
  /// secondary_control_compid
  final uint8_t secondaryControlCompid;

  GimbalManagerStatus({
    required this.timeBootMs,
    required this.flags,
    required this.gimbalDeviceId,
    required this.primaryControlSysid,
    required this.primaryControlCompid,
    required this.secondaryControlSysid,
    required this.secondaryControlCompid,
  });

  GimbalManagerStatus copyWith({
    uint32_t? timeBootMs,
    GimbalManagerFlags? flags,
    uint8_t? gimbalDeviceId,
    uint8_t? primaryControlSysid,
    uint8_t? primaryControlCompid,
    uint8_t? secondaryControlSysid,
    uint8_t? secondaryControlCompid,
  }) {
    return GimbalManagerStatus(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      flags: flags ?? this.flags,
      gimbalDeviceId: gimbalDeviceId ?? this.gimbalDeviceId,
      primaryControlSysid: primaryControlSysid ?? this.primaryControlSysid,
      primaryControlCompid: primaryControlCompid ?? this.primaryControlCompid,
      secondaryControlSysid:
          secondaryControlSysid ?? this.secondaryControlSysid,
      secondaryControlCompid:
          secondaryControlCompid ?? this.secondaryControlCompid,
    );
  }

  factory GimbalManagerStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalManagerStatus.mavlinkEncodedLength) {
      var len = GimbalManagerStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var flags = data_.getUint32(4, Endian.little);
    var gimbalDeviceId = data_.getUint8(8);
    var primaryControlSysid = data_.getUint8(9);
    var primaryControlCompid = data_.getUint8(10);
    var secondaryControlSysid = data_.getUint8(11);
    var secondaryControlCompid = data_.getUint8(12);

    return GimbalManagerStatus(
        timeBootMs: timeBootMs,
        flags: flags,
        gimbalDeviceId: gimbalDeviceId,
        primaryControlSysid: primaryControlSysid,
        primaryControlCompid: primaryControlCompid,
        secondaryControlSysid: secondaryControlSysid,
        secondaryControlCompid: secondaryControlCompid);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint32(4, flags, Endian.little);
    data_.setUint8(8, gimbalDeviceId);
    data_.setUint8(9, primaryControlSysid);
    data_.setUint8(10, primaryControlCompid);
    data_.setUint8(11, secondaryControlSysid);
    data_.setUint8(12, secondaryControlCompid);
    return data_;
  }
}

/// High level message to control a gimbal's attitude. This message is to be sent to the gimbal manager (e.g. from a ground station). Angles and rates can be set to NaN according to use case.
///
/// GIMBAL_MANAGER_SET_ATTITUDE
class GimbalManagerSetAttitude implements MavlinkMessage {
  static const int _mavlinkMessageId = 282;

  static const int _mavlinkCrcExtra = 123;

  static const int mavlinkEncodedLength = 35;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// High level gimbal manager flags to use.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [GimbalManagerFlags]
  ///
  /// flags
  final GimbalManagerFlags flags;

  /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation, the frame is depends on whether the flag GIMBAL_MANAGER_FLAGS_YAW_LOCK is set)
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// X component of angular velocity, positive is rolling to the right, NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_x
  final float angularVelocityX;

  /// Y component of angular velocity, positive is pitching up, NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_y
  final float angularVelocityY;

  /// Z component of angular velocity, positive is yawing to the right, NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_z
  final float angularVelocityZ;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components. Send command multiple times for more than one gimbal (but not all gimbals).
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_device_id
  final uint8_t gimbalDeviceId;

  GimbalManagerSetAttitude({
    required this.flags,
    required this.q,
    required this.angularVelocityX,
    required this.angularVelocityY,
    required this.angularVelocityZ,
    required this.targetSystem,
    required this.targetComponent,
    required this.gimbalDeviceId,
  });

  GimbalManagerSetAttitude copyWith({
    GimbalManagerFlags? flags,
    List<float>? q,
    float? angularVelocityX,
    float? angularVelocityY,
    float? angularVelocityZ,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? gimbalDeviceId,
  }) {
    return GimbalManagerSetAttitude(
      flags: flags ?? this.flags,
      q: q ?? this.q,
      angularVelocityX: angularVelocityX ?? this.angularVelocityX,
      angularVelocityY: angularVelocityY ?? this.angularVelocityY,
      angularVelocityZ: angularVelocityZ ?? this.angularVelocityZ,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      gimbalDeviceId: gimbalDeviceId ?? this.gimbalDeviceId,
    );
  }

  factory GimbalManagerSetAttitude.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalManagerSetAttitude.mavlinkEncodedLength) {
      var len =
          GimbalManagerSetAttitude.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var flags = data_.getUint32(0, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 4, 4);
    var angularVelocityX = data_.getFloat32(20, Endian.little);
    var angularVelocityY = data_.getFloat32(24, Endian.little);
    var angularVelocityZ = data_.getFloat32(28, Endian.little);
    var targetSystem = data_.getUint8(32);
    var targetComponent = data_.getUint8(33);
    var gimbalDeviceId = data_.getUint8(34);

    return GimbalManagerSetAttitude(
        flags: flags,
        q: q,
        angularVelocityX: angularVelocityX,
        angularVelocityY: angularVelocityY,
        angularVelocityZ: angularVelocityZ,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        gimbalDeviceId: gimbalDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, flags, Endian.little);
    MavlinkMessage.setFloat32List(data_, 4, q);
    data_.setFloat32(20, angularVelocityX, Endian.little);
    data_.setFloat32(24, angularVelocityY, Endian.little);
    data_.setFloat32(28, angularVelocityZ, Endian.little);
    data_.setUint8(32, targetSystem);
    data_.setUint8(33, targetComponent);
    data_.setUint8(34, gimbalDeviceId);
    return data_;
  }
}

/// Information about a low level gimbal. This message should be requested by the gimbal manager or a ground station using MAV_CMD_REQUEST_MESSAGE. The maximum angles and rates are the limits by hardware. However, the limits by software used are likely different/smaller and dependent on mode/settings/etc..
///
/// GIMBAL_DEVICE_INFORMATION
class GimbalDeviceInformation implements MavlinkMessage {
  static const int _mavlinkMessageId = 283;

  static const int _mavlinkCrcExtra = 74;

  static const int mavlinkEncodedLength = 145;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// UID of gimbal hardware (0 if unknown).
  ///
  /// MAVLink type: uint64_t
  ///
  /// uid
  final uint64_t uid;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Version of the gimbal firmware, encoded as: (Dev & 0xff) << 24 | (Patch & 0xff) << 16 | (Minor & 0xff) << 8 | (Major & 0xff).
  ///
  /// MAVLink type: uint32_t
  ///
  /// firmware_version
  final uint32_t firmwareVersion;

  /// Version of the gimbal hardware, encoded as: (Dev & 0xff) << 24 | (Patch & 0xff) << 16 | (Minor & 0xff) << 8 | (Major & 0xff).
  ///
  /// MAVLink type: uint32_t
  ///
  /// hardware_version
  final uint32_t hardwareVersion;

  /// Minimum hardware roll angle (positive: rolling to the right, negative: rolling to the left). NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll_min
  final float rollMin;

  /// Maximum hardware roll angle (positive: rolling to the right, negative: rolling to the left). NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll_max
  final float rollMax;

  /// Minimum hardware pitch angle (positive: up, negative: down). NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch_min
  final float pitchMin;

  /// Maximum hardware pitch angle (positive: up, negative: down). NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch_max
  final float pitchMax;

  /// Minimum hardware yaw angle (positive: to the right, negative: to the left). NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw_min
  final float yawMin;

  /// Maximum hardware yaw angle (positive: to the right, negative: to the left). NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw_max
  final float yawMax;

  /// Bitmap of gimbal capability flags.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [GimbalDeviceCapFlags]
  ///
  /// cap_flags
  final GimbalDeviceCapFlags capFlags;

  /// Bitmap for use for gimbal-specific capability flags.
  ///
  /// MAVLink type: uint16_t
  ///
  /// custom_cap_flags
  final uint16_t customCapFlags;

  /// Name of the gimbal vendor.
  ///
  /// MAVLink type: char[32]
  ///
  /// vendor_name
  final List<char> vendorName;

  /// Name of the gimbal model.
  ///
  /// MAVLink type: char[32]
  ///
  /// model_name
  final List<char> modelName;

  /// Custom name of the gimbal given to it by the user.
  ///
  /// MAVLink type: char[32]
  ///
  /// custom_name
  final List<char> customName;

  /// This field is to be used if the gimbal manager and the gimbal device are the same component and hence have the same component ID. This field is then set to a number between 1-6. If the component ID is separate, this field is not required and must be set to 0.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// gimbal_device_id
  final uint8_t gimbalDeviceId;

  GimbalDeviceInformation({
    required this.uid,
    required this.timeBootMs,
    required this.firmwareVersion,
    required this.hardwareVersion,
    required this.rollMin,
    required this.rollMax,
    required this.pitchMin,
    required this.pitchMax,
    required this.yawMin,
    required this.yawMax,
    required this.capFlags,
    required this.customCapFlags,
    required this.vendorName,
    required this.modelName,
    required this.customName,
    required this.gimbalDeviceId,
  });

  GimbalDeviceInformation copyWith({
    uint64_t? uid,
    uint32_t? timeBootMs,
    uint32_t? firmwareVersion,
    uint32_t? hardwareVersion,
    float? rollMin,
    float? rollMax,
    float? pitchMin,
    float? pitchMax,
    float? yawMin,
    float? yawMax,
    GimbalDeviceCapFlags? capFlags,
    uint16_t? customCapFlags,
    List<char>? vendorName,
    List<char>? modelName,
    List<char>? customName,
    uint8_t? gimbalDeviceId,
  }) {
    return GimbalDeviceInformation(
      uid: uid ?? this.uid,
      timeBootMs: timeBootMs ?? this.timeBootMs,
      firmwareVersion: firmwareVersion ?? this.firmwareVersion,
      hardwareVersion: hardwareVersion ?? this.hardwareVersion,
      rollMin: rollMin ?? this.rollMin,
      rollMax: rollMax ?? this.rollMax,
      pitchMin: pitchMin ?? this.pitchMin,
      pitchMax: pitchMax ?? this.pitchMax,
      yawMin: yawMin ?? this.yawMin,
      yawMax: yawMax ?? this.yawMax,
      capFlags: capFlags ?? this.capFlags,
      customCapFlags: customCapFlags ?? this.customCapFlags,
      vendorName: vendorName ?? this.vendorName,
      modelName: modelName ?? this.modelName,
      customName: customName ?? this.customName,
      gimbalDeviceId: gimbalDeviceId ?? this.gimbalDeviceId,
    );
  }

  factory GimbalDeviceInformation.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalDeviceInformation.mavlinkEncodedLength) {
      var len =
          GimbalDeviceInformation.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var uid = data_.getUint64(0, Endian.little);
    var timeBootMs = data_.getUint32(8, Endian.little);
    var firmwareVersion = data_.getUint32(12, Endian.little);
    var hardwareVersion = data_.getUint32(16, Endian.little);
    var rollMin = data_.getFloat32(20, Endian.little);
    var rollMax = data_.getFloat32(24, Endian.little);
    var pitchMin = data_.getFloat32(28, Endian.little);
    var pitchMax = data_.getFloat32(32, Endian.little);
    var yawMin = data_.getFloat32(36, Endian.little);
    var yawMax = data_.getFloat32(40, Endian.little);
    var capFlags = data_.getUint16(44, Endian.little);
    var customCapFlags = data_.getUint16(46, Endian.little);
    var vendorName = MavlinkMessage.asInt8List(data_, 48, 32);
    var modelName = MavlinkMessage.asInt8List(data_, 80, 32);
    var customName = MavlinkMessage.asInt8List(data_, 112, 32);
    var gimbalDeviceId = data_.getUint8(144);

    return GimbalDeviceInformation(
        uid: uid,
        timeBootMs: timeBootMs,
        firmwareVersion: firmwareVersion,
        hardwareVersion: hardwareVersion,
        rollMin: rollMin,
        rollMax: rollMax,
        pitchMin: pitchMin,
        pitchMax: pitchMax,
        yawMin: yawMin,
        yawMax: yawMax,
        capFlags: capFlags,
        customCapFlags: customCapFlags,
        vendorName: vendorName,
        modelName: modelName,
        customName: customName,
        gimbalDeviceId: gimbalDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, uid, Endian.little);
    data_.setUint32(8, timeBootMs, Endian.little);
    data_.setUint32(12, firmwareVersion, Endian.little);
    data_.setUint32(16, hardwareVersion, Endian.little);
    data_.setFloat32(20, rollMin, Endian.little);
    data_.setFloat32(24, rollMax, Endian.little);
    data_.setFloat32(28, pitchMin, Endian.little);
    data_.setFloat32(32, pitchMax, Endian.little);
    data_.setFloat32(36, yawMin, Endian.little);
    data_.setFloat32(40, yawMax, Endian.little);
    data_.setUint16(44, capFlags, Endian.little);
    data_.setUint16(46, customCapFlags, Endian.little);
    MavlinkMessage.setInt8List(data_, 48, vendorName);
    MavlinkMessage.setInt8List(data_, 80, modelName);
    MavlinkMessage.setInt8List(data_, 112, customName);
    data_.setUint8(144, gimbalDeviceId);
    return data_;
  }
}

/// Low level message to control a gimbal device's attitude.
/// This message is to be sent from the gimbal manager to the gimbal device component.
/// The quaternion and angular velocities can be set to NaN according to use case.
/// For the angles encoded in the quaternion and the angular velocities holds:
/// If the flag GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME is set, then they are relative to the vehicle heading (vehicle frame).
/// If the flag GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME is set, then they are relative to absolute North (earth frame).
/// If neither of these flags are set, then (for backwards compatibility) it holds:
/// If the flag GIMBAL_DEVICE_FLAGS_YAW_LOCK is set, then they are relative to absolute North (earth frame),
/// else they are relative to the vehicle heading (vehicle frame).
/// Setting both GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME and GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME is not allowed.
/// These rules are to ensure backwards compatibility.
/// New implementations should always set either GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME or GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME.
///
/// GIMBAL_DEVICE_SET_ATTITUDE
class GimbalDeviceSetAttitude implements MavlinkMessage {
  static const int _mavlinkMessageId = 284;

  static const int _mavlinkCrcExtra = 99;

  static const int mavlinkEncodedLength = 32;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation). The frame is described in the message description. Set fields to NaN to be ignored.
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// X component of angular velocity (positive: rolling to the right). The frame is described in the message description. NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_x
  final float angularVelocityX;

  /// Y component of angular velocity (positive: pitching up). The frame is described in the message description. NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_y
  final float angularVelocityY;

  /// Z component of angular velocity (positive: yawing to the right). The frame is described in the message description. NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_z
  final float angularVelocityZ;

  /// Low level gimbal flags.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [GimbalDeviceFlags]
  ///
  /// flags
  final GimbalDeviceFlags flags;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  GimbalDeviceSetAttitude({
    required this.q,
    required this.angularVelocityX,
    required this.angularVelocityY,
    required this.angularVelocityZ,
    required this.flags,
    required this.targetSystem,
    required this.targetComponent,
  });

  GimbalDeviceSetAttitude copyWith({
    List<float>? q,
    float? angularVelocityX,
    float? angularVelocityY,
    float? angularVelocityZ,
    GimbalDeviceFlags? flags,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return GimbalDeviceSetAttitude(
      q: q ?? this.q,
      angularVelocityX: angularVelocityX ?? this.angularVelocityX,
      angularVelocityY: angularVelocityY ?? this.angularVelocityY,
      angularVelocityZ: angularVelocityZ ?? this.angularVelocityZ,
      flags: flags ?? this.flags,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory GimbalDeviceSetAttitude.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalDeviceSetAttitude.mavlinkEncodedLength) {
      var len =
          GimbalDeviceSetAttitude.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var q = MavlinkMessage.asFloat32List(data_, 0, 4);
    var angularVelocityX = data_.getFloat32(16, Endian.little);
    var angularVelocityY = data_.getFloat32(20, Endian.little);
    var angularVelocityZ = data_.getFloat32(24, Endian.little);
    var flags = data_.getUint16(28, Endian.little);
    var targetSystem = data_.getUint8(30);
    var targetComponent = data_.getUint8(31);

    return GimbalDeviceSetAttitude(
        q: q,
        angularVelocityX: angularVelocityX,
        angularVelocityY: angularVelocityY,
        angularVelocityZ: angularVelocityZ,
        flags: flags,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setFloat32List(data_, 0, q);
    data_.setFloat32(16, angularVelocityX, Endian.little);
    data_.setFloat32(20, angularVelocityY, Endian.little);
    data_.setFloat32(24, angularVelocityZ, Endian.little);
    data_.setUint16(28, flags, Endian.little);
    data_.setUint8(30, targetSystem);
    data_.setUint8(31, targetComponent);
    return data_;
  }
}

/// Message reporting the status of a gimbal device.
/// This message should be broadcast by a gimbal device component at a low regular rate (e.g. 5 Hz).
/// For the angles encoded in the quaternion and the angular velocities holds:
/// If the flag GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME is set, then they are relative to the vehicle heading (vehicle frame).
/// If the flag GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME is set, then they are relative to absolute North (earth frame).
/// If neither of these flags are set, then (for backwards compatibility) it holds:
/// If the flag GIMBAL_DEVICE_FLAGS_YAW_LOCK is set, then they are relative to absolute North (earth frame),
/// else they are relative to the vehicle heading (vehicle frame).
/// Other conditions of the flags are not allowed.
/// The quaternion and angular velocities in the other frame can be calculated from delta_yaw and delta_yaw_velocity as
/// q_earth = q_delta_yaw * q_vehicle and w_earth = w_delta_yaw_velocity + w_vehicle (if not NaN).
/// If neither the GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME nor the GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME flag is set,
/// then (for backwards compatibility) the data in the delta_yaw and delta_yaw_velocity fields are to be ignored.
/// New implementations should always set either GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME or GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME,
/// and always should set delta_yaw and delta_yaw_velocity either to the proper value or NaN.
///
/// GIMBAL_DEVICE_ATTITUDE_STATUS
class GimbalDeviceAttitudeStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 285;

  static const int _mavlinkCrcExtra = 137;

  static const int mavlinkEncodedLength = 49;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation). The frame is described in the message description.
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// X component of angular velocity (positive: rolling to the right). The frame is described in the message description. NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_x
  final float angularVelocityX;

  /// Y component of angular velocity (positive: pitching up). The frame is described in the message description. NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_y
  final float angularVelocityY;

  /// Z component of angular velocity (positive: yawing to the right). The frame is described in the message description. NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_z
  final float angularVelocityZ;

  /// Failure flags (0 for no failure)
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [GimbalDeviceErrorFlags]
  ///
  /// failure_flags
  final GimbalDeviceErrorFlags failureFlags;

  /// Current gimbal flags set.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [GimbalDeviceFlags]
  ///
  /// flags
  final GimbalDeviceFlags flags;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Yaw angle relating the quaternions in earth and body frames (see message description). NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// delta_yaw
  final float deltaYaw;

  /// Yaw angular velocity relating the angular velocities in earth and body frames (see message description). NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// delta_yaw_velocity
  final float deltaYawVelocity;

  /// This field is to be used if the gimbal manager and the gimbal device are the same component and hence have the same component ID. This field is then set a number between 1-6. If the component ID is separate, this field is not required and must be set to 0.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// gimbal_device_id
  final uint8_t gimbalDeviceId;

  GimbalDeviceAttitudeStatus({
    required this.timeBootMs,
    required this.q,
    required this.angularVelocityX,
    required this.angularVelocityY,
    required this.angularVelocityZ,
    required this.failureFlags,
    required this.flags,
    required this.targetSystem,
    required this.targetComponent,
    required this.deltaYaw,
    required this.deltaYawVelocity,
    required this.gimbalDeviceId,
  });

  GimbalDeviceAttitudeStatus copyWith({
    uint32_t? timeBootMs,
    List<float>? q,
    float? angularVelocityX,
    float? angularVelocityY,
    float? angularVelocityZ,
    GimbalDeviceErrorFlags? failureFlags,
    GimbalDeviceFlags? flags,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    float? deltaYaw,
    float? deltaYawVelocity,
    uint8_t? gimbalDeviceId,
  }) {
    return GimbalDeviceAttitudeStatus(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      q: q ?? this.q,
      angularVelocityX: angularVelocityX ?? this.angularVelocityX,
      angularVelocityY: angularVelocityY ?? this.angularVelocityY,
      angularVelocityZ: angularVelocityZ ?? this.angularVelocityZ,
      failureFlags: failureFlags ?? this.failureFlags,
      flags: flags ?? this.flags,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      deltaYaw: deltaYaw ?? this.deltaYaw,
      deltaYawVelocity: deltaYawVelocity ?? this.deltaYawVelocity,
      gimbalDeviceId: gimbalDeviceId ?? this.gimbalDeviceId,
    );
  }

  factory GimbalDeviceAttitudeStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalDeviceAttitudeStatus.mavlinkEncodedLength) {
      var len =
          GimbalDeviceAttitudeStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 4, 4);
    var angularVelocityX = data_.getFloat32(20, Endian.little);
    var angularVelocityY = data_.getFloat32(24, Endian.little);
    var angularVelocityZ = data_.getFloat32(28, Endian.little);
    var failureFlags = data_.getUint32(32, Endian.little);
    var flags = data_.getUint16(36, Endian.little);
    var targetSystem = data_.getUint8(38);
    var targetComponent = data_.getUint8(39);
    var deltaYaw = data_.getFloat32(40, Endian.little);
    var deltaYawVelocity = data_.getFloat32(44, Endian.little);
    var gimbalDeviceId = data_.getUint8(48);

    return GimbalDeviceAttitudeStatus(
        timeBootMs: timeBootMs,
        q: q,
        angularVelocityX: angularVelocityX,
        angularVelocityY: angularVelocityY,
        angularVelocityZ: angularVelocityZ,
        failureFlags: failureFlags,
        flags: flags,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        deltaYaw: deltaYaw,
        deltaYawVelocity: deltaYawVelocity,
        gimbalDeviceId: gimbalDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    MavlinkMessage.setFloat32List(data_, 4, q);
    data_.setFloat32(20, angularVelocityX, Endian.little);
    data_.setFloat32(24, angularVelocityY, Endian.little);
    data_.setFloat32(28, angularVelocityZ, Endian.little);
    data_.setUint32(32, failureFlags, Endian.little);
    data_.setUint16(36, flags, Endian.little);
    data_.setUint8(38, targetSystem);
    data_.setUint8(39, targetComponent);
    data_.setFloat32(40, deltaYaw, Endian.little);
    data_.setFloat32(44, deltaYawVelocity, Endian.little);
    data_.setUint8(48, gimbalDeviceId);
    return data_;
  }
}

/// Low level message containing autopilot state relevant for a gimbal device. This message is to be sent from the autopilot to the gimbal device component. The data of this message are for the gimbal device's estimator corrections, in particular horizon compensation, as well as indicates autopilot control intentions, e.g. feed forward angular control in the z-axis.
///
/// AUTOPILOT_STATE_FOR_GIMBAL_DEVICE
class AutopilotStateForGimbalDevice implements MavlinkMessage {
  static const int _mavlinkMessageId = 286;

  static const int _mavlinkCrcExtra = 210;

  static const int mavlinkEncodedLength = 57;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_boot_us
  final uint64_t timeBootUs;

  /// Quaternion components of autopilot attitude: w, x, y, z (1 0 0 0 is the null-rotation, Hamilton convention).
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// Estimated delay of the attitude data. 0 if unknown.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: us
  ///
  /// q_estimated_delay_us
  final uint32_t qEstimatedDelayUs;

  /// X Speed in NED (North, East, Down). NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// Y Speed in NED (North, East, Down). NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// Z Speed in NED (North, East, Down). NAN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  /// Estimated delay of the speed data. 0 if unknown.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: us
  ///
  /// v_estimated_delay_us
  final uint32_t vEstimatedDelayUs;

  /// Feed forward Z component of angular velocity (positive: yawing to the right). NaN to be ignored. This is to indicate if the autopilot is actively yawing.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// feed_forward_angular_velocity_z
  final float feedForwardAngularVelocityZ;

  /// Bitmap indicating which estimator outputs are valid.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [EstimatorStatusFlags]
  ///
  /// estimator_status
  final EstimatorStatusFlags estimatorStatus;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// The landed state. Is set to MAV_LANDED_STATE_UNDEFINED if landed state is unknown.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavLandedState]
  ///
  /// landed_state
  final MavLandedState landedState;

  /// Z component of angular velocity in NED (North, East, Down). NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// angular_velocity_z
  final float angularVelocityZ;

  AutopilotStateForGimbalDevice({
    required this.timeBootUs,
    required this.q,
    required this.qEstimatedDelayUs,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.vEstimatedDelayUs,
    required this.feedForwardAngularVelocityZ,
    required this.estimatorStatus,
    required this.targetSystem,
    required this.targetComponent,
    required this.landedState,
    required this.angularVelocityZ,
  });

  AutopilotStateForGimbalDevice copyWith({
    uint64_t? timeBootUs,
    List<float>? q,
    uint32_t? qEstimatedDelayUs,
    float? vx,
    float? vy,
    float? vz,
    uint32_t? vEstimatedDelayUs,
    float? feedForwardAngularVelocityZ,
    EstimatorStatusFlags? estimatorStatus,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavLandedState? landedState,
    float? angularVelocityZ,
  }) {
    return AutopilotStateForGimbalDevice(
      timeBootUs: timeBootUs ?? this.timeBootUs,
      q: q ?? this.q,
      qEstimatedDelayUs: qEstimatedDelayUs ?? this.qEstimatedDelayUs,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      vEstimatedDelayUs: vEstimatedDelayUs ?? this.vEstimatedDelayUs,
      feedForwardAngularVelocityZ:
          feedForwardAngularVelocityZ ?? this.feedForwardAngularVelocityZ,
      estimatorStatus: estimatorStatus ?? this.estimatorStatus,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      landedState: landedState ?? this.landedState,
      angularVelocityZ: angularVelocityZ ?? this.angularVelocityZ,
    );
  }

  factory AutopilotStateForGimbalDevice.parse(ByteData data_) {
    if (data_.lengthInBytes <
        AutopilotStateForGimbalDevice.mavlinkEncodedLength) {
      var len = AutopilotStateForGimbalDevice.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootUs = data_.getUint64(0, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 8, 4);
    var qEstimatedDelayUs = data_.getUint32(24, Endian.little);
    var vx = data_.getFloat32(28, Endian.little);
    var vy = data_.getFloat32(32, Endian.little);
    var vz = data_.getFloat32(36, Endian.little);
    var vEstimatedDelayUs = data_.getUint32(40, Endian.little);
    var feedForwardAngularVelocityZ = data_.getFloat32(44, Endian.little);
    var estimatorStatus = data_.getUint16(48, Endian.little);
    var targetSystem = data_.getUint8(50);
    var targetComponent = data_.getUint8(51);
    var landedState = data_.getUint8(52);
    var angularVelocityZ = data_.getFloat32(53, Endian.little);

    return AutopilotStateForGimbalDevice(
        timeBootUs: timeBootUs,
        q: q,
        qEstimatedDelayUs: qEstimatedDelayUs,
        vx: vx,
        vy: vy,
        vz: vz,
        vEstimatedDelayUs: vEstimatedDelayUs,
        feedForwardAngularVelocityZ: feedForwardAngularVelocityZ,
        estimatorStatus: estimatorStatus,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        landedState: landedState,
        angularVelocityZ: angularVelocityZ);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeBootUs, Endian.little);
    MavlinkMessage.setFloat32List(data_, 8, q);
    data_.setUint32(24, qEstimatedDelayUs, Endian.little);
    data_.setFloat32(28, vx, Endian.little);
    data_.setFloat32(32, vy, Endian.little);
    data_.setFloat32(36, vz, Endian.little);
    data_.setUint32(40, vEstimatedDelayUs, Endian.little);
    data_.setFloat32(44, feedForwardAngularVelocityZ, Endian.little);
    data_.setUint16(48, estimatorStatus, Endian.little);
    data_.setUint8(50, targetSystem);
    data_.setUint8(51, targetComponent);
    data_.setUint8(52, landedState);
    data_.setFloat32(53, angularVelocityZ, Endian.little);
    return data_;
  }
}

/// Set gimbal manager pitch and yaw angles (high rate message). This message is to be sent to the gimbal manager (e.g. from a ground station) and will be ignored by gimbal devices. Angles and rates can be set to NaN according to use case. Use MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW for low-rate adjustments that require confirmation.
///
/// GIMBAL_MANAGER_SET_PITCHYAW
class GimbalManagerSetPitchyaw implements MavlinkMessage {
  static const int _mavlinkMessageId = 287;

  static const int _mavlinkCrcExtra = 1;

  static const int mavlinkEncodedLength = 23;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// High level gimbal manager flags to use.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [GimbalManagerFlags]
  ///
  /// flags
  final GimbalManagerFlags flags;

  /// Pitch angle (positive: up, negative: down, NaN to be ignored).
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle (positive: to the right, negative: to the left, NaN to be ignored).
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Pitch angular rate (positive: up, negative: down, NaN to be ignored).
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitch_rate
  final float pitchRate;

  /// Yaw angular rate (positive: to the right, negative: to the left, NaN to be ignored).
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yaw_rate
  final float yawRate;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components. Send command multiple times for more than one gimbal (but not all gimbals).
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_device_id
  final uint8_t gimbalDeviceId;

  GimbalManagerSetPitchyaw({
    required this.flags,
    required this.pitch,
    required this.yaw,
    required this.pitchRate,
    required this.yawRate,
    required this.targetSystem,
    required this.targetComponent,
    required this.gimbalDeviceId,
  });

  GimbalManagerSetPitchyaw copyWith({
    GimbalManagerFlags? flags,
    float? pitch,
    float? yaw,
    float? pitchRate,
    float? yawRate,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? gimbalDeviceId,
  }) {
    return GimbalManagerSetPitchyaw(
      flags: flags ?? this.flags,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      pitchRate: pitchRate ?? this.pitchRate,
      yawRate: yawRate ?? this.yawRate,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      gimbalDeviceId: gimbalDeviceId ?? this.gimbalDeviceId,
    );
  }

  factory GimbalManagerSetPitchyaw.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalManagerSetPitchyaw.mavlinkEncodedLength) {
      var len =
          GimbalManagerSetPitchyaw.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var flags = data_.getUint32(0, Endian.little);
    var pitch = data_.getFloat32(4, Endian.little);
    var yaw = data_.getFloat32(8, Endian.little);
    var pitchRate = data_.getFloat32(12, Endian.little);
    var yawRate = data_.getFloat32(16, Endian.little);
    var targetSystem = data_.getUint8(20);
    var targetComponent = data_.getUint8(21);
    var gimbalDeviceId = data_.getUint8(22);

    return GimbalManagerSetPitchyaw(
        flags: flags,
        pitch: pitch,
        yaw: yaw,
        pitchRate: pitchRate,
        yawRate: yawRate,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        gimbalDeviceId: gimbalDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, flags, Endian.little);
    data_.setFloat32(4, pitch, Endian.little);
    data_.setFloat32(8, yaw, Endian.little);
    data_.setFloat32(12, pitchRate, Endian.little);
    data_.setFloat32(16, yawRate, Endian.little);
    data_.setUint8(20, targetSystem);
    data_.setUint8(21, targetComponent);
    data_.setUint8(22, gimbalDeviceId);
    return data_;
  }
}

/// High level message to control a gimbal manually. The angles or angular rates are unitless; the actual rates will depend on internal gimbal manager settings/configuration (e.g. set by parameters). This message is to be sent to the gimbal manager (e.g. from a ground station). Angles and rates can be set to NaN according to use case.
///
/// GIMBAL_MANAGER_SET_MANUAL_CONTROL
class GimbalManagerSetManualControl implements MavlinkMessage {
  static const int _mavlinkMessageId = 288;

  static const int _mavlinkCrcExtra = 20;

  static const int mavlinkEncodedLength = 23;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// High level gimbal manager flags.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [GimbalManagerFlags]
  ///
  /// flags
  final GimbalManagerFlags flags;

  /// Pitch angle unitless (-1..1, positive: up, negative: down, NaN to be ignored).
  ///
  /// MAVLink type: float
  ///
  /// pitch
  final float pitch;

  /// Yaw angle unitless (-1..1, positive: to the right, negative: to the left, NaN to be ignored).
  ///
  /// MAVLink type: float
  ///
  /// yaw
  final float yaw;

  /// Pitch angular rate unitless (-1..1, positive: up, negative: down, NaN to be ignored).
  ///
  /// MAVLink type: float
  ///
  /// pitch_rate
  final float pitchRate;

  /// Yaw angular rate unitless (-1..1, positive: to the right, negative: to the left, NaN to be ignored).
  ///
  /// MAVLink type: float
  ///
  /// yaw_rate
  final float yawRate;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components. Send command multiple times for more than one gimbal (but not all gimbals).
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_device_id
  final uint8_t gimbalDeviceId;

  GimbalManagerSetManualControl({
    required this.flags,
    required this.pitch,
    required this.yaw,
    required this.pitchRate,
    required this.yawRate,
    required this.targetSystem,
    required this.targetComponent,
    required this.gimbalDeviceId,
  });

  GimbalManagerSetManualControl copyWith({
    GimbalManagerFlags? flags,
    float? pitch,
    float? yaw,
    float? pitchRate,
    float? yawRate,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? gimbalDeviceId,
  }) {
    return GimbalManagerSetManualControl(
      flags: flags ?? this.flags,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      pitchRate: pitchRate ?? this.pitchRate,
      yawRate: yawRate ?? this.yawRate,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      gimbalDeviceId: gimbalDeviceId ?? this.gimbalDeviceId,
    );
  }

  factory GimbalManagerSetManualControl.parse(ByteData data_) {
    if (data_.lengthInBytes <
        GimbalManagerSetManualControl.mavlinkEncodedLength) {
      var len = GimbalManagerSetManualControl.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var flags = data_.getUint32(0, Endian.little);
    var pitch = data_.getFloat32(4, Endian.little);
    var yaw = data_.getFloat32(8, Endian.little);
    var pitchRate = data_.getFloat32(12, Endian.little);
    var yawRate = data_.getFloat32(16, Endian.little);
    var targetSystem = data_.getUint8(20);
    var targetComponent = data_.getUint8(21);
    var gimbalDeviceId = data_.getUint8(22);

    return GimbalManagerSetManualControl(
        flags: flags,
        pitch: pitch,
        yaw: yaw,
        pitchRate: pitchRate,
        yawRate: yawRate,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        gimbalDeviceId: gimbalDeviceId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, flags, Endian.little);
    data_.setFloat32(4, pitch, Endian.little);
    data_.setFloat32(8, yaw, Endian.little);
    data_.setFloat32(12, pitchRate, Endian.little);
    data_.setFloat32(16, yawRate, Endian.little);
    data_.setUint8(20, targetSystem);
    data_.setUint8(21, targetComponent);
    data_.setUint8(22, gimbalDeviceId);
    return data_;
  }
}

/// ESC information for lower rate streaming. Recommended streaming rate 1Hz. See ESC_STATUS for higher-rate ESC data.
///
/// ESC_INFO
class EscInfo implements MavlinkMessage {
  static const int _mavlinkMessageId = 290;

  static const int _mavlinkCrcExtra = 251;

  static const int mavlinkEncodedLength = 46;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Number of reported errors by each ESC since boot.
  ///
  /// MAVLink type: uint32_t[4]
  ///
  /// error_count
  final List<int32_t> errorCount;

  /// Counter of data packets received.
  ///
  /// MAVLink type: uint16_t
  ///
  /// counter
  final uint16_t counter;

  /// Bitmap of ESC failure flags.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// enum: [EscFailureFlags]
  ///
  /// failure_flags
  final List<EscFailureFlags> failureFlags;

  /// Temperature of each ESC. INT16_MAX: if data not supplied by ESC.
  ///
  /// MAVLink type: int16_t[4]
  ///
  /// units: cdegC
  ///
  /// temperature
  final List<int16_t> temperature;

  /// Index of the first ESC in this message. minValue = 0, maxValue = 60, increment = 4.
  ///
  /// MAVLink type: uint8_t
  ///
  /// index
  final uint8_t index;

  /// Total number of ESCs in all messages of this type. Message fields with an index higher than this should be ignored because they contain invalid data.
  ///
  /// MAVLink type: uint8_t
  ///
  /// count
  final uint8_t count;

  /// Connection type protocol for all ESC.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [EscConnectionType]
  ///
  /// connection_type
  final EscConnectionType connectionType;

  /// Information regarding online/offline status of each ESC.
  ///
  /// MAVLink type: uint8_t
  ///
  /// info
  final uint8_t info;

  EscInfo({
    required this.timeUsec,
    required this.errorCount,
    required this.counter,
    required this.failureFlags,
    required this.temperature,
    required this.index,
    required this.count,
    required this.connectionType,
    required this.info,
  });

  EscInfo copyWith({
    uint64_t? timeUsec,
    List<int32_t>? errorCount,
    uint16_t? counter,
    List<EscFailureFlags>? failureFlags,
    List<int16_t>? temperature,
    uint8_t? index,
    uint8_t? count,
    EscConnectionType? connectionType,
    uint8_t? info,
  }) {
    return EscInfo(
      timeUsec: timeUsec ?? this.timeUsec,
      errorCount: errorCount ?? this.errorCount,
      counter: counter ?? this.counter,
      failureFlags: failureFlags ?? this.failureFlags,
      temperature: temperature ?? this.temperature,
      index: index ?? this.index,
      count: count ?? this.count,
      connectionType: connectionType ?? this.connectionType,
      info: info ?? this.info,
    );
  }

  factory EscInfo.parse(ByteData data_) {
    if (data_.lengthInBytes < EscInfo.mavlinkEncodedLength) {
      var len = EscInfo.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var errorCount = MavlinkMessage.asUint32List(data_, 8, 4);
    var counter = data_.getUint16(24, Endian.little);
    var failureFlags = MavlinkMessage.asUint16List(data_, 26, 4);
    var temperature = MavlinkMessage.asInt16List(data_, 34, 4);
    var index = data_.getUint8(42);
    var count = data_.getUint8(43);
    var connectionType = data_.getUint8(44);
    var info = data_.getUint8(45);

    return EscInfo(
        timeUsec: timeUsec,
        errorCount: errorCount,
        counter: counter,
        failureFlags: failureFlags,
        temperature: temperature,
        index: index,
        count: count,
        connectionType: connectionType,
        info: info);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setUint32List(data_, 8, errorCount);
    data_.setUint16(24, counter, Endian.little);
    MavlinkMessage.setUint16List(data_, 26, failureFlags);
    MavlinkMessage.setInt16List(data_, 34, temperature);
    data_.setUint8(42, index);
    data_.setUint8(43, count);
    data_.setUint8(44, connectionType);
    data_.setUint8(45, info);
    return data_;
  }
}

/// ESC information for higher rate streaming. Recommended streaming rate is ~10 Hz. Information that changes more slowly is sent in ESC_INFO. It should typically only be streamed on high-bandwidth links (i.e. to a companion computer).
///
/// ESC_STATUS
class EscStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 291;

  static const int _mavlinkCrcExtra = 10;

  static const int mavlinkEncodedLength = 57;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Reported motor RPM from each ESC (negative for reverse rotation).
  ///
  /// MAVLink type: int32_t[4]
  ///
  /// units: rpm
  ///
  /// rpm
  final List<int32_t> rpm;

  /// Voltage measured from each ESC.
  ///
  /// MAVLink type: float[4]
  ///
  /// units: V
  ///
  /// voltage
  final List<float> voltage;

  /// Current measured from each ESC.
  ///
  /// MAVLink type: float[4]
  ///
  /// units: A
  ///
  /// current
  final List<float> current;

  /// Index of the first ESC in this message. minValue = 0, maxValue = 60, increment = 4.
  ///
  /// MAVLink type: uint8_t
  ///
  /// index
  final uint8_t index;

  EscStatus({
    required this.timeUsec,
    required this.rpm,
    required this.voltage,
    required this.current,
    required this.index,
  });

  EscStatus copyWith({
    uint64_t? timeUsec,
    List<int32_t>? rpm,
    List<float>? voltage,
    List<float>? current,
    uint8_t? index,
  }) {
    return EscStatus(
      timeUsec: timeUsec ?? this.timeUsec,
      rpm: rpm ?? this.rpm,
      voltage: voltage ?? this.voltage,
      current: current ?? this.current,
      index: index ?? this.index,
    );
  }

  factory EscStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < EscStatus.mavlinkEncodedLength) {
      var len = EscStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var rpm = MavlinkMessage.asInt32List(data_, 8, 4);
    var voltage = MavlinkMessage.asFloat32List(data_, 24, 4);
    var current = MavlinkMessage.asFloat32List(data_, 40, 4);
    var index = data_.getUint8(56);

    return EscStatus(
        timeUsec: timeUsec,
        rpm: rpm,
        voltage: voltage,
        current: current,
        index: index);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setInt32List(data_, 8, rpm);
    MavlinkMessage.setFloat32List(data_, 24, voltage);
    MavlinkMessage.setFloat32List(data_, 40, current);
    data_.setUint8(56, index);
    return data_;
  }
}

/// Configure WiFi AP SSID, password, and mode. This message is re-emitted as an acknowledgement by the AP. The message may also be explicitly requested using MAV_CMD_REQUEST_MESSAGE
///
/// WIFI_CONFIG_AP
class WifiConfigAp implements MavlinkMessage {
  static const int _mavlinkMessageId = 299;

  static const int _mavlinkCrcExtra = 19;

  static const int mavlinkEncodedLength = 98;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Name of Wi-Fi network (SSID). Blank to leave it unchanged when setting. Current SSID when sent back as a response.
  ///
  /// MAVLink type: char[32]
  ///
  /// ssid
  final List<char> ssid;

  /// Password. Blank for an open AP. MD5 hash when message is sent back as a response.
  ///
  /// MAVLink type: char[64]
  ///
  /// password
  final List<char> password;

  /// WiFi Mode.
  ///
  /// MAVLink type: int8_t
  ///
  /// enum: [WifiConfigApMode]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mode
  final WifiConfigApMode mode;

  /// Message acceptance response (sent back to GS).
  ///
  /// MAVLink type: int8_t
  ///
  /// enum: [WifiConfigApResponse]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// response
  final WifiConfigApResponse response;

  WifiConfigAp({
    required this.ssid,
    required this.password,
    required this.mode,
    required this.response,
  });

  WifiConfigAp copyWith({
    List<char>? ssid,
    List<char>? password,
    WifiConfigApMode? mode,
    WifiConfigApResponse? response,
  }) {
    return WifiConfigAp(
      ssid: ssid ?? this.ssid,
      password: password ?? this.password,
      mode: mode ?? this.mode,
      response: response ?? this.response,
    );
  }

  factory WifiConfigAp.parse(ByteData data_) {
    if (data_.lengthInBytes < WifiConfigAp.mavlinkEncodedLength) {
      var len = WifiConfigAp.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var ssid = MavlinkMessage.asInt8List(data_, 0, 32);
    var password = MavlinkMessage.asInt8List(data_, 32, 64);
    var mode = data_.getInt8(96);
    var response = data_.getInt8(97);

    return WifiConfigAp(
        ssid: ssid, password: password, mode: mode, response: response);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setInt8List(data_, 0, ssid);
    MavlinkMessage.setInt8List(data_, 32, password);
    data_.setInt8(96, mode);
    data_.setInt8(97, response);
    return data_;
  }
}

/// The location and information of an AIS vessel
///
/// AIS_VESSEL
class AisVessel implements MavlinkMessage {
  static const int _mavlinkMessageId = 301;

  static const int _mavlinkCrcExtra = 243;

  static const int mavlinkEncodedLength = 58;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Mobile Marine Service Identifier, 9 decimal digits
  ///
  /// MAVLink type: uint32_t
  ///
  /// MMSI
  final uint32_t mmsi;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Course over ground
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// COG
  final uint16_t cog;

  /// True heading
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// heading
  final uint16_t heading;

  /// Speed over ground
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// velocity
  final uint16_t velocity;

  /// Distance from lat/lon location to bow
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: m
  ///
  /// dimension_bow
  final uint16_t dimensionBow;

  /// Distance from lat/lon location to stern
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: m
  ///
  /// dimension_stern
  final uint16_t dimensionStern;

  /// Time since last communication in seconds
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: s
  ///
  /// tslc
  final uint16_t tslc;

  /// Bitmask to indicate various statuses including valid data fields
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [AisFlags]
  ///
  /// flags
  final AisFlags flags;

  /// Turn rate
  ///
  /// MAVLink type: int8_t
  ///
  /// units: cdeg/s
  ///
  /// turn_rate
  final int8_t turnRate;

  /// Navigational status
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AisNavStatus]
  ///
  /// navigational_status
  final AisNavStatus navigationalStatus;

  /// Type of vessels
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AisType]
  ///
  /// type
  final AisType type;

  /// Distance from lat/lon location to port side
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: m
  ///
  /// dimension_port
  final uint8_t dimensionPort;

  /// Distance from lat/lon location to starboard side
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: m
  ///
  /// dimension_starboard
  final uint8_t dimensionStarboard;

  /// The vessel callsign
  ///
  /// MAVLink type: char[7]
  ///
  /// callsign
  final List<char> callsign;

  /// The vessel name
  ///
  /// MAVLink type: char[20]
  ///
  /// name
  final List<char> name;

  AisVessel({
    required this.mmsi,
    required this.lat,
    required this.lon,
    required this.cog,
    required this.heading,
    required this.velocity,
    required this.dimensionBow,
    required this.dimensionStern,
    required this.tslc,
    required this.flags,
    required this.turnRate,
    required this.navigationalStatus,
    required this.type,
    required this.dimensionPort,
    required this.dimensionStarboard,
    required this.callsign,
    required this.name,
  });

  AisVessel copyWith({
    uint32_t? mmsi,
    int32_t? lat,
    int32_t? lon,
    uint16_t? cog,
    uint16_t? heading,
    uint16_t? velocity,
    uint16_t? dimensionBow,
    uint16_t? dimensionStern,
    uint16_t? tslc,
    AisFlags? flags,
    int8_t? turnRate,
    AisNavStatus? navigationalStatus,
    AisType? type,
    uint8_t? dimensionPort,
    uint8_t? dimensionStarboard,
    List<char>? callsign,
    List<char>? name,
  }) {
    return AisVessel(
      mmsi: mmsi ?? this.mmsi,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      cog: cog ?? this.cog,
      heading: heading ?? this.heading,
      velocity: velocity ?? this.velocity,
      dimensionBow: dimensionBow ?? this.dimensionBow,
      dimensionStern: dimensionStern ?? this.dimensionStern,
      tslc: tslc ?? this.tslc,
      flags: flags ?? this.flags,
      turnRate: turnRate ?? this.turnRate,
      navigationalStatus: navigationalStatus ?? this.navigationalStatus,
      type: type ?? this.type,
      dimensionPort: dimensionPort ?? this.dimensionPort,
      dimensionStarboard: dimensionStarboard ?? this.dimensionStarboard,
      callsign: callsign ?? this.callsign,
      name: name ?? this.name,
    );
  }

  factory AisVessel.parse(ByteData data_) {
    if (data_.lengthInBytes < AisVessel.mavlinkEncodedLength) {
      var len = AisVessel.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var mmsi = data_.getUint32(0, Endian.little);
    var lat = data_.getInt32(4, Endian.little);
    var lon = data_.getInt32(8, Endian.little);
    var cog = data_.getUint16(12, Endian.little);
    var heading = data_.getUint16(14, Endian.little);
    var velocity = data_.getUint16(16, Endian.little);
    var dimensionBow = data_.getUint16(18, Endian.little);
    var dimensionStern = data_.getUint16(20, Endian.little);
    var tslc = data_.getUint16(22, Endian.little);
    var flags = data_.getUint16(24, Endian.little);
    var turnRate = data_.getInt8(26);
    var navigationalStatus = data_.getUint8(27);
    var type = data_.getUint8(28);
    var dimensionPort = data_.getUint8(29);
    var dimensionStarboard = data_.getUint8(30);
    var callsign = MavlinkMessage.asInt8List(data_, 31, 7);
    var name = MavlinkMessage.asInt8List(data_, 38, 20);

    return AisVessel(
        mmsi: mmsi,
        lat: lat,
        lon: lon,
        cog: cog,
        heading: heading,
        velocity: velocity,
        dimensionBow: dimensionBow,
        dimensionStern: dimensionStern,
        tslc: tslc,
        flags: flags,
        turnRate: turnRate,
        navigationalStatus: navigationalStatus,
        type: type,
        dimensionPort: dimensionPort,
        dimensionStarboard: dimensionStarboard,
        callsign: callsign,
        name: name);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, mmsi, Endian.little);
    data_.setInt32(4, lat, Endian.little);
    data_.setInt32(8, lon, Endian.little);
    data_.setUint16(12, cog, Endian.little);
    data_.setUint16(14, heading, Endian.little);
    data_.setUint16(16, velocity, Endian.little);
    data_.setUint16(18, dimensionBow, Endian.little);
    data_.setUint16(20, dimensionStern, Endian.little);
    data_.setUint16(22, tslc, Endian.little);
    data_.setUint16(24, flags, Endian.little);
    data_.setInt8(26, turnRate);
    data_.setUint8(27, navigationalStatus);
    data_.setUint8(28, type);
    data_.setUint8(29, dimensionPort);
    data_.setUint8(30, dimensionStarboard);
    MavlinkMessage.setInt8List(data_, 31, callsign);
    MavlinkMessage.setInt8List(data_, 38, name);
    return data_;
  }
}

/// General status information of an UAVCAN node. Please refer to the definition of the UAVCAN message "uavcan.protocol.NodeStatus" for the background information. The UAVCAN specification is available at http://uavcan.org.
///
/// UAVCAN_NODE_STATUS
class UavcanNodeStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 310;

  static const int _mavlinkCrcExtra = 28;

  static const int mavlinkEncodedLength = 17;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Time since the start-up of the node.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: s
  ///
  /// uptime_sec
  final uint32_t uptimeSec;

  /// Vendor-specific status information.
  ///
  /// MAVLink type: uint16_t
  ///
  /// vendor_specific_status_code
  final uint16_t vendorSpecificStatusCode;

  /// Generalized node health status.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UavcanNodeHealth]
  ///
  /// health
  final UavcanNodeHealth health;

  /// Generalized operating mode.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UavcanNodeMode]
  ///
  /// mode
  final UavcanNodeMode mode;

  /// Not used currently.
  ///
  /// MAVLink type: uint8_t
  ///
  /// sub_mode
  final uint8_t subMode;

  UavcanNodeStatus({
    required this.timeUsec,
    required this.uptimeSec,
    required this.vendorSpecificStatusCode,
    required this.health,
    required this.mode,
    required this.subMode,
  });

  UavcanNodeStatus copyWith({
    uint64_t? timeUsec,
    uint32_t? uptimeSec,
    uint16_t? vendorSpecificStatusCode,
    UavcanNodeHealth? health,
    UavcanNodeMode? mode,
    uint8_t? subMode,
  }) {
    return UavcanNodeStatus(
      timeUsec: timeUsec ?? this.timeUsec,
      uptimeSec: uptimeSec ?? this.uptimeSec,
      vendorSpecificStatusCode:
          vendorSpecificStatusCode ?? this.vendorSpecificStatusCode,
      health: health ?? this.health,
      mode: mode ?? this.mode,
      subMode: subMode ?? this.subMode,
    );
  }

  factory UavcanNodeStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < UavcanNodeStatus.mavlinkEncodedLength) {
      var len = UavcanNodeStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var uptimeSec = data_.getUint32(8, Endian.little);
    var vendorSpecificStatusCode = data_.getUint16(12, Endian.little);
    var health = data_.getUint8(14);
    var mode = data_.getUint8(15);
    var subMode = data_.getUint8(16);

    return UavcanNodeStatus(
        timeUsec: timeUsec,
        uptimeSec: uptimeSec,
        vendorSpecificStatusCode: vendorSpecificStatusCode,
        health: health,
        mode: mode,
        subMode: subMode);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint32(8, uptimeSec, Endian.little);
    data_.setUint16(12, vendorSpecificStatusCode, Endian.little);
    data_.setUint8(14, health);
    data_.setUint8(15, mode);
    data_.setUint8(16, subMode);
    return data_;
  }
}

/// General information describing a particular UAVCAN node. Please refer to the definition of the UAVCAN service "uavcan.protocol.GetNodeInfo" for the background information. This message should be emitted by the system whenever a new node appears online, or an existing node reboots. Additionally, it can be emitted upon request from the other end of the MAVLink channel (see MAV_CMD_UAVCAN_GET_NODE_INFO). It is also not prohibited to emit this message unconditionally at a low frequency. The UAVCAN specification is available at http://uavcan.org.
///
/// UAVCAN_NODE_INFO
class UavcanNodeInfo implements MavlinkMessage {
  static const int _mavlinkMessageId = 311;

  static const int _mavlinkCrcExtra = 95;

  static const int mavlinkEncodedLength = 116;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Time since the start-up of the node.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: s
  ///
  /// uptime_sec
  final uint32_t uptimeSec;

  /// Version control system (VCS) revision identifier (e.g. git short commit hash). 0 if unknown.
  ///
  /// MAVLink type: uint32_t
  ///
  /// sw_vcs_commit
  final uint32_t swVcsCommit;

  /// Node name string. For example, "sapog.px4.io".
  ///
  /// MAVLink type: char[80]
  ///
  /// name
  final List<char> name;

  /// Hardware major version number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// hw_version_major
  final uint8_t hwVersionMajor;

  /// Hardware minor version number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// hw_version_minor
  final uint8_t hwVersionMinor;

  /// Hardware unique 128-bit ID.
  ///
  /// MAVLink type: uint8_t[16]
  ///
  /// hw_unique_id
  final List<int8_t> hwUniqueId;

  /// Software major version number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// sw_version_major
  final uint8_t swVersionMajor;

  /// Software minor version number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// sw_version_minor
  final uint8_t swVersionMinor;

  UavcanNodeInfo({
    required this.timeUsec,
    required this.uptimeSec,
    required this.swVcsCommit,
    required this.name,
    required this.hwVersionMajor,
    required this.hwVersionMinor,
    required this.hwUniqueId,
    required this.swVersionMajor,
    required this.swVersionMinor,
  });

  UavcanNodeInfo copyWith({
    uint64_t? timeUsec,
    uint32_t? uptimeSec,
    uint32_t? swVcsCommit,
    List<char>? name,
    uint8_t? hwVersionMajor,
    uint8_t? hwVersionMinor,
    List<int8_t>? hwUniqueId,
    uint8_t? swVersionMajor,
    uint8_t? swVersionMinor,
  }) {
    return UavcanNodeInfo(
      timeUsec: timeUsec ?? this.timeUsec,
      uptimeSec: uptimeSec ?? this.uptimeSec,
      swVcsCommit: swVcsCommit ?? this.swVcsCommit,
      name: name ?? this.name,
      hwVersionMajor: hwVersionMajor ?? this.hwVersionMajor,
      hwVersionMinor: hwVersionMinor ?? this.hwVersionMinor,
      hwUniqueId: hwUniqueId ?? this.hwUniqueId,
      swVersionMajor: swVersionMajor ?? this.swVersionMajor,
      swVersionMinor: swVersionMinor ?? this.swVersionMinor,
    );
  }

  factory UavcanNodeInfo.parse(ByteData data_) {
    if (data_.lengthInBytes < UavcanNodeInfo.mavlinkEncodedLength) {
      var len = UavcanNodeInfo.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var uptimeSec = data_.getUint32(8, Endian.little);
    var swVcsCommit = data_.getUint32(12, Endian.little);
    var name = MavlinkMessage.asInt8List(data_, 16, 80);
    var hwVersionMajor = data_.getUint8(96);
    var hwVersionMinor = data_.getUint8(97);
    var hwUniqueId = MavlinkMessage.asUint8List(data_, 98, 16);
    var swVersionMajor = data_.getUint8(114);
    var swVersionMinor = data_.getUint8(115);

    return UavcanNodeInfo(
        timeUsec: timeUsec,
        uptimeSec: uptimeSec,
        swVcsCommit: swVcsCommit,
        name: name,
        hwVersionMajor: hwVersionMajor,
        hwVersionMinor: hwVersionMinor,
        hwUniqueId: hwUniqueId,
        swVersionMajor: swVersionMajor,
        swVersionMinor: swVersionMinor);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint32(8, uptimeSec, Endian.little);
    data_.setUint32(12, swVcsCommit, Endian.little);
    MavlinkMessage.setInt8List(data_, 16, name);
    data_.setUint8(96, hwVersionMajor);
    data_.setUint8(97, hwVersionMinor);
    MavlinkMessage.setUint8List(data_, 98, hwUniqueId);
    data_.setUint8(114, swVersionMajor);
    data_.setUint8(115, swVersionMinor);
    return data_;
  }
}

/// Request to read the value of a parameter with either the param_id string id or param_index. PARAM_EXT_VALUE should be emitted in response.
///
/// PARAM_EXT_REQUEST_READ
class ParamExtRequestRead implements MavlinkMessage {
  static const int _mavlinkMessageId = 320;

  static const int _mavlinkCrcExtra = 243;

  static const int mavlinkEncodedLength = 20;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Parameter index. Set to -1 to use the Parameter ID field as identifier (else param_id will be ignored)
  ///
  /// MAVLink type: int16_t
  ///
  /// param_index
  final int16_t paramIndex;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  ParamExtRequestRead({
    required this.paramIndex,
    required this.targetSystem,
    required this.targetComponent,
    required this.paramId,
  });

  ParamExtRequestRead copyWith({
    int16_t? paramIndex,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<char>? paramId,
  }) {
    return ParamExtRequestRead(
      paramIndex: paramIndex ?? this.paramIndex,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      paramId: paramId ?? this.paramId,
    );
  }

  factory ParamExtRequestRead.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamExtRequestRead.mavlinkEncodedLength) {
      var len = ParamExtRequestRead.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var paramIndex = data_.getInt16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);
    var paramId = MavlinkMessage.asInt8List(data_, 4, 16);

    return ParamExtRequestRead(
        paramIndex: paramIndex,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        paramId: paramId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt16(0, paramIndex, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    MavlinkMessage.setInt8List(data_, 4, paramId);
    return data_;
  }
}

/// Request all parameters of this component. All parameters should be emitted in response as PARAM_EXT_VALUE.
///
/// PARAM_EXT_REQUEST_LIST
class ParamExtRequestList implements MavlinkMessage {
  static const int _mavlinkMessageId = 321;

  static const int _mavlinkCrcExtra = 88;

  static const int mavlinkEncodedLength = 2;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  ParamExtRequestList({
    required this.targetSystem,
    required this.targetComponent,
  });

  ParamExtRequestList copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return ParamExtRequestList(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory ParamExtRequestList.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamExtRequestList.mavlinkEncodedLength) {
      var len = ParamExtRequestList.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);

    return ParamExtRequestList(
        targetSystem: targetSystem, targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    return data_;
  }
}

/// Emit the value of a parameter. The inclusion of param_count and param_index in the message allows the recipient to keep track of received parameters and allows them to re-request missing parameters after a loss or timeout.
///
/// PARAM_EXT_VALUE
class ParamExtValue implements MavlinkMessage {
  static const int _mavlinkMessageId = 322;

  static const int _mavlinkCrcExtra = 243;

  static const int mavlinkEncodedLength = 149;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Total number of parameters
  ///
  /// MAVLink type: uint16_t
  ///
  /// param_count
  final uint16_t paramCount;

  /// Index of this parameter
  ///
  /// MAVLink type: uint16_t
  ///
  /// param_index
  final uint16_t paramIndex;

  /// Parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  /// Parameter value
  ///
  /// MAVLink type: char[128]
  ///
  /// param_value
  final List<char> paramValue;

  /// Parameter type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavParamExtType]
  ///
  /// param_type
  final MavParamExtType paramType;

  ParamExtValue({
    required this.paramCount,
    required this.paramIndex,
    required this.paramId,
    required this.paramValue,
    required this.paramType,
  });

  ParamExtValue copyWith({
    uint16_t? paramCount,
    uint16_t? paramIndex,
    List<char>? paramId,
    List<char>? paramValue,
    MavParamExtType? paramType,
  }) {
    return ParamExtValue(
      paramCount: paramCount ?? this.paramCount,
      paramIndex: paramIndex ?? this.paramIndex,
      paramId: paramId ?? this.paramId,
      paramValue: paramValue ?? this.paramValue,
      paramType: paramType ?? this.paramType,
    );
  }

  factory ParamExtValue.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamExtValue.mavlinkEncodedLength) {
      var len = ParamExtValue.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var paramCount = data_.getUint16(0, Endian.little);
    var paramIndex = data_.getUint16(2, Endian.little);
    var paramId = MavlinkMessage.asInt8List(data_, 4, 16);
    var paramValue = MavlinkMessage.asInt8List(data_, 20, 128);
    var paramType = data_.getUint8(148);

    return ParamExtValue(
        paramCount: paramCount,
        paramIndex: paramIndex,
        paramId: paramId,
        paramValue: paramValue,
        paramType: paramType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, paramCount, Endian.little);
    data_.setUint16(2, paramIndex, Endian.little);
    MavlinkMessage.setInt8List(data_, 4, paramId);
    MavlinkMessage.setInt8List(data_, 20, paramValue);
    data_.setUint8(148, paramType);
    return data_;
  }
}

/// Set a parameter value. In order to deal with message loss (and retransmission of PARAM_EXT_SET), when setting a parameter value and the new value is the same as the current value, you will immediately get a PARAM_ACK_ACCEPTED response. If the current state is PARAM_ACK_IN_PROGRESS, you will accordingly receive a PARAM_ACK_IN_PROGRESS in response.
///
/// PARAM_EXT_SET
class ParamExtSet implements MavlinkMessage {
  static const int _mavlinkMessageId = 323;

  static const int _mavlinkCrcExtra = 78;

  static const int mavlinkEncodedLength = 147;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  /// Parameter value
  ///
  /// MAVLink type: char[128]
  ///
  /// param_value
  final List<char> paramValue;

  /// Parameter type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavParamExtType]
  ///
  /// param_type
  final MavParamExtType paramType;

  ParamExtSet({
    required this.targetSystem,
    required this.targetComponent,
    required this.paramId,
    required this.paramValue,
    required this.paramType,
  });

  ParamExtSet copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<char>? paramId,
    List<char>? paramValue,
    MavParamExtType? paramType,
  }) {
    return ParamExtSet(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      paramId: paramId ?? this.paramId,
      paramValue: paramValue ?? this.paramValue,
      paramType: paramType ?? this.paramType,
    );
  }

  factory ParamExtSet.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamExtSet.mavlinkEncodedLength) {
      var len = ParamExtSet.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var paramId = MavlinkMessage.asInt8List(data_, 2, 16);
    var paramValue = MavlinkMessage.asInt8List(data_, 18, 128);
    var paramType = data_.getUint8(146);

    return ParamExtSet(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        paramId: paramId,
        paramValue: paramValue,
        paramType: paramType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    MavlinkMessage.setInt8List(data_, 2, paramId);
    MavlinkMessage.setInt8List(data_, 18, paramValue);
    data_.setUint8(146, paramType);
    return data_;
  }
}

/// Response from a PARAM_EXT_SET message.
///
/// PARAM_EXT_ACK
class ParamExtAck implements MavlinkMessage {
  static const int _mavlinkMessageId = 324;

  static const int _mavlinkCrcExtra = 132;

  static const int mavlinkEncodedLength = 146;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  /// Parameter value (new value if PARAM_ACK_ACCEPTED, current value otherwise)
  ///
  /// MAVLink type: char[128]
  ///
  /// param_value
  final List<char> paramValue;

  /// Parameter type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavParamExtType]
  ///
  /// param_type
  final MavParamExtType paramType;

  /// Result code.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [ParamAck]
  ///
  /// param_result
  final ParamAck paramResult;

  ParamExtAck({
    required this.paramId,
    required this.paramValue,
    required this.paramType,
    required this.paramResult,
  });

  ParamExtAck copyWith({
    List<char>? paramId,
    List<char>? paramValue,
    MavParamExtType? paramType,
    ParamAck? paramResult,
  }) {
    return ParamExtAck(
      paramId: paramId ?? this.paramId,
      paramValue: paramValue ?? this.paramValue,
      paramType: paramType ?? this.paramType,
      paramResult: paramResult ?? this.paramResult,
    );
  }

  factory ParamExtAck.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamExtAck.mavlinkEncodedLength) {
      var len = ParamExtAck.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var paramId = MavlinkMessage.asInt8List(data_, 0, 16);
    var paramValue = MavlinkMessage.asInt8List(data_, 16, 128);
    var paramType = data_.getUint8(144);
    var paramResult = data_.getUint8(145);

    return ParamExtAck(
        paramId: paramId,
        paramValue: paramValue,
        paramType: paramType,
        paramResult: paramResult);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setInt8List(data_, 0, paramId);
    MavlinkMessage.setInt8List(data_, 16, paramValue);
    data_.setUint8(144, paramType);
    data_.setUint8(145, paramResult);
    return data_;
  }
}

/// Obstacle distances in front of the sensor, starting from the left in increment degrees to the right
///
/// OBSTACLE_DISTANCE
class ObstacleDistance implements MavlinkMessage {
  static const int _mavlinkMessageId = 330;

  static const int _mavlinkCrcExtra = 23;

  static const int mavlinkEncodedLength = 167;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Distance of obstacles around the vehicle with index 0 corresponding to north + angle_offset, unless otherwise specified in the frame. A value of 0 is valid and means that the obstacle is practically touching the sensor. A value of max_distance +1 means no obstacle is present. A value of UINT16_MAX for unknown/not used. In a array element, one unit corresponds to 1cm.
  ///
  /// MAVLink type: uint16_t[72]
  ///
  /// units: cm
  ///
  /// distances
  final List<int16_t> distances;

  /// Minimum distance the sensor can measure.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm
  ///
  /// min_distance
  final uint16_t minDistance;

  /// Maximum distance the sensor can measure.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm
  ///
  /// max_distance
  final uint16_t maxDistance;

  /// Class id of the distance sensor type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavDistanceSensor]
  ///
  /// sensor_type
  final MavDistanceSensor sensorType;

  /// Angular width in degrees of each array element. Increment direction is clockwise. This field is ignored if increment_f is non-zero.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: deg
  ///
  /// increment
  final uint8_t increment;

  /// Angular width in degrees of each array element as a float. If non-zero then this value is used instead of the uint8_t increment field. Positive is clockwise direction, negative is counter-clockwise.
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// increment_f
  final float incrementF;

  /// Relative angle offset of the 0-index element in the distances array. Value of 0 corresponds to forward. Positive is clockwise direction, negative is counter-clockwise.
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// angle_offset
  final float angleOffset;

  /// Coordinate frame of reference for the yaw rotation and offset of the sensor data. Defaults to MAV_FRAME_GLOBAL, which is north aligned. For body-mounted sensors use MAV_FRAME_BODY_FRD, which is vehicle front aligned.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// frame
  final MavFrame frame;

  ObstacleDistance({
    required this.timeUsec,
    required this.distances,
    required this.minDistance,
    required this.maxDistance,
    required this.sensorType,
    required this.increment,
    required this.incrementF,
    required this.angleOffset,
    required this.frame,
  });

  ObstacleDistance copyWith({
    uint64_t? timeUsec,
    List<int16_t>? distances,
    uint16_t? minDistance,
    uint16_t? maxDistance,
    MavDistanceSensor? sensorType,
    uint8_t? increment,
    float? incrementF,
    float? angleOffset,
    MavFrame? frame,
  }) {
    return ObstacleDistance(
      timeUsec: timeUsec ?? this.timeUsec,
      distances: distances ?? this.distances,
      minDistance: minDistance ?? this.minDistance,
      maxDistance: maxDistance ?? this.maxDistance,
      sensorType: sensorType ?? this.sensorType,
      increment: increment ?? this.increment,
      incrementF: incrementF ?? this.incrementF,
      angleOffset: angleOffset ?? this.angleOffset,
      frame: frame ?? this.frame,
    );
  }

  factory ObstacleDistance.parse(ByteData data_) {
    if (data_.lengthInBytes < ObstacleDistance.mavlinkEncodedLength) {
      var len = ObstacleDistance.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var distances = MavlinkMessage.asUint16List(data_, 8, 72);
    var minDistance = data_.getUint16(152, Endian.little);
    var maxDistance = data_.getUint16(154, Endian.little);
    var sensorType = data_.getUint8(156);
    var increment = data_.getUint8(157);
    var incrementF = data_.getFloat32(158, Endian.little);
    var angleOffset = data_.getFloat32(162, Endian.little);
    var frame = data_.getUint8(166);

    return ObstacleDistance(
        timeUsec: timeUsec,
        distances: distances,
        minDistance: minDistance,
        maxDistance: maxDistance,
        sensorType: sensorType,
        increment: increment,
        incrementF: incrementF,
        angleOffset: angleOffset,
        frame: frame);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setUint16List(data_, 8, distances);
    data_.setUint16(152, minDistance, Endian.little);
    data_.setUint16(154, maxDistance, Endian.little);
    data_.setUint8(156, sensorType);
    data_.setUint8(157, increment);
    data_.setFloat32(158, incrementF, Endian.little);
    data_.setFloat32(162, angleOffset, Endian.little);
    data_.setUint8(166, frame);
    return data_;
  }
}

/// Odometry message to communicate odometry information with an external interface. Fits ROS REP 147 standard for aerial vehicles (http://www.ros.org/reps/rep-0147.html).
///
/// ODOMETRY
class Odometry implements MavlinkMessage {
  static const int _mavlinkMessageId = 331;

  static const int _mavlinkCrcExtra = 91;

  static const int mavlinkEncodedLength = 233;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// X Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Y Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Z Position
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation)
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// X linear speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// Y linear speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// Z linear speed
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  /// Roll angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// rollspeed
  final float rollspeed;

  /// Pitch angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitchspeed
  final float pitchspeed;

  /// Yaw angular speed
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yawspeed
  final float yawspeed;

  /// Row-major representation of a 6x6 pose cross-covariance matrix upper right triangle (states: x, y, z, roll, pitch, yaw; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[21]
  ///
  /// pose_covariance
  final List<float> poseCovariance;

  /// Row-major representation of a 6x6 velocity cross-covariance matrix upper right triangle (states: vx, vy, vz, rollspeed, pitchspeed, yawspeed; first six entries are the first ROW, next five entries are the second ROW, etc.). If unknown, assign NaN value to first element in the array.
  ///
  /// MAVLink type: float[21]
  ///
  /// velocity_covariance
  final List<float> velocityCovariance;

  /// Coordinate frame of reference for the pose data.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// frame_id
  final MavFrame frameId;

  /// Coordinate frame of reference for the velocity in free space (twist) data.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// child_frame_id
  final MavFrame childFrameId;

  /// Estimate reset counter. This should be incremented when the estimate resets in any of the dimensions (position, velocity, attitude, angular speed). This is designed to be used when e.g an external SLAM system detects a loop-closure and the estimate jumps.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// reset_counter
  final uint8_t resetCounter;

  /// Type of estimator that is providing the odometry.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavEstimatorType]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// estimator_type
  final MavEstimatorType estimatorType;

  /// Optional odometry quality metric as a percentage. -1 = odometry has failed, 0 = unknown/unset quality, 1 = worst quality, 100 = best quality
  ///
  /// MAVLink type: int8_t
  ///
  /// units: %
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// quality
  final int8_t quality;

  Odometry({
    required this.timeUsec,
    required this.x,
    required this.y,
    required this.z,
    required this.q,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.rollspeed,
    required this.pitchspeed,
    required this.yawspeed,
    required this.poseCovariance,
    required this.velocityCovariance,
    required this.frameId,
    required this.childFrameId,
    required this.resetCounter,
    required this.estimatorType,
    required this.quality,
  });

  Odometry copyWith({
    uint64_t? timeUsec,
    float? x,
    float? y,
    float? z,
    List<float>? q,
    float? vx,
    float? vy,
    float? vz,
    float? rollspeed,
    float? pitchspeed,
    float? yawspeed,
    List<float>? poseCovariance,
    List<float>? velocityCovariance,
    MavFrame? frameId,
    MavFrame? childFrameId,
    uint8_t? resetCounter,
    MavEstimatorType? estimatorType,
    int8_t? quality,
  }) {
    return Odometry(
      timeUsec: timeUsec ?? this.timeUsec,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      q: q ?? this.q,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      rollspeed: rollspeed ?? this.rollspeed,
      pitchspeed: pitchspeed ?? this.pitchspeed,
      yawspeed: yawspeed ?? this.yawspeed,
      poseCovariance: poseCovariance ?? this.poseCovariance,
      velocityCovariance: velocityCovariance ?? this.velocityCovariance,
      frameId: frameId ?? this.frameId,
      childFrameId: childFrameId ?? this.childFrameId,
      resetCounter: resetCounter ?? this.resetCounter,
      estimatorType: estimatorType ?? this.estimatorType,
      quality: quality ?? this.quality,
    );
  }

  factory Odometry.parse(ByteData data_) {
    if (data_.lengthInBytes < Odometry.mavlinkEncodedLength) {
      var len = Odometry.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var x = data_.getFloat32(8, Endian.little);
    var y = data_.getFloat32(12, Endian.little);
    var z = data_.getFloat32(16, Endian.little);
    var q = MavlinkMessage.asFloat32List(data_, 20, 4);
    var vx = data_.getFloat32(36, Endian.little);
    var vy = data_.getFloat32(40, Endian.little);
    var vz = data_.getFloat32(44, Endian.little);
    var rollspeed = data_.getFloat32(48, Endian.little);
    var pitchspeed = data_.getFloat32(52, Endian.little);
    var yawspeed = data_.getFloat32(56, Endian.little);
    var poseCovariance = MavlinkMessage.asFloat32List(data_, 60, 21);
    var velocityCovariance = MavlinkMessage.asFloat32List(data_, 144, 21);
    var frameId = data_.getUint8(228);
    var childFrameId = data_.getUint8(229);
    var resetCounter = data_.getUint8(230);
    var estimatorType = data_.getUint8(231);
    var quality = data_.getInt8(232);

    return Odometry(
        timeUsec: timeUsec,
        x: x,
        y: y,
        z: z,
        q: q,
        vx: vx,
        vy: vy,
        vz: vz,
        rollspeed: rollspeed,
        pitchspeed: pitchspeed,
        yawspeed: yawspeed,
        poseCovariance: poseCovariance,
        velocityCovariance: velocityCovariance,
        frameId: frameId,
        childFrameId: childFrameId,
        resetCounter: resetCounter,
        estimatorType: estimatorType,
        quality: quality);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, x, Endian.little);
    data_.setFloat32(12, y, Endian.little);
    data_.setFloat32(16, z, Endian.little);
    MavlinkMessage.setFloat32List(data_, 20, q);
    data_.setFloat32(36, vx, Endian.little);
    data_.setFloat32(40, vy, Endian.little);
    data_.setFloat32(44, vz, Endian.little);
    data_.setFloat32(48, rollspeed, Endian.little);
    data_.setFloat32(52, pitchspeed, Endian.little);
    data_.setFloat32(56, yawspeed, Endian.little);
    MavlinkMessage.setFloat32List(data_, 60, poseCovariance);
    MavlinkMessage.setFloat32List(data_, 144, velocityCovariance);
    data_.setUint8(228, frameId);
    data_.setUint8(229, childFrameId);
    data_.setUint8(230, resetCounter);
    data_.setUint8(231, estimatorType);
    data_.setInt8(232, quality);
    return data_;
  }
}

/// Describe a trajectory using an array of up-to 5 waypoints in the local frame (MAV_FRAME_LOCAL_NED).
///
/// TRAJECTORY_REPRESENTATION_WAYPOINTS
class TrajectoryRepresentationWaypoints implements MavlinkMessage {
  static const int _mavlinkMessageId = 332;

  static const int _mavlinkCrcExtra = 236;

  static const int mavlinkEncodedLength = 239;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// X-coordinate of waypoint, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m
  ///
  /// pos_x
  final List<float> posX;

  /// Y-coordinate of waypoint, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m
  ///
  /// pos_y
  final List<float> posY;

  /// Z-coordinate of waypoint, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m
  ///
  /// pos_z
  final List<float> posZ;

  /// X-velocity of waypoint, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m/s
  ///
  /// vel_x
  final List<float> velX;

  /// Y-velocity of waypoint, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m/s
  ///
  /// vel_y
  final List<float> velY;

  /// Z-velocity of waypoint, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m/s
  ///
  /// vel_z
  final List<float> velZ;

  /// X-acceleration of waypoint, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m/s/s
  ///
  /// acc_x
  final List<float> accX;

  /// Y-acceleration of waypoint, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m/s/s
  ///
  /// acc_y
  final List<float> accY;

  /// Z-acceleration of waypoint, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m/s/s
  ///
  /// acc_z
  final List<float> accZ;

  /// Yaw angle, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: rad
  ///
  /// pos_yaw
  final List<float> posYaw;

  /// Yaw rate, set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: rad/s
  ///
  /// vel_yaw
  final List<float> velYaw;

  /// MAV_CMD command id of waypoint, set to UINT16_MAX if not being used.
  ///
  /// MAVLink type: uint16_t[5]
  ///
  /// enum: [MavCmd]
  ///
  /// command
  final List<MavCmd> command;

  /// Number of valid points (up-to 5 waypoints are possible)
  ///
  /// MAVLink type: uint8_t
  ///
  /// valid_points
  final uint8_t validPoints;

  TrajectoryRepresentationWaypoints({
    required this.timeUsec,
    required this.posX,
    required this.posY,
    required this.posZ,
    required this.velX,
    required this.velY,
    required this.velZ,
    required this.accX,
    required this.accY,
    required this.accZ,
    required this.posYaw,
    required this.velYaw,
    required this.command,
    required this.validPoints,
  });

  TrajectoryRepresentationWaypoints copyWith({
    uint64_t? timeUsec,
    List<float>? posX,
    List<float>? posY,
    List<float>? posZ,
    List<float>? velX,
    List<float>? velY,
    List<float>? velZ,
    List<float>? accX,
    List<float>? accY,
    List<float>? accZ,
    List<float>? posYaw,
    List<float>? velYaw,
    List<MavCmd>? command,
    uint8_t? validPoints,
  }) {
    return TrajectoryRepresentationWaypoints(
      timeUsec: timeUsec ?? this.timeUsec,
      posX: posX ?? this.posX,
      posY: posY ?? this.posY,
      posZ: posZ ?? this.posZ,
      velX: velX ?? this.velX,
      velY: velY ?? this.velY,
      velZ: velZ ?? this.velZ,
      accX: accX ?? this.accX,
      accY: accY ?? this.accY,
      accZ: accZ ?? this.accZ,
      posYaw: posYaw ?? this.posYaw,
      velYaw: velYaw ?? this.velYaw,
      command: command ?? this.command,
      validPoints: validPoints ?? this.validPoints,
    );
  }

  factory TrajectoryRepresentationWaypoints.parse(ByteData data_) {
    if (data_.lengthInBytes <
        TrajectoryRepresentationWaypoints.mavlinkEncodedLength) {
      var len = TrajectoryRepresentationWaypoints.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var posX = MavlinkMessage.asFloat32List(data_, 8, 5);
    var posY = MavlinkMessage.asFloat32List(data_, 28, 5);
    var posZ = MavlinkMessage.asFloat32List(data_, 48, 5);
    var velX = MavlinkMessage.asFloat32List(data_, 68, 5);
    var velY = MavlinkMessage.asFloat32List(data_, 88, 5);
    var velZ = MavlinkMessage.asFloat32List(data_, 108, 5);
    var accX = MavlinkMessage.asFloat32List(data_, 128, 5);
    var accY = MavlinkMessage.asFloat32List(data_, 148, 5);
    var accZ = MavlinkMessage.asFloat32List(data_, 168, 5);
    var posYaw = MavlinkMessage.asFloat32List(data_, 188, 5);
    var velYaw = MavlinkMessage.asFloat32List(data_, 208, 5);
    var command = MavlinkMessage.asUint16List(data_, 228, 5);
    var validPoints = data_.getUint8(238);

    return TrajectoryRepresentationWaypoints(
        timeUsec: timeUsec,
        posX: posX,
        posY: posY,
        posZ: posZ,
        velX: velX,
        velY: velY,
        velZ: velZ,
        accX: accX,
        accY: accY,
        accZ: accZ,
        posYaw: posYaw,
        velYaw: velYaw,
        command: command,
        validPoints: validPoints);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setFloat32List(data_, 8, posX);
    MavlinkMessage.setFloat32List(data_, 28, posY);
    MavlinkMessage.setFloat32List(data_, 48, posZ);
    MavlinkMessage.setFloat32List(data_, 68, velX);
    MavlinkMessage.setFloat32List(data_, 88, velY);
    MavlinkMessage.setFloat32List(data_, 108, velZ);
    MavlinkMessage.setFloat32List(data_, 128, accX);
    MavlinkMessage.setFloat32List(data_, 148, accY);
    MavlinkMessage.setFloat32List(data_, 168, accZ);
    MavlinkMessage.setFloat32List(data_, 188, posYaw);
    MavlinkMessage.setFloat32List(data_, 208, velYaw);
    MavlinkMessage.setUint16List(data_, 228, command);
    data_.setUint8(238, validPoints);
    return data_;
  }
}

/// Describe a trajectory using an array of up-to 5 bezier control points in the local frame (MAV_FRAME_LOCAL_NED).
///
/// TRAJECTORY_REPRESENTATION_BEZIER
class TrajectoryRepresentationBezier implements MavlinkMessage {
  static const int _mavlinkMessageId = 333;

  static const int _mavlinkCrcExtra = 231;

  static const int mavlinkEncodedLength = 109;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// X-coordinate of bezier control points. Set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m
  ///
  /// pos_x
  final List<float> posX;

  /// Y-coordinate of bezier control points. Set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m
  ///
  /// pos_y
  final List<float> posY;

  /// Z-coordinate of bezier control points. Set to NaN if not being used
  ///
  /// MAVLink type: float[5]
  ///
  /// units: m
  ///
  /// pos_z
  final List<float> posZ;

  /// Bezier time horizon. Set to NaN if velocity/acceleration should not be incorporated
  ///
  /// MAVLink type: float[5]
  ///
  /// units: s
  ///
  /// delta
  final List<float> delta;

  /// Yaw. Set to NaN for unchanged
  ///
  /// MAVLink type: float[5]
  ///
  /// units: rad
  ///
  /// pos_yaw
  final List<float> posYaw;

  /// Number of valid control points (up-to 5 points are possible)
  ///
  /// MAVLink type: uint8_t
  ///
  /// valid_points
  final uint8_t validPoints;

  TrajectoryRepresentationBezier({
    required this.timeUsec,
    required this.posX,
    required this.posY,
    required this.posZ,
    required this.delta,
    required this.posYaw,
    required this.validPoints,
  });

  TrajectoryRepresentationBezier copyWith({
    uint64_t? timeUsec,
    List<float>? posX,
    List<float>? posY,
    List<float>? posZ,
    List<float>? delta,
    List<float>? posYaw,
    uint8_t? validPoints,
  }) {
    return TrajectoryRepresentationBezier(
      timeUsec: timeUsec ?? this.timeUsec,
      posX: posX ?? this.posX,
      posY: posY ?? this.posY,
      posZ: posZ ?? this.posZ,
      delta: delta ?? this.delta,
      posYaw: posYaw ?? this.posYaw,
      validPoints: validPoints ?? this.validPoints,
    );
  }

  factory TrajectoryRepresentationBezier.parse(ByteData data_) {
    if (data_.lengthInBytes <
        TrajectoryRepresentationBezier.mavlinkEncodedLength) {
      var len = TrajectoryRepresentationBezier.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var posX = MavlinkMessage.asFloat32List(data_, 8, 5);
    var posY = MavlinkMessage.asFloat32List(data_, 28, 5);
    var posZ = MavlinkMessage.asFloat32List(data_, 48, 5);
    var delta = MavlinkMessage.asFloat32List(data_, 68, 5);
    var posYaw = MavlinkMessage.asFloat32List(data_, 88, 5);
    var validPoints = data_.getUint8(108);

    return TrajectoryRepresentationBezier(
        timeUsec: timeUsec,
        posX: posX,
        posY: posY,
        posZ: posZ,
        delta: delta,
        posYaw: posYaw,
        validPoints: validPoints);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setFloat32List(data_, 8, posX);
    MavlinkMessage.setFloat32List(data_, 28, posY);
    MavlinkMessage.setFloat32List(data_, 48, posZ);
    MavlinkMessage.setFloat32List(data_, 68, delta);
    MavlinkMessage.setFloat32List(data_, 88, posYaw);
    data_.setUint8(108, validPoints);
    return data_;
  }
}

/// Report current used cellular network status
///
/// CELLULAR_STATUS
class CellularStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 334;

  static const int _mavlinkCrcExtra = 72;

  static const int mavlinkEncodedLength = 10;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Mobile country code. If unknown, set to UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// mcc
  final uint16_t mcc;

  /// Mobile network code. If unknown, set to UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// mnc
  final uint16_t mnc;

  /// Location area code. If unknown, set to 0
  ///
  /// MAVLink type: uint16_t
  ///
  /// lac
  final uint16_t lac;

  /// Cellular modem status
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CellularStatusFlag]
  ///
  /// status
  final CellularStatusFlag status;

  /// Failure reason when status in in CELLULAR_STATUS_FLAG_FAILED
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CellularNetworkFailedReason]
  ///
  /// failure_reason
  final CellularNetworkFailedReason failureReason;

  /// Cellular network radio type: gsm, cdma, lte...
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CellularNetworkRadioType]
  ///
  /// type
  final CellularNetworkRadioType type;

  /// Signal quality in percent. If unknown, set to UINT8_MAX
  ///
  /// MAVLink type: uint8_t
  ///
  /// quality
  final uint8_t quality;

  CellularStatus({
    required this.mcc,
    required this.mnc,
    required this.lac,
    required this.status,
    required this.failureReason,
    required this.type,
    required this.quality,
  });

  CellularStatus copyWith({
    uint16_t? mcc,
    uint16_t? mnc,
    uint16_t? lac,
    CellularStatusFlag? status,
    CellularNetworkFailedReason? failureReason,
    CellularNetworkRadioType? type,
    uint8_t? quality,
  }) {
    return CellularStatus(
      mcc: mcc ?? this.mcc,
      mnc: mnc ?? this.mnc,
      lac: lac ?? this.lac,
      status: status ?? this.status,
      failureReason: failureReason ?? this.failureReason,
      type: type ?? this.type,
      quality: quality ?? this.quality,
    );
  }

  factory CellularStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < CellularStatus.mavlinkEncodedLength) {
      var len = CellularStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var mcc = data_.getUint16(0, Endian.little);
    var mnc = data_.getUint16(2, Endian.little);
    var lac = data_.getUint16(4, Endian.little);
    var status = data_.getUint8(6);
    var failureReason = data_.getUint8(7);
    var type = data_.getUint8(8);
    var quality = data_.getUint8(9);

    return CellularStatus(
        mcc: mcc,
        mnc: mnc,
        lac: lac,
        status: status,
        failureReason: failureReason,
        type: type,
        quality: quality);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, mcc, Endian.little);
    data_.setUint16(2, mnc, Endian.little);
    data_.setUint16(4, lac, Endian.little);
    data_.setUint8(6, status);
    data_.setUint8(7, failureReason);
    data_.setUint8(8, type);
    data_.setUint8(9, quality);
    return data_;
  }
}

/// Status of the Iridium SBD link.
///
/// ISBD_LINK_STATUS
class IsbdLinkStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 335;

  static const int _mavlinkCrcExtra = 225;

  static const int mavlinkEncodedLength = 24;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// timestamp
  final uint64_t timestamp;

  /// Timestamp of the last successful sbd session. The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// last_heartbeat
  final uint64_t lastHeartbeat;

  /// Number of failed SBD sessions.
  ///
  /// MAVLink type: uint16_t
  ///
  /// failed_sessions
  final uint16_t failedSessions;

  /// Number of successful SBD sessions.
  ///
  /// MAVLink type: uint16_t
  ///
  /// successful_sessions
  final uint16_t successfulSessions;

  /// Signal quality equal to the number of bars displayed on the ISU signal strength indicator. Range is 0 to 5, where 0 indicates no signal and 5 indicates maximum signal strength.
  ///
  /// MAVLink type: uint8_t
  ///
  /// signal_quality
  final uint8_t signalQuality;

  /// 1: Ring call pending, 0: No call pending.
  ///
  /// MAVLink type: uint8_t
  ///
  /// ring_pending
  final uint8_t ringPending;

  /// 1: Transmission session pending, 0: No transmission session pending.
  ///
  /// MAVLink type: uint8_t
  ///
  /// tx_session_pending
  final uint8_t txSessionPending;

  /// 1: Receiving session pending, 0: No receiving session pending.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rx_session_pending
  final uint8_t rxSessionPending;

  IsbdLinkStatus({
    required this.timestamp,
    required this.lastHeartbeat,
    required this.failedSessions,
    required this.successfulSessions,
    required this.signalQuality,
    required this.ringPending,
    required this.txSessionPending,
    required this.rxSessionPending,
  });

  IsbdLinkStatus copyWith({
    uint64_t? timestamp,
    uint64_t? lastHeartbeat,
    uint16_t? failedSessions,
    uint16_t? successfulSessions,
    uint8_t? signalQuality,
    uint8_t? ringPending,
    uint8_t? txSessionPending,
    uint8_t? rxSessionPending,
  }) {
    return IsbdLinkStatus(
      timestamp: timestamp ?? this.timestamp,
      lastHeartbeat: lastHeartbeat ?? this.lastHeartbeat,
      failedSessions: failedSessions ?? this.failedSessions,
      successfulSessions: successfulSessions ?? this.successfulSessions,
      signalQuality: signalQuality ?? this.signalQuality,
      ringPending: ringPending ?? this.ringPending,
      txSessionPending: txSessionPending ?? this.txSessionPending,
      rxSessionPending: rxSessionPending ?? this.rxSessionPending,
    );
  }

  factory IsbdLinkStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < IsbdLinkStatus.mavlinkEncodedLength) {
      var len = IsbdLinkStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timestamp = data_.getUint64(0, Endian.little);
    var lastHeartbeat = data_.getUint64(8, Endian.little);
    var failedSessions = data_.getUint16(16, Endian.little);
    var successfulSessions = data_.getUint16(18, Endian.little);
    var signalQuality = data_.getUint8(20);
    var ringPending = data_.getUint8(21);
    var txSessionPending = data_.getUint8(22);
    var rxSessionPending = data_.getUint8(23);

    return IsbdLinkStatus(
        timestamp: timestamp,
        lastHeartbeat: lastHeartbeat,
        failedSessions: failedSessions,
        successfulSessions: successfulSessions,
        signalQuality: signalQuality,
        ringPending: ringPending,
        txSessionPending: txSessionPending,
        rxSessionPending: rxSessionPending);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timestamp, Endian.little);
    data_.setUint64(8, lastHeartbeat, Endian.little);
    data_.setUint16(16, failedSessions, Endian.little);
    data_.setUint16(18, successfulSessions, Endian.little);
    data_.setUint8(20, signalQuality);
    data_.setUint8(21, ringPending);
    data_.setUint8(22, txSessionPending);
    data_.setUint8(23, rxSessionPending);
    return data_;
  }
}

/// Configure cellular modems.
/// This message is re-emitted as an acknowledgement by the modem.
/// The message may also be explicitly requested using MAV_CMD_REQUEST_MESSAGE.
///
/// CELLULAR_CONFIG
class CellularConfig implements MavlinkMessage {
  static const int _mavlinkMessageId = 336;

  static const int _mavlinkCrcExtra = 245;

  static const int mavlinkEncodedLength = 84;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Enable/disable LTE. 0: setting unchanged, 1: disabled, 2: enabled. Current setting when sent back as a response.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enable_lte
  final uint8_t enableLte;

  /// Enable/disable PIN on the SIM card. 0: setting unchanged, 1: disabled, 2: enabled. Current setting when sent back as a response.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enable_pin
  final uint8_t enablePin;

  /// PIN sent to the SIM card. Blank when PIN is disabled. Empty when message is sent back as a response.
  ///
  /// MAVLink type: char[16]
  ///
  /// pin
  final List<char> pin;

  /// New PIN when changing the PIN. Blank to leave it unchanged. Empty when message is sent back as a response.
  ///
  /// MAVLink type: char[16]
  ///
  /// new_pin
  final List<char> newPin;

  /// Name of the cellular APN. Blank to leave it unchanged. Current APN when sent back as a response.
  ///
  /// MAVLink type: char[32]
  ///
  /// apn
  final List<char> apn;

  /// Required PUK code in case the user failed to authenticate 3 times with the PIN. Empty when message is sent back as a response.
  ///
  /// MAVLink type: char[16]
  ///
  /// puk
  final List<char> puk;

  /// Enable/disable roaming. 0: setting unchanged, 1: disabled, 2: enabled. Current setting when sent back as a response.
  ///
  /// MAVLink type: uint8_t
  ///
  /// roaming
  final uint8_t roaming;

  /// Message acceptance response (sent back to GS).
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CellularConfigResponse]
  ///
  /// response
  final CellularConfigResponse response;

  CellularConfig({
    required this.enableLte,
    required this.enablePin,
    required this.pin,
    required this.newPin,
    required this.apn,
    required this.puk,
    required this.roaming,
    required this.response,
  });

  CellularConfig copyWith({
    uint8_t? enableLte,
    uint8_t? enablePin,
    List<char>? pin,
    List<char>? newPin,
    List<char>? apn,
    List<char>? puk,
    uint8_t? roaming,
    CellularConfigResponse? response,
  }) {
    return CellularConfig(
      enableLte: enableLte ?? this.enableLte,
      enablePin: enablePin ?? this.enablePin,
      pin: pin ?? this.pin,
      newPin: newPin ?? this.newPin,
      apn: apn ?? this.apn,
      puk: puk ?? this.puk,
      roaming: roaming ?? this.roaming,
      response: response ?? this.response,
    );
  }

  factory CellularConfig.parse(ByteData data_) {
    if (data_.lengthInBytes < CellularConfig.mavlinkEncodedLength) {
      var len = CellularConfig.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var enableLte = data_.getUint8(0);
    var enablePin = data_.getUint8(1);
    var pin = MavlinkMessage.asInt8List(data_, 2, 16);
    var newPin = MavlinkMessage.asInt8List(data_, 18, 16);
    var apn = MavlinkMessage.asInt8List(data_, 34, 32);
    var puk = MavlinkMessage.asInt8List(data_, 66, 16);
    var roaming = data_.getUint8(82);
    var response = data_.getUint8(83);

    return CellularConfig(
        enableLte: enableLte,
        enablePin: enablePin,
        pin: pin,
        newPin: newPin,
        apn: apn,
        puk: puk,
        roaming: roaming,
        response: response);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, enableLte);
    data_.setUint8(1, enablePin);
    MavlinkMessage.setInt8List(data_, 2, pin);
    MavlinkMessage.setInt8List(data_, 18, newPin);
    MavlinkMessage.setInt8List(data_, 34, apn);
    MavlinkMessage.setInt8List(data_, 66, puk);
    data_.setUint8(82, roaming);
    data_.setUint8(83, response);
    return data_;
  }
}

/// RPM sensor data message.
///
/// RAW_RPM
class RawRpm implements MavlinkMessage {
  static const int _mavlinkMessageId = 339;

  static const int _mavlinkCrcExtra = 199;

  static const int mavlinkEncodedLength = 5;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Indicated rate
  ///
  /// MAVLink type: float
  ///
  /// units: rpm
  ///
  /// frequency
  final float frequency;

  /// Index of this RPM sensor (0-indexed)
  ///
  /// MAVLink type: uint8_t
  ///
  /// index
  final uint8_t index;

  RawRpm({
    required this.frequency,
    required this.index,
  });

  RawRpm copyWith({
    float? frequency,
    uint8_t? index,
  }) {
    return RawRpm(
      frequency: frequency ?? this.frequency,
      index: index ?? this.index,
    );
  }

  factory RawRpm.parse(ByteData data_) {
    if (data_.lengthInBytes < RawRpm.mavlinkEncodedLength) {
      var len = RawRpm.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var frequency = data_.getFloat32(0, Endian.little);
    var index = data_.getUint8(4);

    return RawRpm(frequency: frequency, index: index);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, frequency, Endian.little);
    data_.setUint8(4, index);
    return data_;
  }
}

/// The global position resulting from GPS and sensor fusion.
///
/// UTM_GLOBAL_POSITION
class UtmGlobalPosition implements MavlinkMessage {
  static const int _mavlinkMessageId = 340;

  static const int _mavlinkCrcExtra = 99;

  static const int mavlinkEncodedLength = 70;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Time of applicability of position (microseconds since UNIX epoch).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time
  final uint64_t time;

  /// Latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lon
  final int32_t lon;

  /// Altitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// alt
  final int32_t alt;

  /// Altitude above ground
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// relative_alt
  final int32_t relativeAlt;

  /// Next waypoint, latitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// next_lat
  final int32_t nextLat;

  /// Next waypoint, longitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// next_lon
  final int32_t nextLon;

  /// Next waypoint, altitude (WGS84)
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// next_alt
  final int32_t nextAlt;

  /// Ground X speed (latitude, positive north)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vx
  final int16_t vx;

  /// Ground Y speed (longitude, positive east)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vy
  final int16_t vy;

  /// Ground Z speed (altitude, positive down)
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// vz
  final int16_t vz;

  /// Horizontal position uncertainty (standard deviation)
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mm
  ///
  /// h_acc
  final uint16_t hAcc;

  /// Altitude uncertainty (standard deviation)
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mm
  ///
  /// v_acc
  final uint16_t vAcc;

  /// Speed uncertainty (standard deviation)
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// vel_acc
  final uint16_t velAcc;

  /// Time until next update. Set to 0 if unknown or in data driven mode.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cs
  ///
  /// update_rate
  final uint16_t updateRate;

  /// Unique UAS ID.
  ///
  /// MAVLink type: uint8_t[18]
  ///
  /// uas_id
  final List<int8_t> uasId;

  /// Flight state
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UtmFlightState]
  ///
  /// flight_state
  final UtmFlightState flightState;

  /// Bitwise OR combination of the data available flags.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UtmDataAvailFlags]
  ///
  /// flags
  final UtmDataAvailFlags flags;

  UtmGlobalPosition({
    required this.time,
    required this.lat,
    required this.lon,
    required this.alt,
    required this.relativeAlt,
    required this.nextLat,
    required this.nextLon,
    required this.nextAlt,
    required this.vx,
    required this.vy,
    required this.vz,
    required this.hAcc,
    required this.vAcc,
    required this.velAcc,
    required this.updateRate,
    required this.uasId,
    required this.flightState,
    required this.flags,
  });

  UtmGlobalPosition copyWith({
    uint64_t? time,
    int32_t? lat,
    int32_t? lon,
    int32_t? alt,
    int32_t? relativeAlt,
    int32_t? nextLat,
    int32_t? nextLon,
    int32_t? nextAlt,
    int16_t? vx,
    int16_t? vy,
    int16_t? vz,
    uint16_t? hAcc,
    uint16_t? vAcc,
    uint16_t? velAcc,
    uint16_t? updateRate,
    List<int8_t>? uasId,
    UtmFlightState? flightState,
    UtmDataAvailFlags? flags,
  }) {
    return UtmGlobalPosition(
      time: time ?? this.time,
      lat: lat ?? this.lat,
      lon: lon ?? this.lon,
      alt: alt ?? this.alt,
      relativeAlt: relativeAlt ?? this.relativeAlt,
      nextLat: nextLat ?? this.nextLat,
      nextLon: nextLon ?? this.nextLon,
      nextAlt: nextAlt ?? this.nextAlt,
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      hAcc: hAcc ?? this.hAcc,
      vAcc: vAcc ?? this.vAcc,
      velAcc: velAcc ?? this.velAcc,
      updateRate: updateRate ?? this.updateRate,
      uasId: uasId ?? this.uasId,
      flightState: flightState ?? this.flightState,
      flags: flags ?? this.flags,
    );
  }

  factory UtmGlobalPosition.parse(ByteData data_) {
    if (data_.lengthInBytes < UtmGlobalPosition.mavlinkEncodedLength) {
      var len = UtmGlobalPosition.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var time = data_.getUint64(0, Endian.little);
    var lat = data_.getInt32(8, Endian.little);
    var lon = data_.getInt32(12, Endian.little);
    var alt = data_.getInt32(16, Endian.little);
    var relativeAlt = data_.getInt32(20, Endian.little);
    var nextLat = data_.getInt32(24, Endian.little);
    var nextLon = data_.getInt32(28, Endian.little);
    var nextAlt = data_.getInt32(32, Endian.little);
    var vx = data_.getInt16(36, Endian.little);
    var vy = data_.getInt16(38, Endian.little);
    var vz = data_.getInt16(40, Endian.little);
    var hAcc = data_.getUint16(42, Endian.little);
    var vAcc = data_.getUint16(44, Endian.little);
    var velAcc = data_.getUint16(46, Endian.little);
    var updateRate = data_.getUint16(48, Endian.little);
    var uasId = MavlinkMessage.asUint8List(data_, 50, 18);
    var flightState = data_.getUint8(68);
    var flags = data_.getUint8(69);

    return UtmGlobalPosition(
        time: time,
        lat: lat,
        lon: lon,
        alt: alt,
        relativeAlt: relativeAlt,
        nextLat: nextLat,
        nextLon: nextLon,
        nextAlt: nextAlt,
        vx: vx,
        vy: vy,
        vz: vz,
        hAcc: hAcc,
        vAcc: vAcc,
        velAcc: velAcc,
        updateRate: updateRate,
        uasId: uasId,
        flightState: flightState,
        flags: flags);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, time, Endian.little);
    data_.setInt32(8, lat, Endian.little);
    data_.setInt32(12, lon, Endian.little);
    data_.setInt32(16, alt, Endian.little);
    data_.setInt32(20, relativeAlt, Endian.little);
    data_.setInt32(24, nextLat, Endian.little);
    data_.setInt32(28, nextLon, Endian.little);
    data_.setInt32(32, nextAlt, Endian.little);
    data_.setInt16(36, vx, Endian.little);
    data_.setInt16(38, vy, Endian.little);
    data_.setInt16(40, vz, Endian.little);
    data_.setUint16(42, hAcc, Endian.little);
    data_.setUint16(44, vAcc, Endian.little);
    data_.setUint16(46, velAcc, Endian.little);
    data_.setUint16(48, updateRate, Endian.little);
    MavlinkMessage.setUint8List(data_, 50, uasId);
    data_.setUint8(68, flightState);
    data_.setUint8(69, flags);
    return data_;
  }
}

/// Large debug/prototyping array. The message uses the maximum available payload for data. The array_id and name fields are used to discriminate between messages in code and in user interfaces (respectively). Do not use in production code.
///
/// DEBUG_FLOAT_ARRAY
class DebugFloatArray implements MavlinkMessage {
  static const int _mavlinkMessageId = 350;

  static const int _mavlinkCrcExtra = 232;

  static const int mavlinkEncodedLength = 252;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Unique ID used to discriminate between arrays
  ///
  /// MAVLink type: uint16_t
  ///
  /// array_id
  final uint16_t arrayId;

  /// Name, for human-friendly display in a Ground Control Station
  ///
  /// MAVLink type: char[10]
  ///
  /// name
  final List<char> name;

  /// data
  ///
  /// MAVLink type: float[58]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// data
  final List<float> data;

  DebugFloatArray({
    required this.timeUsec,
    required this.arrayId,
    required this.name,
    required this.data,
  });

  DebugFloatArray copyWith({
    uint64_t? timeUsec,
    uint16_t? arrayId,
    List<char>? name,
    List<float>? data,
  }) {
    return DebugFloatArray(
      timeUsec: timeUsec ?? this.timeUsec,
      arrayId: arrayId ?? this.arrayId,
      name: name ?? this.name,
      data: data ?? this.data,
    );
  }

  factory DebugFloatArray.parse(ByteData data_) {
    if (data_.lengthInBytes < DebugFloatArray.mavlinkEncodedLength) {
      var len = DebugFloatArray.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var arrayId = data_.getUint16(8, Endian.little);
    var name = MavlinkMessage.asInt8List(data_, 10, 10);
    var data = MavlinkMessage.asFloat32List(data_, 20, 58);

    return DebugFloatArray(
        timeUsec: timeUsec, arrayId: arrayId, name: name, data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint16(8, arrayId, Endian.little);
    MavlinkMessage.setInt8List(data_, 10, name);
    MavlinkMessage.setFloat32List(data_, 20, data);
    return data_;
  }
}

/// Vehicle status report that is sent out while orbit execution is in progress (see MAV_CMD_DO_ORBIT).
///
/// ORBIT_EXECUTION_STATUS
class OrbitExecutionStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 360;

  static const int _mavlinkCrcExtra = 11;

  static const int mavlinkEncodedLength = 25;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Radius of the orbit circle. Positive values orbit clockwise, negative values orbit counter-clockwise.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// radius
  final float radius;

  /// X coordinate of center point. Coordinate system depends on frame field: local = x position in meters * 1e4, global = latitude in degrees * 1e7.
  ///
  /// MAVLink type: int32_t
  ///
  /// x
  final int32_t x;

  /// Y coordinate of center point.  Coordinate system depends on frame field: local = x position in meters * 1e4, global = latitude in degrees * 1e7.
  ///
  /// MAVLink type: int32_t
  ///
  /// y
  final int32_t y;

  /// Altitude of center point. Coordinate system depends on frame field.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// The coordinate system of the fields: x, y, z.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// frame
  final MavFrame frame;

  OrbitExecutionStatus({
    required this.timeUsec,
    required this.radius,
    required this.x,
    required this.y,
    required this.z,
    required this.frame,
  });

  OrbitExecutionStatus copyWith({
    uint64_t? timeUsec,
    float? radius,
    int32_t? x,
    int32_t? y,
    float? z,
    MavFrame? frame,
  }) {
    return OrbitExecutionStatus(
      timeUsec: timeUsec ?? this.timeUsec,
      radius: radius ?? this.radius,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      frame: frame ?? this.frame,
    );
  }

  factory OrbitExecutionStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < OrbitExecutionStatus.mavlinkEncodedLength) {
      var len = OrbitExecutionStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var radius = data_.getFloat32(8, Endian.little);
    var x = data_.getInt32(12, Endian.little);
    var y = data_.getInt32(16, Endian.little);
    var z = data_.getFloat32(20, Endian.little);
    var frame = data_.getUint8(24);

    return OrbitExecutionStatus(
        timeUsec: timeUsec, radius: radius, x: x, y: y, z: z, frame: frame);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, radius, Endian.little);
    data_.setInt32(12, x, Endian.little);
    data_.setInt32(16, y, Endian.little);
    data_.setFloat32(20, z, Endian.little);
    data_.setUint8(24, frame);
    return data_;
  }
}

///
/// Battery information that is static, or requires infrequent update.
/// This message should requested using MAV_CMD_REQUEST_MESSAGE and/or streamed at very low rate.
/// BATTERY_STATUS_V2 is used for higher-rate battery status information.
///
///
/// BATTERY_INFO
class BatteryInfo implements MavlinkMessage {
  static const int _mavlinkMessageId = 370;

  static const int _mavlinkCrcExtra = 26;

  static const int mavlinkEncodedLength = 140;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Minimum per-cell voltage when discharging. 0: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: V
  ///
  /// discharge_minimum_voltage
  final float dischargeMinimumVoltage;

  /// Minimum per-cell voltage when charging. 0: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: V
  ///
  /// charging_minimum_voltage
  final float chargingMinimumVoltage;

  /// Minimum per-cell voltage when resting. 0: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: V
  ///
  /// resting_minimum_voltage
  final float restingMinimumVoltage;

  /// Maximum per-cell voltage when charged. 0: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: V
  ///
  /// charging_maximum_voltage
  final float chargingMaximumVoltage;

  /// Maximum pack continuous charge current. 0: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: A
  ///
  /// charging_maximum_current
  final float chargingMaximumCurrent;

  /// Battery nominal voltage. Used for conversion between Wh and Ah. 0: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: V
  ///
  /// nominal_voltage
  final float nominalVoltage;

  /// Maximum pack discharge current. 0: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: A
  ///
  /// discharge_maximum_current
  final float dischargeMaximumCurrent;

  /// Maximum pack discharge burst current. 0: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: A
  ///
  /// discharge_maximum_burst_current
  final float dischargeMaximumBurstCurrent;

  /// Fully charged design capacity. 0: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: Ah
  ///
  /// design_capacity
  final float designCapacity;

  /// Predicted battery capacity when fully charged (accounting for battery degradation). NAN: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: Ah
  ///
  /// full_charge_capacity
  final float fullChargeCapacity;

  /// Lifetime count of the number of charge/discharge cycles (https://en.wikipedia.org/wiki/Charge_cycle). UINT16_MAX: field not provided.
  ///
  /// MAVLink type: uint16_t
  ///
  /// cycle_count
  final uint16_t cycleCount;

  /// Battery weight. 0: field not provided.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: g
  ///
  /// weight
  final uint16_t weight;

  /// Battery ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// id
  final uint8_t id;

  /// Function of the battery.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavBatteryFunction]
  ///
  /// battery_function
  final MavBatteryFunction batteryFunction;

  /// Type (chemistry) of the battery.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavBatteryType]
  ///
  /// type
  final MavBatteryType type;

  /// State of Health (SOH) estimate. Typically 100% at the time of manufacture and will decrease over time and use. -1: field not provided.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// state_of_health
  final uint8_t stateOfHealth;

  /// Number of battery cells in series. 0: field not provided.
  ///
  /// MAVLink type: uint8_t
  ///
  /// cells_in_series
  final uint8_t cellsInSeries;

  /// Manufacture date (DDMMYYYY) in ASCII characters, 0 terminated. All 0: field not provided.
  ///
  /// MAVLink type: char[9]
  ///
  /// manufacture_date
  final List<char> manufactureDate;

  /// Serial number in ASCII characters, 0 terminated. All 0: field not provided.
  ///
  /// MAVLink type: char[32]
  ///
  /// serial_number
  final List<char> serialNumber;

  /// Battery device name. Formatted as manufacturer name then product name, separated with an underscore (in ASCII characters), 0 terminated. All 0: field not provided.
  ///
  /// MAVLink type: char[50]
  ///
  /// name
  final List<char> name;

  BatteryInfo({
    required this.dischargeMinimumVoltage,
    required this.chargingMinimumVoltage,
    required this.restingMinimumVoltage,
    required this.chargingMaximumVoltage,
    required this.chargingMaximumCurrent,
    required this.nominalVoltage,
    required this.dischargeMaximumCurrent,
    required this.dischargeMaximumBurstCurrent,
    required this.designCapacity,
    required this.fullChargeCapacity,
    required this.cycleCount,
    required this.weight,
    required this.id,
    required this.batteryFunction,
    required this.type,
    required this.stateOfHealth,
    required this.cellsInSeries,
    required this.manufactureDate,
    required this.serialNumber,
    required this.name,
  });

  BatteryInfo copyWith({
    float? dischargeMinimumVoltage,
    float? chargingMinimumVoltage,
    float? restingMinimumVoltage,
    float? chargingMaximumVoltage,
    float? chargingMaximumCurrent,
    float? nominalVoltage,
    float? dischargeMaximumCurrent,
    float? dischargeMaximumBurstCurrent,
    float? designCapacity,
    float? fullChargeCapacity,
    uint16_t? cycleCount,
    uint16_t? weight,
    uint8_t? id,
    MavBatteryFunction? batteryFunction,
    MavBatteryType? type,
    uint8_t? stateOfHealth,
    uint8_t? cellsInSeries,
    List<char>? manufactureDate,
    List<char>? serialNumber,
    List<char>? name,
  }) {
    return BatteryInfo(
      dischargeMinimumVoltage:
          dischargeMinimumVoltage ?? this.dischargeMinimumVoltage,
      chargingMinimumVoltage:
          chargingMinimumVoltage ?? this.chargingMinimumVoltage,
      restingMinimumVoltage:
          restingMinimumVoltage ?? this.restingMinimumVoltage,
      chargingMaximumVoltage:
          chargingMaximumVoltage ?? this.chargingMaximumVoltage,
      chargingMaximumCurrent:
          chargingMaximumCurrent ?? this.chargingMaximumCurrent,
      nominalVoltage: nominalVoltage ?? this.nominalVoltage,
      dischargeMaximumCurrent:
          dischargeMaximumCurrent ?? this.dischargeMaximumCurrent,
      dischargeMaximumBurstCurrent:
          dischargeMaximumBurstCurrent ?? this.dischargeMaximumBurstCurrent,
      designCapacity: designCapacity ?? this.designCapacity,
      fullChargeCapacity: fullChargeCapacity ?? this.fullChargeCapacity,
      cycleCount: cycleCount ?? this.cycleCount,
      weight: weight ?? this.weight,
      id: id ?? this.id,
      batteryFunction: batteryFunction ?? this.batteryFunction,
      type: type ?? this.type,
      stateOfHealth: stateOfHealth ?? this.stateOfHealth,
      cellsInSeries: cellsInSeries ?? this.cellsInSeries,
      manufactureDate: manufactureDate ?? this.manufactureDate,
      serialNumber: serialNumber ?? this.serialNumber,
      name: name ?? this.name,
    );
  }

  factory BatteryInfo.parse(ByteData data_) {
    if (data_.lengthInBytes < BatteryInfo.mavlinkEncodedLength) {
      var len = BatteryInfo.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var dischargeMinimumVoltage = data_.getFloat32(0, Endian.little);
    var chargingMinimumVoltage = data_.getFloat32(4, Endian.little);
    var restingMinimumVoltage = data_.getFloat32(8, Endian.little);
    var chargingMaximumVoltage = data_.getFloat32(12, Endian.little);
    var chargingMaximumCurrent = data_.getFloat32(16, Endian.little);
    var nominalVoltage = data_.getFloat32(20, Endian.little);
    var dischargeMaximumCurrent = data_.getFloat32(24, Endian.little);
    var dischargeMaximumBurstCurrent = data_.getFloat32(28, Endian.little);
    var designCapacity = data_.getFloat32(32, Endian.little);
    var fullChargeCapacity = data_.getFloat32(36, Endian.little);
    var cycleCount = data_.getUint16(40, Endian.little);
    var weight = data_.getUint16(42, Endian.little);
    var id = data_.getUint8(44);
    var batteryFunction = data_.getUint8(45);
    var type = data_.getUint8(46);
    var stateOfHealth = data_.getUint8(47);
    var cellsInSeries = data_.getUint8(48);
    var manufactureDate = MavlinkMessage.asInt8List(data_, 49, 9);
    var serialNumber = MavlinkMessage.asInt8List(data_, 58, 32);
    var name = MavlinkMessage.asInt8List(data_, 90, 50);

    return BatteryInfo(
        dischargeMinimumVoltage: dischargeMinimumVoltage,
        chargingMinimumVoltage: chargingMinimumVoltage,
        restingMinimumVoltage: restingMinimumVoltage,
        chargingMaximumVoltage: chargingMaximumVoltage,
        chargingMaximumCurrent: chargingMaximumCurrent,
        nominalVoltage: nominalVoltage,
        dischargeMaximumCurrent: dischargeMaximumCurrent,
        dischargeMaximumBurstCurrent: dischargeMaximumBurstCurrent,
        designCapacity: designCapacity,
        fullChargeCapacity: fullChargeCapacity,
        cycleCount: cycleCount,
        weight: weight,
        id: id,
        batteryFunction: batteryFunction,
        type: type,
        stateOfHealth: stateOfHealth,
        cellsInSeries: cellsInSeries,
        manufactureDate: manufactureDate,
        serialNumber: serialNumber,
        name: name);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, dischargeMinimumVoltage, Endian.little);
    data_.setFloat32(4, chargingMinimumVoltage, Endian.little);
    data_.setFloat32(8, restingMinimumVoltage, Endian.little);
    data_.setFloat32(12, chargingMaximumVoltage, Endian.little);
    data_.setFloat32(16, chargingMaximumCurrent, Endian.little);
    data_.setFloat32(20, nominalVoltage, Endian.little);
    data_.setFloat32(24, dischargeMaximumCurrent, Endian.little);
    data_.setFloat32(28, dischargeMaximumBurstCurrent, Endian.little);
    data_.setFloat32(32, designCapacity, Endian.little);
    data_.setFloat32(36, fullChargeCapacity, Endian.little);
    data_.setUint16(40, cycleCount, Endian.little);
    data_.setUint16(42, weight, Endian.little);
    data_.setUint8(44, id);
    data_.setUint8(45, batteryFunction);
    data_.setUint8(46, type);
    data_.setUint8(47, stateOfHealth);
    data_.setUint8(48, cellsInSeries);
    MavlinkMessage.setInt8List(data_, 49, manufactureDate);
    MavlinkMessage.setInt8List(data_, 58, serialNumber);
    MavlinkMessage.setInt8List(data_, 90, name);
    return data_;
  }
}

/// Telemetry of power generation system. Alternator or mechanical generator.
///
/// GENERATOR_STATUS
class GeneratorStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 373;

  static const int _mavlinkCrcExtra = 117;

  static const int mavlinkEncodedLength = 42;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Status flags.
  ///
  /// MAVLink type: uint64_t
  ///
  /// enum: [MavGeneratorStatusFlag]
  ///
  /// status
  final MavGeneratorStatusFlag status;

  /// Current into/out of battery. Positive for out. Negative for in. NaN: field not provided.
  ///
  /// MAVLink type: float
  ///
  /// units: A
  ///
  /// battery_current
  final float batteryCurrent;

  /// Current going to the UAV. If battery current not available this is the DC current from the generator. Positive for out. Negative for in. NaN: field not provided
  ///
  /// MAVLink type: float
  ///
  /// units: A
  ///
  /// load_current
  final float loadCurrent;

  /// The power being generated. NaN: field not provided
  ///
  /// MAVLink type: float
  ///
  /// units: W
  ///
  /// power_generated
  final float powerGenerated;

  /// Voltage of the bus seen at the generator, or battery bus if battery bus is controlled by generator and at a different voltage to main bus.
  ///
  /// MAVLink type: float
  ///
  /// units: V
  ///
  /// bus_voltage
  final float busVoltage;

  /// The target battery current. Positive for out. Negative for in. NaN: field not provided
  ///
  /// MAVLink type: float
  ///
  /// units: A
  ///
  /// bat_current_setpoint
  final float batCurrentSetpoint;

  /// Seconds this generator has run since it was rebooted. UINT32_MAX: field not provided.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: s
  ///
  /// runtime
  final uint32_t runtime;

  /// Seconds until this generator requires maintenance.  A negative value indicates maintenance is past-due. INT32_MAX: field not provided.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: s
  ///
  /// time_until_maintenance
  final int32_t timeUntilMaintenance;

  /// Speed of electrical generator or alternator. UINT16_MAX: field not provided.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: rpm
  ///
  /// generator_speed
  final uint16_t generatorSpeed;

  /// The temperature of the rectifier or power converter. INT16_MAX: field not provided.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: degC
  ///
  /// rectifier_temperature
  final int16_t rectifierTemperature;

  /// The temperature of the mechanical motor, fuel cell core or generator. INT16_MAX: field not provided.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: degC
  ///
  /// generator_temperature
  final int16_t generatorTemperature;

  GeneratorStatus({
    required this.status,
    required this.batteryCurrent,
    required this.loadCurrent,
    required this.powerGenerated,
    required this.busVoltage,
    required this.batCurrentSetpoint,
    required this.runtime,
    required this.timeUntilMaintenance,
    required this.generatorSpeed,
    required this.rectifierTemperature,
    required this.generatorTemperature,
  });

  GeneratorStatus copyWith({
    MavGeneratorStatusFlag? status,
    float? batteryCurrent,
    float? loadCurrent,
    float? powerGenerated,
    float? busVoltage,
    float? batCurrentSetpoint,
    uint32_t? runtime,
    int32_t? timeUntilMaintenance,
    uint16_t? generatorSpeed,
    int16_t? rectifierTemperature,
    int16_t? generatorTemperature,
  }) {
    return GeneratorStatus(
      status: status ?? this.status,
      batteryCurrent: batteryCurrent ?? this.batteryCurrent,
      loadCurrent: loadCurrent ?? this.loadCurrent,
      powerGenerated: powerGenerated ?? this.powerGenerated,
      busVoltage: busVoltage ?? this.busVoltage,
      batCurrentSetpoint: batCurrentSetpoint ?? this.batCurrentSetpoint,
      runtime: runtime ?? this.runtime,
      timeUntilMaintenance: timeUntilMaintenance ?? this.timeUntilMaintenance,
      generatorSpeed: generatorSpeed ?? this.generatorSpeed,
      rectifierTemperature: rectifierTemperature ?? this.rectifierTemperature,
      generatorTemperature: generatorTemperature ?? this.generatorTemperature,
    );
  }

  factory GeneratorStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < GeneratorStatus.mavlinkEncodedLength) {
      var len = GeneratorStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var status = data_.getUint64(0, Endian.little);
    var batteryCurrent = data_.getFloat32(8, Endian.little);
    var loadCurrent = data_.getFloat32(12, Endian.little);
    var powerGenerated = data_.getFloat32(16, Endian.little);
    var busVoltage = data_.getFloat32(20, Endian.little);
    var batCurrentSetpoint = data_.getFloat32(24, Endian.little);
    var runtime = data_.getUint32(28, Endian.little);
    var timeUntilMaintenance = data_.getInt32(32, Endian.little);
    var generatorSpeed = data_.getUint16(36, Endian.little);
    var rectifierTemperature = data_.getInt16(38, Endian.little);
    var generatorTemperature = data_.getInt16(40, Endian.little);

    return GeneratorStatus(
        status: status,
        batteryCurrent: batteryCurrent,
        loadCurrent: loadCurrent,
        powerGenerated: powerGenerated,
        busVoltage: busVoltage,
        batCurrentSetpoint: batCurrentSetpoint,
        runtime: runtime,
        timeUntilMaintenance: timeUntilMaintenance,
        generatorSpeed: generatorSpeed,
        rectifierTemperature: rectifierTemperature,
        generatorTemperature: generatorTemperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, status, Endian.little);
    data_.setFloat32(8, batteryCurrent, Endian.little);
    data_.setFloat32(12, loadCurrent, Endian.little);
    data_.setFloat32(16, powerGenerated, Endian.little);
    data_.setFloat32(20, busVoltage, Endian.little);
    data_.setFloat32(24, batCurrentSetpoint, Endian.little);
    data_.setUint32(28, runtime, Endian.little);
    data_.setInt32(32, timeUntilMaintenance, Endian.little);
    data_.setUint16(36, generatorSpeed, Endian.little);
    data_.setInt16(38, rectifierTemperature, Endian.little);
    data_.setInt16(40, generatorTemperature, Endian.little);
    return data_;
  }
}

/// The raw values of the actuator outputs (e.g. on Pixhawk, from MAIN, AUX ports). This message supersedes SERVO_OUTPUT_RAW.
///
/// ACTUATOR_OUTPUT_STATUS
class ActuatorOutputStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 375;

  static const int _mavlinkCrcExtra = 251;

  static const int mavlinkEncodedLength = 140;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (since system boot).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Active outputs
  ///
  /// MAVLink type: uint32_t
  ///
  /// active
  final uint32_t active;

  /// Servo / motor output array values. Zero values indicate unused channels.
  ///
  /// MAVLink type: float[32]
  ///
  /// actuator
  final List<float> actuator;

  ActuatorOutputStatus({
    required this.timeUsec,
    required this.active,
    required this.actuator,
  });

  ActuatorOutputStatus copyWith({
    uint64_t? timeUsec,
    uint32_t? active,
    List<float>? actuator,
  }) {
    return ActuatorOutputStatus(
      timeUsec: timeUsec ?? this.timeUsec,
      active: active ?? this.active,
      actuator: actuator ?? this.actuator,
    );
  }

  factory ActuatorOutputStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < ActuatorOutputStatus.mavlinkEncodedLength) {
      var len = ActuatorOutputStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var active = data_.getUint32(8, Endian.little);
    var actuator = MavlinkMessage.asFloat32List(data_, 12, 32);

    return ActuatorOutputStatus(
        timeUsec: timeUsec, active: active, actuator: actuator);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint32(8, active, Endian.little);
    MavlinkMessage.setFloat32List(data_, 12, actuator);
    return data_;
  }
}

/// Time/duration estimates for various events and actions given the current vehicle state and position.
///
/// TIME_ESTIMATE_TO_TARGET
class TimeEstimateToTarget implements MavlinkMessage {
  static const int _mavlinkMessageId = 380;

  static const int _mavlinkCrcExtra = 232;

  static const int mavlinkEncodedLength = 20;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Estimated time to complete the vehicle's configured "safe return" action from its current position (e.g. RTL, Smart RTL, etc.). -1 indicates that the vehicle is landed, or that no time estimate available.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: s
  ///
  /// safe_return
  final int32_t safeReturn;

  /// Estimated time for vehicle to complete the LAND action from its current position. -1 indicates that the vehicle is landed, or that no time estimate available.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: s
  ///
  /// land
  final int32_t land;

  /// Estimated time for reaching/completing the currently active mission item. -1 means no time estimate available.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: s
  ///
  /// mission_next_item
  final int32_t missionNextItem;

  /// Estimated time for completing the current mission. -1 means no mission active and/or no estimate available.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: s
  ///
  /// mission_end
  final int32_t missionEnd;

  /// Estimated time for completing the current commanded action (i.e. Go To, Takeoff, Land, etc.). -1 means no action active and/or no estimate available.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: s
  ///
  /// commanded_action
  final int32_t commandedAction;

  TimeEstimateToTarget({
    required this.safeReturn,
    required this.land,
    required this.missionNextItem,
    required this.missionEnd,
    required this.commandedAction,
  });

  TimeEstimateToTarget copyWith({
    int32_t? safeReturn,
    int32_t? land,
    int32_t? missionNextItem,
    int32_t? missionEnd,
    int32_t? commandedAction,
  }) {
    return TimeEstimateToTarget(
      safeReturn: safeReturn ?? this.safeReturn,
      land: land ?? this.land,
      missionNextItem: missionNextItem ?? this.missionNextItem,
      missionEnd: missionEnd ?? this.missionEnd,
      commandedAction: commandedAction ?? this.commandedAction,
    );
  }

  factory TimeEstimateToTarget.parse(ByteData data_) {
    if (data_.lengthInBytes < TimeEstimateToTarget.mavlinkEncodedLength) {
      var len = TimeEstimateToTarget.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var safeReturn = data_.getInt32(0, Endian.little);
    var land = data_.getInt32(4, Endian.little);
    var missionNextItem = data_.getInt32(8, Endian.little);
    var missionEnd = data_.getInt32(12, Endian.little);
    var commandedAction = data_.getInt32(16, Endian.little);

    return TimeEstimateToTarget(
        safeReturn: safeReturn,
        land: land,
        missionNextItem: missionNextItem,
        missionEnd: missionEnd,
        commandedAction: commandedAction);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, safeReturn, Endian.little);
    data_.setInt32(4, land, Endian.little);
    data_.setInt32(8, missionNextItem, Endian.little);
    data_.setInt32(12, missionEnd, Endian.little);
    data_.setInt32(16, commandedAction, Endian.little);
    return data_;
  }
}

/// Message for transporting "arbitrary" variable-length data from one component to another (broadcast is not forbidden, but discouraged). The encoding of the data is usually extension specific, i.e. determined by the source, and is usually not documented as part of the MAVLink specification.
///
/// TUNNEL
class Tunnel implements MavlinkMessage {
  static const int _mavlinkMessageId = 385;

  static const int _mavlinkCrcExtra = 147;

  static const int mavlinkEncodedLength = 133;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// A code that identifies the content of the payload (0 for unknown, which is the default). If this code is less than 32768, it is a 'registered' payload type and the corresponding code should be added to the MAV_TUNNEL_PAYLOAD_TYPE enum. Software creators can register blocks of types as needed. Codes greater than 32767 are considered local experiments and should not be checked in to any widely distributed codebase.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavTunnelPayloadType]
  ///
  /// payload_type
  final MavTunnelPayloadType payloadType;

  /// System ID (can be 0 for broadcast, but this is discouraged)
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (can be 0 for broadcast, but this is discouraged)
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Length of the data transported in payload
  ///
  /// MAVLink type: uint8_t
  ///
  /// payload_length
  final uint8_t payloadLength;

  /// Variable length payload. The payload length is defined by payload_length. The entire content of this block is opaque unless you understand the encoding specified by payload_type.
  ///
  /// MAVLink type: uint8_t[128]
  ///
  /// payload
  final List<int8_t> payload;

  Tunnel({
    required this.payloadType,
    required this.targetSystem,
    required this.targetComponent,
    required this.payloadLength,
    required this.payload,
  });

  Tunnel copyWith({
    MavTunnelPayloadType? payloadType,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? payloadLength,
    List<int8_t>? payload,
  }) {
    return Tunnel(
      payloadType: payloadType ?? this.payloadType,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      payloadLength: payloadLength ?? this.payloadLength,
      payload: payload ?? this.payload,
    );
  }

  factory Tunnel.parse(ByteData data_) {
    if (data_.lengthInBytes < Tunnel.mavlinkEncodedLength) {
      var len = Tunnel.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var payloadType = data_.getUint16(0, Endian.little);
    var targetSystem = data_.getUint8(2);
    var targetComponent = data_.getUint8(3);
    var payloadLength = data_.getUint8(4);
    var payload = MavlinkMessage.asUint8List(data_, 5, 128);

    return Tunnel(
        payloadType: payloadType,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        payloadLength: payloadLength,
        payload: payload);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, payloadType, Endian.little);
    data_.setUint8(2, targetSystem);
    data_.setUint8(3, targetComponent);
    data_.setUint8(4, payloadLength);
    MavlinkMessage.setUint8List(data_, 5, payload);
    return data_;
  }
}

/// A forwarded CAN frame as requested by MAV_CMD_CAN_FORWARD.
///
/// CAN_FRAME
class CanFrame implements MavlinkMessage {
  static const int _mavlinkMessageId = 386;

  static const int _mavlinkCrcExtra = 132;

  static const int mavlinkEncodedLength = 16;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Frame ID
  ///
  /// MAVLink type: uint32_t
  ///
  /// id
  final uint32_t id;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Bus number
  ///
  /// MAVLink type: uint8_t
  ///
  /// bus
  final uint8_t bus;

  /// Frame length
  ///
  /// MAVLink type: uint8_t
  ///
  /// len
  final uint8_t len;

  /// Frame data
  ///
  /// MAVLink type: uint8_t[8]
  ///
  /// data
  final List<int8_t> data;

  CanFrame({
    required this.id,
    required this.targetSystem,
    required this.targetComponent,
    required this.bus,
    required this.len,
    required this.data,
  });

  CanFrame copyWith({
    uint32_t? id,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? bus,
    uint8_t? len,
    List<int8_t>? data,
  }) {
    return CanFrame(
      id: id ?? this.id,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      bus: bus ?? this.bus,
      len: len ?? this.len,
      data: data ?? this.data,
    );
  }

  factory CanFrame.parse(ByteData data_) {
    if (data_.lengthInBytes < CanFrame.mavlinkEncodedLength) {
      var len = CanFrame.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var id = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var bus = data_.getUint8(6);
    var len = data_.getUint8(7);
    var data = MavlinkMessage.asUint8List(data_, 8, 8);

    return CanFrame(
        id: id,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        bus: bus,
        len: len,
        data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, id, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, bus);
    data_.setUint8(7, len);
    MavlinkMessage.setUint8List(data_, 8, data);
    return data_;
  }
}

/// Hardware status sent by an onboard computer.
///
/// ONBOARD_COMPUTER_STATUS
class OnboardComputerStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 390;

  static const int _mavlinkCrcExtra = 156;

  static const int mavlinkEncodedLength = 238;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude of the number.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Time since system boot.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// uptime
  final uint32_t uptime;

  /// Amount of used RAM on the component system. A value of UINT32_MAX implies the field is unused.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: MiB
  ///
  /// ram_usage
  final uint32_t ramUsage;

  /// Total amount of RAM on the component system. A value of UINT32_MAX implies the field is unused.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: MiB
  ///
  /// ram_total
  final uint32_t ramTotal;

  /// Storage type: 0: HDD, 1: SSD, 2: EMMC, 3: SD card (non-removable), 4: SD card (removable). A value of UINT32_MAX implies the field is unused.
  ///
  /// MAVLink type: uint32_t[4]
  ///
  /// storage_type
  final List<int32_t> storageType;

  /// Amount of used storage space on the component system. A value of UINT32_MAX implies the field is unused.
  ///
  /// MAVLink type: uint32_t[4]
  ///
  /// units: MiB
  ///
  /// storage_usage
  final List<int32_t> storageUsage;

  /// Total amount of storage space on the component system. A value of UINT32_MAX implies the field is unused.
  ///
  /// MAVLink type: uint32_t[4]
  ///
  /// units: MiB
  ///
  /// storage_total
  final List<int32_t> storageTotal;

  /// Link type: 0-9: UART, 10-19: Wired network, 20-29: Wifi, 30-39: Point-to-point proprietary, 40-49: Mesh proprietary
  ///
  /// MAVLink type: uint32_t[6]
  ///
  /// link_type
  final List<int32_t> linkType;

  /// Network traffic from the component system. A value of UINT32_MAX implies the field is unused.
  ///
  /// MAVLink type: uint32_t[6]
  ///
  /// units: KiB/s
  ///
  /// link_tx_rate
  final List<int32_t> linkTxRate;

  /// Network traffic to the component system. A value of UINT32_MAX implies the field is unused.
  ///
  /// MAVLink type: uint32_t[6]
  ///
  /// units: KiB/s
  ///
  /// link_rx_rate
  final List<int32_t> linkRxRate;

  /// Network capacity from the component system. A value of UINT32_MAX implies the field is unused.
  ///
  /// MAVLink type: uint32_t[6]
  ///
  /// units: KiB/s
  ///
  /// link_tx_max
  final List<int32_t> linkTxMax;

  /// Network capacity to the component system. A value of UINT32_MAX implies the field is unused.
  ///
  /// MAVLink type: uint32_t[6]
  ///
  /// units: KiB/s
  ///
  /// link_rx_max
  final List<int32_t> linkRxMax;

  /// Fan speeds. A value of INT16_MAX implies the field is unused.
  ///
  /// MAVLink type: int16_t[4]
  ///
  /// units: rpm
  ///
  /// fan_speed
  final List<int16_t> fanSpeed;

  /// Type of the onboard computer: 0: Mission computer primary, 1: Mission computer backup 1, 2: Mission computer backup 2, 3: Compute node, 4-5: Compute spares, 6-9: Payload computers.
  ///
  /// MAVLink type: uint8_t
  ///
  /// type
  final uint8_t type;

  /// CPU usage on the component in percent (100 - idle). A value of UINT8_MAX implies the field is unused.
  ///
  /// MAVLink type: uint8_t[8]
  ///
  /// cpu_cores
  final List<int8_t> cpuCores;

  /// Combined CPU usage as the last 10 slices of 100 MS (a histogram). This allows to identify spikes in load that max out the system, but only for a short amount of time. A value of UINT8_MAX implies the field is unused.
  ///
  /// MAVLink type: uint8_t[10]
  ///
  /// cpu_combined
  final List<int8_t> cpuCombined;

  /// GPU usage on the component in percent (100 - idle). A value of UINT8_MAX implies the field is unused.
  ///
  /// MAVLink type: uint8_t[4]
  ///
  /// gpu_cores
  final List<int8_t> gpuCores;

  /// Combined GPU usage as the last 10 slices of 100 MS (a histogram). This allows to identify spikes in load that max out the system, but only for a short amount of time. A value of UINT8_MAX implies the field is unused.
  ///
  /// MAVLink type: uint8_t[10]
  ///
  /// gpu_combined
  final List<int8_t> gpuCombined;

  /// Temperature of the board. A value of INT8_MAX implies the field is unused.
  ///
  /// MAVLink type: int8_t
  ///
  /// units: degC
  ///
  /// temperature_board
  final int8_t temperatureBoard;

  /// Temperature of the CPU core. A value of INT8_MAX implies the field is unused.
  ///
  /// MAVLink type: int8_t[8]
  ///
  /// units: degC
  ///
  /// temperature_core
  final List<int8_t> temperatureCore;

  OnboardComputerStatus({
    required this.timeUsec,
    required this.uptime,
    required this.ramUsage,
    required this.ramTotal,
    required this.storageType,
    required this.storageUsage,
    required this.storageTotal,
    required this.linkType,
    required this.linkTxRate,
    required this.linkRxRate,
    required this.linkTxMax,
    required this.linkRxMax,
    required this.fanSpeed,
    required this.type,
    required this.cpuCores,
    required this.cpuCombined,
    required this.gpuCores,
    required this.gpuCombined,
    required this.temperatureBoard,
    required this.temperatureCore,
  });

  OnboardComputerStatus copyWith({
    uint64_t? timeUsec,
    uint32_t? uptime,
    uint32_t? ramUsage,
    uint32_t? ramTotal,
    List<int32_t>? storageType,
    List<int32_t>? storageUsage,
    List<int32_t>? storageTotal,
    List<int32_t>? linkType,
    List<int32_t>? linkTxRate,
    List<int32_t>? linkRxRate,
    List<int32_t>? linkTxMax,
    List<int32_t>? linkRxMax,
    List<int16_t>? fanSpeed,
    uint8_t? type,
    List<int8_t>? cpuCores,
    List<int8_t>? cpuCombined,
    List<int8_t>? gpuCores,
    List<int8_t>? gpuCombined,
    int8_t? temperatureBoard,
    List<int8_t>? temperatureCore,
  }) {
    return OnboardComputerStatus(
      timeUsec: timeUsec ?? this.timeUsec,
      uptime: uptime ?? this.uptime,
      ramUsage: ramUsage ?? this.ramUsage,
      ramTotal: ramTotal ?? this.ramTotal,
      storageType: storageType ?? this.storageType,
      storageUsage: storageUsage ?? this.storageUsage,
      storageTotal: storageTotal ?? this.storageTotal,
      linkType: linkType ?? this.linkType,
      linkTxRate: linkTxRate ?? this.linkTxRate,
      linkRxRate: linkRxRate ?? this.linkRxRate,
      linkTxMax: linkTxMax ?? this.linkTxMax,
      linkRxMax: linkRxMax ?? this.linkRxMax,
      fanSpeed: fanSpeed ?? this.fanSpeed,
      type: type ?? this.type,
      cpuCores: cpuCores ?? this.cpuCores,
      cpuCombined: cpuCombined ?? this.cpuCombined,
      gpuCores: gpuCores ?? this.gpuCores,
      gpuCombined: gpuCombined ?? this.gpuCombined,
      temperatureBoard: temperatureBoard ?? this.temperatureBoard,
      temperatureCore: temperatureCore ?? this.temperatureCore,
    );
  }

  factory OnboardComputerStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < OnboardComputerStatus.mavlinkEncodedLength) {
      var len =
          OnboardComputerStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var uptime = data_.getUint32(8, Endian.little);
    var ramUsage = data_.getUint32(12, Endian.little);
    var ramTotal = data_.getUint32(16, Endian.little);
    var storageType = MavlinkMessage.asUint32List(data_, 20, 4);
    var storageUsage = MavlinkMessage.asUint32List(data_, 36, 4);
    var storageTotal = MavlinkMessage.asUint32List(data_, 52, 4);
    var linkType = MavlinkMessage.asUint32List(data_, 68, 6);
    var linkTxRate = MavlinkMessage.asUint32List(data_, 92, 6);
    var linkRxRate = MavlinkMessage.asUint32List(data_, 116, 6);
    var linkTxMax = MavlinkMessage.asUint32List(data_, 140, 6);
    var linkRxMax = MavlinkMessage.asUint32List(data_, 164, 6);
    var fanSpeed = MavlinkMessage.asInt16List(data_, 188, 4);
    var type = data_.getUint8(196);
    var cpuCores = MavlinkMessage.asUint8List(data_, 197, 8);
    var cpuCombined = MavlinkMessage.asUint8List(data_, 205, 10);
    var gpuCores = MavlinkMessage.asUint8List(data_, 215, 4);
    var gpuCombined = MavlinkMessage.asUint8List(data_, 219, 10);
    var temperatureBoard = data_.getInt8(229);
    var temperatureCore = MavlinkMessage.asInt8List(data_, 230, 8);

    return OnboardComputerStatus(
        timeUsec: timeUsec,
        uptime: uptime,
        ramUsage: ramUsage,
        ramTotal: ramTotal,
        storageType: storageType,
        storageUsage: storageUsage,
        storageTotal: storageTotal,
        linkType: linkType,
        linkTxRate: linkTxRate,
        linkRxRate: linkRxRate,
        linkTxMax: linkTxMax,
        linkRxMax: linkRxMax,
        fanSpeed: fanSpeed,
        type: type,
        cpuCores: cpuCores,
        cpuCombined: cpuCombined,
        gpuCores: gpuCores,
        gpuCombined: gpuCombined,
        temperatureBoard: temperatureBoard,
        temperatureCore: temperatureCore);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint32(8, uptime, Endian.little);
    data_.setUint32(12, ramUsage, Endian.little);
    data_.setUint32(16, ramTotal, Endian.little);
    MavlinkMessage.setUint32List(data_, 20, storageType);
    MavlinkMessage.setUint32List(data_, 36, storageUsage);
    MavlinkMessage.setUint32List(data_, 52, storageTotal);
    MavlinkMessage.setUint32List(data_, 68, linkType);
    MavlinkMessage.setUint32List(data_, 92, linkTxRate);
    MavlinkMessage.setUint32List(data_, 116, linkRxRate);
    MavlinkMessage.setUint32List(data_, 140, linkTxMax);
    MavlinkMessage.setUint32List(data_, 164, linkRxMax);
    MavlinkMessage.setInt16List(data_, 188, fanSpeed);
    data_.setUint8(196, type);
    MavlinkMessage.setUint8List(data_, 197, cpuCores);
    MavlinkMessage.setUint8List(data_, 205, cpuCombined);
    MavlinkMessage.setUint8List(data_, 215, gpuCores);
    MavlinkMessage.setUint8List(data_, 219, gpuCombined);
    data_.setInt8(229, temperatureBoard);
    MavlinkMessage.setInt8List(data_, 230, temperatureCore);
    return data_;
  }
}

///
/// Component information message, which may be requested using MAV_CMD_REQUEST_MESSAGE.
///
///
/// COMPONENT_INFORMATION
class ComponentInformation implements MavlinkMessage {
  static const int _mavlinkMessageId = 395;

  static const int _mavlinkCrcExtra = 0;

  static const int mavlinkEncodedLength = 212;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// CRC32 of the general metadata file (general_metadata_uri).
  ///
  /// MAVLink type: uint32_t
  ///
  /// general_metadata_file_crc
  final uint32_t generalMetadataFileCrc;

  /// CRC32 of peripherals metadata file (peripherals_metadata_uri).
  ///
  /// MAVLink type: uint32_t
  ///
  /// peripherals_metadata_file_crc
  final uint32_t peripheralsMetadataFileCrc;

  /// MAVLink FTP URI for the general metadata file (COMP_METADATA_TYPE_GENERAL), which may be compressed with xz. The file contains general component metadata, and may contain URI links for additional metadata (see COMP_METADATA_TYPE). The information is static from boot, and may be generated at compile time. The string needs to be zero terminated.
  ///
  /// MAVLink type: char[100]
  ///
  /// general_metadata_uri
  final List<char> generalMetadataUri;

  /// (Optional) MAVLink FTP URI for the peripherals metadata file (COMP_METADATA_TYPE_PERIPHERALS), which may be compressed with xz. This contains data about "attached components" such as UAVCAN nodes. The peripherals are in a separate file because the information must be generated dynamically at runtime. The string needs to be zero terminated.
  ///
  /// MAVLink type: char[100]
  ///
  /// peripherals_metadata_uri
  final List<char> peripheralsMetadataUri;

  ComponentInformation({
    required this.timeBootMs,
    required this.generalMetadataFileCrc,
    required this.peripheralsMetadataFileCrc,
    required this.generalMetadataUri,
    required this.peripheralsMetadataUri,
  });

  ComponentInformation copyWith({
    uint32_t? timeBootMs,
    uint32_t? generalMetadataFileCrc,
    uint32_t? peripheralsMetadataFileCrc,
    List<char>? generalMetadataUri,
    List<char>? peripheralsMetadataUri,
  }) {
    return ComponentInformation(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      generalMetadataFileCrc:
          generalMetadataFileCrc ?? this.generalMetadataFileCrc,
      peripheralsMetadataFileCrc:
          peripheralsMetadataFileCrc ?? this.peripheralsMetadataFileCrc,
      generalMetadataUri: generalMetadataUri ?? this.generalMetadataUri,
      peripheralsMetadataUri:
          peripheralsMetadataUri ?? this.peripheralsMetadataUri,
    );
  }

  factory ComponentInformation.parse(ByteData data_) {
    if (data_.lengthInBytes < ComponentInformation.mavlinkEncodedLength) {
      var len = ComponentInformation.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var generalMetadataFileCrc = data_.getUint32(4, Endian.little);
    var peripheralsMetadataFileCrc = data_.getUint32(8, Endian.little);
    var generalMetadataUri = MavlinkMessage.asInt8List(data_, 12, 100);
    var peripheralsMetadataUri = MavlinkMessage.asInt8List(data_, 112, 100);

    return ComponentInformation(
        timeBootMs: timeBootMs,
        generalMetadataFileCrc: generalMetadataFileCrc,
        peripheralsMetadataFileCrc: peripheralsMetadataFileCrc,
        generalMetadataUri: generalMetadataUri,
        peripheralsMetadataUri: peripheralsMetadataUri);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint32(4, generalMetadataFileCrc, Endian.little);
    data_.setUint32(8, peripheralsMetadataFileCrc, Endian.little);
    MavlinkMessage.setInt8List(data_, 12, generalMetadataUri);
    MavlinkMessage.setInt8List(data_, 112, peripheralsMetadataUri);
    return data_;
  }
}

/// Basic component information data. Should be requested using MAV_CMD_REQUEST_MESSAGE on startup, or when required.
///
/// COMPONENT_INFORMATION_BASIC
class ComponentInformationBasic implements MavlinkMessage {
  static const int _mavlinkMessageId = 396;

  static const int _mavlinkCrcExtra = 50;

  static const int mavlinkEncodedLength = 160;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Component capability flags
  ///
  /// MAVLink type: uint64_t
  ///
  /// enum: [MavProtocolCapability]
  ///
  /// capabilities
  final MavProtocolCapability capabilities;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Date of manufacture as a UNIX Epoch time (since 1.1.1970) in seconds.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: s
  ///
  /// time_manufacture_s
  final uint32_t timeManufactureS;

  /// Name of the component vendor. Needs to be zero terminated. The field is optional and can be empty/all zeros.
  ///
  /// MAVLink type: char[32]
  ///
  /// vendor_name
  final List<char> vendorName;

  /// Name of the component model. Needs to be zero terminated. The field is optional and can be empty/all zeros.
  ///
  /// MAVLink type: char[32]
  ///
  /// model_name
  final List<char> modelName;

  /// Software version. The recommended format is SEMVER: 'major.minor.patch'  (any format may be used). The field must be zero terminated if it has a value. The field is optional and can be empty/all zeros.
  ///
  /// MAVLink type: char[24]
  ///
  /// software_version
  final List<char> softwareVersion;

  /// Hardware version. The recommended format is SEMVER: 'major.minor.patch'  (any format may be used). The field must be zero terminated if it has a value. The field is optional and can be empty/all zeros.
  ///
  /// MAVLink type: char[24]
  ///
  /// hardware_version
  final List<char> hardwareVersion;

  /// Hardware serial number. The field must be zero terminated if it has a value. The field is optional and can be empty/all zeros.
  ///
  /// MAVLink type: char[32]
  ///
  /// serial_number
  final List<char> serialNumber;

  ComponentInformationBasic({
    required this.capabilities,
    required this.timeBootMs,
    required this.timeManufactureS,
    required this.vendorName,
    required this.modelName,
    required this.softwareVersion,
    required this.hardwareVersion,
    required this.serialNumber,
  });

  ComponentInformationBasic copyWith({
    MavProtocolCapability? capabilities,
    uint32_t? timeBootMs,
    uint32_t? timeManufactureS,
    List<char>? vendorName,
    List<char>? modelName,
    List<char>? softwareVersion,
    List<char>? hardwareVersion,
    List<char>? serialNumber,
  }) {
    return ComponentInformationBasic(
      capabilities: capabilities ?? this.capabilities,
      timeBootMs: timeBootMs ?? this.timeBootMs,
      timeManufactureS: timeManufactureS ?? this.timeManufactureS,
      vendorName: vendorName ?? this.vendorName,
      modelName: modelName ?? this.modelName,
      softwareVersion: softwareVersion ?? this.softwareVersion,
      hardwareVersion: hardwareVersion ?? this.hardwareVersion,
      serialNumber: serialNumber ?? this.serialNumber,
    );
  }

  factory ComponentInformationBasic.parse(ByteData data_) {
    if (data_.lengthInBytes < ComponentInformationBasic.mavlinkEncodedLength) {
      var len =
          ComponentInformationBasic.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var capabilities = data_.getUint64(0, Endian.little);
    var timeBootMs = data_.getUint32(8, Endian.little);
    var timeManufactureS = data_.getUint32(12, Endian.little);
    var vendorName = MavlinkMessage.asInt8List(data_, 16, 32);
    var modelName = MavlinkMessage.asInt8List(data_, 48, 32);
    var softwareVersion = MavlinkMessage.asInt8List(data_, 80, 24);
    var hardwareVersion = MavlinkMessage.asInt8List(data_, 104, 24);
    var serialNumber = MavlinkMessage.asInt8List(data_, 128, 32);

    return ComponentInformationBasic(
        capabilities: capabilities,
        timeBootMs: timeBootMs,
        timeManufactureS: timeManufactureS,
        vendorName: vendorName,
        modelName: modelName,
        softwareVersion: softwareVersion,
        hardwareVersion: hardwareVersion,
        serialNumber: serialNumber);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, capabilities, Endian.little);
    data_.setUint32(8, timeBootMs, Endian.little);
    data_.setUint32(12, timeManufactureS, Endian.little);
    MavlinkMessage.setInt8List(data_, 16, vendorName);
    MavlinkMessage.setInt8List(data_, 48, modelName);
    MavlinkMessage.setInt8List(data_, 80, softwareVersion);
    MavlinkMessage.setInt8List(data_, 104, hardwareVersion);
    MavlinkMessage.setInt8List(data_, 128, serialNumber);
    return data_;
  }
}

///
/// Component metadata message, which may be requested using MAV_CMD_REQUEST_MESSAGE.
///
/// This contains the MAVLink FTP URI and CRC for the component's general metadata file.
/// The file must be hosted on the component, and may be xz compressed.
/// The file CRC can be used for file caching.
///
/// The general metadata file can be read to get the locations of other metadata files (COMP_METADATA_TYPE) and translations, which may be hosted either on the vehicle or the internet.
/// For more information see: https://mavlink.io/en/services/component_information.html.
///
/// Note: Camera components should use CAMERA_INFORMATION instead, and autopilots may use both this message and AUTOPILOT_VERSION.
///
///
/// COMPONENT_METADATA
class ComponentMetadata implements MavlinkMessage {
  static const int _mavlinkMessageId = 397;

  static const int _mavlinkCrcExtra = 182;

  static const int mavlinkEncodedLength = 108;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// CRC32 of the general metadata file.
  ///
  /// MAVLink type: uint32_t
  ///
  /// file_crc
  final uint32_t fileCrc;

  /// MAVLink FTP URI for the general metadata file (COMP_METADATA_TYPE_GENERAL), which may be compressed with xz. The file contains general component metadata, and may contain URI links for additional metadata (see COMP_METADATA_TYPE). The information is static from boot, and may be generated at compile time. The string needs to be zero terminated.
  ///
  /// MAVLink type: char[100]
  ///
  /// uri
  final List<char> uri;

  ComponentMetadata({
    required this.timeBootMs,
    required this.fileCrc,
    required this.uri,
  });

  ComponentMetadata copyWith({
    uint32_t? timeBootMs,
    uint32_t? fileCrc,
    List<char>? uri,
  }) {
    return ComponentMetadata(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      fileCrc: fileCrc ?? this.fileCrc,
      uri: uri ?? this.uri,
    );
  }

  factory ComponentMetadata.parse(ByteData data_) {
    if (data_.lengthInBytes < ComponentMetadata.mavlinkEncodedLength) {
      var len = ComponentMetadata.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var fileCrc = data_.getUint32(4, Endian.little);
    var uri = MavlinkMessage.asInt8List(data_, 8, 100);

    return ComponentMetadata(
        timeBootMs: timeBootMs, fileCrc: fileCrc, uri: uri);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint32(4, fileCrc, Endian.little);
    MavlinkMessage.setInt8List(data_, 8, uri);
    return data_;
  }
}

/// Play vehicle tone/tune (buzzer). Supersedes message PLAY_TUNE.
///
/// PLAY_TUNE_V2
class PlayTuneV2 implements MavlinkMessage {
  static const int _mavlinkMessageId = 400;

  static const int _mavlinkCrcExtra = 110;

  static const int mavlinkEncodedLength = 254;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Tune format
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [TuneFormat]
  ///
  /// format
  final TuneFormat format;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Tune definition as a NULL-terminated string.
  ///
  /// MAVLink type: char[248]
  ///
  /// tune
  final List<char> tune;

  PlayTuneV2({
    required this.format,
    required this.targetSystem,
    required this.targetComponent,
    required this.tune,
  });

  PlayTuneV2 copyWith({
    TuneFormat? format,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<char>? tune,
  }) {
    return PlayTuneV2(
      format: format ?? this.format,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      tune: tune ?? this.tune,
    );
  }

  factory PlayTuneV2.parse(ByteData data_) {
    if (data_.lengthInBytes < PlayTuneV2.mavlinkEncodedLength) {
      var len = PlayTuneV2.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var format = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var tune = MavlinkMessage.asInt8List(data_, 6, 248);

    return PlayTuneV2(
        format: format,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        tune: tune);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, format, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    MavlinkMessage.setInt8List(data_, 6, tune);
    return data_;
  }
}

/// Tune formats supported by vehicle. This should be emitted as response to MAV_CMD_REQUEST_MESSAGE.
///
/// SUPPORTED_TUNES
class SupportedTunes implements MavlinkMessage {
  static const int _mavlinkMessageId = 401;

  static const int _mavlinkCrcExtra = 183;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Bitfield of supported tune formats.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [TuneFormat]
  ///
  /// format
  final TuneFormat format;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  SupportedTunes({
    required this.format,
    required this.targetSystem,
    required this.targetComponent,
  });

  SupportedTunes copyWith({
    TuneFormat? format,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return SupportedTunes(
      format: format ?? this.format,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory SupportedTunes.parse(ByteData data_) {
    if (data_.lengthInBytes < SupportedTunes.mavlinkEncodedLength) {
      var len = SupportedTunes.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var format = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);

    return SupportedTunes(
        format: format,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, format, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    return data_;
  }
}

/// Event message. Each new event from a particular component gets a new sequence number. The same message might be sent multiple times if (re-)requested. Most events are broadcast, some can be specific to a target component (as receivers keep track of the sequence for missed events, all events need to be broadcast. Thus we use destination_component instead of target_component).
///
/// EVENT
class Event implements MavlinkMessage {
  static const int _mavlinkMessageId = 410;

  static const int _mavlinkCrcExtra = 160;

  static const int mavlinkEncodedLength = 53;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Event ID (as defined in the component metadata)
  ///
  /// MAVLink type: uint32_t
  ///
  /// id
  final uint32_t id;

  /// Timestamp (time since system boot when the event happened).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// event_time_boot_ms
  final uint32_t eventTimeBootMs;

  /// Sequence number.
  ///
  /// MAVLink type: uint16_t
  ///
  /// sequence
  final uint16_t sequence;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// destination_component
  final uint8_t destinationComponent;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// destination_system
  final uint8_t destinationSystem;

  /// Log levels: 4 bits MSB: internal (for logging purposes), 4 bits LSB: external. Levels: Emergency = 0, Alert = 1, Critical = 2, Error = 3, Warning = 4, Notice = 5, Info = 6, Debug = 7, Protocol = 8, Disabled = 9
  ///
  /// MAVLink type: uint8_t
  ///
  /// log_levels
  final uint8_t logLevels;

  /// Arguments (depend on event ID).
  ///
  /// MAVLink type: uint8_t[40]
  ///
  /// arguments
  final List<int8_t> arguments;

  Event({
    required this.id,
    required this.eventTimeBootMs,
    required this.sequence,
    required this.destinationComponent,
    required this.destinationSystem,
    required this.logLevels,
    required this.arguments,
  });

  Event copyWith({
    uint32_t? id,
    uint32_t? eventTimeBootMs,
    uint16_t? sequence,
    uint8_t? destinationComponent,
    uint8_t? destinationSystem,
    uint8_t? logLevels,
    List<int8_t>? arguments,
  }) {
    return Event(
      id: id ?? this.id,
      eventTimeBootMs: eventTimeBootMs ?? this.eventTimeBootMs,
      sequence: sequence ?? this.sequence,
      destinationComponent: destinationComponent ?? this.destinationComponent,
      destinationSystem: destinationSystem ?? this.destinationSystem,
      logLevels: logLevels ?? this.logLevels,
      arguments: arguments ?? this.arguments,
    );
  }

  factory Event.parse(ByteData data_) {
    if (data_.lengthInBytes < Event.mavlinkEncodedLength) {
      var len = Event.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var id = data_.getUint32(0, Endian.little);
    var eventTimeBootMs = data_.getUint32(4, Endian.little);
    var sequence = data_.getUint16(8, Endian.little);
    var destinationComponent = data_.getUint8(10);
    var destinationSystem = data_.getUint8(11);
    var logLevels = data_.getUint8(12);
    var arguments = MavlinkMessage.asUint8List(data_, 13, 40);

    return Event(
        id: id,
        eventTimeBootMs: eventTimeBootMs,
        sequence: sequence,
        destinationComponent: destinationComponent,
        destinationSystem: destinationSystem,
        logLevels: logLevels,
        arguments: arguments);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, id, Endian.little);
    data_.setUint32(4, eventTimeBootMs, Endian.little);
    data_.setUint16(8, sequence, Endian.little);
    data_.setUint8(10, destinationComponent);
    data_.setUint8(11, destinationSystem);
    data_.setUint8(12, logLevels);
    MavlinkMessage.setUint8List(data_, 13, arguments);
    return data_;
  }
}

/// Regular broadcast for the current latest event sequence number for a component. This is used to check for dropped events.
///
/// CURRENT_EVENT_SEQUENCE
class CurrentEventSequence implements MavlinkMessage {
  static const int _mavlinkMessageId = 411;

  static const int _mavlinkCrcExtra = 106;

  static const int mavlinkEncodedLength = 3;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Sequence number.
  ///
  /// MAVLink type: uint16_t
  ///
  /// sequence
  final uint16_t sequence;

  /// Flag bitset.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavEventCurrentSequenceFlags]
  ///
  /// flags
  final MavEventCurrentSequenceFlags flags;

  CurrentEventSequence({
    required this.sequence,
    required this.flags,
  });

  CurrentEventSequence copyWith({
    uint16_t? sequence,
    MavEventCurrentSequenceFlags? flags,
  }) {
    return CurrentEventSequence(
      sequence: sequence ?? this.sequence,
      flags: flags ?? this.flags,
    );
  }

  factory CurrentEventSequence.parse(ByteData data_) {
    if (data_.lengthInBytes < CurrentEventSequence.mavlinkEncodedLength) {
      var len = CurrentEventSequence.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var sequence = data_.getUint16(0, Endian.little);
    var flags = data_.getUint8(2);

    return CurrentEventSequence(sequence: sequence, flags: flags);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, sequence, Endian.little);
    data_.setUint8(2, flags);
    return data_;
  }
}

/// Request one or more events to be (re-)sent. If first_sequence==last_sequence, only a single event is requested. Note that first_sequence can be larger than last_sequence (because the sequence number can wrap). Each sequence will trigger an EVENT or EVENT_ERROR response.
///
/// REQUEST_EVENT
class RequestEvent implements MavlinkMessage {
  static const int _mavlinkMessageId = 412;

  static const int _mavlinkCrcExtra = 33;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// First sequence number of the requested event.
  ///
  /// MAVLink type: uint16_t
  ///
  /// first_sequence
  final uint16_t firstSequence;

  /// Last sequence number of the requested event.
  ///
  /// MAVLink type: uint16_t
  ///
  /// last_sequence
  final uint16_t lastSequence;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  RequestEvent({
    required this.firstSequence,
    required this.lastSequence,
    required this.targetSystem,
    required this.targetComponent,
  });

  RequestEvent copyWith({
    uint16_t? firstSequence,
    uint16_t? lastSequence,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return RequestEvent(
      firstSequence: firstSequence ?? this.firstSequence,
      lastSequence: lastSequence ?? this.lastSequence,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory RequestEvent.parse(ByteData data_) {
    if (data_.lengthInBytes < RequestEvent.mavlinkEncodedLength) {
      var len = RequestEvent.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var firstSequence = data_.getUint16(0, Endian.little);
    var lastSequence = data_.getUint16(2, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);

    return RequestEvent(
        firstSequence: firstSequence,
        lastSequence: lastSequence,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, firstSequence, Endian.little);
    data_.setUint16(2, lastSequence, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    return data_;
  }
}

/// Response to a REQUEST_EVENT in case of an error (e.g. the event is not available anymore).
///
/// RESPONSE_EVENT_ERROR
class ResponseEventError implements MavlinkMessage {
  static const int _mavlinkMessageId = 413;

  static const int _mavlinkCrcExtra = 77;

  static const int mavlinkEncodedLength = 7;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Sequence number.
  ///
  /// MAVLink type: uint16_t
  ///
  /// sequence
  final uint16_t sequence;

  /// Oldest Sequence number that is still available after the sequence set in REQUEST_EVENT.
  ///
  /// MAVLink type: uint16_t
  ///
  /// sequence_oldest_available
  final uint16_t sequenceOldestAvailable;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Error reason.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavEventErrorReason]
  ///
  /// reason
  final MavEventErrorReason reason;

  ResponseEventError({
    required this.sequence,
    required this.sequenceOldestAvailable,
    required this.targetSystem,
    required this.targetComponent,
    required this.reason,
  });

  ResponseEventError copyWith({
    uint16_t? sequence,
    uint16_t? sequenceOldestAvailable,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavEventErrorReason? reason,
  }) {
    return ResponseEventError(
      sequence: sequence ?? this.sequence,
      sequenceOldestAvailable:
          sequenceOldestAvailable ?? this.sequenceOldestAvailable,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      reason: reason ?? this.reason,
    );
  }

  factory ResponseEventError.parse(ByteData data_) {
    if (data_.lengthInBytes < ResponseEventError.mavlinkEncodedLength) {
      var len = ResponseEventError.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var sequence = data_.getUint16(0, Endian.little);
    var sequenceOldestAvailable = data_.getUint16(2, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var reason = data_.getUint8(6);

    return ResponseEventError(
        sequence: sequence,
        sequenceOldestAvailable: sequenceOldestAvailable,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        reason: reason);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, sequence, Endian.little);
    data_.setUint16(2, sequenceOldestAvailable, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, reason);
    return data_;
  }
}

/// Illuminator status
///
/// ILLUMINATOR_STATUS
class IlluminatorStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 440;

  static const int _mavlinkCrcExtra = 66;

  static const int mavlinkEncodedLength = 35;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Time since the start-up of the illuminator in ms
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// uptime_ms
  final uint32_t uptimeMs;

  /// Errors
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [IlluminatorErrorFlags]
  ///
  /// error_status
  final IlluminatorErrorFlags errorStatus;

  /// Illuminator brightness
  ///
  /// MAVLink type: float
  ///
  /// units: %
  ///
  /// brightness
  final float brightness;

  /// Illuminator strobing period in seconds
  ///
  /// MAVLink type: float
  ///
  /// units: s
  ///
  /// strobe_period
  final float strobePeriod;

  /// Illuminator strobing duty cycle
  ///
  /// MAVLink type: float
  ///
  /// units: %
  ///
  /// strobe_duty_cycle
  final float strobeDutyCycle;

  /// Temperature in Celsius
  ///
  /// MAVLink type: float
  ///
  /// temp_c
  final float tempC;

  /// Minimum strobing period in seconds
  ///
  /// MAVLink type: float
  ///
  /// units: s
  ///
  /// min_strobe_period
  final float minStrobePeriod;

  /// Maximum strobing period in seconds
  ///
  /// MAVLink type: float
  ///
  /// units: s
  ///
  /// max_strobe_period
  final float maxStrobePeriod;

  /// 0: Illuminators OFF, 1: Illuminators ON
  ///
  /// MAVLink type: uint8_t
  ///
  /// enable
  final uint8_t enable;

  /// Supported illuminator modes
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [IlluminatorMode]
  ///
  /// mode_bitmask
  final IlluminatorMode modeBitmask;

  /// Illuminator mode
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [IlluminatorMode]
  ///
  /// mode
  final IlluminatorMode mode;

  IlluminatorStatus({
    required this.uptimeMs,
    required this.errorStatus,
    required this.brightness,
    required this.strobePeriod,
    required this.strobeDutyCycle,
    required this.tempC,
    required this.minStrobePeriod,
    required this.maxStrobePeriod,
    required this.enable,
    required this.modeBitmask,
    required this.mode,
  });

  IlluminatorStatus copyWith({
    uint32_t? uptimeMs,
    IlluminatorErrorFlags? errorStatus,
    float? brightness,
    float? strobePeriod,
    float? strobeDutyCycle,
    float? tempC,
    float? minStrobePeriod,
    float? maxStrobePeriod,
    uint8_t? enable,
    IlluminatorMode? modeBitmask,
    IlluminatorMode? mode,
  }) {
    return IlluminatorStatus(
      uptimeMs: uptimeMs ?? this.uptimeMs,
      errorStatus: errorStatus ?? this.errorStatus,
      brightness: brightness ?? this.brightness,
      strobePeriod: strobePeriod ?? this.strobePeriod,
      strobeDutyCycle: strobeDutyCycle ?? this.strobeDutyCycle,
      tempC: tempC ?? this.tempC,
      minStrobePeriod: minStrobePeriod ?? this.minStrobePeriod,
      maxStrobePeriod: maxStrobePeriod ?? this.maxStrobePeriod,
      enable: enable ?? this.enable,
      modeBitmask: modeBitmask ?? this.modeBitmask,
      mode: mode ?? this.mode,
    );
  }

  factory IlluminatorStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < IlluminatorStatus.mavlinkEncodedLength) {
      var len = IlluminatorStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var uptimeMs = data_.getUint32(0, Endian.little);
    var errorStatus = data_.getUint32(4, Endian.little);
    var brightness = data_.getFloat32(8, Endian.little);
    var strobePeriod = data_.getFloat32(12, Endian.little);
    var strobeDutyCycle = data_.getFloat32(16, Endian.little);
    var tempC = data_.getFloat32(20, Endian.little);
    var minStrobePeriod = data_.getFloat32(24, Endian.little);
    var maxStrobePeriod = data_.getFloat32(28, Endian.little);
    var enable = data_.getUint8(32);
    var modeBitmask = data_.getUint8(33);
    var mode = data_.getUint8(34);

    return IlluminatorStatus(
        uptimeMs: uptimeMs,
        errorStatus: errorStatus,
        brightness: brightness,
        strobePeriod: strobePeriod,
        strobeDutyCycle: strobeDutyCycle,
        tempC: tempC,
        minStrobePeriod: minStrobePeriod,
        maxStrobePeriod: maxStrobePeriod,
        enable: enable,
        modeBitmask: modeBitmask,
        mode: mode);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, uptimeMs, Endian.little);
    data_.setUint32(4, errorStatus, Endian.little);
    data_.setFloat32(8, brightness, Endian.little);
    data_.setFloat32(12, strobePeriod, Endian.little);
    data_.setFloat32(16, strobeDutyCycle, Endian.little);
    data_.setFloat32(20, tempC, Endian.little);
    data_.setFloat32(24, minStrobePeriod, Endian.little);
    data_.setFloat32(28, maxStrobePeriod, Endian.little);
    data_.setUint8(32, enable);
    data_.setUint8(33, modeBitmask);
    data_.setUint8(34, mode);
    return data_;
  }
}

/// A forwarded CANFD frame as requested by MAV_CMD_CAN_FORWARD. These are separated from CAN_FRAME as they need different handling (eg. TAO handling)
///
/// CANFD_FRAME
class CanfdFrame implements MavlinkMessage {
  static const int _mavlinkMessageId = 387;

  static const int _mavlinkCrcExtra = 4;

  static const int mavlinkEncodedLength = 72;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Frame ID
  ///
  /// MAVLink type: uint32_t
  ///
  /// id
  final uint32_t id;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// bus number
  ///
  /// MAVLink type: uint8_t
  ///
  /// bus
  final uint8_t bus;

  /// Frame length
  ///
  /// MAVLink type: uint8_t
  ///
  /// len
  final uint8_t len;

  /// Frame data
  ///
  /// MAVLink type: uint8_t[64]
  ///
  /// data
  final List<int8_t> data;

  CanfdFrame({
    required this.id,
    required this.targetSystem,
    required this.targetComponent,
    required this.bus,
    required this.len,
    required this.data,
  });

  CanfdFrame copyWith({
    uint32_t? id,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? bus,
    uint8_t? len,
    List<int8_t>? data,
  }) {
    return CanfdFrame(
      id: id ?? this.id,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      bus: bus ?? this.bus,
      len: len ?? this.len,
      data: data ?? this.data,
    );
  }

  factory CanfdFrame.parse(ByteData data_) {
    if (data_.lengthInBytes < CanfdFrame.mavlinkEncodedLength) {
      var len = CanfdFrame.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var id = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var bus = data_.getUint8(6);
    var len = data_.getUint8(7);
    var data = MavlinkMessage.asUint8List(data_, 8, 64);

    return CanfdFrame(
        id: id,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        bus: bus,
        len: len,
        data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, id, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, bus);
    data_.setUint8(7, len);
    MavlinkMessage.setUint8List(data_, 8, data);
    return data_;
  }
}

/// Modify the filter of what CAN messages to forward over the mavlink. This can be used to make CAN forwarding work well on low bandwidth links. The filtering is applied on bits 8 to 24 of the CAN id (2nd and 3rd bytes) which corresponds to the DroneCAN message ID for DroneCAN. Filters with more than 16 IDs can be constructed by sending multiple CAN_FILTER_MODIFY messages.
///
/// CAN_FILTER_MODIFY
class CanFilterModify implements MavlinkMessage {
  static const int _mavlinkMessageId = 388;

  static const int _mavlinkCrcExtra = 8;

  static const int mavlinkEncodedLength = 37;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// filter IDs, length num_ids
  ///
  /// MAVLink type: uint16_t[16]
  ///
  /// ids
  final List<int16_t> ids;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// bus number
  ///
  /// MAVLink type: uint8_t
  ///
  /// bus
  final uint8_t bus;

  /// what operation to perform on the filter list. See CAN_FILTER_OP enum.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CanFilterOp]
  ///
  /// operation
  final CanFilterOp operation;

  /// number of IDs in filter list
  ///
  /// MAVLink type: uint8_t
  ///
  /// num_ids
  final uint8_t numIds;

  CanFilterModify({
    required this.ids,
    required this.targetSystem,
    required this.targetComponent,
    required this.bus,
    required this.operation,
    required this.numIds,
  });

  CanFilterModify copyWith({
    List<int16_t>? ids,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? bus,
    CanFilterOp? operation,
    uint8_t? numIds,
  }) {
    return CanFilterModify(
      ids: ids ?? this.ids,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      bus: bus ?? this.bus,
      operation: operation ?? this.operation,
      numIds: numIds ?? this.numIds,
    );
  }

  factory CanFilterModify.parse(ByteData data_) {
    if (data_.lengthInBytes < CanFilterModify.mavlinkEncodedLength) {
      var len = CanFilterModify.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var ids = MavlinkMessage.asUint16List(data_, 0, 16);
    var targetSystem = data_.getUint8(32);
    var targetComponent = data_.getUint8(33);
    var bus = data_.getUint8(34);
    var operation = data_.getUint8(35);
    var numIds = data_.getUint8(36);

    return CanFilterModify(
        ids: ids,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        bus: bus,
        operation: operation,
        numIds: numIds);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setUint16List(data_, 0, ids);
    data_.setUint8(32, targetSystem);
    data_.setUint8(33, targetComponent);
    data_.setUint8(34, bus);
    data_.setUint8(35, operation);
    data_.setUint8(36, numIds);
    return data_;
  }
}

/// Cumulative distance traveled for each reported wheel.
///
/// WHEEL_DISTANCE
class WheelDistance implements MavlinkMessage {
  static const int _mavlinkMessageId = 9000;

  static const int _mavlinkCrcExtra = 113;

  static const int mavlinkEncodedLength = 137;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (synced to UNIX time or since system boot).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Distance reported by individual wheel encoders. Forward rotations increase values, reverse rotations decrease them. Not all wheels will necessarily have wheel encoders; the mapping of encoders to wheel positions must be agreed/understood by the endpoints.
  ///
  /// MAVLink type: double[16]
  ///
  /// units: m
  ///
  /// distance
  final List<double> distance;

  /// Number of wheels reported.
  ///
  /// MAVLink type: uint8_t
  ///
  /// count
  final uint8_t count;

  WheelDistance({
    required this.timeUsec,
    required this.distance,
    required this.count,
  });

  WheelDistance copyWith({
    uint64_t? timeUsec,
    List<double>? distance,
    uint8_t? count,
  }) {
    return WheelDistance(
      timeUsec: timeUsec ?? this.timeUsec,
      distance: distance ?? this.distance,
      count: count ?? this.count,
    );
  }

  factory WheelDistance.parse(ByteData data_) {
    if (data_.lengthInBytes < WheelDistance.mavlinkEncodedLength) {
      var len = WheelDistance.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var distance = MavlinkMessage.asFloat64List(data_, 8, 16);
    var count = data_.getUint8(136);

    return WheelDistance(timeUsec: timeUsec, distance: distance, count: count);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    MavlinkMessage.setFloat64List(data_, 8, distance);
    data_.setUint8(136, count);
    return data_;
  }
}

/// Winch status.
///
/// WINCH_STATUS
class WinchStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 9005;

  static const int _mavlinkCrcExtra = 117;

  static const int mavlinkEncodedLength = 34;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (synced to UNIX time or since system boot).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Length of line released. NaN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// line_length
  final float lineLength;

  /// Speed line is being released or retracted. Positive values if being released, negative values if being retracted, NaN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// speed
  final float speed;

  /// Tension on the line. NaN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: kg
  ///
  /// tension
  final float tension;

  /// Voltage of the battery supplying the winch. NaN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: V
  ///
  /// voltage
  final float voltage;

  /// Current draw from the winch. NaN if unknown
  ///
  /// MAVLink type: float
  ///
  /// units: A
  ///
  /// current
  final float current;

  /// Status flags
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavWinchStatusFlag]
  ///
  /// status
  final MavWinchStatusFlag status;

  /// Temperature of the motor. INT16_MAX if unknown
  ///
  /// MAVLink type: int16_t
  ///
  /// units: degC
  ///
  /// temperature
  final int16_t temperature;

  WinchStatus({
    required this.timeUsec,
    required this.lineLength,
    required this.speed,
    required this.tension,
    required this.voltage,
    required this.current,
    required this.status,
    required this.temperature,
  });

  WinchStatus copyWith({
    uint64_t? timeUsec,
    float? lineLength,
    float? speed,
    float? tension,
    float? voltage,
    float? current,
    MavWinchStatusFlag? status,
    int16_t? temperature,
  }) {
    return WinchStatus(
      timeUsec: timeUsec ?? this.timeUsec,
      lineLength: lineLength ?? this.lineLength,
      speed: speed ?? this.speed,
      tension: tension ?? this.tension,
      voltage: voltage ?? this.voltage,
      current: current ?? this.current,
      status: status ?? this.status,
      temperature: temperature ?? this.temperature,
    );
  }

  factory WinchStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < WinchStatus.mavlinkEncodedLength) {
      var len = WinchStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var lineLength = data_.getFloat32(8, Endian.little);
    var speed = data_.getFloat32(12, Endian.little);
    var tension = data_.getFloat32(16, Endian.little);
    var voltage = data_.getFloat32(20, Endian.little);
    var current = data_.getFloat32(24, Endian.little);
    var status = data_.getUint32(28, Endian.little);
    var temperature = data_.getInt16(32, Endian.little);

    return WinchStatus(
        timeUsec: timeUsec,
        lineLength: lineLength,
        speed: speed,
        tension: tension,
        voltage: voltage,
        current: current,
        status: status,
        temperature: temperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, lineLength, Endian.little);
    data_.setFloat32(12, speed, Endian.little);
    data_.setFloat32(16, tension, Endian.little);
    data_.setFloat32(20, voltage, Endian.little);
    data_.setFloat32(24, current, Endian.little);
    data_.setUint32(28, status, Endian.little);
    data_.setInt16(32, temperature, Endian.little);
    return data_;
  }
}

/// Data for filling the OpenDroneID Basic ID message. This and the below messages are primarily meant for feeding data to/from an OpenDroneID implementation. E.g. https://github.com/opendroneid/opendroneid-core-c. These messages are compatible with the ASTM F3411 Remote ID standard and the ASD-STAN prEN 4709-002 Direct Remote ID standard. Additional information and usage of these messages is documented at https://mavlink.io/en/services/opendroneid.html.
///
/// OPEN_DRONE_ID_BASIC_ID
class OpenDroneIdBasicId implements MavlinkMessage {
  static const int _mavlinkMessageId = 12900;

  static const int _mavlinkCrcExtra = 114;

  static const int mavlinkEncodedLength = 44;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Only used for drone ID data received from other UAs. See detailed description at https://mavlink.io/en/services/opendroneid.html.
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// id_or_mac
  final List<int8_t> idOrMac;

  /// Indicates the format for the uas_id field of this message.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidIdType]
  ///
  /// id_type
  final MavOdidIdType idType;

  /// Indicates the type of UA (Unmanned Aircraft).
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidUaType]
  ///
  /// ua_type
  final MavOdidUaType uaType;

  /// UAS (Unmanned Aircraft System) ID following the format specified by id_type. Shall be filled with nulls in the unused portion of the field.
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// uas_id
  final List<int8_t> uasId;

  OpenDroneIdBasicId({
    required this.targetSystem,
    required this.targetComponent,
    required this.idOrMac,
    required this.idType,
    required this.uaType,
    required this.uasId,
  });

  OpenDroneIdBasicId copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? idOrMac,
    MavOdidIdType? idType,
    MavOdidUaType? uaType,
    List<int8_t>? uasId,
  }) {
    return OpenDroneIdBasicId(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idOrMac: idOrMac ?? this.idOrMac,
      idType: idType ?? this.idType,
      uaType: uaType ?? this.uaType,
      uasId: uasId ?? this.uasId,
    );
  }

  factory OpenDroneIdBasicId.parse(ByteData data_) {
    if (data_.lengthInBytes < OpenDroneIdBasicId.mavlinkEncodedLength) {
      var len = OpenDroneIdBasicId.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var idOrMac = MavlinkMessage.asUint8List(data_, 2, 20);
    var idType = data_.getUint8(22);
    var uaType = data_.getUint8(23);
    var uasId = MavlinkMessage.asUint8List(data_, 24, 20);

    return OpenDroneIdBasicId(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        idOrMac: idOrMac,
        idType: idType,
        uaType: uaType,
        uasId: uasId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    MavlinkMessage.setUint8List(data_, 2, idOrMac);
    data_.setUint8(22, idType);
    data_.setUint8(23, uaType);
    MavlinkMessage.setUint8List(data_, 24, uasId);
    return data_;
  }
}

/// Data for filling the OpenDroneID Location message. The float data types are 32-bit IEEE 754. The Location message provides the location, altitude, direction and speed of the aircraft.
///
/// OPEN_DRONE_ID_LOCATION
class OpenDroneIdLocation implements MavlinkMessage {
  static const int _mavlinkMessageId = 12901;

  static const int _mavlinkCrcExtra = 254;

  static const int mavlinkEncodedLength = 59;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Current latitude of the unmanned aircraft. If unknown: 0 (both Lat/Lon).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// latitude
  final int32_t latitude;

  /// Current longitude of the unmanned aircraft. If unknown: 0 (both Lat/Lon).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// longitude
  final int32_t longitude;

  /// The altitude calculated from the barometric pressue. Reference is against 29.92inHg or 1013.2mb. If unknown: -1000 m.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude_barometric
  final float altitudeBarometric;

  /// The geodetic altitude as defined by WGS84. If unknown: -1000 m.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude_geodetic
  final float altitudeGeodetic;

  /// The current height of the unmanned aircraft above the take-off location or the ground as indicated by height_reference. If unknown: -1000 m.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// height
  final float height;

  /// Seconds after the full hour with reference to UTC time. Typically the GPS outputs a time-of-week value in milliseconds. First convert that to UTC and then convert for this field using ((float) (time_week_ms % (60*60*1000))) / 1000. If unknown: 0xFFFF.
  ///
  /// MAVLink type: float
  ///
  /// units: s
  ///
  /// timestamp
  final float timestamp;

  /// Direction over ground (not heading, but direction of movement) measured clockwise from true North: 0 - 35999 centi-degrees. If unknown: 36100 centi-degrees.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// direction
  final uint16_t direction;

  /// Ground speed. Positive only. If unknown: 25500 cm/s. If speed is larger than 25425 cm/s, use 25425 cm/s.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// speed_horizontal
  final uint16_t speedHorizontal;

  /// The vertical speed. Up is positive. If unknown: 6300 cm/s. If speed is larger than 6200 cm/s, use 6200 cm/s. If lower than -6200 cm/s, use -6200 cm/s.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// speed_vertical
  final int16_t speedVertical;

  /// System ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Only used for drone ID data received from other UAs. See detailed description at https://mavlink.io/en/services/opendroneid.html.
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// id_or_mac
  final List<int8_t> idOrMac;

  /// Indicates whether the unmanned aircraft is on the ground or in the air.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidStatus]
  ///
  /// status
  final MavOdidStatus status;

  /// Indicates the reference point for the height field.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidHeightRef]
  ///
  /// height_reference
  final MavOdidHeightRef heightReference;

  /// The accuracy of the horizontal position.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidHorAcc]
  ///
  /// horizontal_accuracy
  final MavOdidHorAcc horizontalAccuracy;

  /// The accuracy of the vertical position.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidVerAcc]
  ///
  /// vertical_accuracy
  final MavOdidVerAcc verticalAccuracy;

  /// The accuracy of the barometric altitude.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidVerAcc]
  ///
  /// barometer_accuracy
  final MavOdidVerAcc barometerAccuracy;

  /// The accuracy of the horizontal and vertical speed.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidSpeedAcc]
  ///
  /// speed_accuracy
  final MavOdidSpeedAcc speedAccuracy;

  /// The accuracy of the timestamps.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidTimeAcc]
  ///
  /// timestamp_accuracy
  final MavOdidTimeAcc timestampAccuracy;

  OpenDroneIdLocation({
    required this.latitude,
    required this.longitude,
    required this.altitudeBarometric,
    required this.altitudeGeodetic,
    required this.height,
    required this.timestamp,
    required this.direction,
    required this.speedHorizontal,
    required this.speedVertical,
    required this.targetSystem,
    required this.targetComponent,
    required this.idOrMac,
    required this.status,
    required this.heightReference,
    required this.horizontalAccuracy,
    required this.verticalAccuracy,
    required this.barometerAccuracy,
    required this.speedAccuracy,
    required this.timestampAccuracy,
  });

  OpenDroneIdLocation copyWith({
    int32_t? latitude,
    int32_t? longitude,
    float? altitudeBarometric,
    float? altitudeGeodetic,
    float? height,
    float? timestamp,
    uint16_t? direction,
    uint16_t? speedHorizontal,
    int16_t? speedVertical,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? idOrMac,
    MavOdidStatus? status,
    MavOdidHeightRef? heightReference,
    MavOdidHorAcc? horizontalAccuracy,
    MavOdidVerAcc? verticalAccuracy,
    MavOdidVerAcc? barometerAccuracy,
    MavOdidSpeedAcc? speedAccuracy,
    MavOdidTimeAcc? timestampAccuracy,
  }) {
    return OpenDroneIdLocation(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      altitudeBarometric: altitudeBarometric ?? this.altitudeBarometric,
      altitudeGeodetic: altitudeGeodetic ?? this.altitudeGeodetic,
      height: height ?? this.height,
      timestamp: timestamp ?? this.timestamp,
      direction: direction ?? this.direction,
      speedHorizontal: speedHorizontal ?? this.speedHorizontal,
      speedVertical: speedVertical ?? this.speedVertical,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idOrMac: idOrMac ?? this.idOrMac,
      status: status ?? this.status,
      heightReference: heightReference ?? this.heightReference,
      horizontalAccuracy: horizontalAccuracy ?? this.horizontalAccuracy,
      verticalAccuracy: verticalAccuracy ?? this.verticalAccuracy,
      barometerAccuracy: barometerAccuracy ?? this.barometerAccuracy,
      speedAccuracy: speedAccuracy ?? this.speedAccuracy,
      timestampAccuracy: timestampAccuracy ?? this.timestampAccuracy,
    );
  }

  factory OpenDroneIdLocation.parse(ByteData data_) {
    if (data_.lengthInBytes < OpenDroneIdLocation.mavlinkEncodedLength) {
      var len = OpenDroneIdLocation.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var latitude = data_.getInt32(0, Endian.little);
    var longitude = data_.getInt32(4, Endian.little);
    var altitudeBarometric = data_.getFloat32(8, Endian.little);
    var altitudeGeodetic = data_.getFloat32(12, Endian.little);
    var height = data_.getFloat32(16, Endian.little);
    var timestamp = data_.getFloat32(20, Endian.little);
    var direction = data_.getUint16(24, Endian.little);
    var speedHorizontal = data_.getUint16(26, Endian.little);
    var speedVertical = data_.getInt16(28, Endian.little);
    var targetSystem = data_.getUint8(30);
    var targetComponent = data_.getUint8(31);
    var idOrMac = MavlinkMessage.asUint8List(data_, 32, 20);
    var status = data_.getUint8(52);
    var heightReference = data_.getUint8(53);
    var horizontalAccuracy = data_.getUint8(54);
    var verticalAccuracy = data_.getUint8(55);
    var barometerAccuracy = data_.getUint8(56);
    var speedAccuracy = data_.getUint8(57);
    var timestampAccuracy = data_.getUint8(58);

    return OpenDroneIdLocation(
        latitude: latitude,
        longitude: longitude,
        altitudeBarometric: altitudeBarometric,
        altitudeGeodetic: altitudeGeodetic,
        height: height,
        timestamp: timestamp,
        direction: direction,
        speedHorizontal: speedHorizontal,
        speedVertical: speedVertical,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        idOrMac: idOrMac,
        status: status,
        heightReference: heightReference,
        horizontalAccuracy: horizontalAccuracy,
        verticalAccuracy: verticalAccuracy,
        barometerAccuracy: barometerAccuracy,
        speedAccuracy: speedAccuracy,
        timestampAccuracy: timestampAccuracy);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, latitude, Endian.little);
    data_.setInt32(4, longitude, Endian.little);
    data_.setFloat32(8, altitudeBarometric, Endian.little);
    data_.setFloat32(12, altitudeGeodetic, Endian.little);
    data_.setFloat32(16, height, Endian.little);
    data_.setFloat32(20, timestamp, Endian.little);
    data_.setUint16(24, direction, Endian.little);
    data_.setUint16(26, speedHorizontal, Endian.little);
    data_.setInt16(28, speedVertical, Endian.little);
    data_.setUint8(30, targetSystem);
    data_.setUint8(31, targetComponent);
    MavlinkMessage.setUint8List(data_, 32, idOrMac);
    data_.setUint8(52, status);
    data_.setUint8(53, heightReference);
    data_.setUint8(54, horizontalAccuracy);
    data_.setUint8(55, verticalAccuracy);
    data_.setUint8(56, barometerAccuracy);
    data_.setUint8(57, speedAccuracy);
    data_.setUint8(58, timestampAccuracy);
    return data_;
  }
}

/// Data for filling the OpenDroneID Authentication message. The Authentication Message defines a field that can provide a means of authenticity for the identity of the UAS (Unmanned Aircraft System). The Authentication message can have two different formats. For data page 0, the fields PageCount, Length and TimeStamp are present and AuthData is only 17 bytes. For data page 1 through 15, PageCount, Length and TimeStamp are not present and the size of AuthData is 23 bytes.
///
/// OPEN_DRONE_ID_AUTHENTICATION
class OpenDroneIdAuthentication implements MavlinkMessage {
  static const int _mavlinkMessageId = 12902;

  static const int _mavlinkCrcExtra = 140;

  static const int mavlinkEncodedLength = 53;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// This field is only present for page 0. 32 bit Unix Timestamp in seconds since 00:00:00 01/01/2019.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: s
  ///
  /// timestamp
  final uint32_t timestamp;

  /// System ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Only used for drone ID data received from other UAs. See detailed description at https://mavlink.io/en/services/opendroneid.html.
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// id_or_mac
  final List<int8_t> idOrMac;

  /// Indicates the type of authentication.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidAuthType]
  ///
  /// authentication_type
  final MavOdidAuthType authenticationType;

  /// Allowed range is 0 - 15.
  ///
  /// MAVLink type: uint8_t
  ///
  /// data_page
  final uint8_t dataPage;

  /// This field is only present for page 0. Allowed range is 0 - 15. See the description of struct ODID_Auth_data at https://github.com/opendroneid/opendroneid-core-c/blob/master/libopendroneid/opendroneid.h.
  ///
  /// MAVLink type: uint8_t
  ///
  /// last_page_index
  final uint8_t lastPageIndex;

  /// This field is only present for page 0. Total bytes of authentication_data from all data pages. See the description of struct ODID_Auth_data at https://github.com/opendroneid/opendroneid-core-c/blob/master/libopendroneid/opendroneid.h.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// length
  final uint8_t length;

  /// Opaque authentication data. For page 0, the size is only 17 bytes. For other pages, the size is 23 bytes. Shall be filled with nulls in the unused portion of the field.
  ///
  /// MAVLink type: uint8_t[23]
  ///
  /// authentication_data
  final List<int8_t> authenticationData;

  OpenDroneIdAuthentication({
    required this.timestamp,
    required this.targetSystem,
    required this.targetComponent,
    required this.idOrMac,
    required this.authenticationType,
    required this.dataPage,
    required this.lastPageIndex,
    required this.length,
    required this.authenticationData,
  });

  OpenDroneIdAuthentication copyWith({
    uint32_t? timestamp,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? idOrMac,
    MavOdidAuthType? authenticationType,
    uint8_t? dataPage,
    uint8_t? lastPageIndex,
    uint8_t? length,
    List<int8_t>? authenticationData,
  }) {
    return OpenDroneIdAuthentication(
      timestamp: timestamp ?? this.timestamp,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idOrMac: idOrMac ?? this.idOrMac,
      authenticationType: authenticationType ?? this.authenticationType,
      dataPage: dataPage ?? this.dataPage,
      lastPageIndex: lastPageIndex ?? this.lastPageIndex,
      length: length ?? this.length,
      authenticationData: authenticationData ?? this.authenticationData,
    );
  }

  factory OpenDroneIdAuthentication.parse(ByteData data_) {
    if (data_.lengthInBytes < OpenDroneIdAuthentication.mavlinkEncodedLength) {
      var len =
          OpenDroneIdAuthentication.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timestamp = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var idOrMac = MavlinkMessage.asUint8List(data_, 6, 20);
    var authenticationType = data_.getUint8(26);
    var dataPage = data_.getUint8(27);
    var lastPageIndex = data_.getUint8(28);
    var length = data_.getUint8(29);
    var authenticationData = MavlinkMessage.asUint8List(data_, 30, 23);

    return OpenDroneIdAuthentication(
        timestamp: timestamp,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        idOrMac: idOrMac,
        authenticationType: authenticationType,
        dataPage: dataPage,
        lastPageIndex: lastPageIndex,
        length: length,
        authenticationData: authenticationData);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timestamp, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    MavlinkMessage.setUint8List(data_, 6, idOrMac);
    data_.setUint8(26, authenticationType);
    data_.setUint8(27, dataPage);
    data_.setUint8(28, lastPageIndex);
    data_.setUint8(29, length);
    MavlinkMessage.setUint8List(data_, 30, authenticationData);
    return data_;
  }
}

/// Data for filling the OpenDroneID Self ID message. The Self ID Message is an opportunity for the operator to (optionally) declare their identity and purpose of the flight. This message can provide additional information that could reduce the threat profile of a UA (Unmanned Aircraft) flying in a particular area or manner. This message can also be used to provide optional additional clarification in an emergency/remote ID system failure situation.
///
/// OPEN_DRONE_ID_SELF_ID
class OpenDroneIdSelfId implements MavlinkMessage {
  static const int _mavlinkMessageId = 12903;

  static const int _mavlinkCrcExtra = 249;

  static const int mavlinkEncodedLength = 46;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Only used for drone ID data received from other UAs. See detailed description at https://mavlink.io/en/services/opendroneid.html.
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// id_or_mac
  final List<int8_t> idOrMac;

  /// Indicates the type of the description field.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidDescType]
  ///
  /// description_type
  final MavOdidDescType descriptionType;

  /// Text description or numeric value expressed as ASCII characters. Shall be filled with nulls in the unused portion of the field.
  ///
  /// MAVLink type: char[23]
  ///
  /// description
  final List<char> description;

  OpenDroneIdSelfId({
    required this.targetSystem,
    required this.targetComponent,
    required this.idOrMac,
    required this.descriptionType,
    required this.description,
  });

  OpenDroneIdSelfId copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? idOrMac,
    MavOdidDescType? descriptionType,
    List<char>? description,
  }) {
    return OpenDroneIdSelfId(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idOrMac: idOrMac ?? this.idOrMac,
      descriptionType: descriptionType ?? this.descriptionType,
      description: description ?? this.description,
    );
  }

  factory OpenDroneIdSelfId.parse(ByteData data_) {
    if (data_.lengthInBytes < OpenDroneIdSelfId.mavlinkEncodedLength) {
      var len = OpenDroneIdSelfId.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var idOrMac = MavlinkMessage.asUint8List(data_, 2, 20);
    var descriptionType = data_.getUint8(22);
    var description = MavlinkMessage.asInt8List(data_, 23, 23);

    return OpenDroneIdSelfId(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        idOrMac: idOrMac,
        descriptionType: descriptionType,
        description: description);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    MavlinkMessage.setUint8List(data_, 2, idOrMac);
    data_.setUint8(22, descriptionType);
    MavlinkMessage.setInt8List(data_, 23, description);
    return data_;
  }
}

/// Data for filling the OpenDroneID System message. The System Message contains general system information including the operator location/altitude and possible aircraft group and/or category/class information.
///
/// OPEN_DRONE_ID_SYSTEM
class OpenDroneIdSystem implements MavlinkMessage {
  static const int _mavlinkMessageId = 12904;

  static const int _mavlinkCrcExtra = 77;

  static const int mavlinkEncodedLength = 54;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude of the operator. If unknown: 0 (both Lat/Lon).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// operator_latitude
  final int32_t operatorLatitude;

  /// Longitude of the operator. If unknown: 0 (both Lat/Lon).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// operator_longitude
  final int32_t operatorLongitude;

  /// Area Operations Ceiling relative to WGS84. If unknown: -1000 m. Used only for swarms/multiple UA.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// area_ceiling
  final float areaCeiling;

  /// Area Operations Floor relative to WGS84. If unknown: -1000 m. Used only for swarms/multiple UA.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// area_floor
  final float areaFloor;

  /// Geodetic altitude of the operator relative to WGS84. If unknown: -1000 m.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// operator_altitude_geo
  final float operatorAltitudeGeo;

  /// 32 bit Unix Timestamp in seconds since 00:00:00 01/01/2019.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: s
  ///
  /// timestamp
  final uint32_t timestamp;

  /// Number of aircraft in the area, group or formation (default 1). Used only for swarms/multiple UA.
  ///
  /// MAVLink type: uint16_t
  ///
  /// area_count
  final uint16_t areaCount;

  /// Radius of the cylindrical area of the group or formation (default 0). Used only for swarms/multiple UA.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: m
  ///
  /// area_radius
  final uint16_t areaRadius;

  /// System ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Only used for drone ID data received from other UAs. See detailed description at https://mavlink.io/en/services/opendroneid.html.
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// id_or_mac
  final List<int8_t> idOrMac;

  /// Specifies the operator location type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidOperatorLocationType]
  ///
  /// operator_location_type
  final MavOdidOperatorLocationType operatorLocationType;

  /// Specifies the classification type of the UA.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidClassificationType]
  ///
  /// classification_type
  final MavOdidClassificationType classificationType;

  /// When classification_type is MAV_ODID_CLASSIFICATION_TYPE_EU, specifies the category of the UA.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidCategoryEu]
  ///
  /// category_eu
  final MavOdidCategoryEu categoryEu;

  /// When classification_type is MAV_ODID_CLASSIFICATION_TYPE_EU, specifies the class of the UA.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidClassEu]
  ///
  /// class_eu
  final MavOdidClassEu classEu;

  OpenDroneIdSystem({
    required this.operatorLatitude,
    required this.operatorLongitude,
    required this.areaCeiling,
    required this.areaFloor,
    required this.operatorAltitudeGeo,
    required this.timestamp,
    required this.areaCount,
    required this.areaRadius,
    required this.targetSystem,
    required this.targetComponent,
    required this.idOrMac,
    required this.operatorLocationType,
    required this.classificationType,
    required this.categoryEu,
    required this.classEu,
  });

  OpenDroneIdSystem copyWith({
    int32_t? operatorLatitude,
    int32_t? operatorLongitude,
    float? areaCeiling,
    float? areaFloor,
    float? operatorAltitudeGeo,
    uint32_t? timestamp,
    uint16_t? areaCount,
    uint16_t? areaRadius,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? idOrMac,
    MavOdidOperatorLocationType? operatorLocationType,
    MavOdidClassificationType? classificationType,
    MavOdidCategoryEu? categoryEu,
    MavOdidClassEu? classEu,
  }) {
    return OpenDroneIdSystem(
      operatorLatitude: operatorLatitude ?? this.operatorLatitude,
      operatorLongitude: operatorLongitude ?? this.operatorLongitude,
      areaCeiling: areaCeiling ?? this.areaCeiling,
      areaFloor: areaFloor ?? this.areaFloor,
      operatorAltitudeGeo: operatorAltitudeGeo ?? this.operatorAltitudeGeo,
      timestamp: timestamp ?? this.timestamp,
      areaCount: areaCount ?? this.areaCount,
      areaRadius: areaRadius ?? this.areaRadius,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idOrMac: idOrMac ?? this.idOrMac,
      operatorLocationType: operatorLocationType ?? this.operatorLocationType,
      classificationType: classificationType ?? this.classificationType,
      categoryEu: categoryEu ?? this.categoryEu,
      classEu: classEu ?? this.classEu,
    );
  }

  factory OpenDroneIdSystem.parse(ByteData data_) {
    if (data_.lengthInBytes < OpenDroneIdSystem.mavlinkEncodedLength) {
      var len = OpenDroneIdSystem.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var operatorLatitude = data_.getInt32(0, Endian.little);
    var operatorLongitude = data_.getInt32(4, Endian.little);
    var areaCeiling = data_.getFloat32(8, Endian.little);
    var areaFloor = data_.getFloat32(12, Endian.little);
    var operatorAltitudeGeo = data_.getFloat32(16, Endian.little);
    var timestamp = data_.getUint32(20, Endian.little);
    var areaCount = data_.getUint16(24, Endian.little);
    var areaRadius = data_.getUint16(26, Endian.little);
    var targetSystem = data_.getUint8(28);
    var targetComponent = data_.getUint8(29);
    var idOrMac = MavlinkMessage.asUint8List(data_, 30, 20);
    var operatorLocationType = data_.getUint8(50);
    var classificationType = data_.getUint8(51);
    var categoryEu = data_.getUint8(52);
    var classEu = data_.getUint8(53);

    return OpenDroneIdSystem(
        operatorLatitude: operatorLatitude,
        operatorLongitude: operatorLongitude,
        areaCeiling: areaCeiling,
        areaFloor: areaFloor,
        operatorAltitudeGeo: operatorAltitudeGeo,
        timestamp: timestamp,
        areaCount: areaCount,
        areaRadius: areaRadius,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        idOrMac: idOrMac,
        operatorLocationType: operatorLocationType,
        classificationType: classificationType,
        categoryEu: categoryEu,
        classEu: classEu);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, operatorLatitude, Endian.little);
    data_.setInt32(4, operatorLongitude, Endian.little);
    data_.setFloat32(8, areaCeiling, Endian.little);
    data_.setFloat32(12, areaFloor, Endian.little);
    data_.setFloat32(16, operatorAltitudeGeo, Endian.little);
    data_.setUint32(20, timestamp, Endian.little);
    data_.setUint16(24, areaCount, Endian.little);
    data_.setUint16(26, areaRadius, Endian.little);
    data_.setUint8(28, targetSystem);
    data_.setUint8(29, targetComponent);
    MavlinkMessage.setUint8List(data_, 30, idOrMac);
    data_.setUint8(50, operatorLocationType);
    data_.setUint8(51, classificationType);
    data_.setUint8(52, categoryEu);
    data_.setUint8(53, classEu);
    return data_;
  }
}

/// Data for filling the OpenDroneID Operator ID message, which contains the CAA (Civil Aviation Authority) issued operator ID.
///
/// OPEN_DRONE_ID_OPERATOR_ID
class OpenDroneIdOperatorId implements MavlinkMessage {
  static const int _mavlinkMessageId = 12905;

  static const int _mavlinkCrcExtra = 49;

  static const int mavlinkEncodedLength = 43;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Only used for drone ID data received from other UAs. See detailed description at https://mavlink.io/en/services/opendroneid.html.
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// id_or_mac
  final List<int8_t> idOrMac;

  /// Indicates the type of the operator_id field.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidOperatorIdType]
  ///
  /// operator_id_type
  final MavOdidOperatorIdType operatorIdType;

  /// Text description or numeric value expressed as ASCII characters. Shall be filled with nulls in the unused portion of the field.
  ///
  /// MAVLink type: char[20]
  ///
  /// operator_id
  final List<char> operatorId;

  OpenDroneIdOperatorId({
    required this.targetSystem,
    required this.targetComponent,
    required this.idOrMac,
    required this.operatorIdType,
    required this.operatorId,
  });

  OpenDroneIdOperatorId copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? idOrMac,
    MavOdidOperatorIdType? operatorIdType,
    List<char>? operatorId,
  }) {
    return OpenDroneIdOperatorId(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idOrMac: idOrMac ?? this.idOrMac,
      operatorIdType: operatorIdType ?? this.operatorIdType,
      operatorId: operatorId ?? this.operatorId,
    );
  }

  factory OpenDroneIdOperatorId.parse(ByteData data_) {
    if (data_.lengthInBytes < OpenDroneIdOperatorId.mavlinkEncodedLength) {
      var len =
          OpenDroneIdOperatorId.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var idOrMac = MavlinkMessage.asUint8List(data_, 2, 20);
    var operatorIdType = data_.getUint8(22);
    var operatorId = MavlinkMessage.asInt8List(data_, 23, 20);

    return OpenDroneIdOperatorId(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        idOrMac: idOrMac,
        operatorIdType: operatorIdType,
        operatorId: operatorId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    MavlinkMessage.setUint8List(data_, 2, idOrMac);
    data_.setUint8(22, operatorIdType);
    MavlinkMessage.setInt8List(data_, 23, operatorId);
    return data_;
  }
}

/// An OpenDroneID message pack is a container for multiple encoded OpenDroneID messages (i.e. not in the format given for the above message descriptions but after encoding into the compressed OpenDroneID byte format). Used e.g. when transmitting on Bluetooth 5.0 Long Range/Extended Advertising or on WiFi Neighbor Aware Networking or on WiFi Beacon.
///
/// OPEN_DRONE_ID_MESSAGE_PACK
class OpenDroneIdMessagePack implements MavlinkMessage {
  static const int _mavlinkMessageId = 12915;

  static const int _mavlinkCrcExtra = 94;

  static const int mavlinkEncodedLength = 249;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Only used for drone ID data received from other UAs. See detailed description at https://mavlink.io/en/services/opendroneid.html.
  ///
  /// MAVLink type: uint8_t[20]
  ///
  /// id_or_mac
  final List<int8_t> idOrMac;

  /// This field must currently always be equal to 25 (bytes), since all encoded OpenDroneID messages are specified to have this length.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// single_message_size
  final uint8_t singleMessageSize;

  /// Number of encoded messages in the pack (not the number of bytes). Allowed range is 1 - 9.
  ///
  /// MAVLink type: uint8_t
  ///
  /// msg_pack_size
  final uint8_t msgPackSize;

  /// Concatenation of encoded OpenDroneID messages. Shall be filled with nulls in the unused portion of the field.
  ///
  /// MAVLink type: uint8_t[225]
  ///
  /// messages
  final List<int8_t> messages;

  OpenDroneIdMessagePack({
    required this.targetSystem,
    required this.targetComponent,
    required this.idOrMac,
    required this.singleMessageSize,
    required this.msgPackSize,
    required this.messages,
  });

  OpenDroneIdMessagePack copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? idOrMac,
    uint8_t? singleMessageSize,
    uint8_t? msgPackSize,
    List<int8_t>? messages,
  }) {
    return OpenDroneIdMessagePack(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idOrMac: idOrMac ?? this.idOrMac,
      singleMessageSize: singleMessageSize ?? this.singleMessageSize,
      msgPackSize: msgPackSize ?? this.msgPackSize,
      messages: messages ?? this.messages,
    );
  }

  factory OpenDroneIdMessagePack.parse(ByteData data_) {
    if (data_.lengthInBytes < OpenDroneIdMessagePack.mavlinkEncodedLength) {
      var len =
          OpenDroneIdMessagePack.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var idOrMac = MavlinkMessage.asUint8List(data_, 2, 20);
    var singleMessageSize = data_.getUint8(22);
    var msgPackSize = data_.getUint8(23);
    var messages = MavlinkMessage.asUint8List(data_, 24, 225);

    return OpenDroneIdMessagePack(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        idOrMac: idOrMac,
        singleMessageSize: singleMessageSize,
        msgPackSize: msgPackSize,
        messages: messages);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    MavlinkMessage.setUint8List(data_, 2, idOrMac);
    data_.setUint8(22, singleMessageSize);
    data_.setUint8(23, msgPackSize);
    MavlinkMessage.setUint8List(data_, 24, messages);
    return data_;
  }
}

/// Transmitter (remote ID system) is enabled and ready to start sending location and other required information. This is streamed by transmitter. A flight controller uses it as a condition to arm.
///
/// OPEN_DRONE_ID_ARM_STATUS
class OpenDroneIdArmStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 12918;

  static const int _mavlinkCrcExtra = 139;

  static const int mavlinkEncodedLength = 51;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Status level indicating if arming is allowed.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavOdidArmStatus]
  ///
  /// status
  final MavOdidArmStatus status;

  /// Text error message, should be empty if status is good to arm. Fill with nulls in unused portion.
  ///
  /// MAVLink type: char[50]
  ///
  /// error
  final List<char> error;

  OpenDroneIdArmStatus({
    required this.status,
    required this.error,
  });

  OpenDroneIdArmStatus copyWith({
    MavOdidArmStatus? status,
    List<char>? error,
  }) {
    return OpenDroneIdArmStatus(
      status: status ?? this.status,
      error: error ?? this.error,
    );
  }

  factory OpenDroneIdArmStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < OpenDroneIdArmStatus.mavlinkEncodedLength) {
      var len = OpenDroneIdArmStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var status = data_.getUint8(0);
    var error = MavlinkMessage.asInt8List(data_, 1, 50);

    return OpenDroneIdArmStatus(status: status, error: error);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, status);
    MavlinkMessage.setInt8List(data_, 1, error);
    return data_;
  }
}

/// Update the data in the OPEN_DRONE_ID_SYSTEM message with new location information. This can be sent to update the location information for the operator when no other information in the SYSTEM message has changed. This message allows for efficient operation on radio links which have limited uplink bandwidth while meeting requirements for update frequency of the operator location.
///
/// OPEN_DRONE_ID_SYSTEM_UPDATE
class OpenDroneIdSystemUpdate implements MavlinkMessage {
  static const int _mavlinkMessageId = 12919;

  static const int _mavlinkCrcExtra = 7;

  static const int mavlinkEncodedLength = 18;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude of the operator. If unknown: 0 (both Lat/Lon).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// operator_latitude
  final int32_t operatorLatitude;

  /// Longitude of the operator. If unknown: 0 (both Lat/Lon).
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// operator_longitude
  final int32_t operatorLongitude;

  /// Geodetic altitude of the operator relative to WGS84. If unknown: -1000 m.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// operator_altitude_geo
  final float operatorAltitudeGeo;

  /// 32 bit Unix Timestamp in seconds since 00:00:00 01/01/2019.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: s
  ///
  /// timestamp
  final uint32_t timestamp;

  /// System ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID (0 for broadcast).
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  OpenDroneIdSystemUpdate({
    required this.operatorLatitude,
    required this.operatorLongitude,
    required this.operatorAltitudeGeo,
    required this.timestamp,
    required this.targetSystem,
    required this.targetComponent,
  });

  OpenDroneIdSystemUpdate copyWith({
    int32_t? operatorLatitude,
    int32_t? operatorLongitude,
    float? operatorAltitudeGeo,
    uint32_t? timestamp,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return OpenDroneIdSystemUpdate(
      operatorLatitude: operatorLatitude ?? this.operatorLatitude,
      operatorLongitude: operatorLongitude ?? this.operatorLongitude,
      operatorAltitudeGeo: operatorAltitudeGeo ?? this.operatorAltitudeGeo,
      timestamp: timestamp ?? this.timestamp,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory OpenDroneIdSystemUpdate.parse(ByteData data_) {
    if (data_.lengthInBytes < OpenDroneIdSystemUpdate.mavlinkEncodedLength) {
      var len =
          OpenDroneIdSystemUpdate.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var operatorLatitude = data_.getInt32(0, Endian.little);
    var operatorLongitude = data_.getInt32(4, Endian.little);
    var operatorAltitudeGeo = data_.getFloat32(8, Endian.little);
    var timestamp = data_.getUint32(12, Endian.little);
    var targetSystem = data_.getUint8(16);
    var targetComponent = data_.getUint8(17);

    return OpenDroneIdSystemUpdate(
        operatorLatitude: operatorLatitude,
        operatorLongitude: operatorLongitude,
        operatorAltitudeGeo: operatorAltitudeGeo,
        timestamp: timestamp,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, operatorLatitude, Endian.little);
    data_.setInt32(4, operatorLongitude, Endian.little);
    data_.setFloat32(8, operatorAltitudeGeo, Endian.little);
    data_.setUint32(12, timestamp, Endian.little);
    data_.setUint8(16, targetSystem);
    data_.setUint8(17, targetComponent);
    return data_;
  }
}

/// Temperature and humidity from hygrometer.
///
/// HYGROMETER_SENSOR
class HygrometerSensor implements MavlinkMessage {
  static const int _mavlinkMessageId = 12920;

  static const int _mavlinkCrcExtra = 20;

  static const int mavlinkEncodedLength = 5;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Temperature
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// temperature
  final int16_t temperature;

  /// Humidity
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: c%
  ///
  /// humidity
  final uint16_t humidity;

  /// Hygrometer ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// id
  final uint8_t id;

  HygrometerSensor({
    required this.temperature,
    required this.humidity,
    required this.id,
  });

  HygrometerSensor copyWith({
    int16_t? temperature,
    uint16_t? humidity,
    uint8_t? id,
  }) {
    return HygrometerSensor(
      temperature: temperature ?? this.temperature,
      humidity: humidity ?? this.humidity,
      id: id ?? this.id,
    );
  }

  factory HygrometerSensor.parse(ByteData data_) {
    if (data_.lengthInBytes < HygrometerSensor.mavlinkEncodedLength) {
      var len = HygrometerSensor.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var temperature = data_.getInt16(0, Endian.little);
    var humidity = data_.getUint16(2, Endian.little);
    var id = data_.getUint8(4);

    return HygrometerSensor(
        temperature: temperature, humidity: humidity, id: id);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt16(0, temperature, Endian.little);
    data_.setUint16(2, humidity, Endian.little);
    data_.setUint8(4, id);
    return data_;
  }
}

/// Static data to configure the ADS-B transponder (send within 10 sec of a POR and every 10 sec thereafter)
///
/// UAVIONIX_ADSB_OUT_CFG
class UavionixAdsbOutCfg implements MavlinkMessage {
  static const int _mavlinkMessageId = 10001;

  static const int _mavlinkCrcExtra = 209;

  static const int mavlinkEncodedLength = 20;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Vehicle address (24 bit)
  ///
  /// MAVLink type: uint32_t
  ///
  /// ICAO
  final uint32_t icao;

  /// Aircraft stall speed in cm/s
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm/s
  ///
  /// stallSpeed
  final uint16_t stallspeed;

  /// Vehicle identifier (8 characters, null terminated, valid characters are A-Z, 0-9, " " only)
  ///
  /// MAVLink type: char[9]
  ///
  /// callsign
  final List<char> callsign;

  /// Transmitting vehicle type. See ADSB_EMITTER_TYPE enum
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AdsbEmitterType]
  ///
  /// emitterType
  final AdsbEmitterType emittertype;

  /// Aircraft length and width encoding (table 2-35 of DO-282B)
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UavionixAdsbOutCfgAircraftSize]
  ///
  /// aircraftSize
  final UavionixAdsbOutCfgAircraftSize aircraftsize;

  /// GPS antenna lateral offset (table 2-36 of DO-282B)
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UavionixAdsbOutCfgGpsOffsetLat]
  ///
  /// gpsOffsetLat
  final UavionixAdsbOutCfgGpsOffsetLat gpsoffsetlat;

  /// GPS antenna longitudinal offset from nose [if non-zero, take position (in meters) divide by 2 and add one] (table 2-37 DO-282B)
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UavionixAdsbOutCfgGpsOffsetLon]
  ///
  /// gpsOffsetLon
  final UavionixAdsbOutCfgGpsOffsetLon gpsoffsetlon;

  /// ADS-B transponder receiver and transmit enable flags
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UavionixAdsbOutRfSelect]
  ///
  /// rfSelect
  final UavionixAdsbOutRfSelect rfselect;

  UavionixAdsbOutCfg({
    required this.icao,
    required this.stallspeed,
    required this.callsign,
    required this.emittertype,
    required this.aircraftsize,
    required this.gpsoffsetlat,
    required this.gpsoffsetlon,
    required this.rfselect,
  });

  UavionixAdsbOutCfg copyWith({
    uint32_t? icao,
    uint16_t? stallspeed,
    List<char>? callsign,
    AdsbEmitterType? emittertype,
    UavionixAdsbOutCfgAircraftSize? aircraftsize,
    UavionixAdsbOutCfgGpsOffsetLat? gpsoffsetlat,
    UavionixAdsbOutCfgGpsOffsetLon? gpsoffsetlon,
    UavionixAdsbOutRfSelect? rfselect,
  }) {
    return UavionixAdsbOutCfg(
      icao: icao ?? this.icao,
      stallspeed: stallspeed ?? this.stallspeed,
      callsign: callsign ?? this.callsign,
      emittertype: emittertype ?? this.emittertype,
      aircraftsize: aircraftsize ?? this.aircraftsize,
      gpsoffsetlat: gpsoffsetlat ?? this.gpsoffsetlat,
      gpsoffsetlon: gpsoffsetlon ?? this.gpsoffsetlon,
      rfselect: rfselect ?? this.rfselect,
    );
  }

  factory UavionixAdsbOutCfg.parse(ByteData data_) {
    if (data_.lengthInBytes < UavionixAdsbOutCfg.mavlinkEncodedLength) {
      var len = UavionixAdsbOutCfg.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var icao = data_.getUint32(0, Endian.little);
    var stallspeed = data_.getUint16(4, Endian.little);
    var callsign = MavlinkMessage.asInt8List(data_, 6, 9);
    var emittertype = data_.getUint8(15);
    var aircraftsize = data_.getUint8(16);
    var gpsoffsetlat = data_.getUint8(17);
    var gpsoffsetlon = data_.getUint8(18);
    var rfselect = data_.getUint8(19);

    return UavionixAdsbOutCfg(
        icao: icao,
        stallspeed: stallspeed,
        callsign: callsign,
        emittertype: emittertype,
        aircraftsize: aircraftsize,
        gpsoffsetlat: gpsoffsetlat,
        gpsoffsetlon: gpsoffsetlon,
        rfselect: rfselect);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, icao, Endian.little);
    data_.setUint16(4, stallspeed, Endian.little);
    MavlinkMessage.setInt8List(data_, 6, callsign);
    data_.setUint8(15, emittertype);
    data_.setUint8(16, aircraftsize);
    data_.setUint8(17, gpsoffsetlat);
    data_.setUint8(18, gpsoffsetlon);
    data_.setUint8(19, rfselect);
    return data_;
  }
}

/// Dynamic data used to generate ADS-B out transponder data (send at 5Hz)
///
/// UAVIONIX_ADSB_OUT_DYNAMIC
class UavionixAdsbOutDynamic implements MavlinkMessage {
  static const int _mavlinkMessageId = 10002;

  static const int _mavlinkCrcExtra = 186;

  static const int mavlinkEncodedLength = 41;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// UTC time in seconds since GPS epoch (Jan 6, 1980). If unknown set to UINT32_MAX
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: s
  ///
  /// utcTime
  final uint32_t utctime;

  /// Latitude WGS84 (deg * 1E7). If unknown set to INT32_MAX
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// gpsLat
  final int32_t gpslat;

  /// Longitude WGS84 (deg * 1E7). If unknown set to INT32_MAX
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// gpsLon
  final int32_t gpslon;

  /// Altitude (WGS84). UP +ve. If unknown set to INT32_MAX
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mm
  ///
  /// gpsAlt
  final int32_t gpsalt;

  /// Barometric pressure altitude (MSL) relative to a standard atmosphere of 1013.2 mBar and NOT bar corrected altitude (m * 1E-3). (up +ve). If unknown set to INT32_MAX
  ///
  /// MAVLink type: int32_t
  ///
  /// units: mbar
  ///
  /// baroAltMSL
  final int32_t baroaltmsl;

  /// Horizontal accuracy in mm (m * 1E-3). If unknown set to UINT32_MAX
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: mm
  ///
  /// accuracyHor
  final uint32_t accuracyhor;

  /// Vertical accuracy in cm. If unknown set to UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cm
  ///
  /// accuracyVert
  final uint16_t accuracyvert;

  /// Velocity accuracy in mm/s (m * 1E-3). If unknown set to UINT16_MAX
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mm/s
  ///
  /// accuracyVel
  final uint16_t accuracyvel;

  /// GPS vertical speed in cm/s. If unknown set to INT16_MAX
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// velVert
  final int16_t velvert;

  /// North-South velocity over ground in cm/s North +ve. If unknown set to INT16_MAX
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// velNS
  final int16_t velns;

  /// East-West velocity over ground in cm/s East +ve. If unknown set to INT16_MAX
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cm/s
  ///
  /// VelEW
  final int16_t velew;

  /// ADS-B transponder dynamic input state flags
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [UavionixAdsbOutDynamicState]
  ///
  /// state
  final UavionixAdsbOutDynamicState state;

  /// Mode A code (typically 1200 [0x04B0] for VFR)
  ///
  /// MAVLink type: uint16_t
  ///
  /// squawk
  final uint16_t squawk;

  /// 0-1: no fix, 2: 2D fix, 3: 3D fix, 4: DGPS, 5: RTK
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UavionixAdsbOutDynamicGpsFix]
  ///
  /// gpsFix
  final UavionixAdsbOutDynamicGpsFix gpsfix;

  /// Number of satellites visible. If unknown set to UINT8_MAX
  ///
  /// MAVLink type: uint8_t
  ///
  /// numSats
  final uint8_t numsats;

  /// Emergency status
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UavionixAdsbEmergencyStatus]
  ///
  /// emergencyStatus
  final UavionixAdsbEmergencyStatus emergencystatus;

  UavionixAdsbOutDynamic({
    required this.utctime,
    required this.gpslat,
    required this.gpslon,
    required this.gpsalt,
    required this.baroaltmsl,
    required this.accuracyhor,
    required this.accuracyvert,
    required this.accuracyvel,
    required this.velvert,
    required this.velns,
    required this.velew,
    required this.state,
    required this.squawk,
    required this.gpsfix,
    required this.numsats,
    required this.emergencystatus,
  });

  UavionixAdsbOutDynamic copyWith({
    uint32_t? utctime,
    int32_t? gpslat,
    int32_t? gpslon,
    int32_t? gpsalt,
    int32_t? baroaltmsl,
    uint32_t? accuracyhor,
    uint16_t? accuracyvert,
    uint16_t? accuracyvel,
    int16_t? velvert,
    int16_t? velns,
    int16_t? velew,
    UavionixAdsbOutDynamicState? state,
    uint16_t? squawk,
    UavionixAdsbOutDynamicGpsFix? gpsfix,
    uint8_t? numsats,
    UavionixAdsbEmergencyStatus? emergencystatus,
  }) {
    return UavionixAdsbOutDynamic(
      utctime: utctime ?? this.utctime,
      gpslat: gpslat ?? this.gpslat,
      gpslon: gpslon ?? this.gpslon,
      gpsalt: gpsalt ?? this.gpsalt,
      baroaltmsl: baroaltmsl ?? this.baroaltmsl,
      accuracyhor: accuracyhor ?? this.accuracyhor,
      accuracyvert: accuracyvert ?? this.accuracyvert,
      accuracyvel: accuracyvel ?? this.accuracyvel,
      velvert: velvert ?? this.velvert,
      velns: velns ?? this.velns,
      velew: velew ?? this.velew,
      state: state ?? this.state,
      squawk: squawk ?? this.squawk,
      gpsfix: gpsfix ?? this.gpsfix,
      numsats: numsats ?? this.numsats,
      emergencystatus: emergencystatus ?? this.emergencystatus,
    );
  }

  factory UavionixAdsbOutDynamic.parse(ByteData data_) {
    if (data_.lengthInBytes < UavionixAdsbOutDynamic.mavlinkEncodedLength) {
      var len =
          UavionixAdsbOutDynamic.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var utctime = data_.getUint32(0, Endian.little);
    var gpslat = data_.getInt32(4, Endian.little);
    var gpslon = data_.getInt32(8, Endian.little);
    var gpsalt = data_.getInt32(12, Endian.little);
    var baroaltmsl = data_.getInt32(16, Endian.little);
    var accuracyhor = data_.getUint32(20, Endian.little);
    var accuracyvert = data_.getUint16(24, Endian.little);
    var accuracyvel = data_.getUint16(26, Endian.little);
    var velvert = data_.getInt16(28, Endian.little);
    var velns = data_.getInt16(30, Endian.little);
    var velew = data_.getInt16(32, Endian.little);
    var state = data_.getUint16(34, Endian.little);
    var squawk = data_.getUint16(36, Endian.little);
    var gpsfix = data_.getUint8(38);
    var numsats = data_.getUint8(39);
    var emergencystatus = data_.getUint8(40);

    return UavionixAdsbOutDynamic(
        utctime: utctime,
        gpslat: gpslat,
        gpslon: gpslon,
        gpsalt: gpsalt,
        baroaltmsl: baroaltmsl,
        accuracyhor: accuracyhor,
        accuracyvert: accuracyvert,
        accuracyvel: accuracyvel,
        velvert: velvert,
        velns: velns,
        velew: velew,
        state: state,
        squawk: squawk,
        gpsfix: gpsfix,
        numsats: numsats,
        emergencystatus: emergencystatus);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, utctime, Endian.little);
    data_.setInt32(4, gpslat, Endian.little);
    data_.setInt32(8, gpslon, Endian.little);
    data_.setInt32(12, gpsalt, Endian.little);
    data_.setInt32(16, baroaltmsl, Endian.little);
    data_.setUint32(20, accuracyhor, Endian.little);
    data_.setUint16(24, accuracyvert, Endian.little);
    data_.setUint16(26, accuracyvel, Endian.little);
    data_.setInt16(28, velvert, Endian.little);
    data_.setInt16(30, velns, Endian.little);
    data_.setInt16(32, velew, Endian.little);
    data_.setUint16(34, state, Endian.little);
    data_.setUint16(36, squawk, Endian.little);
    data_.setUint8(38, gpsfix);
    data_.setUint8(39, numsats);
    data_.setUint8(40, emergencystatus);
    return data_;
  }
}

/// Transceiver heartbeat with health report (updated every 10s)
///
/// UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT
class UavionixAdsbTransceiverHealthReport implements MavlinkMessage {
  static const int _mavlinkMessageId = 10003;

  static const int _mavlinkCrcExtra = 4;

  static const int mavlinkEncodedLength = 1;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// ADS-B transponder messages
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [UavionixAdsbRfHealth]
  ///
  /// rfHealth
  final UavionixAdsbRfHealth rfhealth;

  UavionixAdsbTransceiverHealthReport({
    required this.rfhealth,
  });

  UavionixAdsbTransceiverHealthReport copyWith({
    UavionixAdsbRfHealth? rfhealth,
  }) {
    return UavionixAdsbTransceiverHealthReport(
      rfhealth: rfhealth ?? this.rfhealth,
    );
  }

  factory UavionixAdsbTransceiverHealthReport.parse(ByteData data_) {
    if (data_.lengthInBytes <
        UavionixAdsbTransceiverHealthReport.mavlinkEncodedLength) {
      var len = UavionixAdsbTransceiverHealthReport.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var rfhealth = data_.getUint8(0);

    return UavionixAdsbTransceiverHealthReport(rfhealth: rfhealth);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, rfhealth);
    return data_;
  }
}

/// ICAROUS heartbeat
///
/// ICAROUS_HEARTBEAT
class IcarousHeartbeat implements MavlinkMessage {
  static const int _mavlinkMessageId = 42000;

  static const int _mavlinkCrcExtra = 227;

  static const int mavlinkEncodedLength = 1;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// See the FMS_STATE enum.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [IcarousFmsState]
  ///
  /// status
  final IcarousFmsState status;

  IcarousHeartbeat({
    required this.status,
  });

  IcarousHeartbeat copyWith({
    IcarousFmsState? status,
  }) {
    return IcarousHeartbeat(
      status: status ?? this.status,
    );
  }

  factory IcarousHeartbeat.parse(ByteData data_) {
    if (data_.lengthInBytes < IcarousHeartbeat.mavlinkEncodedLength) {
      var len = IcarousHeartbeat.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var status = data_.getUint8(0);

    return IcarousHeartbeat(status: status);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, status);
    return data_;
  }
}

/// Kinematic multi bands (track) output from Daidalus
///
/// ICAROUS_KINEMATIC_BANDS
class IcarousKinematicBands implements MavlinkMessage {
  static const int _mavlinkMessageId = 42001;

  static const int _mavlinkCrcExtra = 239;

  static const int mavlinkEncodedLength = 46;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// min angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// min1
  final float min1;

  /// max angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// max1
  final float max1;

  /// min angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// min2
  final float min2;

  /// max angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// max2
  final float max2;

  /// min angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// min3
  final float min3;

  /// max angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// max3
  final float max3;

  /// min angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// min4
  final float min4;

  /// max angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// max4
  final float max4;

  /// min angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// min5
  final float min5;

  /// max angle (degrees)
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// max5
  final float max5;

  /// Number of track bands
  ///
  /// MAVLink type: int8_t
  ///
  /// numBands
  final int8_t numbands;

  /// See the TRACK_BAND_TYPES enum.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [IcarousTrackBandTypes]
  ///
  /// type1
  final IcarousTrackBandTypes type1;

  /// See the TRACK_BAND_TYPES enum.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [IcarousTrackBandTypes]
  ///
  /// type2
  final IcarousTrackBandTypes type2;

  /// See the TRACK_BAND_TYPES enum.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [IcarousTrackBandTypes]
  ///
  /// type3
  final IcarousTrackBandTypes type3;

  /// See the TRACK_BAND_TYPES enum.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [IcarousTrackBandTypes]
  ///
  /// type4
  final IcarousTrackBandTypes type4;

  /// See the TRACK_BAND_TYPES enum.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [IcarousTrackBandTypes]
  ///
  /// type5
  final IcarousTrackBandTypes type5;

  IcarousKinematicBands({
    required this.min1,
    required this.max1,
    required this.min2,
    required this.max2,
    required this.min3,
    required this.max3,
    required this.min4,
    required this.max4,
    required this.min5,
    required this.max5,
    required this.numbands,
    required this.type1,
    required this.type2,
    required this.type3,
    required this.type4,
    required this.type5,
  });

  IcarousKinematicBands copyWith({
    float? min1,
    float? max1,
    float? min2,
    float? max2,
    float? min3,
    float? max3,
    float? min4,
    float? max4,
    float? min5,
    float? max5,
    int8_t? numbands,
    IcarousTrackBandTypes? type1,
    IcarousTrackBandTypes? type2,
    IcarousTrackBandTypes? type3,
    IcarousTrackBandTypes? type4,
    IcarousTrackBandTypes? type5,
  }) {
    return IcarousKinematicBands(
      min1: min1 ?? this.min1,
      max1: max1 ?? this.max1,
      min2: min2 ?? this.min2,
      max2: max2 ?? this.max2,
      min3: min3 ?? this.min3,
      max3: max3 ?? this.max3,
      min4: min4 ?? this.min4,
      max4: max4 ?? this.max4,
      min5: min5 ?? this.min5,
      max5: max5 ?? this.max5,
      numbands: numbands ?? this.numbands,
      type1: type1 ?? this.type1,
      type2: type2 ?? this.type2,
      type3: type3 ?? this.type3,
      type4: type4 ?? this.type4,
      type5: type5 ?? this.type5,
    );
  }

  factory IcarousKinematicBands.parse(ByteData data_) {
    if (data_.lengthInBytes < IcarousKinematicBands.mavlinkEncodedLength) {
      var len =
          IcarousKinematicBands.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var min1 = data_.getFloat32(0, Endian.little);
    var max1 = data_.getFloat32(4, Endian.little);
    var min2 = data_.getFloat32(8, Endian.little);
    var max2 = data_.getFloat32(12, Endian.little);
    var min3 = data_.getFloat32(16, Endian.little);
    var max3 = data_.getFloat32(20, Endian.little);
    var min4 = data_.getFloat32(24, Endian.little);
    var max4 = data_.getFloat32(28, Endian.little);
    var min5 = data_.getFloat32(32, Endian.little);
    var max5 = data_.getFloat32(36, Endian.little);
    var numbands = data_.getInt8(40);
    var type1 = data_.getUint8(41);
    var type2 = data_.getUint8(42);
    var type3 = data_.getUint8(43);
    var type4 = data_.getUint8(44);
    var type5 = data_.getUint8(45);

    return IcarousKinematicBands(
        min1: min1,
        max1: max1,
        min2: min2,
        max2: max2,
        min3: min3,
        max3: max3,
        min4: min4,
        max4: max4,
        min5: min5,
        max5: max5,
        numbands: numbands,
        type1: type1,
        type2: type2,
        type3: type3,
        type4: type4,
        type5: type5);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, min1, Endian.little);
    data_.setFloat32(4, max1, Endian.little);
    data_.setFloat32(8, min2, Endian.little);
    data_.setFloat32(12, max2, Endian.little);
    data_.setFloat32(16, min3, Endian.little);
    data_.setFloat32(20, max3, Endian.little);
    data_.setFloat32(24, min4, Endian.little);
    data_.setFloat32(28, max4, Endian.little);
    data_.setFloat32(32, min5, Endian.little);
    data_.setFloat32(36, max5, Endian.little);
    data_.setInt8(40, numbands);
    data_.setUint8(41, type1);
    data_.setUint8(42, type2);
    data_.setUint8(43, type3);
    data_.setUint8(44, type4);
    data_.setUint8(45, type5);
    return data_;
  }
}

/// Raw RC Data
///
/// CUBEPILOT_RAW_RC
class CubepilotRawRc implements MavlinkMessage {
  static const int _mavlinkMessageId = 50001;

  static const int _mavlinkCrcExtra = 246;

  static const int mavlinkEncodedLength = 32;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  ///
  ///
  /// MAVLink type: uint8_t[32]
  ///
  /// rc_raw
  final List<int8_t> rcRaw;

  CubepilotRawRc({
    required this.rcRaw,
  });

  CubepilotRawRc copyWith({
    List<int8_t>? rcRaw,
  }) {
    return CubepilotRawRc(
      rcRaw: rcRaw ?? this.rcRaw,
    );
  }

  factory CubepilotRawRc.parse(ByteData data_) {
    if (data_.lengthInBytes < CubepilotRawRc.mavlinkEncodedLength) {
      var len = CubepilotRawRc.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var rcRaw = MavlinkMessage.asUint8List(data_, 0, 32);

    return CubepilotRawRc(rcRaw: rcRaw);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setUint8List(data_, 0, rcRaw);
    return data_;
  }
}

/// Information about video stream
///
/// HERELINK_VIDEO_STREAM_INFORMATION
class HerelinkVideoStreamInformation implements MavlinkMessage {
  static const int _mavlinkMessageId = 50002;

  static const int _mavlinkCrcExtra = 181;

  static const int mavlinkEncodedLength = 246;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Frame rate.
  ///
  /// MAVLink type: float
  ///
  /// units: Hz
  ///
  /// framerate
  final float framerate;

  /// Bit rate.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bits/s
  ///
  /// bitrate
  final uint32_t bitrate;

  /// Horizontal resolution.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: pix
  ///
  /// resolution_h
  final uint16_t resolutionH;

  /// Vertical resolution.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: pix
  ///
  /// resolution_v
  final uint16_t resolutionV;

  /// Video image rotation clockwise.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: deg
  ///
  /// rotation
  final uint16_t rotation;

  /// Video Stream ID (1 for first, 2 for second, etc.)
  ///
  /// MAVLink type: uint8_t
  ///
  /// camera_id
  final uint8_t cameraId;

  /// Number of streams available.
  ///
  /// MAVLink type: uint8_t
  ///
  /// status
  final uint8_t status;

  /// Video stream URI (TCP or RTSP URI ground station should connect to) or port number (UDP port ground station should listen to).
  ///
  /// MAVLink type: char[230]
  ///
  /// uri
  final List<char> uri;

  HerelinkVideoStreamInformation({
    required this.framerate,
    required this.bitrate,
    required this.resolutionH,
    required this.resolutionV,
    required this.rotation,
    required this.cameraId,
    required this.status,
    required this.uri,
  });

  HerelinkVideoStreamInformation copyWith({
    float? framerate,
    uint32_t? bitrate,
    uint16_t? resolutionH,
    uint16_t? resolutionV,
    uint16_t? rotation,
    uint8_t? cameraId,
    uint8_t? status,
    List<char>? uri,
  }) {
    return HerelinkVideoStreamInformation(
      framerate: framerate ?? this.framerate,
      bitrate: bitrate ?? this.bitrate,
      resolutionH: resolutionH ?? this.resolutionH,
      resolutionV: resolutionV ?? this.resolutionV,
      rotation: rotation ?? this.rotation,
      cameraId: cameraId ?? this.cameraId,
      status: status ?? this.status,
      uri: uri ?? this.uri,
    );
  }

  factory HerelinkVideoStreamInformation.parse(ByteData data_) {
    if (data_.lengthInBytes <
        HerelinkVideoStreamInformation.mavlinkEncodedLength) {
      var len = HerelinkVideoStreamInformation.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var framerate = data_.getFloat32(0, Endian.little);
    var bitrate = data_.getUint32(4, Endian.little);
    var resolutionH = data_.getUint16(8, Endian.little);
    var resolutionV = data_.getUint16(10, Endian.little);
    var rotation = data_.getUint16(12, Endian.little);
    var cameraId = data_.getUint8(14);
    var status = data_.getUint8(15);
    var uri = MavlinkMessage.asInt8List(data_, 16, 230);

    return HerelinkVideoStreamInformation(
        framerate: framerate,
        bitrate: bitrate,
        resolutionH: resolutionH,
        resolutionV: resolutionV,
        rotation: rotation,
        cameraId: cameraId,
        status: status,
        uri: uri);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, framerate, Endian.little);
    data_.setUint32(4, bitrate, Endian.little);
    data_.setUint16(8, resolutionH, Endian.little);
    data_.setUint16(10, resolutionV, Endian.little);
    data_.setUint16(12, rotation, Endian.little);
    data_.setUint8(14, cameraId);
    data_.setUint8(15, status);
    MavlinkMessage.setInt8List(data_, 16, uri);
    return data_;
  }
}

/// Herelink Telemetry
///
/// HERELINK_TELEM
class HerelinkTelem implements MavlinkMessage {
  static const int _mavlinkMessageId = 50003;

  static const int _mavlinkCrcExtra = 62;

  static const int mavlinkEncodedLength = 19;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  ///
  ///
  /// MAVLink type: uint32_t
  ///
  /// rf_freq
  final uint32_t rfFreq;

  ///
  ///
  /// MAVLink type: uint32_t
  ///
  /// link_bw
  final uint32_t linkBw;

  ///
  ///
  /// MAVLink type: uint32_t
  ///
  /// link_rate
  final uint32_t linkRate;

  ///
  ///
  /// MAVLink type: int16_t
  ///
  /// snr
  final int16_t snr;

  ///
  ///
  /// MAVLink type: int16_t
  ///
  /// cpu_temp
  final int16_t cpuTemp;

  ///
  ///
  /// MAVLink type: int16_t
  ///
  /// board_temp
  final int16_t boardTemp;

  ///
  ///
  /// MAVLink type: uint8_t
  ///
  /// rssi
  final uint8_t rssi;

  HerelinkTelem({
    required this.rfFreq,
    required this.linkBw,
    required this.linkRate,
    required this.snr,
    required this.cpuTemp,
    required this.boardTemp,
    required this.rssi,
  });

  HerelinkTelem copyWith({
    uint32_t? rfFreq,
    uint32_t? linkBw,
    uint32_t? linkRate,
    int16_t? snr,
    int16_t? cpuTemp,
    int16_t? boardTemp,
    uint8_t? rssi,
  }) {
    return HerelinkTelem(
      rfFreq: rfFreq ?? this.rfFreq,
      linkBw: linkBw ?? this.linkBw,
      linkRate: linkRate ?? this.linkRate,
      snr: snr ?? this.snr,
      cpuTemp: cpuTemp ?? this.cpuTemp,
      boardTemp: boardTemp ?? this.boardTemp,
      rssi: rssi ?? this.rssi,
    );
  }

  factory HerelinkTelem.parse(ByteData data_) {
    if (data_.lengthInBytes < HerelinkTelem.mavlinkEncodedLength) {
      var len = HerelinkTelem.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var rfFreq = data_.getUint32(0, Endian.little);
    var linkBw = data_.getUint32(4, Endian.little);
    var linkRate = data_.getUint32(8, Endian.little);
    var snr = data_.getInt16(12, Endian.little);
    var cpuTemp = data_.getInt16(14, Endian.little);
    var boardTemp = data_.getInt16(16, Endian.little);
    var rssi = data_.getUint8(18);

    return HerelinkTelem(
        rfFreq: rfFreq,
        linkBw: linkBw,
        linkRate: linkRate,
        snr: snr,
        cpuTemp: cpuTemp,
        boardTemp: boardTemp,
        rssi: rssi);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, rfFreq, Endian.little);
    data_.setUint32(4, linkBw, Endian.little);
    data_.setUint32(8, linkRate, Endian.little);
    data_.setInt16(12, snr, Endian.little);
    data_.setInt16(14, cpuTemp, Endian.little);
    data_.setInt16(16, boardTemp, Endian.little);
    data_.setUint8(18, rssi);
    return data_;
  }
}

/// Start firmware update with encapsulated data.
///
/// CUBEPILOT_FIRMWARE_UPDATE_START
class CubepilotFirmwareUpdateStart implements MavlinkMessage {
  static const int _mavlinkMessageId = 50004;

  static const int _mavlinkCrcExtra = 240;

  static const int mavlinkEncodedLength = 10;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// FW Size.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bytes
  ///
  /// size
  final uint32_t size;

  /// FW CRC.
  ///
  /// MAVLink type: uint32_t
  ///
  /// crc
  final uint32_t crc;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  CubepilotFirmwareUpdateStart({
    required this.size,
    required this.crc,
    required this.targetSystem,
    required this.targetComponent,
  });

  CubepilotFirmwareUpdateStart copyWith({
    uint32_t? size,
    uint32_t? crc,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return CubepilotFirmwareUpdateStart(
      size: size ?? this.size,
      crc: crc ?? this.crc,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory CubepilotFirmwareUpdateStart.parse(ByteData data_) {
    if (data_.lengthInBytes <
        CubepilotFirmwareUpdateStart.mavlinkEncodedLength) {
      var len = CubepilotFirmwareUpdateStart.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var size = data_.getUint32(0, Endian.little);
    var crc = data_.getUint32(4, Endian.little);
    var targetSystem = data_.getUint8(8);
    var targetComponent = data_.getUint8(9);

    return CubepilotFirmwareUpdateStart(
        size: size,
        crc: crc,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, size, Endian.little);
    data_.setUint32(4, crc, Endian.little);
    data_.setUint8(8, targetSystem);
    data_.setUint8(9, targetComponent);
    return data_;
  }
}

/// offset response to encapsulated data.
///
/// CUBEPILOT_FIRMWARE_UPDATE_RESP
class CubepilotFirmwareUpdateResp implements MavlinkMessage {
  static const int _mavlinkMessageId = 50005;

  static const int _mavlinkCrcExtra = 152;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// FW Offset.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bytes
  ///
  /// offset
  final uint32_t offset;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  CubepilotFirmwareUpdateResp({
    required this.offset,
    required this.targetSystem,
    required this.targetComponent,
  });

  CubepilotFirmwareUpdateResp copyWith({
    uint32_t? offset,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return CubepilotFirmwareUpdateResp(
      offset: offset ?? this.offset,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory CubepilotFirmwareUpdateResp.parse(ByteData data_) {
    if (data_.lengthInBytes <
        CubepilotFirmwareUpdateResp.mavlinkEncodedLength) {
      var len = CubepilotFirmwareUpdateResp.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var offset = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);

    return CubepilotFirmwareUpdateResp(
        offset: offset,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, offset, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    return data_;
  }
}

/// Authorization package
///
/// AIRLINK_AUTH
class AirlinkAuth implements MavlinkMessage {
  static const int _mavlinkMessageId = 52000;

  static const int _mavlinkCrcExtra = 13;

  static const int mavlinkEncodedLength = 100;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Login
  ///
  /// MAVLink type: char[50]
  ///
  /// login
  final List<char> login;

  /// Password
  ///
  /// MAVLink type: char[50]
  ///
  /// password
  final List<char> password;

  AirlinkAuth({
    required this.login,
    required this.password,
  });

  AirlinkAuth copyWith({
    List<char>? login,
    List<char>? password,
  }) {
    return AirlinkAuth(
      login: login ?? this.login,
      password: password ?? this.password,
    );
  }

  factory AirlinkAuth.parse(ByteData data_) {
    if (data_.lengthInBytes < AirlinkAuth.mavlinkEncodedLength) {
      var len = AirlinkAuth.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var login = MavlinkMessage.asInt8List(data_, 0, 50);
    var password = MavlinkMessage.asInt8List(data_, 50, 50);

    return AirlinkAuth(login: login, password: password);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setInt8List(data_, 0, login);
    MavlinkMessage.setInt8List(data_, 50, password);
    return data_;
  }
}

/// Response to the authorization request
///
/// AIRLINK_AUTH_RESPONSE
class AirlinkAuthResponse implements MavlinkMessage {
  static const int _mavlinkMessageId = 52001;

  static const int _mavlinkCrcExtra = 239;

  static const int mavlinkEncodedLength = 1;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Response type
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AirlinkAuthResponseType]
  ///
  /// resp_type
  final AirlinkAuthResponseType respType;

  AirlinkAuthResponse({
    required this.respType,
  });

  AirlinkAuthResponse copyWith({
    AirlinkAuthResponseType? respType,
  }) {
    return AirlinkAuthResponse(
      respType: respType ?? this.respType,
    );
  }

  factory AirlinkAuthResponse.parse(ByteData data_) {
    if (data_.lengthInBytes < AirlinkAuthResponse.mavlinkEncodedLength) {
      var len = AirlinkAuthResponse.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var respType = data_.getUint8(0);

    return AirlinkAuthResponse(respType: respType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, respType);
    return data_;
  }
}

/// Request to hole punching
///
/// AIRLINK_EYE_GS_HOLE_PUSH_REQUEST
class AirlinkEyeGsHolePushRequest implements MavlinkMessage {
  static const int _mavlinkMessageId = 52002;

  static const int _mavlinkCrcExtra = 24;

  static const int mavlinkEncodedLength = 1;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Hole push response type
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AirlinkEyeGsHolePushRespType]
  ///
  /// resp_type
  final AirlinkEyeGsHolePushRespType respType;

  AirlinkEyeGsHolePushRequest({
    required this.respType,
  });

  AirlinkEyeGsHolePushRequest copyWith({
    AirlinkEyeGsHolePushRespType? respType,
  }) {
    return AirlinkEyeGsHolePushRequest(
      respType: respType ?? this.respType,
    );
  }

  factory AirlinkEyeGsHolePushRequest.parse(ByteData data_) {
    if (data_.lengthInBytes <
        AirlinkEyeGsHolePushRequest.mavlinkEncodedLength) {
      var len = AirlinkEyeGsHolePushRequest.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var respType = data_.getUint8(0);

    return AirlinkEyeGsHolePushRequest(respType: respType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, respType);
    return data_;
  }
}

/// Response information about the connected device
///
/// AIRLINK_EYE_GS_HOLE_PUSH_RESPONSE
class AirlinkEyeGsHolePushResponse implements MavlinkMessage {
  static const int _mavlinkMessageId = 52003;

  static const int _mavlinkCrcExtra = 166;

  static const int mavlinkEncodedLength = 26;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// port
  ///
  /// MAVLink type: uint32_t
  ///
  /// ip_port
  final uint32_t ipPort;

  /// Hole push response type
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AirlinkEyeGsHolePushRespType]
  ///
  /// resp_type
  final AirlinkEyeGsHolePushRespType respType;

  /// ip version
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AirlinkEyeIpVersion]
  ///
  /// ip_version
  final AirlinkEyeIpVersion ipVersion;

  /// ip 4 address
  ///
  /// MAVLink type: uint8_t[4]
  ///
  /// ip_address_4
  final List<int8_t> ipAddress4;

  /// ip 6 address
  ///
  /// MAVLink type: uint8_t[16]
  ///
  /// ip_address_6
  final List<int8_t> ipAddress6;

  AirlinkEyeGsHolePushResponse({
    required this.ipPort,
    required this.respType,
    required this.ipVersion,
    required this.ipAddress4,
    required this.ipAddress6,
  });

  AirlinkEyeGsHolePushResponse copyWith({
    uint32_t? ipPort,
    AirlinkEyeGsHolePushRespType? respType,
    AirlinkEyeIpVersion? ipVersion,
    List<int8_t>? ipAddress4,
    List<int8_t>? ipAddress6,
  }) {
    return AirlinkEyeGsHolePushResponse(
      ipPort: ipPort ?? this.ipPort,
      respType: respType ?? this.respType,
      ipVersion: ipVersion ?? this.ipVersion,
      ipAddress4: ipAddress4 ?? this.ipAddress4,
      ipAddress6: ipAddress6 ?? this.ipAddress6,
    );
  }

  factory AirlinkEyeGsHolePushResponse.parse(ByteData data_) {
    if (data_.lengthInBytes <
        AirlinkEyeGsHolePushResponse.mavlinkEncodedLength) {
      var len = AirlinkEyeGsHolePushResponse.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var ipPort = data_.getUint32(0, Endian.little);
    var respType = data_.getUint8(4);
    var ipVersion = data_.getUint8(5);
    var ipAddress4 = MavlinkMessage.asUint8List(data_, 6, 4);
    var ipAddress6 = MavlinkMessage.asUint8List(data_, 10, 16);

    return AirlinkEyeGsHolePushResponse(
        ipPort: ipPort,
        respType: respType,
        ipVersion: ipVersion,
        ipAddress4: ipAddress4,
        ipAddress6: ipAddress6);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, ipPort, Endian.little);
    data_.setUint8(4, respType);
    data_.setUint8(5, ipVersion);
    MavlinkMessage.setUint8List(data_, 6, ipAddress4);
    MavlinkMessage.setUint8List(data_, 10, ipAddress6);
    return data_;
  }
}

/// A package with information about the hole punching status. It is used for constant sending to avoid NAT closing timeout.
///
/// AIRLINK_EYE_HP
class AirlinkEyeHp implements MavlinkMessage {
  static const int _mavlinkMessageId = 52004;

  static const int _mavlinkCrcExtra = 39;

  static const int mavlinkEncodedLength = 1;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Hole push response type
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AirlinkEyeHolePushType]
  ///
  /// resp_type
  final AirlinkEyeHolePushType respType;

  AirlinkEyeHp({
    required this.respType,
  });

  AirlinkEyeHp copyWith({
    AirlinkEyeHolePushType? respType,
  }) {
    return AirlinkEyeHp(
      respType: respType ?? this.respType,
    );
  }

  factory AirlinkEyeHp.parse(ByteData data_) {
    if (data_.lengthInBytes < AirlinkEyeHp.mavlinkEncodedLength) {
      var len = AirlinkEyeHp.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var respType = data_.getUint8(0);

    return AirlinkEyeHp(respType: respType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, respType);
    return data_;
  }
}

/// Initializing the TURN protocol
///
/// AIRLINK_EYE_TURN_INIT
class AirlinkEyeTurnInit implements MavlinkMessage {
  static const int _mavlinkMessageId = 52005;

  static const int _mavlinkCrcExtra = 145;

  static const int mavlinkEncodedLength = 1;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Turn init type
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [AirlinkEyeTurnInitType]
  ///
  /// resp_type
  final AirlinkEyeTurnInitType respType;

  AirlinkEyeTurnInit({
    required this.respType,
  });

  AirlinkEyeTurnInit copyWith({
    AirlinkEyeTurnInitType? respType,
  }) {
    return AirlinkEyeTurnInit(
      respType: respType ?? this.respType,
    );
  }

  factory AirlinkEyeTurnInit.parse(ByteData data_) {
    if (data_.lengthInBytes < AirlinkEyeTurnInit.mavlinkEncodedLength) {
      var len = AirlinkEyeTurnInit.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var respType = data_.getUint8(0);

    return AirlinkEyeTurnInit(respType: respType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, respType);
    return data_;
  }
}

/// Offsets and calibrations values for hardware sensors. This makes it easier to debug the calibration process.
///
/// SENSOR_OFFSETS
class SensorOffsets implements MavlinkMessage {
  static const int _mavlinkMessageId = 150;

  static const int _mavlinkCrcExtra = 134;

  static const int mavlinkEncodedLength = 42;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Magnetic declination.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// mag_declination
  final float magDeclination;

  /// Raw pressure from barometer.
  ///
  /// MAVLink type: int32_t
  ///
  /// raw_press
  final int32_t rawPress;

  /// Raw temperature from barometer.
  ///
  /// MAVLink type: int32_t
  ///
  /// raw_temp
  final int32_t rawTemp;

  /// Gyro X calibration.
  ///
  /// MAVLink type: float
  ///
  /// gyro_cal_x
  final float gyroCalX;

  /// Gyro Y calibration.
  ///
  /// MAVLink type: float
  ///
  /// gyro_cal_y
  final float gyroCalY;

  /// Gyro Z calibration.
  ///
  /// MAVLink type: float
  ///
  /// gyro_cal_z
  final float gyroCalZ;

  /// Accel X calibration.
  ///
  /// MAVLink type: float
  ///
  /// accel_cal_x
  final float accelCalX;

  /// Accel Y calibration.
  ///
  /// MAVLink type: float
  ///
  /// accel_cal_y
  final float accelCalY;

  /// Accel Z calibration.
  ///
  /// MAVLink type: float
  ///
  /// accel_cal_z
  final float accelCalZ;

  /// Magnetometer X offset.
  ///
  /// MAVLink type: int16_t
  ///
  /// mag_ofs_x
  final int16_t magOfsX;

  /// Magnetometer Y offset.
  ///
  /// MAVLink type: int16_t
  ///
  /// mag_ofs_y
  final int16_t magOfsY;

  /// Magnetometer Z offset.
  ///
  /// MAVLink type: int16_t
  ///
  /// mag_ofs_z
  final int16_t magOfsZ;

  SensorOffsets({
    required this.magDeclination,
    required this.rawPress,
    required this.rawTemp,
    required this.gyroCalX,
    required this.gyroCalY,
    required this.gyroCalZ,
    required this.accelCalX,
    required this.accelCalY,
    required this.accelCalZ,
    required this.magOfsX,
    required this.magOfsY,
    required this.magOfsZ,
  });

  SensorOffsets copyWith({
    float? magDeclination,
    int32_t? rawPress,
    int32_t? rawTemp,
    float? gyroCalX,
    float? gyroCalY,
    float? gyroCalZ,
    float? accelCalX,
    float? accelCalY,
    float? accelCalZ,
    int16_t? magOfsX,
    int16_t? magOfsY,
    int16_t? magOfsZ,
  }) {
    return SensorOffsets(
      magDeclination: magDeclination ?? this.magDeclination,
      rawPress: rawPress ?? this.rawPress,
      rawTemp: rawTemp ?? this.rawTemp,
      gyroCalX: gyroCalX ?? this.gyroCalX,
      gyroCalY: gyroCalY ?? this.gyroCalY,
      gyroCalZ: gyroCalZ ?? this.gyroCalZ,
      accelCalX: accelCalX ?? this.accelCalX,
      accelCalY: accelCalY ?? this.accelCalY,
      accelCalZ: accelCalZ ?? this.accelCalZ,
      magOfsX: magOfsX ?? this.magOfsX,
      magOfsY: magOfsY ?? this.magOfsY,
      magOfsZ: magOfsZ ?? this.magOfsZ,
    );
  }

  factory SensorOffsets.parse(ByteData data_) {
    if (data_.lengthInBytes < SensorOffsets.mavlinkEncodedLength) {
      var len = SensorOffsets.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var magDeclination = data_.getFloat32(0, Endian.little);
    var rawPress = data_.getInt32(4, Endian.little);
    var rawTemp = data_.getInt32(8, Endian.little);
    var gyroCalX = data_.getFloat32(12, Endian.little);
    var gyroCalY = data_.getFloat32(16, Endian.little);
    var gyroCalZ = data_.getFloat32(20, Endian.little);
    var accelCalX = data_.getFloat32(24, Endian.little);
    var accelCalY = data_.getFloat32(28, Endian.little);
    var accelCalZ = data_.getFloat32(32, Endian.little);
    var magOfsX = data_.getInt16(36, Endian.little);
    var magOfsY = data_.getInt16(38, Endian.little);
    var magOfsZ = data_.getInt16(40, Endian.little);

    return SensorOffsets(
        magDeclination: magDeclination,
        rawPress: rawPress,
        rawTemp: rawTemp,
        gyroCalX: gyroCalX,
        gyroCalY: gyroCalY,
        gyroCalZ: gyroCalZ,
        accelCalX: accelCalX,
        accelCalY: accelCalY,
        accelCalZ: accelCalZ,
        magOfsX: magOfsX,
        magOfsY: magOfsY,
        magOfsZ: magOfsZ);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, magDeclination, Endian.little);
    data_.setInt32(4, rawPress, Endian.little);
    data_.setInt32(8, rawTemp, Endian.little);
    data_.setFloat32(12, gyroCalX, Endian.little);
    data_.setFloat32(16, gyroCalY, Endian.little);
    data_.setFloat32(20, gyroCalZ, Endian.little);
    data_.setFloat32(24, accelCalX, Endian.little);
    data_.setFloat32(28, accelCalY, Endian.little);
    data_.setFloat32(32, accelCalZ, Endian.little);
    data_.setInt16(36, magOfsX, Endian.little);
    data_.setInt16(38, magOfsY, Endian.little);
    data_.setInt16(40, magOfsZ, Endian.little);
    return data_;
  }
}

/// Set the magnetometer offsets
///
/// SET_MAG_OFFSETS
class SetMagOffsets implements MavlinkMessage {
  static const int _mavlinkMessageId = 151;

  static const int _mavlinkCrcExtra = 219;

  static const int mavlinkEncodedLength = 8;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Magnetometer X offset.
  ///
  /// MAVLink type: int16_t
  ///
  /// mag_ofs_x
  final int16_t magOfsX;

  /// Magnetometer Y offset.
  ///
  /// MAVLink type: int16_t
  ///
  /// mag_ofs_y
  final int16_t magOfsY;

  /// Magnetometer Z offset.
  ///
  /// MAVLink type: int16_t
  ///
  /// mag_ofs_z
  final int16_t magOfsZ;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  SetMagOffsets({
    required this.magOfsX,
    required this.magOfsY,
    required this.magOfsZ,
    required this.targetSystem,
    required this.targetComponent,
  });

  SetMagOffsets copyWith({
    int16_t? magOfsX,
    int16_t? magOfsY,
    int16_t? magOfsZ,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return SetMagOffsets(
      magOfsX: magOfsX ?? this.magOfsX,
      magOfsY: magOfsY ?? this.magOfsY,
      magOfsZ: magOfsZ ?? this.magOfsZ,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory SetMagOffsets.parse(ByteData data_) {
    if (data_.lengthInBytes < SetMagOffsets.mavlinkEncodedLength) {
      var len = SetMagOffsets.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var magOfsX = data_.getInt16(0, Endian.little);
    var magOfsY = data_.getInt16(2, Endian.little);
    var magOfsZ = data_.getInt16(4, Endian.little);
    var targetSystem = data_.getUint8(6);
    var targetComponent = data_.getUint8(7);

    return SetMagOffsets(
        magOfsX: magOfsX,
        magOfsY: magOfsY,
        magOfsZ: magOfsZ,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt16(0, magOfsX, Endian.little);
    data_.setInt16(2, magOfsY, Endian.little);
    data_.setInt16(4, magOfsZ, Endian.little);
    data_.setUint8(6, targetSystem);
    data_.setUint8(7, targetComponent);
    return data_;
  }
}

/// State of autopilot RAM.
///
/// MEMINFO
class Meminfo implements MavlinkMessage {
  static const int _mavlinkMessageId = 152;

  static const int _mavlinkCrcExtra = 208;

  static const int mavlinkEncodedLength = 8;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Heap top.
  ///
  /// MAVLink type: uint16_t
  ///
  /// brkval
  final uint16_t brkval;

  /// Free memory.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: bytes
  ///
  /// freemem
  final uint16_t freemem;

  /// Free memory (32 bit).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: bytes
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// freemem32
  final uint32_t freemem32;

  Meminfo({
    required this.brkval,
    required this.freemem,
    required this.freemem32,
  });

  Meminfo copyWith({
    uint16_t? brkval,
    uint16_t? freemem,
    uint32_t? freemem32,
  }) {
    return Meminfo(
      brkval: brkval ?? this.brkval,
      freemem: freemem ?? this.freemem,
      freemem32: freemem32 ?? this.freemem32,
    );
  }

  factory Meminfo.parse(ByteData data_) {
    if (data_.lengthInBytes < Meminfo.mavlinkEncodedLength) {
      var len = Meminfo.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var brkval = data_.getUint16(0, Endian.little);
    var freemem = data_.getUint16(2, Endian.little);
    var freemem32 = data_.getUint32(4, Endian.little);

    return Meminfo(brkval: brkval, freemem: freemem, freemem32: freemem32);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, brkval, Endian.little);
    data_.setUint16(2, freemem, Endian.little);
    data_.setUint32(4, freemem32, Endian.little);
    return data_;
  }
}

/// Raw ADC output.
///
/// AP_ADC
class ApAdc implements MavlinkMessage {
  static const int _mavlinkMessageId = 153;

  static const int _mavlinkCrcExtra = 188;

  static const int mavlinkEncodedLength = 12;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// ADC output 1.
  ///
  /// MAVLink type: uint16_t
  ///
  /// adc1
  final uint16_t adc1;

  /// ADC output 2.
  ///
  /// MAVLink type: uint16_t
  ///
  /// adc2
  final uint16_t adc2;

  /// ADC output 3.
  ///
  /// MAVLink type: uint16_t
  ///
  /// adc3
  final uint16_t adc3;

  /// ADC output 4.
  ///
  /// MAVLink type: uint16_t
  ///
  /// adc4
  final uint16_t adc4;

  /// ADC output 5.
  ///
  /// MAVLink type: uint16_t
  ///
  /// adc5
  final uint16_t adc5;

  /// ADC output 6.
  ///
  /// MAVLink type: uint16_t
  ///
  /// adc6
  final uint16_t adc6;

  ApAdc({
    required this.adc1,
    required this.adc2,
    required this.adc3,
    required this.adc4,
    required this.adc5,
    required this.adc6,
  });

  ApAdc copyWith({
    uint16_t? adc1,
    uint16_t? adc2,
    uint16_t? adc3,
    uint16_t? adc4,
    uint16_t? adc5,
    uint16_t? adc6,
  }) {
    return ApAdc(
      adc1: adc1 ?? this.adc1,
      adc2: adc2 ?? this.adc2,
      adc3: adc3 ?? this.adc3,
      adc4: adc4 ?? this.adc4,
      adc5: adc5 ?? this.adc5,
      adc6: adc6 ?? this.adc6,
    );
  }

  factory ApAdc.parse(ByteData data_) {
    if (data_.lengthInBytes < ApAdc.mavlinkEncodedLength) {
      var len = ApAdc.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var adc1 = data_.getUint16(0, Endian.little);
    var adc2 = data_.getUint16(2, Endian.little);
    var adc3 = data_.getUint16(4, Endian.little);
    var adc4 = data_.getUint16(6, Endian.little);
    var adc5 = data_.getUint16(8, Endian.little);
    var adc6 = data_.getUint16(10, Endian.little);

    return ApAdc(
        adc1: adc1, adc2: adc2, adc3: adc3, adc4: adc4, adc5: adc5, adc6: adc6);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, adc1, Endian.little);
    data_.setUint16(2, adc2, Endian.little);
    data_.setUint16(4, adc3, Endian.little);
    data_.setUint16(6, adc4, Endian.little);
    data_.setUint16(8, adc5, Endian.little);
    data_.setUint16(10, adc6, Endian.little);
    return data_;
  }
}

/// Configure on-board Camera Control System.
///
/// DIGICAM_CONFIGURE
class DigicamConfigure implements MavlinkMessage {
  static const int _mavlinkMessageId = 154;

  static const int _mavlinkCrcExtra = 84;

  static const int mavlinkEncodedLength = 15;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Correspondent value to given extra_param.
  ///
  /// MAVLink type: float
  ///
  /// extra_value
  final float extraValue;

  /// Divisor number //e.g. 1000 means 1/1000 (0 means ignore).
  ///
  /// MAVLink type: uint16_t
  ///
  /// shutter_speed
  final uint16_t shutterSpeed;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mode enumeration from 1 to N //P, TV, AV, M, etc. (0 means ignore).
  ///
  /// MAVLink type: uint8_t
  ///
  /// mode
  final uint8_t mode;

  /// F stop number x 10 //e.g. 28 means 2.8 (0 means ignore).
  ///
  /// MAVLink type: uint8_t
  ///
  /// aperture
  final uint8_t aperture;

  /// ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore).
  ///
  /// MAVLink type: uint8_t
  ///
  /// iso
  final uint8_t iso;

  /// Exposure type enumeration from 1 to N (0 means ignore).
  ///
  /// MAVLink type: uint8_t
  ///
  /// exposure_type
  final uint8_t exposureType;

  /// Command Identity (incremental loop: 0 to 255). //A command sent multiple times will be executed or pooled just once.
  ///
  /// MAVLink type: uint8_t
  ///
  /// command_id
  final uint8_t commandId;

  /// Main engine cut-off time before camera trigger (0 means no cut-off).
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: ds
  ///
  /// engine_cut_off
  final uint8_t engineCutOff;

  /// Extra parameters enumeration (0 means ignore).
  ///
  /// MAVLink type: uint8_t
  ///
  /// extra_param
  final uint8_t extraParam;

  DigicamConfigure({
    required this.extraValue,
    required this.shutterSpeed,
    required this.targetSystem,
    required this.targetComponent,
    required this.mode,
    required this.aperture,
    required this.iso,
    required this.exposureType,
    required this.commandId,
    required this.engineCutOff,
    required this.extraParam,
  });

  DigicamConfigure copyWith({
    float? extraValue,
    uint16_t? shutterSpeed,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? mode,
    uint8_t? aperture,
    uint8_t? iso,
    uint8_t? exposureType,
    uint8_t? commandId,
    uint8_t? engineCutOff,
    uint8_t? extraParam,
  }) {
    return DigicamConfigure(
      extraValue: extraValue ?? this.extraValue,
      shutterSpeed: shutterSpeed ?? this.shutterSpeed,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      mode: mode ?? this.mode,
      aperture: aperture ?? this.aperture,
      iso: iso ?? this.iso,
      exposureType: exposureType ?? this.exposureType,
      commandId: commandId ?? this.commandId,
      engineCutOff: engineCutOff ?? this.engineCutOff,
      extraParam: extraParam ?? this.extraParam,
    );
  }

  factory DigicamConfigure.parse(ByteData data_) {
    if (data_.lengthInBytes < DigicamConfigure.mavlinkEncodedLength) {
      var len = DigicamConfigure.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var extraValue = data_.getFloat32(0, Endian.little);
    var shutterSpeed = data_.getUint16(4, Endian.little);
    var targetSystem = data_.getUint8(6);
    var targetComponent = data_.getUint8(7);
    var mode = data_.getUint8(8);
    var aperture = data_.getUint8(9);
    var iso = data_.getUint8(10);
    var exposureType = data_.getUint8(11);
    var commandId = data_.getUint8(12);
    var engineCutOff = data_.getUint8(13);
    var extraParam = data_.getUint8(14);

    return DigicamConfigure(
        extraValue: extraValue,
        shutterSpeed: shutterSpeed,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        mode: mode,
        aperture: aperture,
        iso: iso,
        exposureType: exposureType,
        commandId: commandId,
        engineCutOff: engineCutOff,
        extraParam: extraParam);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, extraValue, Endian.little);
    data_.setUint16(4, shutterSpeed, Endian.little);
    data_.setUint8(6, targetSystem);
    data_.setUint8(7, targetComponent);
    data_.setUint8(8, mode);
    data_.setUint8(9, aperture);
    data_.setUint8(10, iso);
    data_.setUint8(11, exposureType);
    data_.setUint8(12, commandId);
    data_.setUint8(13, engineCutOff);
    data_.setUint8(14, extraParam);
    return data_;
  }
}

/// Control on-board Camera Control System to take shots.
///
/// DIGICAM_CONTROL
class DigicamControl implements MavlinkMessage {
  static const int _mavlinkMessageId = 155;

  static const int _mavlinkCrcExtra = 22;

  static const int mavlinkEncodedLength = 13;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Correspondent value to given extra_param.
  ///
  /// MAVLink type: float
  ///
  /// extra_value
  final float extraValue;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// 0: stop, 1: start or keep it up //Session control e.g. show/hide lens.
  ///
  /// MAVLink type: uint8_t
  ///
  /// session
  final uint8_t session;

  /// 1 to N //Zoom's absolute position (0 means ignore).
  ///
  /// MAVLink type: uint8_t
  ///
  /// zoom_pos
  final uint8_t zoomPos;

  /// -100 to 100 //Zooming step value to offset zoom from the current position.
  ///
  /// MAVLink type: int8_t
  ///
  /// zoom_step
  final int8_t zoomStep;

  /// 0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus.
  ///
  /// MAVLink type: uint8_t
  ///
  /// focus_lock
  final uint8_t focusLock;

  /// 0: ignore, 1: shot or start filming.
  ///
  /// MAVLink type: uint8_t
  ///
  /// shot
  final uint8_t shot;

  /// Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once.
  ///
  /// MAVLink type: uint8_t
  ///
  /// command_id
  final uint8_t commandId;

  /// Extra parameters enumeration (0 means ignore).
  ///
  /// MAVLink type: uint8_t
  ///
  /// extra_param
  final uint8_t extraParam;

  DigicamControl({
    required this.extraValue,
    required this.targetSystem,
    required this.targetComponent,
    required this.session,
    required this.zoomPos,
    required this.zoomStep,
    required this.focusLock,
    required this.shot,
    required this.commandId,
    required this.extraParam,
  });

  DigicamControl copyWith({
    float? extraValue,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? session,
    uint8_t? zoomPos,
    int8_t? zoomStep,
    uint8_t? focusLock,
    uint8_t? shot,
    uint8_t? commandId,
    uint8_t? extraParam,
  }) {
    return DigicamControl(
      extraValue: extraValue ?? this.extraValue,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      session: session ?? this.session,
      zoomPos: zoomPos ?? this.zoomPos,
      zoomStep: zoomStep ?? this.zoomStep,
      focusLock: focusLock ?? this.focusLock,
      shot: shot ?? this.shot,
      commandId: commandId ?? this.commandId,
      extraParam: extraParam ?? this.extraParam,
    );
  }

  factory DigicamControl.parse(ByteData data_) {
    if (data_.lengthInBytes < DigicamControl.mavlinkEncodedLength) {
      var len = DigicamControl.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var extraValue = data_.getFloat32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var session = data_.getUint8(6);
    var zoomPos = data_.getUint8(7);
    var zoomStep = data_.getInt8(8);
    var focusLock = data_.getUint8(9);
    var shot = data_.getUint8(10);
    var commandId = data_.getUint8(11);
    var extraParam = data_.getUint8(12);

    return DigicamControl(
        extraValue: extraValue,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        session: session,
        zoomPos: zoomPos,
        zoomStep: zoomStep,
        focusLock: focusLock,
        shot: shot,
        commandId: commandId,
        extraParam: extraParam);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, extraValue, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, session);
    data_.setUint8(7, zoomPos);
    data_.setInt8(8, zoomStep);
    data_.setUint8(9, focusLock);
    data_.setUint8(10, shot);
    data_.setUint8(11, commandId);
    data_.setUint8(12, extraParam);
    return data_;
  }
}

/// Message to configure a camera mount, directional antenna, etc.
///
/// MOUNT_CONFIGURE
class MountConfigure implements MavlinkMessage {
  static const int _mavlinkMessageId = 156;

  static const int _mavlinkCrcExtra = 19;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mount operating mode.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMountMode]
  ///
  /// mount_mode
  final MavMountMode mountMode;

  /// (1 = yes, 0 = no).
  ///
  /// MAVLink type: uint8_t
  ///
  /// stab_roll
  final uint8_t stabRoll;

  /// (1 = yes, 0 = no).
  ///
  /// MAVLink type: uint8_t
  ///
  /// stab_pitch
  final uint8_t stabPitch;

  /// (1 = yes, 0 = no).
  ///
  /// MAVLink type: uint8_t
  ///
  /// stab_yaw
  final uint8_t stabYaw;

  MountConfigure({
    required this.targetSystem,
    required this.targetComponent,
    required this.mountMode,
    required this.stabRoll,
    required this.stabPitch,
    required this.stabYaw,
  });

  MountConfigure copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMountMode? mountMode,
    uint8_t? stabRoll,
    uint8_t? stabPitch,
    uint8_t? stabYaw,
  }) {
    return MountConfigure(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      mountMode: mountMode ?? this.mountMode,
      stabRoll: stabRoll ?? this.stabRoll,
      stabPitch: stabPitch ?? this.stabPitch,
      stabYaw: stabYaw ?? this.stabYaw,
    );
  }

  factory MountConfigure.parse(ByteData data_) {
    if (data_.lengthInBytes < MountConfigure.mavlinkEncodedLength) {
      var len = MountConfigure.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var mountMode = data_.getUint8(2);
    var stabRoll = data_.getUint8(3);
    var stabPitch = data_.getUint8(4);
    var stabYaw = data_.getUint8(5);

    return MountConfigure(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        mountMode: mountMode,
        stabRoll: stabRoll,
        stabPitch: stabPitch,
        stabYaw: stabYaw);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, mountMode);
    data_.setUint8(3, stabRoll);
    data_.setUint8(4, stabPitch);
    data_.setUint8(5, stabYaw);
    return data_;
  }
}

/// Message to control a camera mount, directional antenna, etc.
///
/// MOUNT_CONTROL
class MountControl implements MavlinkMessage {
  static const int _mavlinkMessageId = 157;

  static const int _mavlinkCrcExtra = 21;

  static const int mavlinkEncodedLength = 15;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Pitch (centi-degrees) or lat (degE7), depending on mount mode.
  ///
  /// MAVLink type: int32_t
  ///
  /// input_a
  final int32_t inputA;

  /// Roll (centi-degrees) or lon (degE7) depending on mount mode.
  ///
  /// MAVLink type: int32_t
  ///
  /// input_b
  final int32_t inputB;

  /// Yaw (centi-degrees) or alt (cm) depending on mount mode.
  ///
  /// MAVLink type: int32_t
  ///
  /// input_c
  final int32_t inputC;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// If "1" it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING).
  ///
  /// MAVLink type: uint8_t
  ///
  /// save_position
  final uint8_t savePosition;

  MountControl({
    required this.inputA,
    required this.inputB,
    required this.inputC,
    required this.targetSystem,
    required this.targetComponent,
    required this.savePosition,
  });

  MountControl copyWith({
    int32_t? inputA,
    int32_t? inputB,
    int32_t? inputC,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? savePosition,
  }) {
    return MountControl(
      inputA: inputA ?? this.inputA,
      inputB: inputB ?? this.inputB,
      inputC: inputC ?? this.inputC,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      savePosition: savePosition ?? this.savePosition,
    );
  }

  factory MountControl.parse(ByteData data_) {
    if (data_.lengthInBytes < MountControl.mavlinkEncodedLength) {
      var len = MountControl.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var inputA = data_.getInt32(0, Endian.little);
    var inputB = data_.getInt32(4, Endian.little);
    var inputC = data_.getInt32(8, Endian.little);
    var targetSystem = data_.getUint8(12);
    var targetComponent = data_.getUint8(13);
    var savePosition = data_.getUint8(14);

    return MountControl(
        inputA: inputA,
        inputB: inputB,
        inputC: inputC,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        savePosition: savePosition);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, inputA, Endian.little);
    data_.setInt32(4, inputB, Endian.little);
    data_.setInt32(8, inputC, Endian.little);
    data_.setUint8(12, targetSystem);
    data_.setUint8(13, targetComponent);
    data_.setUint8(14, savePosition);
    return data_;
  }
}

/// Message with some status from autopilot to GCS about camera or antenna mount.
///
/// MOUNT_STATUS
class MountStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 158;

  static const int _mavlinkCrcExtra = 134;

  static const int mavlinkEncodedLength = 15;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Pitch.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: cdeg
  ///
  /// pointing_a
  final int32_t pointingA;

  /// Roll.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: cdeg
  ///
  /// pointing_b
  final int32_t pointingB;

  /// Yaw.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: cdeg
  ///
  /// pointing_c
  final int32_t pointingC;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Mount operating mode.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavMountMode]
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// mount_mode
  final MavMountMode mountMode;

  MountStatus({
    required this.pointingA,
    required this.pointingB,
    required this.pointingC,
    required this.targetSystem,
    required this.targetComponent,
    required this.mountMode,
  });

  MountStatus copyWith({
    int32_t? pointingA,
    int32_t? pointingB,
    int32_t? pointingC,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavMountMode? mountMode,
  }) {
    return MountStatus(
      pointingA: pointingA ?? this.pointingA,
      pointingB: pointingB ?? this.pointingB,
      pointingC: pointingC ?? this.pointingC,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      mountMode: mountMode ?? this.mountMode,
    );
  }

  factory MountStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < MountStatus.mavlinkEncodedLength) {
      var len = MountStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var pointingA = data_.getInt32(0, Endian.little);
    var pointingB = data_.getInt32(4, Endian.little);
    var pointingC = data_.getInt32(8, Endian.little);
    var targetSystem = data_.getUint8(12);
    var targetComponent = data_.getUint8(13);
    var mountMode = data_.getUint8(14);

    return MountStatus(
        pointingA: pointingA,
        pointingB: pointingB,
        pointingC: pointingC,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        mountMode: mountMode);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, pointingA, Endian.little);
    data_.setInt32(4, pointingB, Endian.little);
    data_.setInt32(8, pointingC, Endian.little);
    data_.setUint8(12, targetSystem);
    data_.setUint8(13, targetComponent);
    data_.setUint8(14, mountMode);
    return data_;
  }
}

/// A fence point. Used to set a point when from GCS -> MAV. Also used to return a point from MAV -> GCS.
///
/// FENCE_POINT
class FencePoint implements MavlinkMessage {
  static const int _mavlinkMessageId = 160;

  static const int _mavlinkCrcExtra = 78;

  static const int mavlinkEncodedLength = 12;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude of point.
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// lat
  final float lat;

  /// Longitude of point.
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// lng
  final float lng;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Point index (first point is 1, 0 is for return point).
  ///
  /// MAVLink type: uint8_t
  ///
  /// idx
  final uint8_t idx;

  /// Total number of points (for sanity checking).
  ///
  /// MAVLink type: uint8_t
  ///
  /// count
  final uint8_t count;

  FencePoint({
    required this.lat,
    required this.lng,
    required this.targetSystem,
    required this.targetComponent,
    required this.idx,
    required this.count,
  });

  FencePoint copyWith({
    float? lat,
    float? lng,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? idx,
    uint8_t? count,
  }) {
    return FencePoint(
      lat: lat ?? this.lat,
      lng: lng ?? this.lng,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idx: idx ?? this.idx,
      count: count ?? this.count,
    );
  }

  factory FencePoint.parse(ByteData data_) {
    if (data_.lengthInBytes < FencePoint.mavlinkEncodedLength) {
      var len = FencePoint.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var lat = data_.getFloat32(0, Endian.little);
    var lng = data_.getFloat32(4, Endian.little);
    var targetSystem = data_.getUint8(8);
    var targetComponent = data_.getUint8(9);
    var idx = data_.getUint8(10);
    var count = data_.getUint8(11);

    return FencePoint(
        lat: lat,
        lng: lng,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        idx: idx,
        count: count);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, lat, Endian.little);
    data_.setFloat32(4, lng, Endian.little);
    data_.setUint8(8, targetSystem);
    data_.setUint8(9, targetComponent);
    data_.setUint8(10, idx);
    data_.setUint8(11, count);
    return data_;
  }
}

/// Request a current fence point from MAV.
///
/// FENCE_FETCH_POINT
class FenceFetchPoint implements MavlinkMessage {
  static const int _mavlinkMessageId = 161;

  static const int _mavlinkCrcExtra = 68;

  static const int mavlinkEncodedLength = 3;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Point index (first point is 1, 0 is for return point).
  ///
  /// MAVLink type: uint8_t
  ///
  /// idx
  final uint8_t idx;

  FenceFetchPoint({
    required this.targetSystem,
    required this.targetComponent,
    required this.idx,
  });

  FenceFetchPoint copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? idx,
  }) {
    return FenceFetchPoint(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idx: idx ?? this.idx,
    );
  }

  factory FenceFetchPoint.parse(ByteData data_) {
    if (data_.lengthInBytes < FenceFetchPoint.mavlinkEncodedLength) {
      var len = FenceFetchPoint.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var idx = data_.getUint8(2);

    return FenceFetchPoint(
        targetSystem: targetSystem, targetComponent: targetComponent, idx: idx);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, idx);
    return data_;
  }
}

/// Status of DCM attitude estimator.
///
/// AHRS
class Ahrs implements MavlinkMessage {
  static const int _mavlinkMessageId = 163;

  static const int _mavlinkCrcExtra = 127;

  static const int mavlinkEncodedLength = 28;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// X gyro drift estimate.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// omegaIx
  final float omegaix;

  /// Y gyro drift estimate.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// omegaIy
  final float omegaiy;

  /// Z gyro drift estimate.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// omegaIz
  final float omegaiz;

  /// Average accel_weight.
  ///
  /// MAVLink type: float
  ///
  /// accel_weight
  final float accelWeight;

  /// Average renormalisation value.
  ///
  /// MAVLink type: float
  ///
  /// renorm_val
  final float renormVal;

  /// Average error_roll_pitch value.
  ///
  /// MAVLink type: float
  ///
  /// error_rp
  final float errorRp;

  /// Average error_yaw value.
  ///
  /// MAVLink type: float
  ///
  /// error_yaw
  final float errorYaw;

  Ahrs({
    required this.omegaix,
    required this.omegaiy,
    required this.omegaiz,
    required this.accelWeight,
    required this.renormVal,
    required this.errorRp,
    required this.errorYaw,
  });

  Ahrs copyWith({
    float? omegaix,
    float? omegaiy,
    float? omegaiz,
    float? accelWeight,
    float? renormVal,
    float? errorRp,
    float? errorYaw,
  }) {
    return Ahrs(
      omegaix: omegaix ?? this.omegaix,
      omegaiy: omegaiy ?? this.omegaiy,
      omegaiz: omegaiz ?? this.omegaiz,
      accelWeight: accelWeight ?? this.accelWeight,
      renormVal: renormVal ?? this.renormVal,
      errorRp: errorRp ?? this.errorRp,
      errorYaw: errorYaw ?? this.errorYaw,
    );
  }

  factory Ahrs.parse(ByteData data_) {
    if (data_.lengthInBytes < Ahrs.mavlinkEncodedLength) {
      var len = Ahrs.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var omegaix = data_.getFloat32(0, Endian.little);
    var omegaiy = data_.getFloat32(4, Endian.little);
    var omegaiz = data_.getFloat32(8, Endian.little);
    var accelWeight = data_.getFloat32(12, Endian.little);
    var renormVal = data_.getFloat32(16, Endian.little);
    var errorRp = data_.getFloat32(20, Endian.little);
    var errorYaw = data_.getFloat32(24, Endian.little);

    return Ahrs(
        omegaix: omegaix,
        omegaiy: omegaiy,
        omegaiz: omegaiz,
        accelWeight: accelWeight,
        renormVal: renormVal,
        errorRp: errorRp,
        errorYaw: errorYaw);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, omegaix, Endian.little);
    data_.setFloat32(4, omegaiy, Endian.little);
    data_.setFloat32(8, omegaiz, Endian.little);
    data_.setFloat32(12, accelWeight, Endian.little);
    data_.setFloat32(16, renormVal, Endian.little);
    data_.setFloat32(20, errorRp, Endian.little);
    data_.setFloat32(24, errorYaw, Endian.little);
    return data_;
  }
}

/// Status of simulation environment, if used.
///
/// SIMSTATE
class Simstate implements MavlinkMessage {
  static const int _mavlinkMessageId = 164;

  static const int _mavlinkCrcExtra = 154;

  static const int mavlinkEncodedLength = 44;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Roll angle.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch angle.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// X acceleration.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// xacc
  final float xacc;

  /// Y acceleration.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// yacc
  final float yacc;

  /// Z acceleration.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s/s
  ///
  /// zacc
  final float zacc;

  /// Angular speed around X axis.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// xgyro
  final float xgyro;

  /// Angular speed around Y axis.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// ygyro
  final float ygyro;

  /// Angular speed around Z axis.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// zgyro
  final float zgyro;

  /// Latitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lng
  final int32_t lng;

  Simstate({
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.xacc,
    required this.yacc,
    required this.zacc,
    required this.xgyro,
    required this.ygyro,
    required this.zgyro,
    required this.lat,
    required this.lng,
  });

  Simstate copyWith({
    float? roll,
    float? pitch,
    float? yaw,
    float? xacc,
    float? yacc,
    float? zacc,
    float? xgyro,
    float? ygyro,
    float? zgyro,
    int32_t? lat,
    int32_t? lng,
  }) {
    return Simstate(
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      xacc: xacc ?? this.xacc,
      yacc: yacc ?? this.yacc,
      zacc: zacc ?? this.zacc,
      xgyro: xgyro ?? this.xgyro,
      ygyro: ygyro ?? this.ygyro,
      zgyro: zgyro ?? this.zgyro,
      lat: lat ?? this.lat,
      lng: lng ?? this.lng,
    );
  }

  factory Simstate.parse(ByteData data_) {
    if (data_.lengthInBytes < Simstate.mavlinkEncodedLength) {
      var len = Simstate.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var roll = data_.getFloat32(0, Endian.little);
    var pitch = data_.getFloat32(4, Endian.little);
    var yaw = data_.getFloat32(8, Endian.little);
    var xacc = data_.getFloat32(12, Endian.little);
    var yacc = data_.getFloat32(16, Endian.little);
    var zacc = data_.getFloat32(20, Endian.little);
    var xgyro = data_.getFloat32(24, Endian.little);
    var ygyro = data_.getFloat32(28, Endian.little);
    var zgyro = data_.getFloat32(32, Endian.little);
    var lat = data_.getInt32(36, Endian.little);
    var lng = data_.getInt32(40, Endian.little);

    return Simstate(
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        xacc: xacc,
        yacc: yacc,
        zacc: zacc,
        xgyro: xgyro,
        ygyro: ygyro,
        zgyro: zgyro,
        lat: lat,
        lng: lng);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, roll, Endian.little);
    data_.setFloat32(4, pitch, Endian.little);
    data_.setFloat32(8, yaw, Endian.little);
    data_.setFloat32(12, xacc, Endian.little);
    data_.setFloat32(16, yacc, Endian.little);
    data_.setFloat32(20, zacc, Endian.little);
    data_.setFloat32(24, xgyro, Endian.little);
    data_.setFloat32(28, ygyro, Endian.little);
    data_.setFloat32(32, zgyro, Endian.little);
    data_.setInt32(36, lat, Endian.little);
    data_.setInt32(40, lng, Endian.little);
    return data_;
  }
}

/// Status of key hardware.
///
/// HWSTATUS
class Hwstatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 165;

  static const int _mavlinkCrcExtra = 21;

  static const int mavlinkEncodedLength = 3;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Board voltage.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mV
  ///
  /// Vcc
  final uint16_t vcc;

  /// I2C error count.
  ///
  /// MAVLink type: uint8_t
  ///
  /// I2Cerr
  final uint8_t i2cerr;

  Hwstatus({
    required this.vcc,
    required this.i2cerr,
  });

  Hwstatus copyWith({
    uint16_t? vcc,
    uint8_t? i2cerr,
  }) {
    return Hwstatus(
      vcc: vcc ?? this.vcc,
      i2cerr: i2cerr ?? this.i2cerr,
    );
  }

  factory Hwstatus.parse(ByteData data_) {
    if (data_.lengthInBytes < Hwstatus.mavlinkEncodedLength) {
      var len = Hwstatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var vcc = data_.getUint16(0, Endian.little);
    var i2cerr = data_.getUint8(2);

    return Hwstatus(vcc: vcc, i2cerr: i2cerr);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, vcc, Endian.little);
    data_.setUint8(2, i2cerr);
    return data_;
  }
}

/// Status generated by radio.
///
/// RADIO
class Radio implements MavlinkMessage {
  static const int _mavlinkMessageId = 166;

  static const int _mavlinkCrcExtra = 21;

  static const int mavlinkEncodedLength = 9;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Receive errors.
  ///
  /// MAVLink type: uint16_t
  ///
  /// rxerrors
  final uint16_t rxerrors;

  /// Count of error corrected packets.
  ///
  /// MAVLink type: uint16_t
  ///
  /// fixed
  final uint16_t fixed;

  /// Local signal strength.
  ///
  /// MAVLink type: uint8_t
  ///
  /// rssi
  final uint8_t rssi;

  /// Remote signal strength.
  ///
  /// MAVLink type: uint8_t
  ///
  /// remrssi
  final uint8_t remrssi;

  /// How full the tx buffer is.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// txbuf
  final uint8_t txbuf;

  /// Background noise level.
  ///
  /// MAVLink type: uint8_t
  ///
  /// noise
  final uint8_t noise;

  /// Remote background noise level.
  ///
  /// MAVLink type: uint8_t
  ///
  /// remnoise
  final uint8_t remnoise;

  Radio({
    required this.rxerrors,
    required this.fixed,
    required this.rssi,
    required this.remrssi,
    required this.txbuf,
    required this.noise,
    required this.remnoise,
  });

  Radio copyWith({
    uint16_t? rxerrors,
    uint16_t? fixed,
    uint8_t? rssi,
    uint8_t? remrssi,
    uint8_t? txbuf,
    uint8_t? noise,
    uint8_t? remnoise,
  }) {
    return Radio(
      rxerrors: rxerrors ?? this.rxerrors,
      fixed: fixed ?? this.fixed,
      rssi: rssi ?? this.rssi,
      remrssi: remrssi ?? this.remrssi,
      txbuf: txbuf ?? this.txbuf,
      noise: noise ?? this.noise,
      remnoise: remnoise ?? this.remnoise,
    );
  }

  factory Radio.parse(ByteData data_) {
    if (data_.lengthInBytes < Radio.mavlinkEncodedLength) {
      var len = Radio.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var rxerrors = data_.getUint16(0, Endian.little);
    var fixed = data_.getUint16(2, Endian.little);
    var rssi = data_.getUint8(4);
    var remrssi = data_.getUint8(5);
    var txbuf = data_.getUint8(6);
    var noise = data_.getUint8(7);
    var remnoise = data_.getUint8(8);

    return Radio(
        rxerrors: rxerrors,
        fixed: fixed,
        rssi: rssi,
        remrssi: remrssi,
        txbuf: txbuf,
        noise: noise,
        remnoise: remnoise);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, rxerrors, Endian.little);
    data_.setUint16(2, fixed, Endian.little);
    data_.setUint8(4, rssi);
    data_.setUint8(5, remrssi);
    data_.setUint8(6, txbuf);
    data_.setUint8(7, noise);
    data_.setUint8(8, remnoise);
    return data_;
  }
}

/// Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled.
///
/// LIMITS_STATUS
class LimitsStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 167;

  static const int _mavlinkCrcExtra = 144;

  static const int mavlinkEncodedLength = 22;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Time (since boot) of last breach.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// last_trigger
  final uint32_t lastTrigger;

  /// Time (since boot) of last recovery action.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// last_action
  final uint32_t lastAction;

  /// Time (since boot) of last successful recovery.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// last_recovery
  final uint32_t lastRecovery;

  /// Time (since boot) of last all-clear.
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// last_clear
  final uint32_t lastClear;

  /// Number of fence breaches.
  ///
  /// MAVLink type: uint16_t
  ///
  /// breach_count
  final uint16_t breachCount;

  /// State of AP_Limits.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [LimitsState]
  ///
  /// limits_state
  final LimitsState limitsState;

  /// AP_Limit_Module bitfield of enabled modules.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [LimitModule]
  ///
  /// mods_enabled
  final LimitModule modsEnabled;

  /// AP_Limit_Module bitfield of required modules.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [LimitModule]
  ///
  /// mods_required
  final LimitModule modsRequired;

  /// AP_Limit_Module bitfield of triggered modules.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [LimitModule]
  ///
  /// mods_triggered
  final LimitModule modsTriggered;

  LimitsStatus({
    required this.lastTrigger,
    required this.lastAction,
    required this.lastRecovery,
    required this.lastClear,
    required this.breachCount,
    required this.limitsState,
    required this.modsEnabled,
    required this.modsRequired,
    required this.modsTriggered,
  });

  LimitsStatus copyWith({
    uint32_t? lastTrigger,
    uint32_t? lastAction,
    uint32_t? lastRecovery,
    uint32_t? lastClear,
    uint16_t? breachCount,
    LimitsState? limitsState,
    LimitModule? modsEnabled,
    LimitModule? modsRequired,
    LimitModule? modsTriggered,
  }) {
    return LimitsStatus(
      lastTrigger: lastTrigger ?? this.lastTrigger,
      lastAction: lastAction ?? this.lastAction,
      lastRecovery: lastRecovery ?? this.lastRecovery,
      lastClear: lastClear ?? this.lastClear,
      breachCount: breachCount ?? this.breachCount,
      limitsState: limitsState ?? this.limitsState,
      modsEnabled: modsEnabled ?? this.modsEnabled,
      modsRequired: modsRequired ?? this.modsRequired,
      modsTriggered: modsTriggered ?? this.modsTriggered,
    );
  }

  factory LimitsStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < LimitsStatus.mavlinkEncodedLength) {
      var len = LimitsStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var lastTrigger = data_.getUint32(0, Endian.little);
    var lastAction = data_.getUint32(4, Endian.little);
    var lastRecovery = data_.getUint32(8, Endian.little);
    var lastClear = data_.getUint32(12, Endian.little);
    var breachCount = data_.getUint16(16, Endian.little);
    var limitsState = data_.getUint8(18);
    var modsEnabled = data_.getUint8(19);
    var modsRequired = data_.getUint8(20);
    var modsTriggered = data_.getUint8(21);

    return LimitsStatus(
        lastTrigger: lastTrigger,
        lastAction: lastAction,
        lastRecovery: lastRecovery,
        lastClear: lastClear,
        breachCount: breachCount,
        limitsState: limitsState,
        modsEnabled: modsEnabled,
        modsRequired: modsRequired,
        modsTriggered: modsTriggered);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, lastTrigger, Endian.little);
    data_.setUint32(4, lastAction, Endian.little);
    data_.setUint32(8, lastRecovery, Endian.little);
    data_.setUint32(12, lastClear, Endian.little);
    data_.setUint16(16, breachCount, Endian.little);
    data_.setUint8(18, limitsState);
    data_.setUint8(19, modsEnabled);
    data_.setUint8(20, modsRequired);
    data_.setUint8(21, modsTriggered);
    return data_;
  }
}

/// Wind estimation.
///
/// WIND
class Wind implements MavlinkMessage {
  static const int _mavlinkMessageId = 168;

  static const int _mavlinkCrcExtra = 1;

  static const int mavlinkEncodedLength = 12;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Wind direction (that wind is coming from).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// direction
  final float direction;

  /// Wind speed in ground plane.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// speed
  final float speed;

  /// Vertical wind speed.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// speed_z
  final float speedZ;

  Wind({
    required this.direction,
    required this.speed,
    required this.speedZ,
  });

  Wind copyWith({
    float? direction,
    float? speed,
    float? speedZ,
  }) {
    return Wind(
      direction: direction ?? this.direction,
      speed: speed ?? this.speed,
      speedZ: speedZ ?? this.speedZ,
    );
  }

  factory Wind.parse(ByteData data_) {
    if (data_.lengthInBytes < Wind.mavlinkEncodedLength) {
      var len = Wind.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var direction = data_.getFloat32(0, Endian.little);
    var speed = data_.getFloat32(4, Endian.little);
    var speedZ = data_.getFloat32(8, Endian.little);

    return Wind(direction: direction, speed: speed, speedZ: speedZ);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, direction, Endian.little);
    data_.setFloat32(4, speed, Endian.little);
    data_.setFloat32(8, speedZ, Endian.little);
    return data_;
  }
}

/// Data packet, size 16.
///
/// DATA16
class Data16 implements MavlinkMessage {
  static const int _mavlinkMessageId = 169;

  static const int _mavlinkCrcExtra = 234;

  static const int mavlinkEncodedLength = 18;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Data type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// type
  final uint8_t type;

  /// Data length.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// len
  final uint8_t len;

  /// Raw data.
  ///
  /// MAVLink type: uint8_t[16]
  ///
  /// data
  final List<int8_t> data;

  Data16({
    required this.type,
    required this.len,
    required this.data,
  });

  Data16 copyWith({
    uint8_t? type,
    uint8_t? len,
    List<int8_t>? data,
  }) {
    return Data16(
      type: type ?? this.type,
      len: len ?? this.len,
      data: data ?? this.data,
    );
  }

  factory Data16.parse(ByteData data_) {
    if (data_.lengthInBytes < Data16.mavlinkEncodedLength) {
      var len = Data16.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var type = data_.getUint8(0);
    var len = data_.getUint8(1);
    var data = MavlinkMessage.asUint8List(data_, 2, 16);

    return Data16(type: type, len: len, data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, type);
    data_.setUint8(1, len);
    MavlinkMessage.setUint8List(data_, 2, data);
    return data_;
  }
}

/// Data packet, size 32.
///
/// DATA32
class Data32 implements MavlinkMessage {
  static const int _mavlinkMessageId = 170;

  static const int _mavlinkCrcExtra = 73;

  static const int mavlinkEncodedLength = 34;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Data type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// type
  final uint8_t type;

  /// Data length.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// len
  final uint8_t len;

  /// Raw data.
  ///
  /// MAVLink type: uint8_t[32]
  ///
  /// data
  final List<int8_t> data;

  Data32({
    required this.type,
    required this.len,
    required this.data,
  });

  Data32 copyWith({
    uint8_t? type,
    uint8_t? len,
    List<int8_t>? data,
  }) {
    return Data32(
      type: type ?? this.type,
      len: len ?? this.len,
      data: data ?? this.data,
    );
  }

  factory Data32.parse(ByteData data_) {
    if (data_.lengthInBytes < Data32.mavlinkEncodedLength) {
      var len = Data32.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var type = data_.getUint8(0);
    var len = data_.getUint8(1);
    var data = MavlinkMessage.asUint8List(data_, 2, 32);

    return Data32(type: type, len: len, data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, type);
    data_.setUint8(1, len);
    MavlinkMessage.setUint8List(data_, 2, data);
    return data_;
  }
}

/// Data packet, size 64.
///
/// DATA64
class Data64 implements MavlinkMessage {
  static const int _mavlinkMessageId = 171;

  static const int _mavlinkCrcExtra = 181;

  static const int mavlinkEncodedLength = 66;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Data type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// type
  final uint8_t type;

  /// Data length.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// len
  final uint8_t len;

  /// Raw data.
  ///
  /// MAVLink type: uint8_t[64]
  ///
  /// data
  final List<int8_t> data;

  Data64({
    required this.type,
    required this.len,
    required this.data,
  });

  Data64 copyWith({
    uint8_t? type,
    uint8_t? len,
    List<int8_t>? data,
  }) {
    return Data64(
      type: type ?? this.type,
      len: len ?? this.len,
      data: data ?? this.data,
    );
  }

  factory Data64.parse(ByteData data_) {
    if (data_.lengthInBytes < Data64.mavlinkEncodedLength) {
      var len = Data64.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var type = data_.getUint8(0);
    var len = data_.getUint8(1);
    var data = MavlinkMessage.asUint8List(data_, 2, 64);

    return Data64(type: type, len: len, data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, type);
    data_.setUint8(1, len);
    MavlinkMessage.setUint8List(data_, 2, data);
    return data_;
  }
}

/// Data packet, size 96.
///
/// DATA96
class Data96 implements MavlinkMessage {
  static const int _mavlinkMessageId = 172;

  static const int _mavlinkCrcExtra = 22;

  static const int mavlinkEncodedLength = 98;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Data type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// type
  final uint8_t type;

  /// Data length.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: bytes
  ///
  /// len
  final uint8_t len;

  /// Raw data.
  ///
  /// MAVLink type: uint8_t[96]
  ///
  /// data
  final List<int8_t> data;

  Data96({
    required this.type,
    required this.len,
    required this.data,
  });

  Data96 copyWith({
    uint8_t? type,
    uint8_t? len,
    List<int8_t>? data,
  }) {
    return Data96(
      type: type ?? this.type,
      len: len ?? this.len,
      data: data ?? this.data,
    );
  }

  factory Data96.parse(ByteData data_) {
    if (data_.lengthInBytes < Data96.mavlinkEncodedLength) {
      var len = Data96.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var type = data_.getUint8(0);
    var len = data_.getUint8(1);
    var data = MavlinkMessage.asUint8List(data_, 2, 96);

    return Data96(type: type, len: len, data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, type);
    data_.setUint8(1, len);
    MavlinkMessage.setUint8List(data_, 2, data);
    return data_;
  }
}

/// Rangefinder reporting.
///
/// RANGEFINDER
class Rangefinder implements MavlinkMessage {
  static const int _mavlinkMessageId = 173;

  static const int _mavlinkCrcExtra = 83;

  static const int mavlinkEncodedLength = 8;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Distance.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// distance
  final float distance;

  /// Raw voltage if available, zero otherwise.
  ///
  /// MAVLink type: float
  ///
  /// units: V
  ///
  /// voltage
  final float voltage;

  Rangefinder({
    required this.distance,
    required this.voltage,
  });

  Rangefinder copyWith({
    float? distance,
    float? voltage,
  }) {
    return Rangefinder(
      distance: distance ?? this.distance,
      voltage: voltage ?? this.voltage,
    );
  }

  factory Rangefinder.parse(ByteData data_) {
    if (data_.lengthInBytes < Rangefinder.mavlinkEncodedLength) {
      var len = Rangefinder.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var distance = data_.getFloat32(0, Endian.little);
    var voltage = data_.getFloat32(4, Endian.little);

    return Rangefinder(distance: distance, voltage: voltage);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, distance, Endian.little);
    data_.setFloat32(4, voltage, Endian.little);
    return data_;
  }
}

/// Airspeed auto-calibration.
///
/// AIRSPEED_AUTOCAL
class AirspeedAutocal implements MavlinkMessage {
  static const int _mavlinkMessageId = 174;

  static const int _mavlinkCrcExtra = 167;

  static const int mavlinkEncodedLength = 48;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// GPS velocity north.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vx
  final float vx;

  /// GPS velocity east.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vy
  final float vy;

  /// GPS velocity down.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// vz
  final float vz;

  /// Differential pressure.
  ///
  /// MAVLink type: float
  ///
  /// units: Pa
  ///
  /// diff_pressure
  final float diffPressure;

  /// Estimated to true airspeed ratio.
  ///
  /// MAVLink type: float
  ///
  /// EAS2TAS
  final float eas2tas;

  /// Airspeed ratio.
  ///
  /// MAVLink type: float
  ///
  /// ratio
  final float ratio;

  /// EKF state x.
  ///
  /// MAVLink type: float
  ///
  /// state_x
  final float stateX;

  /// EKF state y.
  ///
  /// MAVLink type: float
  ///
  /// state_y
  final float stateY;

  /// EKF state z.
  ///
  /// MAVLink type: float
  ///
  /// state_z
  final float stateZ;

  /// EKF Pax.
  ///
  /// MAVLink type: float
  ///
  /// Pax
  final float pax;

  /// EKF Pby.
  ///
  /// MAVLink type: float
  ///
  /// Pby
  final float pby;

  /// EKF Pcz.
  ///
  /// MAVLink type: float
  ///
  /// Pcz
  final float pcz;

  AirspeedAutocal({
    required this.vx,
    required this.vy,
    required this.vz,
    required this.diffPressure,
    required this.eas2tas,
    required this.ratio,
    required this.stateX,
    required this.stateY,
    required this.stateZ,
    required this.pax,
    required this.pby,
    required this.pcz,
  });

  AirspeedAutocal copyWith({
    float? vx,
    float? vy,
    float? vz,
    float? diffPressure,
    float? eas2tas,
    float? ratio,
    float? stateX,
    float? stateY,
    float? stateZ,
    float? pax,
    float? pby,
    float? pcz,
  }) {
    return AirspeedAutocal(
      vx: vx ?? this.vx,
      vy: vy ?? this.vy,
      vz: vz ?? this.vz,
      diffPressure: diffPressure ?? this.diffPressure,
      eas2tas: eas2tas ?? this.eas2tas,
      ratio: ratio ?? this.ratio,
      stateX: stateX ?? this.stateX,
      stateY: stateY ?? this.stateY,
      stateZ: stateZ ?? this.stateZ,
      pax: pax ?? this.pax,
      pby: pby ?? this.pby,
      pcz: pcz ?? this.pcz,
    );
  }

  factory AirspeedAutocal.parse(ByteData data_) {
    if (data_.lengthInBytes < AirspeedAutocal.mavlinkEncodedLength) {
      var len = AirspeedAutocal.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var vx = data_.getFloat32(0, Endian.little);
    var vy = data_.getFloat32(4, Endian.little);
    var vz = data_.getFloat32(8, Endian.little);
    var diffPressure = data_.getFloat32(12, Endian.little);
    var eas2tas = data_.getFloat32(16, Endian.little);
    var ratio = data_.getFloat32(20, Endian.little);
    var stateX = data_.getFloat32(24, Endian.little);
    var stateY = data_.getFloat32(28, Endian.little);
    var stateZ = data_.getFloat32(32, Endian.little);
    var pax = data_.getFloat32(36, Endian.little);
    var pby = data_.getFloat32(40, Endian.little);
    var pcz = data_.getFloat32(44, Endian.little);

    return AirspeedAutocal(
        vx: vx,
        vy: vy,
        vz: vz,
        diffPressure: diffPressure,
        eas2tas: eas2tas,
        ratio: ratio,
        stateX: stateX,
        stateY: stateY,
        stateZ: stateZ,
        pax: pax,
        pby: pby,
        pcz: pcz);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, vx, Endian.little);
    data_.setFloat32(4, vy, Endian.little);
    data_.setFloat32(8, vz, Endian.little);
    data_.setFloat32(12, diffPressure, Endian.little);
    data_.setFloat32(16, eas2tas, Endian.little);
    data_.setFloat32(20, ratio, Endian.little);
    data_.setFloat32(24, stateX, Endian.little);
    data_.setFloat32(28, stateY, Endian.little);
    data_.setFloat32(32, stateZ, Endian.little);
    data_.setFloat32(36, pax, Endian.little);
    data_.setFloat32(40, pby, Endian.little);
    data_.setFloat32(44, pcz, Endian.little);
    return data_;
  }
}

/// A rally point. Used to set a point when from GCS -> MAV. Also used to return a point from MAV -> GCS.
///
/// RALLY_POINT
class RallyPoint implements MavlinkMessage {
  static const int _mavlinkMessageId = 175;

  static const int _mavlinkCrcExtra = 138;

  static const int mavlinkEncodedLength = 19;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Latitude of point.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude of point.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lng
  final int32_t lng;

  /// Transit / loiter altitude relative to home.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: m
  ///
  /// alt
  final int16_t alt;

  /// Break altitude relative to home.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: m
  ///
  /// break_alt
  final int16_t breakAlt;

  /// Heading to aim for when landing.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: cdeg
  ///
  /// land_dir
  final uint16_t landDir;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Point index (first point is 0).
  ///
  /// MAVLink type: uint8_t
  ///
  /// idx
  final uint8_t idx;

  /// Total number of points (for sanity checking).
  ///
  /// MAVLink type: uint8_t
  ///
  /// count
  final uint8_t count;

  /// Configuration flags.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [RallyFlags]
  ///
  /// flags
  final RallyFlags flags;

  RallyPoint({
    required this.lat,
    required this.lng,
    required this.alt,
    required this.breakAlt,
    required this.landDir,
    required this.targetSystem,
    required this.targetComponent,
    required this.idx,
    required this.count,
    required this.flags,
  });

  RallyPoint copyWith({
    int32_t? lat,
    int32_t? lng,
    int16_t? alt,
    int16_t? breakAlt,
    uint16_t? landDir,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? idx,
    uint8_t? count,
    RallyFlags? flags,
  }) {
    return RallyPoint(
      lat: lat ?? this.lat,
      lng: lng ?? this.lng,
      alt: alt ?? this.alt,
      breakAlt: breakAlt ?? this.breakAlt,
      landDir: landDir ?? this.landDir,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idx: idx ?? this.idx,
      count: count ?? this.count,
      flags: flags ?? this.flags,
    );
  }

  factory RallyPoint.parse(ByteData data_) {
    if (data_.lengthInBytes < RallyPoint.mavlinkEncodedLength) {
      var len = RallyPoint.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var lat = data_.getInt32(0, Endian.little);
    var lng = data_.getInt32(4, Endian.little);
    var alt = data_.getInt16(8, Endian.little);
    var breakAlt = data_.getInt16(10, Endian.little);
    var landDir = data_.getUint16(12, Endian.little);
    var targetSystem = data_.getUint8(14);
    var targetComponent = data_.getUint8(15);
    var idx = data_.getUint8(16);
    var count = data_.getUint8(17);
    var flags = data_.getUint8(18);

    return RallyPoint(
        lat: lat,
        lng: lng,
        alt: alt,
        breakAlt: breakAlt,
        landDir: landDir,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        idx: idx,
        count: count,
        flags: flags);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, lat, Endian.little);
    data_.setInt32(4, lng, Endian.little);
    data_.setInt16(8, alt, Endian.little);
    data_.setInt16(10, breakAlt, Endian.little);
    data_.setUint16(12, landDir, Endian.little);
    data_.setUint8(14, targetSystem);
    data_.setUint8(15, targetComponent);
    data_.setUint8(16, idx);
    data_.setUint8(17, count);
    data_.setUint8(18, flags);
    return data_;
  }
}

/// Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not respond if the request is invalid.
///
/// RALLY_FETCH_POINT
class RallyFetchPoint implements MavlinkMessage {
  static const int _mavlinkMessageId = 176;

  static const int _mavlinkCrcExtra = 234;

  static const int mavlinkEncodedLength = 3;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Point index (first point is 0).
  ///
  /// MAVLink type: uint8_t
  ///
  /// idx
  final uint8_t idx;

  RallyFetchPoint({
    required this.targetSystem,
    required this.targetComponent,
    required this.idx,
  });

  RallyFetchPoint copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? idx,
  }) {
    return RallyFetchPoint(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      idx: idx ?? this.idx,
    );
  }

  factory RallyFetchPoint.parse(ByteData data_) {
    if (data_.lengthInBytes < RallyFetchPoint.mavlinkEncodedLength) {
      var len = RallyFetchPoint.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var idx = data_.getUint8(2);

    return RallyFetchPoint(
        targetSystem: targetSystem, targetComponent: targetComponent, idx: idx);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, idx);
    return data_;
  }
}

/// Status of compassmot calibration.
///
/// COMPASSMOT_STATUS
class CompassmotStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 177;

  static const int _mavlinkCrcExtra = 240;

  static const int mavlinkEncodedLength = 20;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Current.
  ///
  /// MAVLink type: float
  ///
  /// units: A
  ///
  /// current
  final float current;

  /// Motor Compensation X.
  ///
  /// MAVLink type: float
  ///
  /// CompensationX
  final float compensationx;

  /// Motor Compensation Y.
  ///
  /// MAVLink type: float
  ///
  /// CompensationY
  final float compensationy;

  /// Motor Compensation Z.
  ///
  /// MAVLink type: float
  ///
  /// CompensationZ
  final float compensationz;

  /// Throttle.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: d%
  ///
  /// throttle
  final uint16_t throttle;

  /// Interference.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: %
  ///
  /// interference
  final uint16_t interference;

  CompassmotStatus({
    required this.current,
    required this.compensationx,
    required this.compensationy,
    required this.compensationz,
    required this.throttle,
    required this.interference,
  });

  CompassmotStatus copyWith({
    float? current,
    float? compensationx,
    float? compensationy,
    float? compensationz,
    uint16_t? throttle,
    uint16_t? interference,
  }) {
    return CompassmotStatus(
      current: current ?? this.current,
      compensationx: compensationx ?? this.compensationx,
      compensationy: compensationy ?? this.compensationy,
      compensationz: compensationz ?? this.compensationz,
      throttle: throttle ?? this.throttle,
      interference: interference ?? this.interference,
    );
  }

  factory CompassmotStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < CompassmotStatus.mavlinkEncodedLength) {
      var len = CompassmotStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var current = data_.getFloat32(0, Endian.little);
    var compensationx = data_.getFloat32(4, Endian.little);
    var compensationy = data_.getFloat32(8, Endian.little);
    var compensationz = data_.getFloat32(12, Endian.little);
    var throttle = data_.getUint16(16, Endian.little);
    var interference = data_.getUint16(18, Endian.little);

    return CompassmotStatus(
        current: current,
        compensationx: compensationx,
        compensationy: compensationy,
        compensationz: compensationz,
        throttle: throttle,
        interference: interference);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, current, Endian.little);
    data_.setFloat32(4, compensationx, Endian.little);
    data_.setFloat32(8, compensationy, Endian.little);
    data_.setFloat32(12, compensationz, Endian.little);
    data_.setUint16(16, throttle, Endian.little);
    data_.setUint16(18, interference, Endian.little);
    return data_;
  }
}

/// Status of secondary AHRS filter if available.
///
/// AHRS2
class Ahrs2 implements MavlinkMessage {
  static const int _mavlinkMessageId = 178;

  static const int _mavlinkCrcExtra = 47;

  static const int mavlinkEncodedLength = 24;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Roll angle.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch angle.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Altitude (MSL).
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude
  final float altitude;

  /// Latitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lng
  final int32_t lng;

  Ahrs2({
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.altitude,
    required this.lat,
    required this.lng,
  });

  Ahrs2 copyWith({
    float? roll,
    float? pitch,
    float? yaw,
    float? altitude,
    int32_t? lat,
    int32_t? lng,
  }) {
    return Ahrs2(
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      altitude: altitude ?? this.altitude,
      lat: lat ?? this.lat,
      lng: lng ?? this.lng,
    );
  }

  factory Ahrs2.parse(ByteData data_) {
    if (data_.lengthInBytes < Ahrs2.mavlinkEncodedLength) {
      var len = Ahrs2.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var roll = data_.getFloat32(0, Endian.little);
    var pitch = data_.getFloat32(4, Endian.little);
    var yaw = data_.getFloat32(8, Endian.little);
    var altitude = data_.getFloat32(12, Endian.little);
    var lat = data_.getInt32(16, Endian.little);
    var lng = data_.getInt32(20, Endian.little);

    return Ahrs2(
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        altitude: altitude,
        lat: lat,
        lng: lng);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, roll, Endian.little);
    data_.setFloat32(4, pitch, Endian.little);
    data_.setFloat32(8, yaw, Endian.little);
    data_.setFloat32(12, altitude, Endian.little);
    data_.setInt32(16, lat, Endian.little);
    data_.setInt32(20, lng, Endian.little);
    return data_;
  }
}

/// Camera Event.
///
/// CAMERA_STATUS
class CameraStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 179;

  static const int _mavlinkCrcExtra = 189;

  static const int mavlinkEncodedLength = 29;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Image timestamp (since UNIX epoch, according to camera clock).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Parameter 1 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum).
  ///
  /// MAVLink type: float
  ///
  /// p1
  final float p1;

  /// Parameter 2 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum).
  ///
  /// MAVLink type: float
  ///
  /// p2
  final float p2;

  /// Parameter 3 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum).
  ///
  /// MAVLink type: float
  ///
  /// p3
  final float p3;

  /// Parameter 4 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum).
  ///
  /// MAVLink type: float
  ///
  /// p4
  final float p4;

  /// Image index.
  ///
  /// MAVLink type: uint16_t
  ///
  /// img_idx
  final uint16_t imgIdx;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Camera ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// cam_idx
  final uint8_t camIdx;

  /// Event type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CameraStatusTypes]
  ///
  /// event_id
  final CameraStatusTypes eventId;

  CameraStatus({
    required this.timeUsec,
    required this.p1,
    required this.p2,
    required this.p3,
    required this.p4,
    required this.imgIdx,
    required this.targetSystem,
    required this.camIdx,
    required this.eventId,
  });

  CameraStatus copyWith({
    uint64_t? timeUsec,
    float? p1,
    float? p2,
    float? p3,
    float? p4,
    uint16_t? imgIdx,
    uint8_t? targetSystem,
    uint8_t? camIdx,
    CameraStatusTypes? eventId,
  }) {
    return CameraStatus(
      timeUsec: timeUsec ?? this.timeUsec,
      p1: p1 ?? this.p1,
      p2: p2 ?? this.p2,
      p3: p3 ?? this.p3,
      p4: p4 ?? this.p4,
      imgIdx: imgIdx ?? this.imgIdx,
      targetSystem: targetSystem ?? this.targetSystem,
      camIdx: camIdx ?? this.camIdx,
      eventId: eventId ?? this.eventId,
    );
  }

  factory CameraStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraStatus.mavlinkEncodedLength) {
      var len = CameraStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var p1 = data_.getFloat32(8, Endian.little);
    var p2 = data_.getFloat32(12, Endian.little);
    var p3 = data_.getFloat32(16, Endian.little);
    var p4 = data_.getFloat32(20, Endian.little);
    var imgIdx = data_.getUint16(24, Endian.little);
    var targetSystem = data_.getUint8(26);
    var camIdx = data_.getUint8(27);
    var eventId = data_.getUint8(28);

    return CameraStatus(
        timeUsec: timeUsec,
        p1: p1,
        p2: p2,
        p3: p3,
        p4: p4,
        imgIdx: imgIdx,
        targetSystem: targetSystem,
        camIdx: camIdx,
        eventId: eventId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, p1, Endian.little);
    data_.setFloat32(12, p2, Endian.little);
    data_.setFloat32(16, p3, Endian.little);
    data_.setFloat32(20, p4, Endian.little);
    data_.setUint16(24, imgIdx, Endian.little);
    data_.setUint8(26, targetSystem);
    data_.setUint8(27, camIdx);
    data_.setUint8(28, eventId);
    return data_;
  }
}

/// Camera Capture Feedback.
///
/// CAMERA_FEEDBACK
class CameraFeedback implements MavlinkMessage {
  static const int _mavlinkMessageId = 180;

  static const int _mavlinkCrcExtra = 52;

  static const int mavlinkEncodedLength = 47;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Image timestamp (since UNIX epoch), as passed in by CAMERA_STATUS message (or autopilot if no CCB).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Latitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lng
  final int32_t lng;

  /// Altitude (MSL).
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt_msl
  final float altMsl;

  /// Altitude (Relative to HOME location).
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt_rel
  final float altRel;

  /// Camera Roll angle (earth frame, +-180).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// roll
  final float roll;

  /// Camera Pitch angle (earth frame, +-180).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// pitch
  final float pitch;

  /// Camera Yaw (earth frame, 0-360, true).
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// yaw
  final float yaw;

  /// Focal Length.
  ///
  /// MAVLink type: float
  ///
  /// units: mm
  ///
  /// foc_len
  final float focLen;

  /// Image index.
  ///
  /// MAVLink type: uint16_t
  ///
  /// img_idx
  final uint16_t imgIdx;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Camera ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// cam_idx
  final uint8_t camIdx;

  /// Feedback flags.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [CameraFeedbackFlags]
  ///
  /// flags
  final CameraFeedbackFlags flags;

  /// Completed image captures.
  ///
  /// MAVLink type: uint16_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// completed_captures
  final uint16_t completedCaptures;

  CameraFeedback({
    required this.timeUsec,
    required this.lat,
    required this.lng,
    required this.altMsl,
    required this.altRel,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.focLen,
    required this.imgIdx,
    required this.targetSystem,
    required this.camIdx,
    required this.flags,
    required this.completedCaptures,
  });

  CameraFeedback copyWith({
    uint64_t? timeUsec,
    int32_t? lat,
    int32_t? lng,
    float? altMsl,
    float? altRel,
    float? roll,
    float? pitch,
    float? yaw,
    float? focLen,
    uint16_t? imgIdx,
    uint8_t? targetSystem,
    uint8_t? camIdx,
    CameraFeedbackFlags? flags,
    uint16_t? completedCaptures,
  }) {
    return CameraFeedback(
      timeUsec: timeUsec ?? this.timeUsec,
      lat: lat ?? this.lat,
      lng: lng ?? this.lng,
      altMsl: altMsl ?? this.altMsl,
      altRel: altRel ?? this.altRel,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      focLen: focLen ?? this.focLen,
      imgIdx: imgIdx ?? this.imgIdx,
      targetSystem: targetSystem ?? this.targetSystem,
      camIdx: camIdx ?? this.camIdx,
      flags: flags ?? this.flags,
      completedCaptures: completedCaptures ?? this.completedCaptures,
    );
  }

  factory CameraFeedback.parse(ByteData data_) {
    if (data_.lengthInBytes < CameraFeedback.mavlinkEncodedLength) {
      var len = CameraFeedback.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var lat = data_.getInt32(8, Endian.little);
    var lng = data_.getInt32(12, Endian.little);
    var altMsl = data_.getFloat32(16, Endian.little);
    var altRel = data_.getFloat32(20, Endian.little);
    var roll = data_.getFloat32(24, Endian.little);
    var pitch = data_.getFloat32(28, Endian.little);
    var yaw = data_.getFloat32(32, Endian.little);
    var focLen = data_.getFloat32(36, Endian.little);
    var imgIdx = data_.getUint16(40, Endian.little);
    var targetSystem = data_.getUint8(42);
    var camIdx = data_.getUint8(43);
    var flags = data_.getUint8(44);
    var completedCaptures = data_.getUint16(45, Endian.little);

    return CameraFeedback(
        timeUsec: timeUsec,
        lat: lat,
        lng: lng,
        altMsl: altMsl,
        altRel: altRel,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        focLen: focLen,
        imgIdx: imgIdx,
        targetSystem: targetSystem,
        camIdx: camIdx,
        flags: flags,
        completedCaptures: completedCaptures);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setInt32(8, lat, Endian.little);
    data_.setInt32(12, lng, Endian.little);
    data_.setFloat32(16, altMsl, Endian.little);
    data_.setFloat32(20, altRel, Endian.little);
    data_.setFloat32(24, roll, Endian.little);
    data_.setFloat32(28, pitch, Endian.little);
    data_.setFloat32(32, yaw, Endian.little);
    data_.setFloat32(36, focLen, Endian.little);
    data_.setUint16(40, imgIdx, Endian.little);
    data_.setUint8(42, targetSystem);
    data_.setUint8(43, camIdx);
    data_.setUint8(44, flags);
    data_.setUint16(45, completedCaptures, Endian.little);
    return data_;
  }
}

/// 2nd Battery status
///
/// BATTERY2
class Battery2 implements MavlinkMessage {
  static const int _mavlinkMessageId = 181;

  static const int _mavlinkCrcExtra = 174;

  static const int mavlinkEncodedLength = 4;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Voltage.
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mV
  ///
  /// voltage
  final uint16_t voltage;

  /// Battery current, -1: autopilot does not measure the current.
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cA
  ///
  /// current_battery
  final int16_t currentBattery;

  Battery2({
    required this.voltage,
    required this.currentBattery,
  });

  Battery2 copyWith({
    uint16_t? voltage,
    int16_t? currentBattery,
  }) {
    return Battery2(
      voltage: voltage ?? this.voltage,
      currentBattery: currentBattery ?? this.currentBattery,
    );
  }

  factory Battery2.parse(ByteData data_) {
    if (data_.lengthInBytes < Battery2.mavlinkEncodedLength) {
      var len = Battery2.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var voltage = data_.getUint16(0, Endian.little);
    var currentBattery = data_.getInt16(2, Endian.little);

    return Battery2(voltage: voltage, currentBattery: currentBattery);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, voltage, Endian.little);
    data_.setInt16(2, currentBattery, Endian.little);
    return data_;
  }
}

/// Status of third AHRS filter if available. This is for ANU research group (Ali and Sean).
///
/// AHRS3
class Ahrs3 implements MavlinkMessage {
  static const int _mavlinkMessageId = 182;

  static const int _mavlinkCrcExtra = 229;

  static const int mavlinkEncodedLength = 40;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Roll angle.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch angle.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Altitude (MSL).
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude
  final float altitude;

  /// Latitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lng
  final int32_t lng;

  /// Test variable1.
  ///
  /// MAVLink type: float
  ///
  /// v1
  final float v1;

  /// Test variable2.
  ///
  /// MAVLink type: float
  ///
  /// v2
  final float v2;

  /// Test variable3.
  ///
  /// MAVLink type: float
  ///
  /// v3
  final float v3;

  /// Test variable4.
  ///
  /// MAVLink type: float
  ///
  /// v4
  final float v4;

  Ahrs3({
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.altitude,
    required this.lat,
    required this.lng,
    required this.v1,
    required this.v2,
    required this.v3,
    required this.v4,
  });

  Ahrs3 copyWith({
    float? roll,
    float? pitch,
    float? yaw,
    float? altitude,
    int32_t? lat,
    int32_t? lng,
    float? v1,
    float? v2,
    float? v3,
    float? v4,
  }) {
    return Ahrs3(
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      altitude: altitude ?? this.altitude,
      lat: lat ?? this.lat,
      lng: lng ?? this.lng,
      v1: v1 ?? this.v1,
      v2: v2 ?? this.v2,
      v3: v3 ?? this.v3,
      v4: v4 ?? this.v4,
    );
  }

  factory Ahrs3.parse(ByteData data_) {
    if (data_.lengthInBytes < Ahrs3.mavlinkEncodedLength) {
      var len = Ahrs3.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var roll = data_.getFloat32(0, Endian.little);
    var pitch = data_.getFloat32(4, Endian.little);
    var yaw = data_.getFloat32(8, Endian.little);
    var altitude = data_.getFloat32(12, Endian.little);
    var lat = data_.getInt32(16, Endian.little);
    var lng = data_.getInt32(20, Endian.little);
    var v1 = data_.getFloat32(24, Endian.little);
    var v2 = data_.getFloat32(28, Endian.little);
    var v3 = data_.getFloat32(32, Endian.little);
    var v4 = data_.getFloat32(36, Endian.little);

    return Ahrs3(
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        altitude: altitude,
        lat: lat,
        lng: lng,
        v1: v1,
        v2: v2,
        v3: v3,
        v4: v4);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, roll, Endian.little);
    data_.setFloat32(4, pitch, Endian.little);
    data_.setFloat32(8, yaw, Endian.little);
    data_.setFloat32(12, altitude, Endian.little);
    data_.setInt32(16, lat, Endian.little);
    data_.setInt32(20, lng, Endian.little);
    data_.setFloat32(24, v1, Endian.little);
    data_.setFloat32(28, v2, Endian.little);
    data_.setFloat32(32, v3, Endian.little);
    data_.setFloat32(36, v4, Endian.little);
    return data_;
  }
}

/// Request the autopilot version from the system/component.
///
/// AUTOPILOT_VERSION_REQUEST
class AutopilotVersionRequest implements MavlinkMessage {
  static const int _mavlinkMessageId = 183;

  static const int _mavlinkCrcExtra = 85;

  static const int mavlinkEncodedLength = 2;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  AutopilotVersionRequest({
    required this.targetSystem,
    required this.targetComponent,
  });

  AutopilotVersionRequest copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return AutopilotVersionRequest(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory AutopilotVersionRequest.parse(ByteData data_) {
    if (data_.lengthInBytes < AutopilotVersionRequest.mavlinkEncodedLength) {
      var len =
          AutopilotVersionRequest.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);

    return AutopilotVersionRequest(
        targetSystem: targetSystem, targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    return data_;
  }
}

/// Send a block of log data to remote location.
///
/// REMOTE_LOG_DATA_BLOCK
class RemoteLogDataBlock implements MavlinkMessage {
  static const int _mavlinkMessageId = 184;

  static const int _mavlinkCrcExtra = 159;

  static const int mavlinkEncodedLength = 206;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Log data block sequence number.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavRemoteLogDataBlockCommands]
  ///
  /// seqno
  final MavRemoteLogDataBlockCommands seqno;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Log data block.
  ///
  /// MAVLink type: uint8_t[200]
  ///
  /// data
  final List<int8_t> data;

  RemoteLogDataBlock({
    required this.seqno,
    required this.targetSystem,
    required this.targetComponent,
    required this.data,
  });

  RemoteLogDataBlock copyWith({
    MavRemoteLogDataBlockCommands? seqno,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    List<int8_t>? data,
  }) {
    return RemoteLogDataBlock(
      seqno: seqno ?? this.seqno,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      data: data ?? this.data,
    );
  }

  factory RemoteLogDataBlock.parse(ByteData data_) {
    if (data_.lengthInBytes < RemoteLogDataBlock.mavlinkEncodedLength) {
      var len = RemoteLogDataBlock.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var seqno = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var data = MavlinkMessage.asUint8List(data_, 6, 200);

    return RemoteLogDataBlock(
        seqno: seqno,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        data: data);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, seqno, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    MavlinkMessage.setUint8List(data_, 6, data);
    return data_;
  }
}

/// Send Status of each log block that autopilot board might have sent.
///
/// REMOTE_LOG_BLOCK_STATUS
class RemoteLogBlockStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 185;

  static const int _mavlinkCrcExtra = 186;

  static const int mavlinkEncodedLength = 7;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Log data block sequence number.
  ///
  /// MAVLink type: uint32_t
  ///
  /// seqno
  final uint32_t seqno;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Log data block status.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavRemoteLogDataBlockStatuses]
  ///
  /// status
  final MavRemoteLogDataBlockStatuses status;

  RemoteLogBlockStatus({
    required this.seqno,
    required this.targetSystem,
    required this.targetComponent,
    required this.status,
  });

  RemoteLogBlockStatus copyWith({
    uint32_t? seqno,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    MavRemoteLogDataBlockStatuses? status,
  }) {
    return RemoteLogBlockStatus(
      seqno: seqno ?? this.seqno,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      status: status ?? this.status,
    );
  }

  factory RemoteLogBlockStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < RemoteLogBlockStatus.mavlinkEncodedLength) {
      var len = RemoteLogBlockStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var seqno = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var status = data_.getUint8(6);

    return RemoteLogBlockStatus(
        seqno: seqno,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        status: status);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, seqno, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, status);
    return data_;
  }
}

/// Control vehicle LEDs.
///
/// LED_CONTROL
class LedControl implements MavlinkMessage {
  static const int _mavlinkMessageId = 186;

  static const int _mavlinkCrcExtra = 72;

  static const int mavlinkEncodedLength = 29;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Instance (LED instance to control or 255 for all LEDs).
  ///
  /// MAVLink type: uint8_t
  ///
  /// instance
  final uint8_t instance;

  /// Pattern (see LED_PATTERN_ENUM).
  ///
  /// MAVLink type: uint8_t
  ///
  /// pattern
  final uint8_t pattern;

  /// Custom Byte Length.
  ///
  /// MAVLink type: uint8_t
  ///
  /// custom_len
  final uint8_t customLen;

  /// Custom Bytes.
  ///
  /// MAVLink type: uint8_t[24]
  ///
  /// custom_bytes
  final List<int8_t> customBytes;

  LedControl({
    required this.targetSystem,
    required this.targetComponent,
    required this.instance,
    required this.pattern,
    required this.customLen,
    required this.customBytes,
  });

  LedControl copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? instance,
    uint8_t? pattern,
    uint8_t? customLen,
    List<int8_t>? customBytes,
  }) {
    return LedControl(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      instance: instance ?? this.instance,
      pattern: pattern ?? this.pattern,
      customLen: customLen ?? this.customLen,
      customBytes: customBytes ?? this.customBytes,
    );
  }

  factory LedControl.parse(ByteData data_) {
    if (data_.lengthInBytes < LedControl.mavlinkEncodedLength) {
      var len = LedControl.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var instance = data_.getUint8(2);
    var pattern = data_.getUint8(3);
    var customLen = data_.getUint8(4);
    var customBytes = MavlinkMessage.asUint8List(data_, 5, 24);

    return LedControl(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        instance: instance,
        pattern: pattern,
        customLen: customLen,
        customBytes: customBytes);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, instance);
    data_.setUint8(3, pattern);
    data_.setUint8(4, customLen);
    MavlinkMessage.setUint8List(data_, 5, customBytes);
    return data_;
  }
}

/// Reports progress of compass calibration.
///
/// MAG_CAL_PROGRESS
class MagCalProgress implements MavlinkMessage {
  static const int _mavlinkMessageId = 191;

  static const int _mavlinkCrcExtra = 92;

  static const int mavlinkEncodedLength = 27;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Body frame direction vector for display.
  ///
  /// MAVLink type: float
  ///
  /// direction_x
  final float directionX;

  /// Body frame direction vector for display.
  ///
  /// MAVLink type: float
  ///
  /// direction_y
  final float directionY;

  /// Body frame direction vector for display.
  ///
  /// MAVLink type: float
  ///
  /// direction_z
  final float directionZ;

  /// Compass being calibrated.
  ///
  /// MAVLink type: uint8_t
  ///
  /// compass_id
  final uint8_t compassId;

  /// Bitmask of compasses being calibrated.
  ///
  /// MAVLink type: uint8_t
  ///
  /// cal_mask
  final uint8_t calMask;

  /// Calibration Status.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MagCalStatus]
  ///
  /// cal_status
  final MagCalStatus calStatus;

  /// Attempt number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// attempt
  final uint8_t attempt;

  /// Completion percentage.
  ///
  /// MAVLink type: uint8_t
  ///
  /// units: %
  ///
  /// completion_pct
  final uint8_t completionPct;

  /// Bitmask of sphere sections (see http://en.wikipedia.org/wiki/Geodesic_grid).
  ///
  /// MAVLink type: uint8_t[10]
  ///
  /// completion_mask
  final List<int8_t> completionMask;

  MagCalProgress({
    required this.directionX,
    required this.directionY,
    required this.directionZ,
    required this.compassId,
    required this.calMask,
    required this.calStatus,
    required this.attempt,
    required this.completionPct,
    required this.completionMask,
  });

  MagCalProgress copyWith({
    float? directionX,
    float? directionY,
    float? directionZ,
    uint8_t? compassId,
    uint8_t? calMask,
    MagCalStatus? calStatus,
    uint8_t? attempt,
    uint8_t? completionPct,
    List<int8_t>? completionMask,
  }) {
    return MagCalProgress(
      directionX: directionX ?? this.directionX,
      directionY: directionY ?? this.directionY,
      directionZ: directionZ ?? this.directionZ,
      compassId: compassId ?? this.compassId,
      calMask: calMask ?? this.calMask,
      calStatus: calStatus ?? this.calStatus,
      attempt: attempt ?? this.attempt,
      completionPct: completionPct ?? this.completionPct,
      completionMask: completionMask ?? this.completionMask,
    );
  }

  factory MagCalProgress.parse(ByteData data_) {
    if (data_.lengthInBytes < MagCalProgress.mavlinkEncodedLength) {
      var len = MagCalProgress.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var directionX = data_.getFloat32(0, Endian.little);
    var directionY = data_.getFloat32(4, Endian.little);
    var directionZ = data_.getFloat32(8, Endian.little);
    var compassId = data_.getUint8(12);
    var calMask = data_.getUint8(13);
    var calStatus = data_.getUint8(14);
    var attempt = data_.getUint8(15);
    var completionPct = data_.getUint8(16);
    var completionMask = MavlinkMessage.asUint8List(data_, 17, 10);

    return MagCalProgress(
        directionX: directionX,
        directionY: directionY,
        directionZ: directionZ,
        compassId: compassId,
        calMask: calMask,
        calStatus: calStatus,
        attempt: attempt,
        completionPct: completionPct,
        completionMask: completionMask);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, directionX, Endian.little);
    data_.setFloat32(4, directionY, Endian.little);
    data_.setFloat32(8, directionZ, Endian.little);
    data_.setUint8(12, compassId);
    data_.setUint8(13, calMask);
    data_.setUint8(14, calStatus);
    data_.setUint8(15, attempt);
    data_.setUint8(16, completionPct);
    MavlinkMessage.setUint8List(data_, 17, completionMask);
    return data_;
  }
}

/// EKF Status message including flags and variances.
///
/// EKF_STATUS_REPORT
class EkfStatusReport implements MavlinkMessage {
  static const int _mavlinkMessageId = 193;

  static const int _mavlinkCrcExtra = 71;

  static const int mavlinkEncodedLength = 26;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Velocity variance.
  ///
  /// MAVLink type: float
  ///
  /// velocity_variance
  final float velocityVariance;

  /// Horizontal Position variance.
  ///
  /// MAVLink type: float
  ///
  /// pos_horiz_variance
  final float posHorizVariance;

  /// Vertical Position variance.
  ///
  /// MAVLink type: float
  ///
  /// pos_vert_variance
  final float posVertVariance;

  /// Compass variance.
  ///
  /// MAVLink type: float
  ///
  /// compass_variance
  final float compassVariance;

  /// Terrain Altitude variance.
  ///
  /// MAVLink type: float
  ///
  /// terrain_alt_variance
  final float terrainAltVariance;

  /// Flags.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [EkfStatusFlags]
  ///
  /// flags
  final EkfStatusFlags flags;

  /// Airspeed variance.
  ///
  /// MAVLink type: float
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// airspeed_variance
  final float airspeedVariance;

  EkfStatusReport({
    required this.velocityVariance,
    required this.posHorizVariance,
    required this.posVertVariance,
    required this.compassVariance,
    required this.terrainAltVariance,
    required this.flags,
    required this.airspeedVariance,
  });

  EkfStatusReport copyWith({
    float? velocityVariance,
    float? posHorizVariance,
    float? posVertVariance,
    float? compassVariance,
    float? terrainAltVariance,
    EkfStatusFlags? flags,
    float? airspeedVariance,
  }) {
    return EkfStatusReport(
      velocityVariance: velocityVariance ?? this.velocityVariance,
      posHorizVariance: posHorizVariance ?? this.posHorizVariance,
      posVertVariance: posVertVariance ?? this.posVertVariance,
      compassVariance: compassVariance ?? this.compassVariance,
      terrainAltVariance: terrainAltVariance ?? this.terrainAltVariance,
      flags: flags ?? this.flags,
      airspeedVariance: airspeedVariance ?? this.airspeedVariance,
    );
  }

  factory EkfStatusReport.parse(ByteData data_) {
    if (data_.lengthInBytes < EkfStatusReport.mavlinkEncodedLength) {
      var len = EkfStatusReport.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var velocityVariance = data_.getFloat32(0, Endian.little);
    var posHorizVariance = data_.getFloat32(4, Endian.little);
    var posVertVariance = data_.getFloat32(8, Endian.little);
    var compassVariance = data_.getFloat32(12, Endian.little);
    var terrainAltVariance = data_.getFloat32(16, Endian.little);
    var flags = data_.getUint16(20, Endian.little);
    var airspeedVariance = data_.getFloat32(22, Endian.little);

    return EkfStatusReport(
        velocityVariance: velocityVariance,
        posHorizVariance: posHorizVariance,
        posVertVariance: posVertVariance,
        compassVariance: compassVariance,
        terrainAltVariance: terrainAltVariance,
        flags: flags,
        airspeedVariance: airspeedVariance);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, velocityVariance, Endian.little);
    data_.setFloat32(4, posHorizVariance, Endian.little);
    data_.setFloat32(8, posVertVariance, Endian.little);
    data_.setFloat32(12, compassVariance, Endian.little);
    data_.setFloat32(16, terrainAltVariance, Endian.little);
    data_.setUint16(20, flags, Endian.little);
    data_.setFloat32(22, airspeedVariance, Endian.little);
    return data_;
  }
}

/// PID tuning information.
///
/// PID_TUNING
class PidTuning implements MavlinkMessage {
  static const int _mavlinkMessageId = 194;

  static const int _mavlinkCrcExtra = 98;

  static const int mavlinkEncodedLength = 33;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Desired rate.
  ///
  /// MAVLink type: float
  ///
  /// desired
  final float desired;

  /// Achieved rate.
  ///
  /// MAVLink type: float
  ///
  /// achieved
  final float achieved;

  /// FF component.
  ///
  /// MAVLink type: float
  ///
  /// FF
  final float ff;

  /// P component.
  ///
  /// MAVLink type: float
  ///
  /// P
  final float p;

  /// I component.
  ///
  /// MAVLink type: float
  ///
  /// I
  final float i;

  /// D component.
  ///
  /// MAVLink type: float
  ///
  /// D
  final float d;

  /// Axis.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [PidTuningAxis]
  ///
  /// axis
  final PidTuningAxis axis;

  /// Slew rate.
  ///
  /// MAVLink type: float
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// SRate
  final float srate;

  /// P/D oscillation modifier.
  ///
  /// MAVLink type: float
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// PDmod
  final float pdmod;

  PidTuning({
    required this.desired,
    required this.achieved,
    required this.ff,
    required this.p,
    required this.i,
    required this.d,
    required this.axis,
    required this.srate,
    required this.pdmod,
  });

  PidTuning copyWith({
    float? desired,
    float? achieved,
    float? ff,
    float? p,
    float? i,
    float? d,
    PidTuningAxis? axis,
    float? srate,
    float? pdmod,
  }) {
    return PidTuning(
      desired: desired ?? this.desired,
      achieved: achieved ?? this.achieved,
      ff: ff ?? this.ff,
      p: p ?? this.p,
      i: i ?? this.i,
      d: d ?? this.d,
      axis: axis ?? this.axis,
      srate: srate ?? this.srate,
      pdmod: pdmod ?? this.pdmod,
    );
  }

  factory PidTuning.parse(ByteData data_) {
    if (data_.lengthInBytes < PidTuning.mavlinkEncodedLength) {
      var len = PidTuning.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var desired = data_.getFloat32(0, Endian.little);
    var achieved = data_.getFloat32(4, Endian.little);
    var ff = data_.getFloat32(8, Endian.little);
    var p = data_.getFloat32(12, Endian.little);
    var i = data_.getFloat32(16, Endian.little);
    var d = data_.getFloat32(20, Endian.little);
    var axis = data_.getUint8(24);
    var srate = data_.getFloat32(25, Endian.little);
    var pdmod = data_.getFloat32(29, Endian.little);

    return PidTuning(
        desired: desired,
        achieved: achieved,
        ff: ff,
        p: p,
        i: i,
        d: d,
        axis: axis,
        srate: srate,
        pdmod: pdmod);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, desired, Endian.little);
    data_.setFloat32(4, achieved, Endian.little);
    data_.setFloat32(8, ff, Endian.little);
    data_.setFloat32(12, p, Endian.little);
    data_.setFloat32(16, i, Endian.little);
    data_.setFloat32(20, d, Endian.little);
    data_.setUint8(24, axis);
    data_.setFloat32(25, srate, Endian.little);
    data_.setFloat32(29, pdmod, Endian.little);
    return data_;
  }
}

/// Deepstall path planning.
///
/// DEEPSTALL
class Deepstall implements MavlinkMessage {
  static const int _mavlinkMessageId = 195;

  static const int _mavlinkCrcExtra = 120;

  static const int mavlinkEncodedLength = 37;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Landing latitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// landing_lat
  final int32_t landingLat;

  /// Landing longitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// landing_lon
  final int32_t landingLon;

  /// Final heading start point, latitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// path_lat
  final int32_t pathLat;

  /// Final heading start point, longitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// path_lon
  final int32_t pathLon;

  /// Arc entry point, latitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// arc_entry_lat
  final int32_t arcEntryLat;

  /// Arc entry point, longitude.
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// arc_entry_lon
  final int32_t arcEntryLon;

  /// Altitude.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// altitude
  final float altitude;

  /// Distance the aircraft expects to travel during the deepstall.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// expected_travel_distance
  final float expectedTravelDistance;

  /// Deepstall cross track error (only valid when in DEEPSTALL_STAGE_LAND).
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// cross_track_error
  final float crossTrackError;

  /// Deepstall stage.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [DeepstallStage]
  ///
  /// stage
  final DeepstallStage stage;

  Deepstall({
    required this.landingLat,
    required this.landingLon,
    required this.pathLat,
    required this.pathLon,
    required this.arcEntryLat,
    required this.arcEntryLon,
    required this.altitude,
    required this.expectedTravelDistance,
    required this.crossTrackError,
    required this.stage,
  });

  Deepstall copyWith({
    int32_t? landingLat,
    int32_t? landingLon,
    int32_t? pathLat,
    int32_t? pathLon,
    int32_t? arcEntryLat,
    int32_t? arcEntryLon,
    float? altitude,
    float? expectedTravelDistance,
    float? crossTrackError,
    DeepstallStage? stage,
  }) {
    return Deepstall(
      landingLat: landingLat ?? this.landingLat,
      landingLon: landingLon ?? this.landingLon,
      pathLat: pathLat ?? this.pathLat,
      pathLon: pathLon ?? this.pathLon,
      arcEntryLat: arcEntryLat ?? this.arcEntryLat,
      arcEntryLon: arcEntryLon ?? this.arcEntryLon,
      altitude: altitude ?? this.altitude,
      expectedTravelDistance:
          expectedTravelDistance ?? this.expectedTravelDistance,
      crossTrackError: crossTrackError ?? this.crossTrackError,
      stage: stage ?? this.stage,
    );
  }

  factory Deepstall.parse(ByteData data_) {
    if (data_.lengthInBytes < Deepstall.mavlinkEncodedLength) {
      var len = Deepstall.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var landingLat = data_.getInt32(0, Endian.little);
    var landingLon = data_.getInt32(4, Endian.little);
    var pathLat = data_.getInt32(8, Endian.little);
    var pathLon = data_.getInt32(12, Endian.little);
    var arcEntryLat = data_.getInt32(16, Endian.little);
    var arcEntryLon = data_.getInt32(20, Endian.little);
    var altitude = data_.getFloat32(24, Endian.little);
    var expectedTravelDistance = data_.getFloat32(28, Endian.little);
    var crossTrackError = data_.getFloat32(32, Endian.little);
    var stage = data_.getUint8(36);

    return Deepstall(
        landingLat: landingLat,
        landingLon: landingLon,
        pathLat: pathLat,
        pathLon: pathLon,
        arcEntryLat: arcEntryLat,
        arcEntryLon: arcEntryLon,
        altitude: altitude,
        expectedTravelDistance: expectedTravelDistance,
        crossTrackError: crossTrackError,
        stage: stage);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt32(0, landingLat, Endian.little);
    data_.setInt32(4, landingLon, Endian.little);
    data_.setInt32(8, pathLat, Endian.little);
    data_.setInt32(12, pathLon, Endian.little);
    data_.setInt32(16, arcEntryLat, Endian.little);
    data_.setInt32(20, arcEntryLon, Endian.little);
    data_.setFloat32(24, altitude, Endian.little);
    data_.setFloat32(28, expectedTravelDistance, Endian.little);
    data_.setFloat32(32, crossTrackError, Endian.little);
    data_.setUint8(36, stage);
    return data_;
  }
}

/// 3 axis gimbal measurements.
///
/// GIMBAL_REPORT
class GimbalReport implements MavlinkMessage {
  static const int _mavlinkMessageId = 200;

  static const int _mavlinkCrcExtra = 134;

  static const int mavlinkEncodedLength = 42;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Time since last update.
  ///
  /// MAVLink type: float
  ///
  /// units: s
  ///
  /// delta_time
  final float deltaTime;

  /// Delta angle X.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// delta_angle_x
  final float deltaAngleX;

  /// Delta angle Y.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// delta_angle_y
  final float deltaAngleY;

  /// Delta angle X.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// delta_angle_z
  final float deltaAngleZ;

  /// Delta velocity X.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// delta_velocity_x
  final float deltaVelocityX;

  /// Delta velocity Y.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// delta_velocity_y
  final float deltaVelocityY;

  /// Delta velocity Z.
  ///
  /// MAVLink type: float
  ///
  /// units: m/s
  ///
  /// delta_velocity_z
  final float deltaVelocityZ;

  /// Joint ROLL.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// joint_roll
  final float jointRoll;

  /// Joint EL.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// joint_el
  final float jointEl;

  /// Joint AZ.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// joint_az
  final float jointAz;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  GimbalReport({
    required this.deltaTime,
    required this.deltaAngleX,
    required this.deltaAngleY,
    required this.deltaAngleZ,
    required this.deltaVelocityX,
    required this.deltaVelocityY,
    required this.deltaVelocityZ,
    required this.jointRoll,
    required this.jointEl,
    required this.jointAz,
    required this.targetSystem,
    required this.targetComponent,
  });

  GimbalReport copyWith({
    float? deltaTime,
    float? deltaAngleX,
    float? deltaAngleY,
    float? deltaAngleZ,
    float? deltaVelocityX,
    float? deltaVelocityY,
    float? deltaVelocityZ,
    float? jointRoll,
    float? jointEl,
    float? jointAz,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return GimbalReport(
      deltaTime: deltaTime ?? this.deltaTime,
      deltaAngleX: deltaAngleX ?? this.deltaAngleX,
      deltaAngleY: deltaAngleY ?? this.deltaAngleY,
      deltaAngleZ: deltaAngleZ ?? this.deltaAngleZ,
      deltaVelocityX: deltaVelocityX ?? this.deltaVelocityX,
      deltaVelocityY: deltaVelocityY ?? this.deltaVelocityY,
      deltaVelocityZ: deltaVelocityZ ?? this.deltaVelocityZ,
      jointRoll: jointRoll ?? this.jointRoll,
      jointEl: jointEl ?? this.jointEl,
      jointAz: jointAz ?? this.jointAz,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory GimbalReport.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalReport.mavlinkEncodedLength) {
      var len = GimbalReport.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var deltaTime = data_.getFloat32(0, Endian.little);
    var deltaAngleX = data_.getFloat32(4, Endian.little);
    var deltaAngleY = data_.getFloat32(8, Endian.little);
    var deltaAngleZ = data_.getFloat32(12, Endian.little);
    var deltaVelocityX = data_.getFloat32(16, Endian.little);
    var deltaVelocityY = data_.getFloat32(20, Endian.little);
    var deltaVelocityZ = data_.getFloat32(24, Endian.little);
    var jointRoll = data_.getFloat32(28, Endian.little);
    var jointEl = data_.getFloat32(32, Endian.little);
    var jointAz = data_.getFloat32(36, Endian.little);
    var targetSystem = data_.getUint8(40);
    var targetComponent = data_.getUint8(41);

    return GimbalReport(
        deltaTime: deltaTime,
        deltaAngleX: deltaAngleX,
        deltaAngleY: deltaAngleY,
        deltaAngleZ: deltaAngleZ,
        deltaVelocityX: deltaVelocityX,
        deltaVelocityY: deltaVelocityY,
        deltaVelocityZ: deltaVelocityZ,
        jointRoll: jointRoll,
        jointEl: jointEl,
        jointAz: jointAz,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, deltaTime, Endian.little);
    data_.setFloat32(4, deltaAngleX, Endian.little);
    data_.setFloat32(8, deltaAngleY, Endian.little);
    data_.setFloat32(12, deltaAngleZ, Endian.little);
    data_.setFloat32(16, deltaVelocityX, Endian.little);
    data_.setFloat32(20, deltaVelocityY, Endian.little);
    data_.setFloat32(24, deltaVelocityZ, Endian.little);
    data_.setFloat32(28, jointRoll, Endian.little);
    data_.setFloat32(32, jointEl, Endian.little);
    data_.setFloat32(36, jointAz, Endian.little);
    data_.setUint8(40, targetSystem);
    data_.setUint8(41, targetComponent);
    return data_;
  }
}

/// Control message for rate gimbal.
///
/// GIMBAL_CONTROL
class GimbalControl implements MavlinkMessage {
  static const int _mavlinkMessageId = 201;

  static const int _mavlinkCrcExtra = 205;

  static const int mavlinkEncodedLength = 14;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Demanded angular rate X.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// demanded_rate_x
  final float demandedRateX;

  /// Demanded angular rate Y.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// demanded_rate_y
  final float demandedRateY;

  /// Demanded angular rate Z.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// demanded_rate_z
  final float demandedRateZ;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  GimbalControl({
    required this.demandedRateX,
    required this.demandedRateY,
    required this.demandedRateZ,
    required this.targetSystem,
    required this.targetComponent,
  });

  GimbalControl copyWith({
    float? demandedRateX,
    float? demandedRateY,
    float? demandedRateZ,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return GimbalControl(
      demandedRateX: demandedRateX ?? this.demandedRateX,
      demandedRateY: demandedRateY ?? this.demandedRateY,
      demandedRateZ: demandedRateZ ?? this.demandedRateZ,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory GimbalControl.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalControl.mavlinkEncodedLength) {
      var len = GimbalControl.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var demandedRateX = data_.getFloat32(0, Endian.little);
    var demandedRateY = data_.getFloat32(4, Endian.little);
    var demandedRateZ = data_.getFloat32(8, Endian.little);
    var targetSystem = data_.getUint8(12);
    var targetComponent = data_.getUint8(13);

    return GimbalControl(
        demandedRateX: demandedRateX,
        demandedRateY: demandedRateY,
        demandedRateZ: demandedRateZ,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, demandedRateX, Endian.little);
    data_.setFloat32(4, demandedRateY, Endian.little);
    data_.setFloat32(8, demandedRateZ, Endian.little);
    data_.setUint8(12, targetSystem);
    data_.setUint8(13, targetComponent);
    return data_;
  }
}

/// 100 Hz gimbal torque command telemetry.
///
/// GIMBAL_TORQUE_CMD_REPORT
class GimbalTorqueCmdReport implements MavlinkMessage {
  static const int _mavlinkMessageId = 214;

  static const int _mavlinkCrcExtra = 69;

  static const int mavlinkEncodedLength = 8;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Roll Torque Command.
  ///
  /// MAVLink type: int16_t
  ///
  /// rl_torque_cmd
  final int16_t rlTorqueCmd;

  /// Elevation Torque Command.
  ///
  /// MAVLink type: int16_t
  ///
  /// el_torque_cmd
  final int16_t elTorqueCmd;

  /// Azimuth Torque Command.
  ///
  /// MAVLink type: int16_t
  ///
  /// az_torque_cmd
  final int16_t azTorqueCmd;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  GimbalTorqueCmdReport({
    required this.rlTorqueCmd,
    required this.elTorqueCmd,
    required this.azTorqueCmd,
    required this.targetSystem,
    required this.targetComponent,
  });

  GimbalTorqueCmdReport copyWith({
    int16_t? rlTorqueCmd,
    int16_t? elTorqueCmd,
    int16_t? azTorqueCmd,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
  }) {
    return GimbalTorqueCmdReport(
      rlTorqueCmd: rlTorqueCmd ?? this.rlTorqueCmd,
      elTorqueCmd: elTorqueCmd ?? this.elTorqueCmd,
      azTorqueCmd: azTorqueCmd ?? this.azTorqueCmd,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
    );
  }

  factory GimbalTorqueCmdReport.parse(ByteData data_) {
    if (data_.lengthInBytes < GimbalTorqueCmdReport.mavlinkEncodedLength) {
      var len =
          GimbalTorqueCmdReport.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var rlTorqueCmd = data_.getInt16(0, Endian.little);
    var elTorqueCmd = data_.getInt16(2, Endian.little);
    var azTorqueCmd = data_.getInt16(4, Endian.little);
    var targetSystem = data_.getUint8(6);
    var targetComponent = data_.getUint8(7);

    return GimbalTorqueCmdReport(
        rlTorqueCmd: rlTorqueCmd,
        elTorqueCmd: elTorqueCmd,
        azTorqueCmd: azTorqueCmd,
        targetSystem: targetSystem,
        targetComponent: targetComponent);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt16(0, rlTorqueCmd, Endian.little);
    data_.setInt16(2, elTorqueCmd, Endian.little);
    data_.setInt16(4, azTorqueCmd, Endian.little);
    data_.setUint8(6, targetSystem);
    data_.setUint8(7, targetComponent);
    return data_;
  }
}

/// Heartbeat from a HeroBus attached GoPro.
///
/// GOPRO_HEARTBEAT
class GoproHeartbeat implements MavlinkMessage {
  static const int _mavlinkMessageId = 215;

  static const int _mavlinkCrcExtra = 101;

  static const int mavlinkEncodedLength = 3;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Status.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GoproHeartbeatStatus]
  ///
  /// status
  final GoproHeartbeatStatus status;

  /// Current capture mode.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GoproCaptureMode]
  ///
  /// capture_mode
  final GoproCaptureMode captureMode;

  /// Additional status bits.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GoproHeartbeatFlags]
  ///
  /// flags
  final GoproHeartbeatFlags flags;

  GoproHeartbeat({
    required this.status,
    required this.captureMode,
    required this.flags,
  });

  GoproHeartbeat copyWith({
    GoproHeartbeatStatus? status,
    GoproCaptureMode? captureMode,
    GoproHeartbeatFlags? flags,
  }) {
    return GoproHeartbeat(
      status: status ?? this.status,
      captureMode: captureMode ?? this.captureMode,
      flags: flags ?? this.flags,
    );
  }

  factory GoproHeartbeat.parse(ByteData data_) {
    if (data_.lengthInBytes < GoproHeartbeat.mavlinkEncodedLength) {
      var len = GoproHeartbeat.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var status = data_.getUint8(0);
    var captureMode = data_.getUint8(1);
    var flags = data_.getUint8(2);

    return GoproHeartbeat(
        status: status, captureMode: captureMode, flags: flags);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, status);
    data_.setUint8(1, captureMode);
    data_.setUint8(2, flags);
    return data_;
  }
}

/// Request a GOPRO_COMMAND response from the GoPro.
///
/// GOPRO_GET_REQUEST
class GoproGetRequest implements MavlinkMessage {
  static const int _mavlinkMessageId = 216;

  static const int _mavlinkCrcExtra = 50;

  static const int mavlinkEncodedLength = 3;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Command ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GoproCommand]
  ///
  /// cmd_id
  final GoproCommand cmdId;

  GoproGetRequest({
    required this.targetSystem,
    required this.targetComponent,
    required this.cmdId,
  });

  GoproGetRequest copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    GoproCommand? cmdId,
  }) {
    return GoproGetRequest(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      cmdId: cmdId ?? this.cmdId,
    );
  }

  factory GoproGetRequest.parse(ByteData data_) {
    if (data_.lengthInBytes < GoproGetRequest.mavlinkEncodedLength) {
      var len = GoproGetRequest.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var cmdId = data_.getUint8(2);

    return GoproGetRequest(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        cmdId: cmdId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, cmdId);
    return data_;
  }
}

/// Response from a GOPRO_COMMAND get request.
///
/// GOPRO_GET_RESPONSE
class GoproGetResponse implements MavlinkMessage {
  static const int _mavlinkMessageId = 217;

  static const int _mavlinkCrcExtra = 202;

  static const int mavlinkEncodedLength = 6;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Command ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GoproCommand]
  ///
  /// cmd_id
  final GoproCommand cmdId;

  /// Status.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GoproRequestStatus]
  ///
  /// status
  final GoproRequestStatus status;

  /// Value.
  ///
  /// MAVLink type: uint8_t[4]
  ///
  /// value
  final List<int8_t> value;

  GoproGetResponse({
    required this.cmdId,
    required this.status,
    required this.value,
  });

  GoproGetResponse copyWith({
    GoproCommand? cmdId,
    GoproRequestStatus? status,
    List<int8_t>? value,
  }) {
    return GoproGetResponse(
      cmdId: cmdId ?? this.cmdId,
      status: status ?? this.status,
      value: value ?? this.value,
    );
  }

  factory GoproGetResponse.parse(ByteData data_) {
    if (data_.lengthInBytes < GoproGetResponse.mavlinkEncodedLength) {
      var len = GoproGetResponse.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var cmdId = data_.getUint8(0);
    var status = data_.getUint8(1);
    var value = MavlinkMessage.asUint8List(data_, 2, 4);

    return GoproGetResponse(cmdId: cmdId, status: status, value: value);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, cmdId);
    data_.setUint8(1, status);
    MavlinkMessage.setUint8List(data_, 2, value);
    return data_;
  }
}

/// Request to set a GOPRO_COMMAND with a desired.
///
/// GOPRO_SET_REQUEST
class GoproSetRequest implements MavlinkMessage {
  static const int _mavlinkMessageId = 218;

  static const int _mavlinkCrcExtra = 17;

  static const int mavlinkEncodedLength = 7;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Command ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GoproCommand]
  ///
  /// cmd_id
  final GoproCommand cmdId;

  /// Value.
  ///
  /// MAVLink type: uint8_t[4]
  ///
  /// value
  final List<int8_t> value;

  GoproSetRequest({
    required this.targetSystem,
    required this.targetComponent,
    required this.cmdId,
    required this.value,
  });

  GoproSetRequest copyWith({
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    GoproCommand? cmdId,
    List<int8_t>? value,
  }) {
    return GoproSetRequest(
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      cmdId: cmdId ?? this.cmdId,
      value: value ?? this.value,
    );
  }

  factory GoproSetRequest.parse(ByteData data_) {
    if (data_.lengthInBytes < GoproSetRequest.mavlinkEncodedLength) {
      var len = GoproSetRequest.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var targetSystem = data_.getUint8(0);
    var targetComponent = data_.getUint8(1);
    var cmdId = data_.getUint8(2);
    var value = MavlinkMessage.asUint8List(data_, 3, 4);

    return GoproSetRequest(
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        cmdId: cmdId,
        value: value);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, targetSystem);
    data_.setUint8(1, targetComponent);
    data_.setUint8(2, cmdId);
    MavlinkMessage.setUint8List(data_, 3, value);
    return data_;
  }
}

/// Response from a GOPRO_COMMAND set request.
///
/// GOPRO_SET_RESPONSE
class GoproSetResponse implements MavlinkMessage {
  static const int _mavlinkMessageId = 219;

  static const int _mavlinkCrcExtra = 162;

  static const int mavlinkEncodedLength = 2;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Command ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GoproCommand]
  ///
  /// cmd_id
  final GoproCommand cmdId;

  /// Status.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [GoproRequestStatus]
  ///
  /// status
  final GoproRequestStatus status;

  GoproSetResponse({
    required this.cmdId,
    required this.status,
  });

  GoproSetResponse copyWith({
    GoproCommand? cmdId,
    GoproRequestStatus? status,
  }) {
    return GoproSetResponse(
      cmdId: cmdId ?? this.cmdId,
      status: status ?? this.status,
    );
  }

  factory GoproSetResponse.parse(ByteData data_) {
    if (data_.lengthInBytes < GoproSetResponse.mavlinkEncodedLength) {
      var len = GoproSetResponse.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var cmdId = data_.getUint8(0);
    var status = data_.getUint8(1);

    return GoproSetResponse(cmdId: cmdId, status: status);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint8(0, cmdId);
    data_.setUint8(1, status);
    return data_;
  }
}

/// RPM sensor output.
///
/// RPM
class Rpm implements MavlinkMessage {
  static const int _mavlinkMessageId = 226;

  static const int _mavlinkCrcExtra = 207;

  static const int mavlinkEncodedLength = 8;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// RPM Sensor1.
  ///
  /// MAVLink type: float
  ///
  /// rpm1
  final float rpm1;

  /// RPM Sensor2.
  ///
  /// MAVLink type: float
  ///
  /// rpm2
  final float rpm2;

  Rpm({
    required this.rpm1,
    required this.rpm2,
  });

  Rpm copyWith({
    float? rpm1,
    float? rpm2,
  }) {
    return Rpm(
      rpm1: rpm1 ?? this.rpm1,
      rpm2: rpm2 ?? this.rpm2,
    );
  }

  factory Rpm.parse(ByteData data_) {
    if (data_.lengthInBytes < Rpm.mavlinkEncodedLength) {
      var len = Rpm.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var rpm1 = data_.getFloat32(0, Endian.little);
    var rpm2 = data_.getFloat32(4, Endian.little);

    return Rpm(rpm1: rpm1, rpm2: rpm2);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, rpm1, Endian.little);
    data_.setFloat32(4, rpm2, Endian.little);
    return data_;
  }
}

/// Read registers for a device.
///
/// DEVICE_OP_READ
class DeviceOpRead implements MavlinkMessage {
  static const int _mavlinkMessageId = 11000;

  static const int _mavlinkCrcExtra = 134;

  static const int mavlinkEncodedLength = 52;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Request ID - copied to reply.
  ///
  /// MAVLink type: uint32_t
  ///
  /// request_id
  final uint32_t requestId;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// The bus type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [DeviceOpBustype]
  ///
  /// bustype
  final DeviceOpBustype bustype;

  /// Bus number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// bus
  final uint8_t bus;

  /// Bus address.
  ///
  /// MAVLink type: uint8_t
  ///
  /// address
  final uint8_t address;

  /// Name of device on bus (for SPI).
  ///
  /// MAVLink type: char[40]
  ///
  /// busname
  final List<char> busname;

  /// First register to read.
  ///
  /// MAVLink type: uint8_t
  ///
  /// regstart
  final uint8_t regstart;

  /// Count of registers to read.
  ///
  /// MAVLink type: uint8_t
  ///
  /// count
  final uint8_t count;

  /// Bank number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// bank
  final uint8_t bank;

  DeviceOpRead({
    required this.requestId,
    required this.targetSystem,
    required this.targetComponent,
    required this.bustype,
    required this.bus,
    required this.address,
    required this.busname,
    required this.regstart,
    required this.count,
    required this.bank,
  });

  DeviceOpRead copyWith({
    uint32_t? requestId,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    DeviceOpBustype? bustype,
    uint8_t? bus,
    uint8_t? address,
    List<char>? busname,
    uint8_t? regstart,
    uint8_t? count,
    uint8_t? bank,
  }) {
    return DeviceOpRead(
      requestId: requestId ?? this.requestId,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      bustype: bustype ?? this.bustype,
      bus: bus ?? this.bus,
      address: address ?? this.address,
      busname: busname ?? this.busname,
      regstart: regstart ?? this.regstart,
      count: count ?? this.count,
      bank: bank ?? this.bank,
    );
  }

  factory DeviceOpRead.parse(ByteData data_) {
    if (data_.lengthInBytes < DeviceOpRead.mavlinkEncodedLength) {
      var len = DeviceOpRead.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var requestId = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var bustype = data_.getUint8(6);
    var bus = data_.getUint8(7);
    var address = data_.getUint8(8);
    var busname = MavlinkMessage.asInt8List(data_, 9, 40);
    var regstart = data_.getUint8(49);
    var count = data_.getUint8(50);
    var bank = data_.getUint8(51);

    return DeviceOpRead(
        requestId: requestId,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        bustype: bustype,
        bus: bus,
        address: address,
        busname: busname,
        regstart: regstart,
        count: count,
        bank: bank);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, requestId, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, bustype);
    data_.setUint8(7, bus);
    data_.setUint8(8, address);
    MavlinkMessage.setInt8List(data_, 9, busname);
    data_.setUint8(49, regstart);
    data_.setUint8(50, count);
    data_.setUint8(51, bank);
    return data_;
  }
}

/// Read registers reply.
///
/// DEVICE_OP_READ_REPLY
class DeviceOpReadReply implements MavlinkMessage {
  static const int _mavlinkMessageId = 11001;

  static const int _mavlinkCrcExtra = 15;

  static const int mavlinkEncodedLength = 136;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Request ID - copied from request.
  ///
  /// MAVLink type: uint32_t
  ///
  /// request_id
  final uint32_t requestId;

  /// 0 for success, anything else is failure code.
  ///
  /// MAVLink type: uint8_t
  ///
  /// result
  final uint8_t result;

  /// Starting register.
  ///
  /// MAVLink type: uint8_t
  ///
  /// regstart
  final uint8_t regstart;

  /// Count of bytes read.
  ///
  /// MAVLink type: uint8_t
  ///
  /// count
  final uint8_t count;

  /// Reply data.
  ///
  /// MAVLink type: uint8_t[128]
  ///
  /// data
  final List<int8_t> data;

  /// Bank number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// bank
  final uint8_t bank;

  DeviceOpReadReply({
    required this.requestId,
    required this.result,
    required this.regstart,
    required this.count,
    required this.data,
    required this.bank,
  });

  DeviceOpReadReply copyWith({
    uint32_t? requestId,
    uint8_t? result,
    uint8_t? regstart,
    uint8_t? count,
    List<int8_t>? data,
    uint8_t? bank,
  }) {
    return DeviceOpReadReply(
      requestId: requestId ?? this.requestId,
      result: result ?? this.result,
      regstart: regstart ?? this.regstart,
      count: count ?? this.count,
      data: data ?? this.data,
      bank: bank ?? this.bank,
    );
  }

  factory DeviceOpReadReply.parse(ByteData data_) {
    if (data_.lengthInBytes < DeviceOpReadReply.mavlinkEncodedLength) {
      var len = DeviceOpReadReply.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var requestId = data_.getUint32(0, Endian.little);
    var result = data_.getUint8(4);
    var regstart = data_.getUint8(5);
    var count = data_.getUint8(6);
    var data = MavlinkMessage.asUint8List(data_, 7, 128);
    var bank = data_.getUint8(135);

    return DeviceOpReadReply(
        requestId: requestId,
        result: result,
        regstart: regstart,
        count: count,
        data: data,
        bank: bank);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, requestId, Endian.little);
    data_.setUint8(4, result);
    data_.setUint8(5, regstart);
    data_.setUint8(6, count);
    MavlinkMessage.setUint8List(data_, 7, data);
    data_.setUint8(135, bank);
    return data_;
  }
}

/// Write registers for a device.
///
/// DEVICE_OP_WRITE
class DeviceOpWrite implements MavlinkMessage {
  static const int _mavlinkMessageId = 11002;

  static const int _mavlinkCrcExtra = 234;

  static const int mavlinkEncodedLength = 180;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Request ID - copied to reply.
  ///
  /// MAVLink type: uint32_t
  ///
  /// request_id
  final uint32_t requestId;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// The bus type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [DeviceOpBustype]
  ///
  /// bustype
  final DeviceOpBustype bustype;

  /// Bus number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// bus
  final uint8_t bus;

  /// Bus address.
  ///
  /// MAVLink type: uint8_t
  ///
  /// address
  final uint8_t address;

  /// Name of device on bus (for SPI).
  ///
  /// MAVLink type: char[40]
  ///
  /// busname
  final List<char> busname;

  /// First register to write.
  ///
  /// MAVLink type: uint8_t
  ///
  /// regstart
  final uint8_t regstart;

  /// Count of registers to write.
  ///
  /// MAVLink type: uint8_t
  ///
  /// count
  final uint8_t count;

  /// Write data.
  ///
  /// MAVLink type: uint8_t[128]
  ///
  /// data
  final List<int8_t> data;

  /// Bank number.
  ///
  /// MAVLink type: uint8_t
  ///
  /// Extensions field for MAVLink 2.
  ///
  /// bank
  final uint8_t bank;

  DeviceOpWrite({
    required this.requestId,
    required this.targetSystem,
    required this.targetComponent,
    required this.bustype,
    required this.bus,
    required this.address,
    required this.busname,
    required this.regstart,
    required this.count,
    required this.data,
    required this.bank,
  });

  DeviceOpWrite copyWith({
    uint32_t? requestId,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    DeviceOpBustype? bustype,
    uint8_t? bus,
    uint8_t? address,
    List<char>? busname,
    uint8_t? regstart,
    uint8_t? count,
    List<int8_t>? data,
    uint8_t? bank,
  }) {
    return DeviceOpWrite(
      requestId: requestId ?? this.requestId,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      bustype: bustype ?? this.bustype,
      bus: bus ?? this.bus,
      address: address ?? this.address,
      busname: busname ?? this.busname,
      regstart: regstart ?? this.regstart,
      count: count ?? this.count,
      data: data ?? this.data,
      bank: bank ?? this.bank,
    );
  }

  factory DeviceOpWrite.parse(ByteData data_) {
    if (data_.lengthInBytes < DeviceOpWrite.mavlinkEncodedLength) {
      var len = DeviceOpWrite.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var requestId = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var bustype = data_.getUint8(6);
    var bus = data_.getUint8(7);
    var address = data_.getUint8(8);
    var busname = MavlinkMessage.asInt8List(data_, 9, 40);
    var regstart = data_.getUint8(49);
    var count = data_.getUint8(50);
    var data = MavlinkMessage.asUint8List(data_, 51, 128);
    var bank = data_.getUint8(179);

    return DeviceOpWrite(
        requestId: requestId,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        bustype: bustype,
        bus: bus,
        address: address,
        busname: busname,
        regstart: regstart,
        count: count,
        data: data,
        bank: bank);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, requestId, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, bustype);
    data_.setUint8(7, bus);
    data_.setUint8(8, address);
    MavlinkMessage.setInt8List(data_, 9, busname);
    data_.setUint8(49, regstart);
    data_.setUint8(50, count);
    MavlinkMessage.setUint8List(data_, 51, data);
    data_.setUint8(179, bank);
    return data_;
  }
}

/// Write registers reply.
///
/// DEVICE_OP_WRITE_REPLY
class DeviceOpWriteReply implements MavlinkMessage {
  static const int _mavlinkMessageId = 11003;

  static const int _mavlinkCrcExtra = 64;

  static const int mavlinkEncodedLength = 5;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Request ID - copied from request.
  ///
  /// MAVLink type: uint32_t
  ///
  /// request_id
  final uint32_t requestId;

  /// 0 for success, anything else is failure code.
  ///
  /// MAVLink type: uint8_t
  ///
  /// result
  final uint8_t result;

  DeviceOpWriteReply({
    required this.requestId,
    required this.result,
  });

  DeviceOpWriteReply copyWith({
    uint32_t? requestId,
    uint8_t? result,
  }) {
    return DeviceOpWriteReply(
      requestId: requestId ?? this.requestId,
      result: result ?? this.result,
    );
  }

  factory DeviceOpWriteReply.parse(ByteData data_) {
    if (data_.lengthInBytes < DeviceOpWriteReply.mavlinkEncodedLength) {
      var len = DeviceOpWriteReply.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var requestId = data_.getUint32(0, Endian.little);
    var result = data_.getUint8(4);

    return DeviceOpWriteReply(requestId: requestId, result: result);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, requestId, Endian.little);
    data_.setUint8(4, result);
    return data_;
  }
}

/// Adaptive Controller tuning information.
///
/// ADAP_TUNING
class AdapTuning implements MavlinkMessage {
  static const int _mavlinkMessageId = 11010;

  static const int _mavlinkCrcExtra = 46;

  static const int mavlinkEncodedLength = 49;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Desired rate.
  ///
  /// MAVLink type: float
  ///
  /// units: deg/s
  ///
  /// desired
  final float desired;

  /// Achieved rate.
  ///
  /// MAVLink type: float
  ///
  /// units: deg/s
  ///
  /// achieved
  final float achieved;

  /// Error between model and vehicle.
  ///
  /// MAVLink type: float
  ///
  /// error
  final float error;

  /// Theta estimated state predictor.
  ///
  /// MAVLink type: float
  ///
  /// theta
  final float theta;

  /// Omega estimated state predictor.
  ///
  /// MAVLink type: float
  ///
  /// omega
  final float omega;

  /// Sigma estimated state predictor.
  ///
  /// MAVLink type: float
  ///
  /// sigma
  final float sigma;

  /// Theta derivative.
  ///
  /// MAVLink type: float
  ///
  /// theta_dot
  final float thetaDot;

  /// Omega derivative.
  ///
  /// MAVLink type: float
  ///
  /// omega_dot
  final float omegaDot;

  /// Sigma derivative.
  ///
  /// MAVLink type: float
  ///
  /// sigma_dot
  final float sigmaDot;

  /// Projection operator value.
  ///
  /// MAVLink type: float
  ///
  /// f
  final float f;

  /// Projection operator derivative.
  ///
  /// MAVLink type: float
  ///
  /// f_dot
  final float fDot;

  /// u adaptive controlled output command.
  ///
  /// MAVLink type: float
  ///
  /// u
  final float u;

  /// Axis.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [PidTuningAxis]
  ///
  /// axis
  final PidTuningAxis axis;

  AdapTuning({
    required this.desired,
    required this.achieved,
    required this.error,
    required this.theta,
    required this.omega,
    required this.sigma,
    required this.thetaDot,
    required this.omegaDot,
    required this.sigmaDot,
    required this.f,
    required this.fDot,
    required this.u,
    required this.axis,
  });

  AdapTuning copyWith({
    float? desired,
    float? achieved,
    float? error,
    float? theta,
    float? omega,
    float? sigma,
    float? thetaDot,
    float? omegaDot,
    float? sigmaDot,
    float? f,
    float? fDot,
    float? u,
    PidTuningAxis? axis,
  }) {
    return AdapTuning(
      desired: desired ?? this.desired,
      achieved: achieved ?? this.achieved,
      error: error ?? this.error,
      theta: theta ?? this.theta,
      omega: omega ?? this.omega,
      sigma: sigma ?? this.sigma,
      thetaDot: thetaDot ?? this.thetaDot,
      omegaDot: omegaDot ?? this.omegaDot,
      sigmaDot: sigmaDot ?? this.sigmaDot,
      f: f ?? this.f,
      fDot: fDot ?? this.fDot,
      u: u ?? this.u,
      axis: axis ?? this.axis,
    );
  }

  factory AdapTuning.parse(ByteData data_) {
    if (data_.lengthInBytes < AdapTuning.mavlinkEncodedLength) {
      var len = AdapTuning.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var desired = data_.getFloat32(0, Endian.little);
    var achieved = data_.getFloat32(4, Endian.little);
    var error = data_.getFloat32(8, Endian.little);
    var theta = data_.getFloat32(12, Endian.little);
    var omega = data_.getFloat32(16, Endian.little);
    var sigma = data_.getFloat32(20, Endian.little);
    var thetaDot = data_.getFloat32(24, Endian.little);
    var omegaDot = data_.getFloat32(28, Endian.little);
    var sigmaDot = data_.getFloat32(32, Endian.little);
    var f = data_.getFloat32(36, Endian.little);
    var fDot = data_.getFloat32(40, Endian.little);
    var u = data_.getFloat32(44, Endian.little);
    var axis = data_.getUint8(48);

    return AdapTuning(
        desired: desired,
        achieved: achieved,
        error: error,
        theta: theta,
        omega: omega,
        sigma: sigma,
        thetaDot: thetaDot,
        omegaDot: omegaDot,
        sigmaDot: sigmaDot,
        f: f,
        fDot: fDot,
        u: u,
        axis: axis);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, desired, Endian.little);
    data_.setFloat32(4, achieved, Endian.little);
    data_.setFloat32(8, error, Endian.little);
    data_.setFloat32(12, theta, Endian.little);
    data_.setFloat32(16, omega, Endian.little);
    data_.setFloat32(20, sigma, Endian.little);
    data_.setFloat32(24, thetaDot, Endian.little);
    data_.setFloat32(28, omegaDot, Endian.little);
    data_.setFloat32(32, sigmaDot, Endian.little);
    data_.setFloat32(36, f, Endian.little);
    data_.setFloat32(40, fDot, Endian.little);
    data_.setFloat32(44, u, Endian.little);
    data_.setUint8(48, axis);
    return data_;
  }
}

/// Camera vision based attitude and position deltas.
///
/// VISION_POSITION_DELTA
class VisionPositionDelta implements MavlinkMessage {
  static const int _mavlinkMessageId = 11011;

  static const int _mavlinkCrcExtra = 106;

  static const int mavlinkEncodedLength = 44;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (synced to UNIX time or since system boot).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Time since the last reported camera frame.
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_delta_usec
  final uint64_t timeDeltaUsec;

  /// Defines a rotation vector [roll, pitch, yaw] to the current MAV_FRAME_BODY_FRD from the previous MAV_FRAME_BODY_FRD.
  ///
  /// MAVLink type: float[3]
  ///
  /// units: rad
  ///
  /// angle_delta
  final List<float> angleDelta;

  /// Change in position to the current MAV_FRAME_BODY_FRD from the previous FRAME_BODY_FRD rotated to the current MAV_FRAME_BODY_FRD.
  ///
  /// MAVLink type: float[3]
  ///
  /// units: m
  ///
  /// position_delta
  final List<float> positionDelta;

  /// Normalised confidence value from 0 to 100.
  ///
  /// MAVLink type: float
  ///
  /// units: %
  ///
  /// confidence
  final float confidence;

  VisionPositionDelta({
    required this.timeUsec,
    required this.timeDeltaUsec,
    required this.angleDelta,
    required this.positionDelta,
    required this.confidence,
  });

  VisionPositionDelta copyWith({
    uint64_t? timeUsec,
    uint64_t? timeDeltaUsec,
    List<float>? angleDelta,
    List<float>? positionDelta,
    float? confidence,
  }) {
    return VisionPositionDelta(
      timeUsec: timeUsec ?? this.timeUsec,
      timeDeltaUsec: timeDeltaUsec ?? this.timeDeltaUsec,
      angleDelta: angleDelta ?? this.angleDelta,
      positionDelta: positionDelta ?? this.positionDelta,
      confidence: confidence ?? this.confidence,
    );
  }

  factory VisionPositionDelta.parse(ByteData data_) {
    if (data_.lengthInBytes < VisionPositionDelta.mavlinkEncodedLength) {
      var len = VisionPositionDelta.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var timeDeltaUsec = data_.getUint64(8, Endian.little);
    var angleDelta = MavlinkMessage.asFloat32List(data_, 16, 3);
    var positionDelta = MavlinkMessage.asFloat32List(data_, 28, 3);
    var confidence = data_.getFloat32(40, Endian.little);

    return VisionPositionDelta(
        timeUsec: timeUsec,
        timeDeltaUsec: timeDeltaUsec,
        angleDelta: angleDelta,
        positionDelta: positionDelta,
        confidence: confidence);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setUint64(8, timeDeltaUsec, Endian.little);
    MavlinkMessage.setFloat32List(data_, 16, angleDelta);
    MavlinkMessage.setFloat32List(data_, 28, positionDelta);
    data_.setFloat32(40, confidence, Endian.little);
    return data_;
  }
}

/// Angle of Attack and Side Slip Angle.
///
/// AOA_SSA
class AoaSsa implements MavlinkMessage {
  static const int _mavlinkMessageId = 11020;

  static const int _mavlinkCrcExtra = 205;

  static const int mavlinkEncodedLength = 16;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (since boot or Unix epoch).
  ///
  /// MAVLink type: uint64_t
  ///
  /// units: us
  ///
  /// time_usec
  final uint64_t timeUsec;

  /// Angle of Attack.
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// AOA
  final float aoa;

  /// Side Slip Angle.
  ///
  /// MAVLink type: float
  ///
  /// units: deg
  ///
  /// SSA
  final float ssa;

  AoaSsa({
    required this.timeUsec,
    required this.aoa,
    required this.ssa,
  });

  AoaSsa copyWith({
    uint64_t? timeUsec,
    float? aoa,
    float? ssa,
  }) {
    return AoaSsa(
      timeUsec: timeUsec ?? this.timeUsec,
      aoa: aoa ?? this.aoa,
      ssa: ssa ?? this.ssa,
    );
  }

  factory AoaSsa.parse(ByteData data_) {
    if (data_.lengthInBytes < AoaSsa.mavlinkEncodedLength) {
      var len = AoaSsa.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeUsec = data_.getUint64(0, Endian.little);
    var aoa = data_.getFloat32(8, Endian.little);
    var ssa = data_.getFloat32(12, Endian.little);

    return AoaSsa(timeUsec: timeUsec, aoa: aoa, ssa: ssa);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint64(0, timeUsec, Endian.little);
    data_.setFloat32(8, aoa, Endian.little);
    data_.setFloat32(12, ssa, Endian.little);
    return data_;
  }
}

/// ESC Telemetry Data for ESCs 1 to 4, matching data sent by BLHeli ESCs.
///
/// ESC_TELEMETRY_1_TO_4
class EscTelemetry1To4 implements MavlinkMessage {
  static const int _mavlinkMessageId = 11030;

  static const int _mavlinkCrcExtra = 144;

  static const int mavlinkEncodedLength = 44;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Voltage.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: cV
  ///
  /// voltage
  final List<int16_t> voltage;

  /// Current.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: cA
  ///
  /// current
  final List<int16_t> current;

  /// Total current.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: mAh
  ///
  /// totalcurrent
  final List<int16_t> totalcurrent;

  /// RPM (eRPM).
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: rpm
  ///
  /// rpm
  final List<int16_t> rpm;

  /// count of telemetry packets received (wraps at 65535).
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// count
  final List<int16_t> count;

  /// Temperature.
  ///
  /// MAVLink type: uint8_t[4]
  ///
  /// units: degC
  ///
  /// temperature
  final List<int8_t> temperature;

  EscTelemetry1To4({
    required this.voltage,
    required this.current,
    required this.totalcurrent,
    required this.rpm,
    required this.count,
    required this.temperature,
  });

  EscTelemetry1To4 copyWith({
    List<int16_t>? voltage,
    List<int16_t>? current,
    List<int16_t>? totalcurrent,
    List<int16_t>? rpm,
    List<int16_t>? count,
    List<int8_t>? temperature,
  }) {
    return EscTelemetry1To4(
      voltage: voltage ?? this.voltage,
      current: current ?? this.current,
      totalcurrent: totalcurrent ?? this.totalcurrent,
      rpm: rpm ?? this.rpm,
      count: count ?? this.count,
      temperature: temperature ?? this.temperature,
    );
  }

  factory EscTelemetry1To4.parse(ByteData data_) {
    if (data_.lengthInBytes < EscTelemetry1To4.mavlinkEncodedLength) {
      var len = EscTelemetry1To4.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var voltage = MavlinkMessage.asUint16List(data_, 0, 4);
    var current = MavlinkMessage.asUint16List(data_, 8, 4);
    var totalcurrent = MavlinkMessage.asUint16List(data_, 16, 4);
    var rpm = MavlinkMessage.asUint16List(data_, 24, 4);
    var count = MavlinkMessage.asUint16List(data_, 32, 4);
    var temperature = MavlinkMessage.asUint8List(data_, 40, 4);

    return EscTelemetry1To4(
        voltage: voltage,
        current: current,
        totalcurrent: totalcurrent,
        rpm: rpm,
        count: count,
        temperature: temperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setUint16List(data_, 0, voltage);
    MavlinkMessage.setUint16List(data_, 8, current);
    MavlinkMessage.setUint16List(data_, 16, totalcurrent);
    MavlinkMessage.setUint16List(data_, 24, rpm);
    MavlinkMessage.setUint16List(data_, 32, count);
    MavlinkMessage.setUint8List(data_, 40, temperature);
    return data_;
  }
}

/// ESC Telemetry Data for ESCs 5 to 8, matching data sent by BLHeli ESCs.
///
/// ESC_TELEMETRY_5_TO_8
class EscTelemetry5To8 implements MavlinkMessage {
  static const int _mavlinkMessageId = 11031;

  static const int _mavlinkCrcExtra = 133;

  static const int mavlinkEncodedLength = 44;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Voltage.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: cV
  ///
  /// voltage
  final List<int16_t> voltage;

  /// Current.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: cA
  ///
  /// current
  final List<int16_t> current;

  /// Total current.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: mAh
  ///
  /// totalcurrent
  final List<int16_t> totalcurrent;

  /// RPM (eRPM).
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: rpm
  ///
  /// rpm
  final List<int16_t> rpm;

  /// count of telemetry packets received (wraps at 65535).
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// count
  final List<int16_t> count;

  /// Temperature.
  ///
  /// MAVLink type: uint8_t[4]
  ///
  /// units: degC
  ///
  /// temperature
  final List<int8_t> temperature;

  EscTelemetry5To8({
    required this.voltage,
    required this.current,
    required this.totalcurrent,
    required this.rpm,
    required this.count,
    required this.temperature,
  });

  EscTelemetry5To8 copyWith({
    List<int16_t>? voltage,
    List<int16_t>? current,
    List<int16_t>? totalcurrent,
    List<int16_t>? rpm,
    List<int16_t>? count,
    List<int8_t>? temperature,
  }) {
    return EscTelemetry5To8(
      voltage: voltage ?? this.voltage,
      current: current ?? this.current,
      totalcurrent: totalcurrent ?? this.totalcurrent,
      rpm: rpm ?? this.rpm,
      count: count ?? this.count,
      temperature: temperature ?? this.temperature,
    );
  }

  factory EscTelemetry5To8.parse(ByteData data_) {
    if (data_.lengthInBytes < EscTelemetry5To8.mavlinkEncodedLength) {
      var len = EscTelemetry5To8.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var voltage = MavlinkMessage.asUint16List(data_, 0, 4);
    var current = MavlinkMessage.asUint16List(data_, 8, 4);
    var totalcurrent = MavlinkMessage.asUint16List(data_, 16, 4);
    var rpm = MavlinkMessage.asUint16List(data_, 24, 4);
    var count = MavlinkMessage.asUint16List(data_, 32, 4);
    var temperature = MavlinkMessage.asUint8List(data_, 40, 4);

    return EscTelemetry5To8(
        voltage: voltage,
        current: current,
        totalcurrent: totalcurrent,
        rpm: rpm,
        count: count,
        temperature: temperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setUint16List(data_, 0, voltage);
    MavlinkMessage.setUint16List(data_, 8, current);
    MavlinkMessage.setUint16List(data_, 16, totalcurrent);
    MavlinkMessage.setUint16List(data_, 24, rpm);
    MavlinkMessage.setUint16List(data_, 32, count);
    MavlinkMessage.setUint8List(data_, 40, temperature);
    return data_;
  }
}

/// ESC Telemetry Data for ESCs 9 to 12, matching data sent by BLHeli ESCs.
///
/// ESC_TELEMETRY_9_TO_12
class EscTelemetry9To12 implements MavlinkMessage {
  static const int _mavlinkMessageId = 11032;

  static const int _mavlinkCrcExtra = 85;

  static const int mavlinkEncodedLength = 44;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Voltage.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: cV
  ///
  /// voltage
  final List<int16_t> voltage;

  /// Current.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: cA
  ///
  /// current
  final List<int16_t> current;

  /// Total current.
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: mAh
  ///
  /// totalcurrent
  final List<int16_t> totalcurrent;

  /// RPM (eRPM).
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// units: rpm
  ///
  /// rpm
  final List<int16_t> rpm;

  /// count of telemetry packets received (wraps at 65535).
  ///
  /// MAVLink type: uint16_t[4]
  ///
  /// count
  final List<int16_t> count;

  /// Temperature.
  ///
  /// MAVLink type: uint8_t[4]
  ///
  /// units: degC
  ///
  /// temperature
  final List<int8_t> temperature;

  EscTelemetry9To12({
    required this.voltage,
    required this.current,
    required this.totalcurrent,
    required this.rpm,
    required this.count,
    required this.temperature,
  });

  EscTelemetry9To12 copyWith({
    List<int16_t>? voltage,
    List<int16_t>? current,
    List<int16_t>? totalcurrent,
    List<int16_t>? rpm,
    List<int16_t>? count,
    List<int8_t>? temperature,
  }) {
    return EscTelemetry9To12(
      voltage: voltage ?? this.voltage,
      current: current ?? this.current,
      totalcurrent: totalcurrent ?? this.totalcurrent,
      rpm: rpm ?? this.rpm,
      count: count ?? this.count,
      temperature: temperature ?? this.temperature,
    );
  }

  factory EscTelemetry9To12.parse(ByteData data_) {
    if (data_.lengthInBytes < EscTelemetry9To12.mavlinkEncodedLength) {
      var len = EscTelemetry9To12.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var voltage = MavlinkMessage.asUint16List(data_, 0, 4);
    var current = MavlinkMessage.asUint16List(data_, 8, 4);
    var totalcurrent = MavlinkMessage.asUint16List(data_, 16, 4);
    var rpm = MavlinkMessage.asUint16List(data_, 24, 4);
    var count = MavlinkMessage.asUint16List(data_, 32, 4);
    var temperature = MavlinkMessage.asUint8List(data_, 40, 4);

    return EscTelemetry9To12(
        voltage: voltage,
        current: current,
        totalcurrent: totalcurrent,
        rpm: rpm,
        count: count,
        temperature: temperature);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setUint16List(data_, 0, voltage);
    MavlinkMessage.setUint16List(data_, 8, current);
    MavlinkMessage.setUint16List(data_, 16, totalcurrent);
    MavlinkMessage.setUint16List(data_, 24, rpm);
    MavlinkMessage.setUint16List(data_, 32, count);
    MavlinkMessage.setUint8List(data_, 40, temperature);
    return data_;
  }
}

/// Configure an OSD parameter slot.
///
/// OSD_PARAM_CONFIG
class OsdParamConfig implements MavlinkMessage {
  static const int _mavlinkMessageId = 11033;

  static const int _mavlinkCrcExtra = 195;

  static const int mavlinkEncodedLength = 37;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Request ID - copied to reply.
  ///
  /// MAVLink type: uint32_t
  ///
  /// request_id
  final uint32_t requestId;

  /// OSD parameter minimum value.
  ///
  /// MAVLink type: float
  ///
  /// min_value
  final float minValue;

  /// OSD parameter maximum value.
  ///
  /// MAVLink type: float
  ///
  /// max_value
  final float maxValue;

  /// OSD parameter increment.
  ///
  /// MAVLink type: float
  ///
  /// increment
  final float increment;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// OSD parameter screen index.
  ///
  /// MAVLink type: uint8_t
  ///
  /// osd_screen
  final uint8_t osdScreen;

  /// OSD parameter display index.
  ///
  /// MAVLink type: uint8_t
  ///
  /// osd_index
  final uint8_t osdIndex;

  /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  /// Config type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [OsdParamConfigType]
  ///
  /// config_type
  final OsdParamConfigType configType;

  OsdParamConfig({
    required this.requestId,
    required this.minValue,
    required this.maxValue,
    required this.increment,
    required this.targetSystem,
    required this.targetComponent,
    required this.osdScreen,
    required this.osdIndex,
    required this.paramId,
    required this.configType,
  });

  OsdParamConfig copyWith({
    uint32_t? requestId,
    float? minValue,
    float? maxValue,
    float? increment,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? osdScreen,
    uint8_t? osdIndex,
    List<char>? paramId,
    OsdParamConfigType? configType,
  }) {
    return OsdParamConfig(
      requestId: requestId ?? this.requestId,
      minValue: minValue ?? this.minValue,
      maxValue: maxValue ?? this.maxValue,
      increment: increment ?? this.increment,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      osdScreen: osdScreen ?? this.osdScreen,
      osdIndex: osdIndex ?? this.osdIndex,
      paramId: paramId ?? this.paramId,
      configType: configType ?? this.configType,
    );
  }

  factory OsdParamConfig.parse(ByteData data_) {
    if (data_.lengthInBytes < OsdParamConfig.mavlinkEncodedLength) {
      var len = OsdParamConfig.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var requestId = data_.getUint32(0, Endian.little);
    var minValue = data_.getFloat32(4, Endian.little);
    var maxValue = data_.getFloat32(8, Endian.little);
    var increment = data_.getFloat32(12, Endian.little);
    var targetSystem = data_.getUint8(16);
    var targetComponent = data_.getUint8(17);
    var osdScreen = data_.getUint8(18);
    var osdIndex = data_.getUint8(19);
    var paramId = MavlinkMessage.asInt8List(data_, 20, 16);
    var configType = data_.getUint8(36);

    return OsdParamConfig(
        requestId: requestId,
        minValue: minValue,
        maxValue: maxValue,
        increment: increment,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        osdScreen: osdScreen,
        osdIndex: osdIndex,
        paramId: paramId,
        configType: configType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, requestId, Endian.little);
    data_.setFloat32(4, minValue, Endian.little);
    data_.setFloat32(8, maxValue, Endian.little);
    data_.setFloat32(12, increment, Endian.little);
    data_.setUint8(16, targetSystem);
    data_.setUint8(17, targetComponent);
    data_.setUint8(18, osdScreen);
    data_.setUint8(19, osdIndex);
    MavlinkMessage.setInt8List(data_, 20, paramId);
    data_.setUint8(36, configType);
    return data_;
  }
}

/// Configure OSD parameter reply.
///
/// OSD_PARAM_CONFIG_REPLY
class OsdParamConfigReply implements MavlinkMessage {
  static const int _mavlinkMessageId = 11034;

  static const int _mavlinkCrcExtra = 79;

  static const int mavlinkEncodedLength = 5;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Request ID - copied from request.
  ///
  /// MAVLink type: uint32_t
  ///
  /// request_id
  final uint32_t requestId;

  /// Config error type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [OsdParamConfigError]
  ///
  /// result
  final OsdParamConfigError result;

  OsdParamConfigReply({
    required this.requestId,
    required this.result,
  });

  OsdParamConfigReply copyWith({
    uint32_t? requestId,
    OsdParamConfigError? result,
  }) {
    return OsdParamConfigReply(
      requestId: requestId ?? this.requestId,
      result: result ?? this.result,
    );
  }

  factory OsdParamConfigReply.parse(ByteData data_) {
    if (data_.lengthInBytes < OsdParamConfigReply.mavlinkEncodedLength) {
      var len = OsdParamConfigReply.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var requestId = data_.getUint32(0, Endian.little);
    var result = data_.getUint8(4);

    return OsdParamConfigReply(requestId: requestId, result: result);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, requestId, Endian.little);
    data_.setUint8(4, result);
    return data_;
  }
}

/// Read a configured an OSD parameter slot.
///
/// OSD_PARAM_SHOW_CONFIG
class OsdParamShowConfig implements MavlinkMessage {
  static const int _mavlinkMessageId = 11035;

  static const int _mavlinkCrcExtra = 128;

  static const int mavlinkEncodedLength = 8;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Request ID - copied to reply.
  ///
  /// MAVLink type: uint32_t
  ///
  /// request_id
  final uint32_t requestId;

  /// System ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID.
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// OSD parameter screen index.
  ///
  /// MAVLink type: uint8_t
  ///
  /// osd_screen
  final uint8_t osdScreen;

  /// OSD parameter display index.
  ///
  /// MAVLink type: uint8_t
  ///
  /// osd_index
  final uint8_t osdIndex;

  OsdParamShowConfig({
    required this.requestId,
    required this.targetSystem,
    required this.targetComponent,
    required this.osdScreen,
    required this.osdIndex,
  });

  OsdParamShowConfig copyWith({
    uint32_t? requestId,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? osdScreen,
    uint8_t? osdIndex,
  }) {
    return OsdParamShowConfig(
      requestId: requestId ?? this.requestId,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      osdScreen: osdScreen ?? this.osdScreen,
      osdIndex: osdIndex ?? this.osdIndex,
    );
  }

  factory OsdParamShowConfig.parse(ByteData data_) {
    if (data_.lengthInBytes < OsdParamShowConfig.mavlinkEncodedLength) {
      var len = OsdParamShowConfig.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var requestId = data_.getUint32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var osdScreen = data_.getUint8(6);
    var osdIndex = data_.getUint8(7);

    return OsdParamShowConfig(
        requestId: requestId,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        osdScreen: osdScreen,
        osdIndex: osdIndex);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, requestId, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, osdScreen);
    data_.setUint8(7, osdIndex);
    return data_;
  }
}

/// Read configured OSD parameter reply.
///
/// OSD_PARAM_SHOW_CONFIG_REPLY
class OsdParamShowConfigReply implements MavlinkMessage {
  static const int _mavlinkMessageId = 11036;

  static const int _mavlinkCrcExtra = 177;

  static const int mavlinkEncodedLength = 34;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Request ID - copied from request.
  ///
  /// MAVLink type: uint32_t
  ///
  /// request_id
  final uint32_t requestId;

  /// OSD parameter minimum value.
  ///
  /// MAVLink type: float
  ///
  /// min_value
  final float minValue;

  /// OSD parameter maximum value.
  ///
  /// MAVLink type: float
  ///
  /// max_value
  final float maxValue;

  /// OSD parameter increment.
  ///
  /// MAVLink type: float
  ///
  /// increment
  final float increment;

  /// Config error type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [OsdParamConfigError]
  ///
  /// result
  final OsdParamConfigError result;

  /// Onboard parameter id, terminated by NULL if the length is less than 16 human-readable chars and WITHOUT null termination (NULL) byte if the length is exactly 16 chars - applications have to provide 16+1 bytes storage if the ID is stored as string
  ///
  /// MAVLink type: char[16]
  ///
  /// param_id
  final List<char> paramId;

  /// Config type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [OsdParamConfigType]
  ///
  /// config_type
  final OsdParamConfigType configType;

  OsdParamShowConfigReply({
    required this.requestId,
    required this.minValue,
    required this.maxValue,
    required this.increment,
    required this.result,
    required this.paramId,
    required this.configType,
  });

  OsdParamShowConfigReply copyWith({
    uint32_t? requestId,
    float? minValue,
    float? maxValue,
    float? increment,
    OsdParamConfigError? result,
    List<char>? paramId,
    OsdParamConfigType? configType,
  }) {
    return OsdParamShowConfigReply(
      requestId: requestId ?? this.requestId,
      minValue: minValue ?? this.minValue,
      maxValue: maxValue ?? this.maxValue,
      increment: increment ?? this.increment,
      result: result ?? this.result,
      paramId: paramId ?? this.paramId,
      configType: configType ?? this.configType,
    );
  }

  factory OsdParamShowConfigReply.parse(ByteData data_) {
    if (data_.lengthInBytes < OsdParamShowConfigReply.mavlinkEncodedLength) {
      var len =
          OsdParamShowConfigReply.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var requestId = data_.getUint32(0, Endian.little);
    var minValue = data_.getFloat32(4, Endian.little);
    var maxValue = data_.getFloat32(8, Endian.little);
    var increment = data_.getFloat32(12, Endian.little);
    var result = data_.getUint8(16);
    var paramId = MavlinkMessage.asInt8List(data_, 17, 16);
    var configType = data_.getUint8(33);

    return OsdParamShowConfigReply(
        requestId: requestId,
        minValue: minValue,
        maxValue: maxValue,
        increment: increment,
        result: result,
        paramId: paramId,
        configType: configType);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, requestId, Endian.little);
    data_.setFloat32(4, minValue, Endian.little);
    data_.setFloat32(8, maxValue, Endian.little);
    data_.setFloat32(12, increment, Endian.little);
    data_.setUint8(16, result);
    MavlinkMessage.setInt8List(data_, 17, paramId);
    data_.setUint8(33, configType);
    return data_;
  }
}

/// Obstacle located as a 3D vector.
///
/// OBSTACLE_DISTANCE_3D
class ObstacleDistance3d implements MavlinkMessage {
  static const int _mavlinkMessageId = 11037;

  static const int _mavlinkCrcExtra = 130;

  static const int mavlinkEncodedLength = 28;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// X position of the obstacle.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// x
  final float x;

  /// Y position of the obstacle.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// y
  final float y;

  /// Z position of the obstacle.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// z
  final float z;

  /// Minimum distance the sensor can measure.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// min_distance
  final float minDistance;

  /// Maximum distance the sensor can measure.
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// max_distance
  final float maxDistance;

  /// Unique ID given to each obstacle so that its movement can be tracked. Use UINT16_MAX if object ID is unknown or cannot be determined.
  ///
  /// MAVLink type: uint16_t
  ///
  /// obstacle_id
  final uint16_t obstacleId;

  /// Class id of the distance sensor type.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavDistanceSensor]
  ///
  /// sensor_type
  final MavDistanceSensor sensorType;

  /// Coordinate frame of reference.
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavFrame]
  ///
  /// frame
  final MavFrame frame;

  ObstacleDistance3d({
    required this.timeBootMs,
    required this.x,
    required this.y,
    required this.z,
    required this.minDistance,
    required this.maxDistance,
    required this.obstacleId,
    required this.sensorType,
    required this.frame,
  });

  ObstacleDistance3d copyWith({
    uint32_t? timeBootMs,
    float? x,
    float? y,
    float? z,
    float? minDistance,
    float? maxDistance,
    uint16_t? obstacleId,
    MavDistanceSensor? sensorType,
    MavFrame? frame,
  }) {
    return ObstacleDistance3d(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      x: x ?? this.x,
      y: y ?? this.y,
      z: z ?? this.z,
      minDistance: minDistance ?? this.minDistance,
      maxDistance: maxDistance ?? this.maxDistance,
      obstacleId: obstacleId ?? this.obstacleId,
      sensorType: sensorType ?? this.sensorType,
      frame: frame ?? this.frame,
    );
  }

  factory ObstacleDistance3d.parse(ByteData data_) {
    if (data_.lengthInBytes < ObstacleDistance3d.mavlinkEncodedLength) {
      var len = ObstacleDistance3d.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var x = data_.getFloat32(4, Endian.little);
    var y = data_.getFloat32(8, Endian.little);
    var z = data_.getFloat32(12, Endian.little);
    var minDistance = data_.getFloat32(16, Endian.little);
    var maxDistance = data_.getFloat32(20, Endian.little);
    var obstacleId = data_.getUint16(24, Endian.little);
    var sensorType = data_.getUint8(26);
    var frame = data_.getUint8(27);

    return ObstacleDistance3d(
        timeBootMs: timeBootMs,
        x: x,
        y: y,
        z: z,
        minDistance: minDistance,
        maxDistance: maxDistance,
        obstacleId: obstacleId,
        sensorType: sensorType,
        frame: frame);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setFloat32(4, x, Endian.little);
    data_.setFloat32(8, y, Endian.little);
    data_.setFloat32(12, z, Endian.little);
    data_.setFloat32(16, minDistance, Endian.little);
    data_.setFloat32(20, maxDistance, Endian.little);
    data_.setUint16(24, obstacleId, Endian.little);
    data_.setUint8(26, sensorType);
    data_.setUint8(27, frame);
    return data_;
  }
}

/// Water depth
///
/// WATER_DEPTH
class WaterDepth implements MavlinkMessage {
  static const int _mavlinkMessageId = 11038;

  static const int _mavlinkCrcExtra = 47;

  static const int mavlinkEncodedLength = 38;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot)
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Latitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lat
  final int32_t lat;

  /// Longitude
  ///
  /// MAVLink type: int32_t
  ///
  /// units: degE7
  ///
  /// lng
  final int32_t lng;

  /// Altitude (MSL) of vehicle
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// alt
  final float alt;

  /// Roll angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// Pitch angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw angle
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Distance (uncorrected)
  ///
  /// MAVLink type: float
  ///
  /// units: m
  ///
  /// distance
  final float distance;

  /// Water temperature
  ///
  /// MAVLink type: float
  ///
  /// units: degC
  ///
  /// temperature
  final float temperature;

  /// Onboard ID of the sensor
  ///
  /// MAVLink type: uint8_t
  ///
  /// id
  final uint8_t id;

  /// Sensor data healthy (0=unhealthy, 1=healthy)
  ///
  /// MAVLink type: uint8_t
  ///
  /// healthy
  final uint8_t healthy;

  WaterDepth({
    required this.timeBootMs,
    required this.lat,
    required this.lng,
    required this.alt,
    required this.roll,
    required this.pitch,
    required this.yaw,
    required this.distance,
    required this.temperature,
    required this.id,
    required this.healthy,
  });

  WaterDepth copyWith({
    uint32_t? timeBootMs,
    int32_t? lat,
    int32_t? lng,
    float? alt,
    float? roll,
    float? pitch,
    float? yaw,
    float? distance,
    float? temperature,
    uint8_t? id,
    uint8_t? healthy,
  }) {
    return WaterDepth(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      lat: lat ?? this.lat,
      lng: lng ?? this.lng,
      alt: alt ?? this.alt,
      roll: roll ?? this.roll,
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      distance: distance ?? this.distance,
      temperature: temperature ?? this.temperature,
      id: id ?? this.id,
      healthy: healthy ?? this.healthy,
    );
  }

  factory WaterDepth.parse(ByteData data_) {
    if (data_.lengthInBytes < WaterDepth.mavlinkEncodedLength) {
      var len = WaterDepth.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var lat = data_.getInt32(4, Endian.little);
    var lng = data_.getInt32(8, Endian.little);
    var alt = data_.getFloat32(12, Endian.little);
    var roll = data_.getFloat32(16, Endian.little);
    var pitch = data_.getFloat32(20, Endian.little);
    var yaw = data_.getFloat32(24, Endian.little);
    var distance = data_.getFloat32(28, Endian.little);
    var temperature = data_.getFloat32(32, Endian.little);
    var id = data_.getUint8(36);
    var healthy = data_.getUint8(37);

    return WaterDepth(
        timeBootMs: timeBootMs,
        lat: lat,
        lng: lng,
        alt: alt,
        roll: roll,
        pitch: pitch,
        yaw: yaw,
        distance: distance,
        temperature: temperature,
        id: id,
        healthy: healthy);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setInt32(4, lat, Endian.little);
    data_.setInt32(8, lng, Endian.little);
    data_.setFloat32(12, alt, Endian.little);
    data_.setFloat32(16, roll, Endian.little);
    data_.setFloat32(20, pitch, Endian.little);
    data_.setFloat32(24, yaw, Endian.little);
    data_.setFloat32(28, distance, Endian.little);
    data_.setFloat32(32, temperature, Endian.little);
    data_.setUint8(36, id);
    data_.setUint8(37, healthy);
    return data_;
  }
}

/// The MCU status, giving MCU temperature and voltage. The min and max voltages are to allow for detecting power supply instability.
///
/// MCU_STATUS
class McuStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 11039;

  static const int _mavlinkCrcExtra = 142;

  static const int mavlinkEncodedLength = 9;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// MCU Internal temperature
  ///
  /// MAVLink type: int16_t
  ///
  /// units: cdegC
  ///
  /// MCU_temperature
  final int16_t mcuTemperature;

  /// MCU voltage
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mV
  ///
  /// MCU_voltage
  final uint16_t mcuVoltage;

  /// MCU voltage minimum
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mV
  ///
  /// MCU_voltage_min
  final uint16_t mcuVoltageMin;

  /// MCU voltage maximum
  ///
  /// MAVLink type: uint16_t
  ///
  /// units: mV
  ///
  /// MCU_voltage_max
  final uint16_t mcuVoltageMax;

  /// MCU instance
  ///
  /// MAVLink type: uint8_t
  ///
  /// id
  final uint8_t id;

  McuStatus({
    required this.mcuTemperature,
    required this.mcuVoltage,
    required this.mcuVoltageMin,
    required this.mcuVoltageMax,
    required this.id,
  });

  McuStatus copyWith({
    int16_t? mcuTemperature,
    uint16_t? mcuVoltage,
    uint16_t? mcuVoltageMin,
    uint16_t? mcuVoltageMax,
    uint8_t? id,
  }) {
    return McuStatus(
      mcuTemperature: mcuTemperature ?? this.mcuTemperature,
      mcuVoltage: mcuVoltage ?? this.mcuVoltage,
      mcuVoltageMin: mcuVoltageMin ?? this.mcuVoltageMin,
      mcuVoltageMax: mcuVoltageMax ?? this.mcuVoltageMax,
      id: id ?? this.id,
    );
  }

  factory McuStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < McuStatus.mavlinkEncodedLength) {
      var len = McuStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var mcuTemperature = data_.getInt16(0, Endian.little);
    var mcuVoltage = data_.getUint16(2, Endian.little);
    var mcuVoltageMin = data_.getUint16(4, Endian.little);
    var mcuVoltageMax = data_.getUint16(6, Endian.little);
    var id = data_.getUint8(8);

    return McuStatus(
        mcuTemperature: mcuTemperature,
        mcuVoltage: mcuVoltage,
        mcuVoltageMin: mcuVoltageMin,
        mcuVoltageMax: mcuVoltageMax,
        id: id);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setInt16(0, mcuTemperature, Endian.little);
    data_.setUint16(2, mcuVoltage, Endian.little);
    data_.setUint16(4, mcuVoltageMin, Endian.little);
    data_.setUint16(6, mcuVoltageMax, Endian.little);
    data_.setUint8(8, id);
    return data_;
  }
}

/// Information about a gimbal manager. This message should be requested by a ground station using MAV_CMD_REQUEST_MESSAGE. It mirrors some fields of the GIMBAL_DEVICE_INFORMATION message, but not all. If the additional information is desired, also GIMBAL_DEVICE_INFORMATION should be requested.
///
/// STORM32_GIMBAL_MANAGER_INFORMATION
class Storm32GimbalManagerInformation implements MavlinkMessage {
  static const int _mavlinkMessageId = 60010;

  static const int _mavlinkCrcExtra = 208;

  static const int mavlinkEncodedLength = 33;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Gimbal device capability flags. Same flags as reported by GIMBAL_DEVICE_INFORMATION. The flag is only 16 bit wide, but stored in 32 bit, for backwards compatibility (high word is zero).
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [GimbalDeviceCapFlags]
  ///
  /// device_cap_flags
  final GimbalDeviceCapFlags deviceCapFlags;

  /// Gimbal manager capability flags.
  ///
  /// MAVLink type: uint32_t
  ///
  /// enum: [MavStorm32GimbalManagerCapFlags]
  ///
  /// manager_cap_flags
  final MavStorm32GimbalManagerCapFlags managerCapFlags;

  /// Hardware minimum roll angle (positive: roll to the right). NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll_min
  final float rollMin;

  /// Hardware maximum roll angle (positive: roll to the right). NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll_max
  final float rollMax;

  /// Hardware minimum pitch/tilt angle (positive: tilt up). NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch_min
  final float pitchMin;

  /// Hardware maximum pitch/tilt angle (positive: tilt up). NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch_max
  final float pitchMax;

  /// Hardware minimum yaw/pan angle (positive: pan to the right, relative to the vehicle/gimbal base). NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw_min
  final float yawMin;

  /// Hardware maximum yaw/pan angle (positive: pan to the right, relative to the vehicle/gimbal base). NaN if unknown.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw_max
  final float yawMax;

  /// Gimbal ID (component ID or 1-6 for non-MAVLink gimbal) that this gimbal manager is responsible for.
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_id
  final uint8_t gimbalId;

  Storm32GimbalManagerInformation({
    required this.deviceCapFlags,
    required this.managerCapFlags,
    required this.rollMin,
    required this.rollMax,
    required this.pitchMin,
    required this.pitchMax,
    required this.yawMin,
    required this.yawMax,
    required this.gimbalId,
  });

  Storm32GimbalManagerInformation copyWith({
    GimbalDeviceCapFlags? deviceCapFlags,
    MavStorm32GimbalManagerCapFlags? managerCapFlags,
    float? rollMin,
    float? rollMax,
    float? pitchMin,
    float? pitchMax,
    float? yawMin,
    float? yawMax,
    uint8_t? gimbalId,
  }) {
    return Storm32GimbalManagerInformation(
      deviceCapFlags: deviceCapFlags ?? this.deviceCapFlags,
      managerCapFlags: managerCapFlags ?? this.managerCapFlags,
      rollMin: rollMin ?? this.rollMin,
      rollMax: rollMax ?? this.rollMax,
      pitchMin: pitchMin ?? this.pitchMin,
      pitchMax: pitchMax ?? this.pitchMax,
      yawMin: yawMin ?? this.yawMin,
      yawMax: yawMax ?? this.yawMax,
      gimbalId: gimbalId ?? this.gimbalId,
    );
  }

  factory Storm32GimbalManagerInformation.parse(ByteData data_) {
    if (data_.lengthInBytes <
        Storm32GimbalManagerInformation.mavlinkEncodedLength) {
      var len = Storm32GimbalManagerInformation.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var deviceCapFlags = data_.getUint32(0, Endian.little);
    var managerCapFlags = data_.getUint32(4, Endian.little);
    var rollMin = data_.getFloat32(8, Endian.little);
    var rollMax = data_.getFloat32(12, Endian.little);
    var pitchMin = data_.getFloat32(16, Endian.little);
    var pitchMax = data_.getFloat32(20, Endian.little);
    var yawMin = data_.getFloat32(24, Endian.little);
    var yawMax = data_.getFloat32(28, Endian.little);
    var gimbalId = data_.getUint8(32);

    return Storm32GimbalManagerInformation(
        deviceCapFlags: deviceCapFlags,
        managerCapFlags: managerCapFlags,
        rollMin: rollMin,
        rollMax: rollMax,
        pitchMin: pitchMin,
        pitchMax: pitchMax,
        yawMin: yawMin,
        yawMax: yawMax,
        gimbalId: gimbalId);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, deviceCapFlags, Endian.little);
    data_.setUint32(4, managerCapFlags, Endian.little);
    data_.setFloat32(8, rollMin, Endian.little);
    data_.setFloat32(12, rollMax, Endian.little);
    data_.setFloat32(16, pitchMin, Endian.little);
    data_.setFloat32(20, pitchMax, Endian.little);
    data_.setFloat32(24, yawMin, Endian.little);
    data_.setFloat32(28, yawMax, Endian.little);
    data_.setUint8(32, gimbalId);
    return data_;
  }
}

/// Message reporting the current status of a gimbal manager. This message should be broadcast at a low regular rate (e.g. 1 Hz, may be increase momentarily to e.g. 5 Hz for a period of 1 sec after a change).
///
/// STORM32_GIMBAL_MANAGER_STATUS
class Storm32GimbalManagerStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 60011;

  static const int _mavlinkCrcExtra = 183;

  static const int mavlinkEncodedLength = 7;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Gimbal device flags currently applied. Same flags as reported by GIMBAL_DEVICE_ATTITUDE_STATUS.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [GimbalDeviceFlags]
  ///
  /// device_flags
  final GimbalDeviceFlags deviceFlags;

  /// Gimbal manager flags currently applied.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavStorm32GimbalManagerFlags]
  ///
  /// manager_flags
  final MavStorm32GimbalManagerFlags managerFlags;

  /// Gimbal ID (component ID or 1-6 for non-MAVLink gimbal) that this gimbal manager is responsible for.
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_id
  final uint8_t gimbalId;

  /// Client who is currently supervisor (0 = none).
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavStorm32GimbalManagerClient]
  ///
  /// supervisor
  final MavStorm32GimbalManagerClient supervisor;

  /// Profile currently applied (0 = default).
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavStorm32GimbalManagerProfile]
  ///
  /// profile
  final MavStorm32GimbalManagerProfile profile;

  Storm32GimbalManagerStatus({
    required this.deviceFlags,
    required this.managerFlags,
    required this.gimbalId,
    required this.supervisor,
    required this.profile,
  });

  Storm32GimbalManagerStatus copyWith({
    GimbalDeviceFlags? deviceFlags,
    MavStorm32GimbalManagerFlags? managerFlags,
    uint8_t? gimbalId,
    MavStorm32GimbalManagerClient? supervisor,
    MavStorm32GimbalManagerProfile? profile,
  }) {
    return Storm32GimbalManagerStatus(
      deviceFlags: deviceFlags ?? this.deviceFlags,
      managerFlags: managerFlags ?? this.managerFlags,
      gimbalId: gimbalId ?? this.gimbalId,
      supervisor: supervisor ?? this.supervisor,
      profile: profile ?? this.profile,
    );
  }

  factory Storm32GimbalManagerStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < Storm32GimbalManagerStatus.mavlinkEncodedLength) {
      var len =
          Storm32GimbalManagerStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var deviceFlags = data_.getUint16(0, Endian.little);
    var managerFlags = data_.getUint16(2, Endian.little);
    var gimbalId = data_.getUint8(4);
    var supervisor = data_.getUint8(5);
    var profile = data_.getUint8(6);

    return Storm32GimbalManagerStatus(
        deviceFlags: deviceFlags,
        managerFlags: managerFlags,
        gimbalId: gimbalId,
        supervisor: supervisor,
        profile: profile);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, deviceFlags, Endian.little);
    data_.setUint16(2, managerFlags, Endian.little);
    data_.setUint8(4, gimbalId);
    data_.setUint8(5, supervisor);
    data_.setUint8(6, profile);
    return data_;
  }
}

/// Message to a gimbal manager to control the gimbal attitude. Angles and rates can be set to NaN according to use case. A gimbal device is never to react to this message.
///
/// STORM32_GIMBAL_MANAGER_CONTROL
class Storm32GimbalManagerControl implements MavlinkMessage {
  static const int _mavlinkMessageId = 60012;

  static const int _mavlinkCrcExtra = 99;

  static const int mavlinkEncodedLength = 36;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation). Set first element to NaN to be ignored. The frame is determined by the GIMBAL_DEVICE_FLAGS_YAW_IN_xxx_FRAME flags.
  ///
  /// MAVLink type: float[4]
  ///
  /// q
  final List<float> q;

  /// X component of angular velocity (positive: roll to the right). NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_x
  final float angularVelocityX;

  /// Y component of angular velocity (positive: tilt up). NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_y
  final float angularVelocityY;

  /// Z component of angular velocity (positive: pan to the right). NaN to be ignored. The frame is determined by the GIMBAL_DEVICE_FLAGS_YAW_IN_xxx_FRAME flags.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// angular_velocity_z
  final float angularVelocityZ;

  /// Gimbal device flags to be applied (UINT16_MAX to be ignored). Same flags as used in GIMBAL_DEVICE_SET_ATTITUDE.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [GimbalDeviceFlags]
  ///
  /// device_flags
  final GimbalDeviceFlags deviceFlags;

  /// Gimbal manager flags to be applied (0 to be ignored).
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavStorm32GimbalManagerFlags]
  ///
  /// manager_flags
  final MavStorm32GimbalManagerFlags managerFlags;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Gimbal ID of the gimbal manager to address (component ID or 1-6 for non-MAVLink gimbal, 0 for all gimbals). Send command multiple times for more than one but not all gimbals.
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_id
  final uint8_t gimbalId;

  /// Client which is contacting the gimbal manager (must be set).
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavStorm32GimbalManagerClient]
  ///
  /// client
  final MavStorm32GimbalManagerClient client;

  Storm32GimbalManagerControl({
    required this.q,
    required this.angularVelocityX,
    required this.angularVelocityY,
    required this.angularVelocityZ,
    required this.deviceFlags,
    required this.managerFlags,
    required this.targetSystem,
    required this.targetComponent,
    required this.gimbalId,
    required this.client,
  });

  Storm32GimbalManagerControl copyWith({
    List<float>? q,
    float? angularVelocityX,
    float? angularVelocityY,
    float? angularVelocityZ,
    GimbalDeviceFlags? deviceFlags,
    MavStorm32GimbalManagerFlags? managerFlags,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? gimbalId,
    MavStorm32GimbalManagerClient? client,
  }) {
    return Storm32GimbalManagerControl(
      q: q ?? this.q,
      angularVelocityX: angularVelocityX ?? this.angularVelocityX,
      angularVelocityY: angularVelocityY ?? this.angularVelocityY,
      angularVelocityZ: angularVelocityZ ?? this.angularVelocityZ,
      deviceFlags: deviceFlags ?? this.deviceFlags,
      managerFlags: managerFlags ?? this.managerFlags,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      gimbalId: gimbalId ?? this.gimbalId,
      client: client ?? this.client,
    );
  }

  factory Storm32GimbalManagerControl.parse(ByteData data_) {
    if (data_.lengthInBytes <
        Storm32GimbalManagerControl.mavlinkEncodedLength) {
      var len = Storm32GimbalManagerControl.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var q = MavlinkMessage.asFloat32List(data_, 0, 4);
    var angularVelocityX = data_.getFloat32(16, Endian.little);
    var angularVelocityY = data_.getFloat32(20, Endian.little);
    var angularVelocityZ = data_.getFloat32(24, Endian.little);
    var deviceFlags = data_.getUint16(28, Endian.little);
    var managerFlags = data_.getUint16(30, Endian.little);
    var targetSystem = data_.getUint8(32);
    var targetComponent = data_.getUint8(33);
    var gimbalId = data_.getUint8(34);
    var client = data_.getUint8(35);

    return Storm32GimbalManagerControl(
        q: q,
        angularVelocityX: angularVelocityX,
        angularVelocityY: angularVelocityY,
        angularVelocityZ: angularVelocityZ,
        deviceFlags: deviceFlags,
        managerFlags: managerFlags,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        gimbalId: gimbalId,
        client: client);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    MavlinkMessage.setFloat32List(data_, 0, q);
    data_.setFloat32(16, angularVelocityX, Endian.little);
    data_.setFloat32(20, angularVelocityY, Endian.little);
    data_.setFloat32(24, angularVelocityZ, Endian.little);
    data_.setUint16(28, deviceFlags, Endian.little);
    data_.setUint16(30, managerFlags, Endian.little);
    data_.setUint8(32, targetSystem);
    data_.setUint8(33, targetComponent);
    data_.setUint8(34, gimbalId);
    data_.setUint8(35, client);
    return data_;
  }
}

/// Message to a gimbal manager to control the gimbal tilt and pan angles. Angles and rates can be set to NaN according to use case. A gimbal device is never to react to this message.
///
/// STORM32_GIMBAL_MANAGER_CONTROL_PITCHYAW
class Storm32GimbalManagerControlPitchyaw implements MavlinkMessage {
  static const int _mavlinkMessageId = 60013;

  static const int _mavlinkCrcExtra = 129;

  static const int mavlinkEncodedLength = 24;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Pitch/tilt angle (positive: tilt up). NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// pitch
  final float pitch;

  /// Yaw/pan angle (positive: pan the right). NaN to be ignored. The frame is determined by the GIMBAL_DEVICE_FLAGS_YAW_IN_xxx_FRAME flags.
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// yaw
  final float yaw;

  /// Pitch/tilt angular rate (positive: tilt up). NaN to be ignored.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// pitch_rate
  final float pitchRate;

  /// Yaw/pan angular rate (positive: pan to the right). NaN to be ignored. The frame is determined by the GIMBAL_DEVICE_FLAGS_YAW_IN_xxx_FRAME flags.
  ///
  /// MAVLink type: float
  ///
  /// units: rad/s
  ///
  /// yaw_rate
  final float yawRate;

  /// Gimbal device flags to be applied (UINT16_MAX to be ignored). Same flags as used in GIMBAL_DEVICE_SET_ATTITUDE.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [GimbalDeviceFlags]
  ///
  /// device_flags
  final GimbalDeviceFlags deviceFlags;

  /// Gimbal manager flags to be applied (0 to be ignored).
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavStorm32GimbalManagerFlags]
  ///
  /// manager_flags
  final MavStorm32GimbalManagerFlags managerFlags;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Gimbal ID of the gimbal manager to address (component ID or 1-6 for non-MAVLink gimbal, 0 for all gimbals). Send command multiple times for more than one but not all gimbals.
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_id
  final uint8_t gimbalId;

  /// Client which is contacting the gimbal manager (must be set).
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavStorm32GimbalManagerClient]
  ///
  /// client
  final MavStorm32GimbalManagerClient client;

  Storm32GimbalManagerControlPitchyaw({
    required this.pitch,
    required this.yaw,
    required this.pitchRate,
    required this.yawRate,
    required this.deviceFlags,
    required this.managerFlags,
    required this.targetSystem,
    required this.targetComponent,
    required this.gimbalId,
    required this.client,
  });

  Storm32GimbalManagerControlPitchyaw copyWith({
    float? pitch,
    float? yaw,
    float? pitchRate,
    float? yawRate,
    GimbalDeviceFlags? deviceFlags,
    MavStorm32GimbalManagerFlags? managerFlags,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? gimbalId,
    MavStorm32GimbalManagerClient? client,
  }) {
    return Storm32GimbalManagerControlPitchyaw(
      pitch: pitch ?? this.pitch,
      yaw: yaw ?? this.yaw,
      pitchRate: pitchRate ?? this.pitchRate,
      yawRate: yawRate ?? this.yawRate,
      deviceFlags: deviceFlags ?? this.deviceFlags,
      managerFlags: managerFlags ?? this.managerFlags,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      gimbalId: gimbalId ?? this.gimbalId,
      client: client ?? this.client,
    );
  }

  factory Storm32GimbalManagerControlPitchyaw.parse(ByteData data_) {
    if (data_.lengthInBytes <
        Storm32GimbalManagerControlPitchyaw.mavlinkEncodedLength) {
      var len = Storm32GimbalManagerControlPitchyaw.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var pitch = data_.getFloat32(0, Endian.little);
    var yaw = data_.getFloat32(4, Endian.little);
    var pitchRate = data_.getFloat32(8, Endian.little);
    var yawRate = data_.getFloat32(12, Endian.little);
    var deviceFlags = data_.getUint16(16, Endian.little);
    var managerFlags = data_.getUint16(18, Endian.little);
    var targetSystem = data_.getUint8(20);
    var targetComponent = data_.getUint8(21);
    var gimbalId = data_.getUint8(22);
    var client = data_.getUint8(23);

    return Storm32GimbalManagerControlPitchyaw(
        pitch: pitch,
        yaw: yaw,
        pitchRate: pitchRate,
        yawRate: yawRate,
        deviceFlags: deviceFlags,
        managerFlags: managerFlags,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        gimbalId: gimbalId,
        client: client);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, pitch, Endian.little);
    data_.setFloat32(4, yaw, Endian.little);
    data_.setFloat32(8, pitchRate, Endian.little);
    data_.setFloat32(12, yawRate, Endian.little);
    data_.setUint16(16, deviceFlags, Endian.little);
    data_.setUint16(18, managerFlags, Endian.little);
    data_.setUint8(20, targetSystem);
    data_.setUint8(21, targetComponent);
    data_.setUint8(22, gimbalId);
    data_.setUint8(23, client);
    return data_;
  }
}

/// Message to a gimbal manager to correct the gimbal roll angle. This message is typically used to manually correct for a tilted horizon in operation. A gimbal device is never to react to this message.
///
/// STORM32_GIMBAL_MANAGER_CORRECT_ROLL
class Storm32GimbalManagerCorrectRoll implements MavlinkMessage {
  static const int _mavlinkMessageId = 60014;

  static const int _mavlinkCrcExtra = 134;

  static const int mavlinkEncodedLength = 8;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Roll angle (positive to roll to the right).
  ///
  /// MAVLink type: float
  ///
  /// units: rad
  ///
  /// roll
  final float roll;

  /// System ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_system
  final uint8_t targetSystem;

  /// Component ID
  ///
  /// MAVLink type: uint8_t
  ///
  /// target_component
  final uint8_t targetComponent;

  /// Gimbal ID of the gimbal manager to address (component ID or 1-6 for non-MAVLink gimbal, 0 for all gimbals). Send command multiple times for more than one but not all gimbals.
  ///
  /// MAVLink type: uint8_t
  ///
  /// gimbal_id
  final uint8_t gimbalId;

  /// Client which is contacting the gimbal manager (must be set).
  ///
  /// MAVLink type: uint8_t
  ///
  /// enum: [MavStorm32GimbalManagerClient]
  ///
  /// client
  final MavStorm32GimbalManagerClient client;

  Storm32GimbalManagerCorrectRoll({
    required this.roll,
    required this.targetSystem,
    required this.targetComponent,
    required this.gimbalId,
    required this.client,
  });

  Storm32GimbalManagerCorrectRoll copyWith({
    float? roll,
    uint8_t? targetSystem,
    uint8_t? targetComponent,
    uint8_t? gimbalId,
    MavStorm32GimbalManagerClient? client,
  }) {
    return Storm32GimbalManagerCorrectRoll(
      roll: roll ?? this.roll,
      targetSystem: targetSystem ?? this.targetSystem,
      targetComponent: targetComponent ?? this.targetComponent,
      gimbalId: gimbalId ?? this.gimbalId,
      client: client ?? this.client,
    );
  }

  factory Storm32GimbalManagerCorrectRoll.parse(ByteData data_) {
    if (data_.lengthInBytes <
        Storm32GimbalManagerCorrectRoll.mavlinkEncodedLength) {
      var len = Storm32GimbalManagerCorrectRoll.mavlinkEncodedLength -
          data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var roll = data_.getFloat32(0, Endian.little);
    var targetSystem = data_.getUint8(4);
    var targetComponent = data_.getUint8(5);
    var gimbalId = data_.getUint8(6);
    var client = data_.getUint8(7);

    return Storm32GimbalManagerCorrectRoll(
        roll: roll,
        targetSystem: targetSystem,
        targetComponent: targetComponent,
        gimbalId: gimbalId,
        client: client);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setFloat32(0, roll, Endian.little);
    data_.setUint8(4, targetSystem);
    data_.setUint8(5, targetComponent);
    data_.setUint8(6, gimbalId);
    data_.setUint8(7, client);
    return data_;
  }
}

/// Information about the shot operation.
///
/// QSHOT_STATUS
class QshotStatus implements MavlinkMessage {
  static const int _mavlinkMessageId = 60020;

  static const int _mavlinkCrcExtra = 202;

  static const int mavlinkEncodedLength = 4;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Current shot mode.
  ///
  /// MAVLink type: uint16_t
  ///
  /// enum: [MavQshotMode]
  ///
  /// mode
  final MavQshotMode mode;

  /// Current state in the shot. States are specific to the selected shot mode.
  ///
  /// MAVLink type: uint16_t
  ///
  /// shot_state
  final uint16_t shotState;

  QshotStatus({
    required this.mode,
    required this.shotState,
  });

  QshotStatus copyWith({
    MavQshotMode? mode,
    uint16_t? shotState,
  }) {
    return QshotStatus(
      mode: mode ?? this.mode,
      shotState: shotState ?? this.shotState,
    );
  }

  factory QshotStatus.parse(ByteData data_) {
    if (data_.lengthInBytes < QshotStatus.mavlinkEncodedLength) {
      var len = QshotStatus.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var mode = data_.getUint16(0, Endian.little);
    var shotState = data_.getUint16(2, Endian.little);

    return QshotStatus(mode: mode, shotState: shotState);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, mode, Endian.little);
    data_.setUint16(2, shotState, Endian.little);
    return data_;
  }
}

/// Frsky SPort passthrough multi packet container.
///
/// FRSKY_PASSTHROUGH_ARRAY
class FrskyPassthroughArray implements MavlinkMessage {
  static const int _mavlinkMessageId = 60040;

  static const int _mavlinkCrcExtra = 156;

  static const int mavlinkEncodedLength = 245;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Timestamp (time since system boot).
  ///
  /// MAVLink type: uint32_t
  ///
  /// units: ms
  ///
  /// time_boot_ms
  final uint32_t timeBootMs;

  /// Number of passthrough packets in this message.
  ///
  /// MAVLink type: uint8_t
  ///
  /// count
  final uint8_t count;

  /// Passthrough packet buffer. A packet has 6 bytes: uint16_t id + uint32_t data. The array has space for 40 packets.
  ///
  /// MAVLink type: uint8_t[240]
  ///
  /// packet_buf
  final List<int8_t> packetBuf;

  FrskyPassthroughArray({
    required this.timeBootMs,
    required this.count,
    required this.packetBuf,
  });

  FrskyPassthroughArray copyWith({
    uint32_t? timeBootMs,
    uint8_t? count,
    List<int8_t>? packetBuf,
  }) {
    return FrskyPassthroughArray(
      timeBootMs: timeBootMs ?? this.timeBootMs,
      count: count ?? this.count,
      packetBuf: packetBuf ?? this.packetBuf,
    );
  }

  factory FrskyPassthroughArray.parse(ByteData data_) {
    if (data_.lengthInBytes < FrskyPassthroughArray.mavlinkEncodedLength) {
      var len =
          FrskyPassthroughArray.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var timeBootMs = data_.getUint32(0, Endian.little);
    var count = data_.getUint8(4);
    var packetBuf = MavlinkMessage.asUint8List(data_, 5, 240);

    return FrskyPassthroughArray(
        timeBootMs: timeBootMs, count: count, packetBuf: packetBuf);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint32(0, timeBootMs, Endian.little);
    data_.setUint8(4, count);
    MavlinkMessage.setUint8List(data_, 5, packetBuf);
    return data_;
  }
}

/// Parameter multi param value container.
///
/// PARAM_VALUE_ARRAY
class ParamValueArray implements MavlinkMessage {
  static const int _mavlinkMessageId = 60041;

  static const int _mavlinkCrcExtra = 191;

  static const int mavlinkEncodedLength = 255;

  @override
  int get mavlinkMessageId => _mavlinkMessageId;

  @override
  int get mavlinkCrcExtra => _mavlinkCrcExtra;

  /// Total number of onboard parameters.
  ///
  /// MAVLink type: uint16_t
  ///
  /// param_count
  final uint16_t paramCount;

  /// Index of the first onboard parameter in this array.
  ///
  /// MAVLink type: uint16_t
  ///
  /// param_index_first
  final uint16_t paramIndexFirst;

  /// Flags.
  ///
  /// MAVLink type: uint16_t
  ///
  /// flags
  final uint16_t flags;

  /// Number of onboard parameters in this array.
  ///
  /// MAVLink type: uint8_t
  ///
  /// param_array_len
  final uint8_t paramArrayLen;

  /// Parameters buffer. Contains a series of variable length parameter blocks, one per parameter, with format as specifed elsewhere.
  ///
  /// MAVLink type: uint8_t[248]
  ///
  /// packet_buf
  final List<int8_t> packetBuf;

  ParamValueArray({
    required this.paramCount,
    required this.paramIndexFirst,
    required this.flags,
    required this.paramArrayLen,
    required this.packetBuf,
  });

  ParamValueArray copyWith({
    uint16_t? paramCount,
    uint16_t? paramIndexFirst,
    uint16_t? flags,
    uint8_t? paramArrayLen,
    List<int8_t>? packetBuf,
  }) {
    return ParamValueArray(
      paramCount: paramCount ?? this.paramCount,
      paramIndexFirst: paramIndexFirst ?? this.paramIndexFirst,
      flags: flags ?? this.flags,
      paramArrayLen: paramArrayLen ?? this.paramArrayLen,
      packetBuf: packetBuf ?? this.packetBuf,
    );
  }

  factory ParamValueArray.parse(ByteData data_) {
    if (data_.lengthInBytes < ParamValueArray.mavlinkEncodedLength) {
      var len = ParamValueArray.mavlinkEncodedLength - data_.lengthInBytes;
      var d = data_.buffer.asUint8List().sublist(0, data_.lengthInBytes) +
          List<int>.filled(len, 0);
      data_ = Uint8List.fromList(d).buffer.asByteData();
    }
    var paramCount = data_.getUint16(0, Endian.little);
    var paramIndexFirst = data_.getUint16(2, Endian.little);
    var flags = data_.getUint16(4, Endian.little);
    var paramArrayLen = data_.getUint8(6);
    var packetBuf = MavlinkMessage.asUint8List(data_, 7, 248);

    return ParamValueArray(
        paramCount: paramCount,
        paramIndexFirst: paramIndexFirst,
        flags: flags,
        paramArrayLen: paramArrayLen,
        packetBuf: packetBuf);
  }

  @override
  ByteData serialize() {
    var data_ = ByteData(mavlinkEncodedLength);
    data_.setUint16(0, paramCount, Endian.little);
    data_.setUint16(2, paramIndexFirst, Endian.little);
    data_.setUint16(4, flags, Endian.little);
    data_.setUint8(6, paramArrayLen);
    MavlinkMessage.setUint8List(data_, 7, packetBuf);
    return data_;
  }
}

class MavlinkDialectStorm32 implements MavlinkDialect {
  static const int mavlinkVersion = 1;

  @override
  int get version => mavlinkVersion;

  @override
  MavlinkMessage? parse(int messageID, ByteData data) {
    switch (messageID) {
      case 0:
        return Heartbeat.parse(data);
      case 300:
        return ProtocolVersion.parse(data);
      case 1:
        return SysStatus.parse(data);
      case 2:
        return SystemTime.parse(data);
      case 4:
        return Ping.parse(data);
      case 5:
        return ChangeOperatorControl.parse(data);
      case 6:
        return ChangeOperatorControlAck.parse(data);
      case 7:
        return AuthKey.parse(data);
      case 8:
        return LinkNodeStatus.parse(data);
      case 11:
        return SetMode.parse(data);
      case 20:
        return ParamRequestRead.parse(data);
      case 21:
        return ParamRequestList.parse(data);
      case 22:
        return ParamValue.parse(data);
      case 23:
        return ParamSet.parse(data);
      case 24:
        return GpsRawInt.parse(data);
      case 25:
        return GpsStatus.parse(data);
      case 26:
        return ScaledImu.parse(data);
      case 27:
        return RawImu.parse(data);
      case 28:
        return RawPressure.parse(data);
      case 29:
        return ScaledPressure.parse(data);
      case 30:
        return Attitude.parse(data);
      case 31:
        return AttitudeQuaternion.parse(data);
      case 32:
        return LocalPositionNed.parse(data);
      case 33:
        return GlobalPositionInt.parse(data);
      case 34:
        return RcChannelsScaled.parse(data);
      case 35:
        return RcChannelsRaw.parse(data);
      case 36:
        return ServoOutputRaw.parse(data);
      case 37:
        return MissionRequestPartialList.parse(data);
      case 38:
        return MissionWritePartialList.parse(data);
      case 39:
        return MissionItem.parse(data);
      case 40:
        return MissionRequest.parse(data);
      case 41:
        return MissionSetCurrent.parse(data);
      case 42:
        return MissionCurrent.parse(data);
      case 43:
        return MissionRequestList.parse(data);
      case 44:
        return MissionCount.parse(data);
      case 45:
        return MissionClearAll.parse(data);
      case 46:
        return MissionItemReached.parse(data);
      case 47:
        return MissionAck.parse(data);
      case 48:
        return SetGpsGlobalOrigin.parse(data);
      case 49:
        return GpsGlobalOrigin.parse(data);
      case 50:
        return ParamMapRc.parse(data);
      case 51:
        return MissionRequestInt.parse(data);
      case 54:
        return SafetySetAllowedArea.parse(data);
      case 55:
        return SafetyAllowedArea.parse(data);
      case 61:
        return AttitudeQuaternionCov.parse(data);
      case 62:
        return NavControllerOutput.parse(data);
      case 63:
        return GlobalPositionIntCov.parse(data);
      case 64:
        return LocalPositionNedCov.parse(data);
      case 65:
        return RcChannels.parse(data);
      case 66:
        return RequestDataStream.parse(data);
      case 67:
        return DataStream.parse(data);
      case 69:
        return ManualControl.parse(data);
      case 70:
        return RcChannelsOverride.parse(data);
      case 73:
        return MissionItemInt.parse(data);
      case 74:
        return VfrHud.parse(data);
      case 75:
        return CommandInt.parse(data);
      case 76:
        return CommandLong.parse(data);
      case 77:
        return CommandAck.parse(data);
      case 80:
        return CommandCancel.parse(data);
      case 81:
        return ManualSetpoint.parse(data);
      case 82:
        return SetAttitudeTarget.parse(data);
      case 83:
        return AttitudeTarget.parse(data);
      case 84:
        return SetPositionTargetLocalNed.parse(data);
      case 85:
        return PositionTargetLocalNed.parse(data);
      case 86:
        return SetPositionTargetGlobalInt.parse(data);
      case 87:
        return PositionTargetGlobalInt.parse(data);
      case 89:
        return LocalPositionNedSystemGlobalOffset.parse(data);
      case 90:
        return HilState.parse(data);
      case 91:
        return HilControls.parse(data);
      case 92:
        return HilRcInputsRaw.parse(data);
      case 93:
        return HilActuatorControls.parse(data);
      case 100:
        return OpticalFlow.parse(data);
      case 101:
        return GlobalVisionPositionEstimate.parse(data);
      case 102:
        return VisionPositionEstimate.parse(data);
      case 103:
        return VisionSpeedEstimate.parse(data);
      case 104:
        return ViconPositionEstimate.parse(data);
      case 105:
        return HighresImu.parse(data);
      case 106:
        return OpticalFlowRad.parse(data);
      case 107:
        return HilSensor.parse(data);
      case 108:
        return SimState.parse(data);
      case 109:
        return RadioStatus.parse(data);
      case 110:
        return FileTransferProtocol.parse(data);
      case 111:
        return Timesync.parse(data);
      case 112:
        return CameraTrigger.parse(data);
      case 113:
        return HilGps.parse(data);
      case 114:
        return HilOpticalFlow.parse(data);
      case 115:
        return HilStateQuaternion.parse(data);
      case 116:
        return ScaledImu2.parse(data);
      case 117:
        return LogRequestList.parse(data);
      case 118:
        return LogEntry.parse(data);
      case 119:
        return LogRequestData.parse(data);
      case 120:
        return LogData.parse(data);
      case 121:
        return LogErase.parse(data);
      case 122:
        return LogRequestEnd.parse(data);
      case 123:
        return GpsInjectData.parse(data);
      case 124:
        return Gps2Raw.parse(data);
      case 125:
        return PowerStatus.parse(data);
      case 126:
        return SerialControl.parse(data);
      case 127:
        return GpsRtk.parse(data);
      case 128:
        return Gps2Rtk.parse(data);
      case 129:
        return ScaledImu3.parse(data);
      case 130:
        return DataTransmissionHandshake.parse(data);
      case 131:
        return EncapsulatedData.parse(data);
      case 132:
        return DistanceSensor.parse(data);
      case 133:
        return TerrainRequest.parse(data);
      case 134:
        return TerrainData.parse(data);
      case 135:
        return TerrainCheck.parse(data);
      case 136:
        return TerrainReport.parse(data);
      case 137:
        return ScaledPressure2.parse(data);
      case 138:
        return AttPosMocap.parse(data);
      case 139:
        return SetActuatorControlTarget.parse(data);
      case 140:
        return ActuatorControlTarget.parse(data);
      case 141:
        return Altitude.parse(data);
      case 142:
        return ResourceRequest.parse(data);
      case 143:
        return ScaledPressure3.parse(data);
      case 144:
        return FollowTarget.parse(data);
      case 146:
        return ControlSystemState.parse(data);
      case 147:
        return BatteryStatus.parse(data);
      case 148:
        return AutopilotVersion.parse(data);
      case 149:
        return LandingTarget.parse(data);
      case 162:
        return FenceStatus.parse(data);
      case 192:
        return MagCalReport.parse(data);
      case 225:
        return EfiStatus.parse(data);
      case 230:
        return EstimatorStatus.parse(data);
      case 231:
        return WindCov.parse(data);
      case 232:
        return GpsInput.parse(data);
      case 233:
        return GpsRtcmData.parse(data);
      case 234:
        return HighLatency.parse(data);
      case 235:
        return HighLatency2.parse(data);
      case 241:
        return Vibration.parse(data);
      case 242:
        return HomePosition.parse(data);
      case 243:
        return SetHomePosition.parse(data);
      case 244:
        return MessageInterval.parse(data);
      case 245:
        return ExtendedSysState.parse(data);
      case 246:
        return AdsbVehicle.parse(data);
      case 247:
        return Collision.parse(data);
      case 248:
        return V2Extension.parse(data);
      case 249:
        return MemoryVect.parse(data);
      case 250:
        return DebugVect.parse(data);
      case 251:
        return NamedValueFloat.parse(data);
      case 252:
        return NamedValueInt.parse(data);
      case 253:
        return Statustext.parse(data);
      case 254:
        return Debug.parse(data);
      case 256:
        return SetupSigning.parse(data);
      case 257:
        return ButtonChange.parse(data);
      case 258:
        return PlayTune.parse(data);
      case 259:
        return CameraInformation.parse(data);
      case 260:
        return CameraSettings.parse(data);
      case 261:
        return StorageInformation.parse(data);
      case 262:
        return CameraCaptureStatus.parse(data);
      case 263:
        return CameraImageCaptured.parse(data);
      case 264:
        return FlightInformation.parse(data);
      case 265:
        return MountOrientation.parse(data);
      case 266:
        return LoggingData.parse(data);
      case 267:
        return LoggingDataAcked.parse(data);
      case 268:
        return LoggingAck.parse(data);
      case 269:
        return VideoStreamInformation.parse(data);
      case 270:
        return VideoStreamStatus.parse(data);
      case 271:
        return CameraFovStatus.parse(data);
      case 275:
        return CameraTrackingImageStatus.parse(data);
      case 276:
        return CameraTrackingGeoStatus.parse(data);
      case 277:
        return CameraThermalRange.parse(data);
      case 280:
        return GimbalManagerInformation.parse(data);
      case 281:
        return GimbalManagerStatus.parse(data);
      case 282:
        return GimbalManagerSetAttitude.parse(data);
      case 283:
        return GimbalDeviceInformation.parse(data);
      case 284:
        return GimbalDeviceSetAttitude.parse(data);
      case 285:
        return GimbalDeviceAttitudeStatus.parse(data);
      case 286:
        return AutopilotStateForGimbalDevice.parse(data);
      case 287:
        return GimbalManagerSetPitchyaw.parse(data);
      case 288:
        return GimbalManagerSetManualControl.parse(data);
      case 290:
        return EscInfo.parse(data);
      case 291:
        return EscStatus.parse(data);
      case 299:
        return WifiConfigAp.parse(data);
      case 301:
        return AisVessel.parse(data);
      case 310:
        return UavcanNodeStatus.parse(data);
      case 311:
        return UavcanNodeInfo.parse(data);
      case 320:
        return ParamExtRequestRead.parse(data);
      case 321:
        return ParamExtRequestList.parse(data);
      case 322:
        return ParamExtValue.parse(data);
      case 323:
        return ParamExtSet.parse(data);
      case 324:
        return ParamExtAck.parse(data);
      case 330:
        return ObstacleDistance.parse(data);
      case 331:
        return Odometry.parse(data);
      case 332:
        return TrajectoryRepresentationWaypoints.parse(data);
      case 333:
        return TrajectoryRepresentationBezier.parse(data);
      case 334:
        return CellularStatus.parse(data);
      case 335:
        return IsbdLinkStatus.parse(data);
      case 336:
        return CellularConfig.parse(data);
      case 339:
        return RawRpm.parse(data);
      case 340:
        return UtmGlobalPosition.parse(data);
      case 350:
        return DebugFloatArray.parse(data);
      case 360:
        return OrbitExecutionStatus.parse(data);
      case 370:
        return BatteryInfo.parse(data);
      case 373:
        return GeneratorStatus.parse(data);
      case 375:
        return ActuatorOutputStatus.parse(data);
      case 380:
        return TimeEstimateToTarget.parse(data);
      case 385:
        return Tunnel.parse(data);
      case 386:
        return CanFrame.parse(data);
      case 390:
        return OnboardComputerStatus.parse(data);
      case 395:
        return ComponentInformation.parse(data);
      case 396:
        return ComponentInformationBasic.parse(data);
      case 397:
        return ComponentMetadata.parse(data);
      case 400:
        return PlayTuneV2.parse(data);
      case 401:
        return SupportedTunes.parse(data);
      case 410:
        return Event.parse(data);
      case 411:
        return CurrentEventSequence.parse(data);
      case 412:
        return RequestEvent.parse(data);
      case 413:
        return ResponseEventError.parse(data);
      case 440:
        return IlluminatorStatus.parse(data);
      case 387:
        return CanfdFrame.parse(data);
      case 388:
        return CanFilterModify.parse(data);
      case 9000:
        return WheelDistance.parse(data);
      case 9005:
        return WinchStatus.parse(data);
      case 12900:
        return OpenDroneIdBasicId.parse(data);
      case 12901:
        return OpenDroneIdLocation.parse(data);
      case 12902:
        return OpenDroneIdAuthentication.parse(data);
      case 12903:
        return OpenDroneIdSelfId.parse(data);
      case 12904:
        return OpenDroneIdSystem.parse(data);
      case 12905:
        return OpenDroneIdOperatorId.parse(data);
      case 12915:
        return OpenDroneIdMessagePack.parse(data);
      case 12918:
        return OpenDroneIdArmStatus.parse(data);
      case 12919:
        return OpenDroneIdSystemUpdate.parse(data);
      case 12920:
        return HygrometerSensor.parse(data);
      case 10001:
        return UavionixAdsbOutCfg.parse(data);
      case 10002:
        return UavionixAdsbOutDynamic.parse(data);
      case 10003:
        return UavionixAdsbTransceiverHealthReport.parse(data);
      case 42000:
        return IcarousHeartbeat.parse(data);
      case 42001:
        return IcarousKinematicBands.parse(data);
      case 50001:
        return CubepilotRawRc.parse(data);
      case 50002:
        return HerelinkVideoStreamInformation.parse(data);
      case 50003:
        return HerelinkTelem.parse(data);
      case 50004:
        return CubepilotFirmwareUpdateStart.parse(data);
      case 50005:
        return CubepilotFirmwareUpdateResp.parse(data);
      case 52000:
        return AirlinkAuth.parse(data);
      case 52001:
        return AirlinkAuthResponse.parse(data);
      case 52002:
        return AirlinkEyeGsHolePushRequest.parse(data);
      case 52003:
        return AirlinkEyeGsHolePushResponse.parse(data);
      case 52004:
        return AirlinkEyeHp.parse(data);
      case 52005:
        return AirlinkEyeTurnInit.parse(data);
      case 150:
        return SensorOffsets.parse(data);
      case 151:
        return SetMagOffsets.parse(data);
      case 152:
        return Meminfo.parse(data);
      case 153:
        return ApAdc.parse(data);
      case 154:
        return DigicamConfigure.parse(data);
      case 155:
        return DigicamControl.parse(data);
      case 156:
        return MountConfigure.parse(data);
      case 157:
        return MountControl.parse(data);
      case 158:
        return MountStatus.parse(data);
      case 160:
        return FencePoint.parse(data);
      case 161:
        return FenceFetchPoint.parse(data);
      case 163:
        return Ahrs.parse(data);
      case 164:
        return Simstate.parse(data);
      case 165:
        return Hwstatus.parse(data);
      case 166:
        return Radio.parse(data);
      case 167:
        return LimitsStatus.parse(data);
      case 168:
        return Wind.parse(data);
      case 169:
        return Data16.parse(data);
      case 170:
        return Data32.parse(data);
      case 171:
        return Data64.parse(data);
      case 172:
        return Data96.parse(data);
      case 173:
        return Rangefinder.parse(data);
      case 174:
        return AirspeedAutocal.parse(data);
      case 175:
        return RallyPoint.parse(data);
      case 176:
        return RallyFetchPoint.parse(data);
      case 177:
        return CompassmotStatus.parse(data);
      case 178:
        return Ahrs2.parse(data);
      case 179:
        return CameraStatus.parse(data);
      case 180:
        return CameraFeedback.parse(data);
      case 181:
        return Battery2.parse(data);
      case 182:
        return Ahrs3.parse(data);
      case 183:
        return AutopilotVersionRequest.parse(data);
      case 184:
        return RemoteLogDataBlock.parse(data);
      case 185:
        return RemoteLogBlockStatus.parse(data);
      case 186:
        return LedControl.parse(data);
      case 191:
        return MagCalProgress.parse(data);
      case 193:
        return EkfStatusReport.parse(data);
      case 194:
        return PidTuning.parse(data);
      case 195:
        return Deepstall.parse(data);
      case 200:
        return GimbalReport.parse(data);
      case 201:
        return GimbalControl.parse(data);
      case 214:
        return GimbalTorqueCmdReport.parse(data);
      case 215:
        return GoproHeartbeat.parse(data);
      case 216:
        return GoproGetRequest.parse(data);
      case 217:
        return GoproGetResponse.parse(data);
      case 218:
        return GoproSetRequest.parse(data);
      case 219:
        return GoproSetResponse.parse(data);
      case 226:
        return Rpm.parse(data);
      case 11000:
        return DeviceOpRead.parse(data);
      case 11001:
        return DeviceOpReadReply.parse(data);
      case 11002:
        return DeviceOpWrite.parse(data);
      case 11003:
        return DeviceOpWriteReply.parse(data);
      case 11010:
        return AdapTuning.parse(data);
      case 11011:
        return VisionPositionDelta.parse(data);
      case 11020:
        return AoaSsa.parse(data);
      case 11030:
        return EscTelemetry1To4.parse(data);
      case 11031:
        return EscTelemetry5To8.parse(data);
      case 11032:
        return EscTelemetry9To12.parse(data);
      case 11033:
        return OsdParamConfig.parse(data);
      case 11034:
        return OsdParamConfigReply.parse(data);
      case 11035:
        return OsdParamShowConfig.parse(data);
      case 11036:
        return OsdParamShowConfigReply.parse(data);
      case 11037:
        return ObstacleDistance3d.parse(data);
      case 11038:
        return WaterDepth.parse(data);
      case 11039:
        return McuStatus.parse(data);
      case 60010:
        return Storm32GimbalManagerInformation.parse(data);
      case 60011:
        return Storm32GimbalManagerStatus.parse(data);
      case 60012:
        return Storm32GimbalManagerControl.parse(data);
      case 60013:
        return Storm32GimbalManagerControlPitchyaw.parse(data);
      case 60014:
        return Storm32GimbalManagerCorrectRoll.parse(data);
      case 60020:
        return QshotStatus.parse(data);
      case 60040:
        return FrskyPassthroughArray.parse(data);
      case 60041:
        return ParamValueArray.parse(data);
      default:
        return null;
    }
  }

  @override
  int crcExtra(int messageID) {
    switch (messageID) {
      case 0:
        return Heartbeat._mavlinkCrcExtra;
      case 300:
        return ProtocolVersion._mavlinkCrcExtra;
      case 1:
        return SysStatus._mavlinkCrcExtra;
      case 2:
        return SystemTime._mavlinkCrcExtra;
      case 4:
        return Ping._mavlinkCrcExtra;
      case 5:
        return ChangeOperatorControl._mavlinkCrcExtra;
      case 6:
        return ChangeOperatorControlAck._mavlinkCrcExtra;
      case 7:
        return AuthKey._mavlinkCrcExtra;
      case 8:
        return LinkNodeStatus._mavlinkCrcExtra;
      case 11:
        return SetMode._mavlinkCrcExtra;
      case 20:
        return ParamRequestRead._mavlinkCrcExtra;
      case 21:
        return ParamRequestList._mavlinkCrcExtra;
      case 22:
        return ParamValue._mavlinkCrcExtra;
      case 23:
        return ParamSet._mavlinkCrcExtra;
      case 24:
        return GpsRawInt._mavlinkCrcExtra;
      case 25:
        return GpsStatus._mavlinkCrcExtra;
      case 26:
        return ScaledImu._mavlinkCrcExtra;
      case 27:
        return RawImu._mavlinkCrcExtra;
      case 28:
        return RawPressure._mavlinkCrcExtra;
      case 29:
        return ScaledPressure._mavlinkCrcExtra;
      case 30:
        return Attitude._mavlinkCrcExtra;
      case 31:
        return AttitudeQuaternion._mavlinkCrcExtra;
      case 32:
        return LocalPositionNed._mavlinkCrcExtra;
      case 33:
        return GlobalPositionInt._mavlinkCrcExtra;
      case 34:
        return RcChannelsScaled._mavlinkCrcExtra;
      case 35:
        return RcChannelsRaw._mavlinkCrcExtra;
      case 36:
        return ServoOutputRaw._mavlinkCrcExtra;
      case 37:
        return MissionRequestPartialList._mavlinkCrcExtra;
      case 38:
        return MissionWritePartialList._mavlinkCrcExtra;
      case 39:
        return MissionItem._mavlinkCrcExtra;
      case 40:
        return MissionRequest._mavlinkCrcExtra;
      case 41:
        return MissionSetCurrent._mavlinkCrcExtra;
      case 42:
        return MissionCurrent._mavlinkCrcExtra;
      case 43:
        return MissionRequestList._mavlinkCrcExtra;
      case 44:
        return MissionCount._mavlinkCrcExtra;
      case 45:
        return MissionClearAll._mavlinkCrcExtra;
      case 46:
        return MissionItemReached._mavlinkCrcExtra;
      case 47:
        return MissionAck._mavlinkCrcExtra;
      case 48:
        return SetGpsGlobalOrigin._mavlinkCrcExtra;
      case 49:
        return GpsGlobalOrigin._mavlinkCrcExtra;
      case 50:
        return ParamMapRc._mavlinkCrcExtra;
      case 51:
        return MissionRequestInt._mavlinkCrcExtra;
      case 54:
        return SafetySetAllowedArea._mavlinkCrcExtra;
      case 55:
        return SafetyAllowedArea._mavlinkCrcExtra;
      case 61:
        return AttitudeQuaternionCov._mavlinkCrcExtra;
      case 62:
        return NavControllerOutput._mavlinkCrcExtra;
      case 63:
        return GlobalPositionIntCov._mavlinkCrcExtra;
      case 64:
        return LocalPositionNedCov._mavlinkCrcExtra;
      case 65:
        return RcChannels._mavlinkCrcExtra;
      case 66:
        return RequestDataStream._mavlinkCrcExtra;
      case 67:
        return DataStream._mavlinkCrcExtra;
      case 69:
        return ManualControl._mavlinkCrcExtra;
      case 70:
        return RcChannelsOverride._mavlinkCrcExtra;
      case 73:
        return MissionItemInt._mavlinkCrcExtra;
      case 74:
        return VfrHud._mavlinkCrcExtra;
      case 75:
        return CommandInt._mavlinkCrcExtra;
      case 76:
        return CommandLong._mavlinkCrcExtra;
      case 77:
        return CommandAck._mavlinkCrcExtra;
      case 80:
        return CommandCancel._mavlinkCrcExtra;
      case 81:
        return ManualSetpoint._mavlinkCrcExtra;
      case 82:
        return SetAttitudeTarget._mavlinkCrcExtra;
      case 83:
        return AttitudeTarget._mavlinkCrcExtra;
      case 84:
        return SetPositionTargetLocalNed._mavlinkCrcExtra;
      case 85:
        return PositionTargetLocalNed._mavlinkCrcExtra;
      case 86:
        return SetPositionTargetGlobalInt._mavlinkCrcExtra;
      case 87:
        return PositionTargetGlobalInt._mavlinkCrcExtra;
      case 89:
        return LocalPositionNedSystemGlobalOffset._mavlinkCrcExtra;
      case 90:
        return HilState._mavlinkCrcExtra;
      case 91:
        return HilControls._mavlinkCrcExtra;
      case 92:
        return HilRcInputsRaw._mavlinkCrcExtra;
      case 93:
        return HilActuatorControls._mavlinkCrcExtra;
      case 100:
        return OpticalFlow._mavlinkCrcExtra;
      case 101:
        return GlobalVisionPositionEstimate._mavlinkCrcExtra;
      case 102:
        return VisionPositionEstimate._mavlinkCrcExtra;
      case 103:
        return VisionSpeedEstimate._mavlinkCrcExtra;
      case 104:
        return ViconPositionEstimate._mavlinkCrcExtra;
      case 105:
        return HighresImu._mavlinkCrcExtra;
      case 106:
        return OpticalFlowRad._mavlinkCrcExtra;
      case 107:
        return HilSensor._mavlinkCrcExtra;
      case 108:
        return SimState._mavlinkCrcExtra;
      case 109:
        return RadioStatus._mavlinkCrcExtra;
      case 110:
        return FileTransferProtocol._mavlinkCrcExtra;
      case 111:
        return Timesync._mavlinkCrcExtra;
      case 112:
        return CameraTrigger._mavlinkCrcExtra;
      case 113:
        return HilGps._mavlinkCrcExtra;
      case 114:
        return HilOpticalFlow._mavlinkCrcExtra;
      case 115:
        return HilStateQuaternion._mavlinkCrcExtra;
      case 116:
        return ScaledImu2._mavlinkCrcExtra;
      case 117:
        return LogRequestList._mavlinkCrcExtra;
      case 118:
        return LogEntry._mavlinkCrcExtra;
      case 119:
        return LogRequestData._mavlinkCrcExtra;
      case 120:
        return LogData._mavlinkCrcExtra;
      case 121:
        return LogErase._mavlinkCrcExtra;
      case 122:
        return LogRequestEnd._mavlinkCrcExtra;
      case 123:
        return GpsInjectData._mavlinkCrcExtra;
      case 124:
        return Gps2Raw._mavlinkCrcExtra;
      case 125:
        return PowerStatus._mavlinkCrcExtra;
      case 126:
        return SerialControl._mavlinkCrcExtra;
      case 127:
        return GpsRtk._mavlinkCrcExtra;
      case 128:
        return Gps2Rtk._mavlinkCrcExtra;
      case 129:
        return ScaledImu3._mavlinkCrcExtra;
      case 130:
        return DataTransmissionHandshake._mavlinkCrcExtra;
      case 131:
        return EncapsulatedData._mavlinkCrcExtra;
      case 132:
        return DistanceSensor._mavlinkCrcExtra;
      case 133:
        return TerrainRequest._mavlinkCrcExtra;
      case 134:
        return TerrainData._mavlinkCrcExtra;
      case 135:
        return TerrainCheck._mavlinkCrcExtra;
      case 136:
        return TerrainReport._mavlinkCrcExtra;
      case 137:
        return ScaledPressure2._mavlinkCrcExtra;
      case 138:
        return AttPosMocap._mavlinkCrcExtra;
      case 139:
        return SetActuatorControlTarget._mavlinkCrcExtra;
      case 140:
        return ActuatorControlTarget._mavlinkCrcExtra;
      case 141:
        return Altitude._mavlinkCrcExtra;
      case 142:
        return ResourceRequest._mavlinkCrcExtra;
      case 143:
        return ScaledPressure3._mavlinkCrcExtra;
      case 144:
        return FollowTarget._mavlinkCrcExtra;
      case 146:
        return ControlSystemState._mavlinkCrcExtra;
      case 147:
        return BatteryStatus._mavlinkCrcExtra;
      case 148:
        return AutopilotVersion._mavlinkCrcExtra;
      case 149:
        return LandingTarget._mavlinkCrcExtra;
      case 162:
        return FenceStatus._mavlinkCrcExtra;
      case 192:
        return MagCalReport._mavlinkCrcExtra;
      case 225:
        return EfiStatus._mavlinkCrcExtra;
      case 230:
        return EstimatorStatus._mavlinkCrcExtra;
      case 231:
        return WindCov._mavlinkCrcExtra;
      case 232:
        return GpsInput._mavlinkCrcExtra;
      case 233:
        return GpsRtcmData._mavlinkCrcExtra;
      case 234:
        return HighLatency._mavlinkCrcExtra;
      case 235:
        return HighLatency2._mavlinkCrcExtra;
      case 241:
        return Vibration._mavlinkCrcExtra;
      case 242:
        return HomePosition._mavlinkCrcExtra;
      case 243:
        return SetHomePosition._mavlinkCrcExtra;
      case 244:
        return MessageInterval._mavlinkCrcExtra;
      case 245:
        return ExtendedSysState._mavlinkCrcExtra;
      case 246:
        return AdsbVehicle._mavlinkCrcExtra;
      case 247:
        return Collision._mavlinkCrcExtra;
      case 248:
        return V2Extension._mavlinkCrcExtra;
      case 249:
        return MemoryVect._mavlinkCrcExtra;
      case 250:
        return DebugVect._mavlinkCrcExtra;
      case 251:
        return NamedValueFloat._mavlinkCrcExtra;
      case 252:
        return NamedValueInt._mavlinkCrcExtra;
      case 253:
        return Statustext._mavlinkCrcExtra;
      case 254:
        return Debug._mavlinkCrcExtra;
      case 256:
        return SetupSigning._mavlinkCrcExtra;
      case 257:
        return ButtonChange._mavlinkCrcExtra;
      case 258:
        return PlayTune._mavlinkCrcExtra;
      case 259:
        return CameraInformation._mavlinkCrcExtra;
      case 260:
        return CameraSettings._mavlinkCrcExtra;
      case 261:
        return StorageInformation._mavlinkCrcExtra;
      case 262:
        return CameraCaptureStatus._mavlinkCrcExtra;
      case 263:
        return CameraImageCaptured._mavlinkCrcExtra;
      case 264:
        return FlightInformation._mavlinkCrcExtra;
      case 265:
        return MountOrientation._mavlinkCrcExtra;
      case 266:
        return LoggingData._mavlinkCrcExtra;
      case 267:
        return LoggingDataAcked._mavlinkCrcExtra;
      case 268:
        return LoggingAck._mavlinkCrcExtra;
      case 269:
        return VideoStreamInformation._mavlinkCrcExtra;
      case 270:
        return VideoStreamStatus._mavlinkCrcExtra;
      case 271:
        return CameraFovStatus._mavlinkCrcExtra;
      case 275:
        return CameraTrackingImageStatus._mavlinkCrcExtra;
      case 276:
        return CameraTrackingGeoStatus._mavlinkCrcExtra;
      case 277:
        return CameraThermalRange._mavlinkCrcExtra;
      case 280:
        return GimbalManagerInformation._mavlinkCrcExtra;
      case 281:
        return GimbalManagerStatus._mavlinkCrcExtra;
      case 282:
        return GimbalManagerSetAttitude._mavlinkCrcExtra;
      case 283:
        return GimbalDeviceInformation._mavlinkCrcExtra;
      case 284:
        return GimbalDeviceSetAttitude._mavlinkCrcExtra;
      case 285:
        return GimbalDeviceAttitudeStatus._mavlinkCrcExtra;
      case 286:
        return AutopilotStateForGimbalDevice._mavlinkCrcExtra;
      case 287:
        return GimbalManagerSetPitchyaw._mavlinkCrcExtra;
      case 288:
        return GimbalManagerSetManualControl._mavlinkCrcExtra;
      case 290:
        return EscInfo._mavlinkCrcExtra;
      case 291:
        return EscStatus._mavlinkCrcExtra;
      case 299:
        return WifiConfigAp._mavlinkCrcExtra;
      case 301:
        return AisVessel._mavlinkCrcExtra;
      case 310:
        return UavcanNodeStatus._mavlinkCrcExtra;
      case 311:
        return UavcanNodeInfo._mavlinkCrcExtra;
      case 320:
        return ParamExtRequestRead._mavlinkCrcExtra;
      case 321:
        return ParamExtRequestList._mavlinkCrcExtra;
      case 322:
        return ParamExtValue._mavlinkCrcExtra;
      case 323:
        return ParamExtSet._mavlinkCrcExtra;
      case 324:
        return ParamExtAck._mavlinkCrcExtra;
      case 330:
        return ObstacleDistance._mavlinkCrcExtra;
      case 331:
        return Odometry._mavlinkCrcExtra;
      case 332:
        return TrajectoryRepresentationWaypoints._mavlinkCrcExtra;
      case 333:
        return TrajectoryRepresentationBezier._mavlinkCrcExtra;
      case 334:
        return CellularStatus._mavlinkCrcExtra;
      case 335:
        return IsbdLinkStatus._mavlinkCrcExtra;
      case 336:
        return CellularConfig._mavlinkCrcExtra;
      case 339:
        return RawRpm._mavlinkCrcExtra;
      case 340:
        return UtmGlobalPosition._mavlinkCrcExtra;
      case 350:
        return DebugFloatArray._mavlinkCrcExtra;
      case 360:
        return OrbitExecutionStatus._mavlinkCrcExtra;
      case 370:
        return BatteryInfo._mavlinkCrcExtra;
      case 373:
        return GeneratorStatus._mavlinkCrcExtra;
      case 375:
        return ActuatorOutputStatus._mavlinkCrcExtra;
      case 380:
        return TimeEstimateToTarget._mavlinkCrcExtra;
      case 385:
        return Tunnel._mavlinkCrcExtra;
      case 386:
        return CanFrame._mavlinkCrcExtra;
      case 390:
        return OnboardComputerStatus._mavlinkCrcExtra;
      case 395:
        return ComponentInformation._mavlinkCrcExtra;
      case 396:
        return ComponentInformationBasic._mavlinkCrcExtra;
      case 397:
        return ComponentMetadata._mavlinkCrcExtra;
      case 400:
        return PlayTuneV2._mavlinkCrcExtra;
      case 401:
        return SupportedTunes._mavlinkCrcExtra;
      case 410:
        return Event._mavlinkCrcExtra;
      case 411:
        return CurrentEventSequence._mavlinkCrcExtra;
      case 412:
        return RequestEvent._mavlinkCrcExtra;
      case 413:
        return ResponseEventError._mavlinkCrcExtra;
      case 440:
        return IlluminatorStatus._mavlinkCrcExtra;
      case 387:
        return CanfdFrame._mavlinkCrcExtra;
      case 388:
        return CanFilterModify._mavlinkCrcExtra;
      case 9000:
        return WheelDistance._mavlinkCrcExtra;
      case 9005:
        return WinchStatus._mavlinkCrcExtra;
      case 12900:
        return OpenDroneIdBasicId._mavlinkCrcExtra;
      case 12901:
        return OpenDroneIdLocation._mavlinkCrcExtra;
      case 12902:
        return OpenDroneIdAuthentication._mavlinkCrcExtra;
      case 12903:
        return OpenDroneIdSelfId._mavlinkCrcExtra;
      case 12904:
        return OpenDroneIdSystem._mavlinkCrcExtra;
      case 12905:
        return OpenDroneIdOperatorId._mavlinkCrcExtra;
      case 12915:
        return OpenDroneIdMessagePack._mavlinkCrcExtra;
      case 12918:
        return OpenDroneIdArmStatus._mavlinkCrcExtra;
      case 12919:
        return OpenDroneIdSystemUpdate._mavlinkCrcExtra;
      case 12920:
        return HygrometerSensor._mavlinkCrcExtra;
      case 10001:
        return UavionixAdsbOutCfg._mavlinkCrcExtra;
      case 10002:
        return UavionixAdsbOutDynamic._mavlinkCrcExtra;
      case 10003:
        return UavionixAdsbTransceiverHealthReport._mavlinkCrcExtra;
      case 42000:
        return IcarousHeartbeat._mavlinkCrcExtra;
      case 42001:
        return IcarousKinematicBands._mavlinkCrcExtra;
      case 50001:
        return CubepilotRawRc._mavlinkCrcExtra;
      case 50002:
        return HerelinkVideoStreamInformation._mavlinkCrcExtra;
      case 50003:
        return HerelinkTelem._mavlinkCrcExtra;
      case 50004:
        return CubepilotFirmwareUpdateStart._mavlinkCrcExtra;
      case 50005:
        return CubepilotFirmwareUpdateResp._mavlinkCrcExtra;
      case 52000:
        return AirlinkAuth._mavlinkCrcExtra;
      case 52001:
        return AirlinkAuthResponse._mavlinkCrcExtra;
      case 52002:
        return AirlinkEyeGsHolePushRequest._mavlinkCrcExtra;
      case 52003:
        return AirlinkEyeGsHolePushResponse._mavlinkCrcExtra;
      case 52004:
        return AirlinkEyeHp._mavlinkCrcExtra;
      case 52005:
        return AirlinkEyeTurnInit._mavlinkCrcExtra;
      case 150:
        return SensorOffsets._mavlinkCrcExtra;
      case 151:
        return SetMagOffsets._mavlinkCrcExtra;
      case 152:
        return Meminfo._mavlinkCrcExtra;
      case 153:
        return ApAdc._mavlinkCrcExtra;
      case 154:
        return DigicamConfigure._mavlinkCrcExtra;
      case 155:
        return DigicamControl._mavlinkCrcExtra;
      case 156:
        return MountConfigure._mavlinkCrcExtra;
      case 157:
        return MountControl._mavlinkCrcExtra;
      case 158:
        return MountStatus._mavlinkCrcExtra;
      case 160:
        return FencePoint._mavlinkCrcExtra;
      case 161:
        return FenceFetchPoint._mavlinkCrcExtra;
      case 163:
        return Ahrs._mavlinkCrcExtra;
      case 164:
        return Simstate._mavlinkCrcExtra;
      case 165:
        return Hwstatus._mavlinkCrcExtra;
      case 166:
        return Radio._mavlinkCrcExtra;
      case 167:
        return LimitsStatus._mavlinkCrcExtra;
      case 168:
        return Wind._mavlinkCrcExtra;
      case 169:
        return Data16._mavlinkCrcExtra;
      case 170:
        return Data32._mavlinkCrcExtra;
      case 171:
        return Data64._mavlinkCrcExtra;
      case 172:
        return Data96._mavlinkCrcExtra;
      case 173:
        return Rangefinder._mavlinkCrcExtra;
      case 174:
        return AirspeedAutocal._mavlinkCrcExtra;
      case 175:
        return RallyPoint._mavlinkCrcExtra;
      case 176:
        return RallyFetchPoint._mavlinkCrcExtra;
      case 177:
        return CompassmotStatus._mavlinkCrcExtra;
      case 178:
        return Ahrs2._mavlinkCrcExtra;
      case 179:
        return CameraStatus._mavlinkCrcExtra;
      case 180:
        return CameraFeedback._mavlinkCrcExtra;
      case 181:
        return Battery2._mavlinkCrcExtra;
      case 182:
        return Ahrs3._mavlinkCrcExtra;
      case 183:
        return AutopilotVersionRequest._mavlinkCrcExtra;
      case 184:
        return RemoteLogDataBlock._mavlinkCrcExtra;
      case 185:
        return RemoteLogBlockStatus._mavlinkCrcExtra;
      case 186:
        return LedControl._mavlinkCrcExtra;
      case 191:
        return MagCalProgress._mavlinkCrcExtra;
      case 193:
        return EkfStatusReport._mavlinkCrcExtra;
      case 194:
        return PidTuning._mavlinkCrcExtra;
      case 195:
        return Deepstall._mavlinkCrcExtra;
      case 200:
        return GimbalReport._mavlinkCrcExtra;
      case 201:
        return GimbalControl._mavlinkCrcExtra;
      case 214:
        return GimbalTorqueCmdReport._mavlinkCrcExtra;
      case 215:
        return GoproHeartbeat._mavlinkCrcExtra;
      case 216:
        return GoproGetRequest._mavlinkCrcExtra;
      case 217:
        return GoproGetResponse._mavlinkCrcExtra;
      case 218:
        return GoproSetRequest._mavlinkCrcExtra;
      case 219:
        return GoproSetResponse._mavlinkCrcExtra;
      case 226:
        return Rpm._mavlinkCrcExtra;
      case 11000:
        return DeviceOpRead._mavlinkCrcExtra;
      case 11001:
        return DeviceOpReadReply._mavlinkCrcExtra;
      case 11002:
        return DeviceOpWrite._mavlinkCrcExtra;
      case 11003:
        return DeviceOpWriteReply._mavlinkCrcExtra;
      case 11010:
        return AdapTuning._mavlinkCrcExtra;
      case 11011:
        return VisionPositionDelta._mavlinkCrcExtra;
      case 11020:
        return AoaSsa._mavlinkCrcExtra;
      case 11030:
        return EscTelemetry1To4._mavlinkCrcExtra;
      case 11031:
        return EscTelemetry5To8._mavlinkCrcExtra;
      case 11032:
        return EscTelemetry9To12._mavlinkCrcExtra;
      case 11033:
        return OsdParamConfig._mavlinkCrcExtra;
      case 11034:
        return OsdParamConfigReply._mavlinkCrcExtra;
      case 11035:
        return OsdParamShowConfig._mavlinkCrcExtra;
      case 11036:
        return OsdParamShowConfigReply._mavlinkCrcExtra;
      case 11037:
        return ObstacleDistance3d._mavlinkCrcExtra;
      case 11038:
        return WaterDepth._mavlinkCrcExtra;
      case 11039:
        return McuStatus._mavlinkCrcExtra;
      case 60010:
        return Storm32GimbalManagerInformation._mavlinkCrcExtra;
      case 60011:
        return Storm32GimbalManagerStatus._mavlinkCrcExtra;
      case 60012:
        return Storm32GimbalManagerControl._mavlinkCrcExtra;
      case 60013:
        return Storm32GimbalManagerControlPitchyaw._mavlinkCrcExtra;
      case 60014:
        return Storm32GimbalManagerCorrectRoll._mavlinkCrcExtra;
      case 60020:
        return QshotStatus._mavlinkCrcExtra;
      case 60040:
        return FrskyPassthroughArray._mavlinkCrcExtra;
      case 60041:
        return ParamValueArray._mavlinkCrcExtra;
      default:
        return -1;
    }
  }
}
